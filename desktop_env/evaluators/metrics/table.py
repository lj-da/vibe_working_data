import functools
import itertools
import logging
import os.path

# import operator
from numbers import Number
from typing import Any, Union, cast, Callable, Iterable
from typing import Dict, List, Tuple, Set

import openpyxl
import pandas as pd
from openpyxl import Workbook
from openpyxl.cell.cell import Cell
from openpyxl.utils import coordinate_to_tuple, get_column_letter
from openpyxl.worksheet.cell_range import MultiCellRange
from openpyxl.worksheet.datavalidation import DataValidation
from openpyxl.worksheet.worksheet import Worksheet
from rapidfuzz import fuzz

from desktop_env.evaluators.metrics.utils import (
    _match_value_to_rule,
    _read_cell_style,
    read_cell_value,
)
from desktop_env.evaluators.metrics.utils import (
    load_charts,
    load_sparklines,
    load_rows_or_cols,
    load_xlsx_styles,
    load_filters,
    load_pivot_tables,
)

# from openpyxl.utils import coordinate_to_tuple

logger = logging.getLogger("desktopenv.metric.table")

BOOK = Union[pd.ExcelFile, Workbook, str]


def _parse_sheet_idx(
    sheet_idx: Union[int, str],
    result: BOOK,
    expected: BOOK,
    result_sheet_names: List[str],
    expected_sheet_names: List[str],
) -> Tuple[BOOK, str]:
    #  function _parse_sheet_idx {{{ #
    if isinstance(sheet_idx, int):
        try:
            if not result_sheet_names or sheet_idx >= len(result_sheet_names):
                logger.error(
                    f"Sheet index {sheet_idx} out of range. Available sheets: {result_sheet_names}"
                )
                index = ""
            else:
                index: str = result_sheet_names[sheet_idx]
                logger.debug(f"Sheet index {sheet_idx} resolved to sheet: {index}")
        except Exception as e:
            logger.error(f"Error resolving sheet index {sheet_idx}: {e}")
            index = ""
        book: BOOK = result
    elif sheet_idx.startswith("RI"):
        try:
            index: str = result_sheet_names[int(sheet_idx[2:])]
        except:
            index = ""
        book: BOOK = result
    elif sheet_idx.startswith("RN"):
        index: str = sheet_idx[2:]
        book: BOOK = result
    elif sheet_idx.startswith("EI"):
        try:
            index: str = expected_sheet_names[int(sheet_idx[2:])]
        except:
            index = ""
        book: BOOK = expected
    elif sheet_idx.startswith("EN"):
        index: str = sheet_idx[2:]
        book: BOOK = expected
    else:
        logger.error("Unrecognized sheet index")
        raise ValueError("Unrecognized sheet index")
    return book, index
    #  }}} function _parse_sheet_idx #


SHEET = Union[pd.DataFrame, Worksheet, List[str]]


def _load_sheet(book: BOOK, index: str) -> SHEET:
    #  function _load_sheet {{{ #
    try:
        if isinstance(book, str):
            book: str = cast(str, book)
            csv_name: str = "{:}-{:}.csv".format(os.path.splitext(book)[0], index)

            try:
                all_lines: List[str] = _safe_read_file(csv_name)
                csv_lines: List[str] = list(
                    itertools.dropwhile(
                        lambda l: len(l) == 0,
                        map(lambda l: l.strip(), reversed(all_lines)),
                    )
                )
                return csv_lines
            except (FileNotFoundError, IOError) as e:
                logger.error(f"Failed to read CSV file {csv_name}: {e}")
                return None
        if isinstance(book, pd.ExcelFile):
            return pd.read_excel(book, index)
        if isinstance(book, Workbook):
            return book[index]
        logger.error("Not supported workbook format")
        raise NotImplementedError("Not supported workbook format")
    except NotImplementedError as e:
        raise e
    except:
        return None
    #  }}} function _load_sheet #


def _safe_read_file(file_path: str) -> List[str]:
    """
    Safely read a file with multiple encoding attempts.

    Args:
        file_path: Path to the file to read

    Returns:
        List of lines from the file

    Raises:
        FileNotFoundError: If file doesn't exist
        IOError: If file cannot be read with any encoding
    """
    # Common encodings to try in order of preference
    encodings = [
        "utf-8",  # Most common modern encoding
        "utf-8-sig",  # UTF-8 with BOM
        "latin-1",  # ISO-8859-1, works with any byte sequence
        "windows-1252",  # Common Windows encoding
        "gbk",  # Chinese encoding
        "cp1251",  # Cyrillic encoding
        "iso-8859-1",  # Alternative latin-1
    ]

    last_error = None

    for encoding in encodings:
        try:
            with open(file_path, "r", encoding=encoding) as f:
                lines = f.read().splitlines()
                logger.debug(
                    f"Successfully read file {file_path} with encoding {encoding}"
                )
                return lines
        except UnicodeDecodeError as e:
            last_error = e
            logger.debug(f"Failed to read {file_path} with encoding {encoding}: {e}")
            continue
        except (FileNotFoundError, IOError) as e:
            # These are non-encoding related errors, re-raise immediately
            raise e

    # If all encodings fail, try with error handling as last resort
    try:
        with open(file_path, "r", encoding="utf-8", errors="replace") as f:
            lines = f.read().splitlines()
            logger.warning(f"Read file {file_path} with UTF-8 and error replacement")
            return lines
    except Exception as e:
        logger.error(
            f"Failed to read file {file_path} with any encoding. Last error: {last_error}"
        )
        raise IOError(
            f"Cannot read file {file_path} with any supported encoding"
        ) from last_error


def compare_csv(result: str, expected: Union[str, List[str]], **options) -> float:
    """
    Compare CSV files. If expected is a list, returns 1.0 if result matches any of the expected files.

    Args:
        result: Path to result CSV file
        expected: Path to expected CSV file or list of paths to expected CSV files
        options: Additional options (strict, ignore_case)

    Returns:
        1.0 if result matches expected (or any file in expected list), 0.0 otherwise
    """
    if result is None:
        return 0.0

    try:
        result_lines: List[str] = _safe_read_file(result)
    except (FileNotFoundError, IOError) as e:
        logger.error(f"Failed to read result file {result}: {e}")
        return 0.0

    # Convert expected to list if it's a single string (for backward compatibility)
    if isinstance(expected, str):
        expected_files = [expected]
    else:
        expected_files = expected

    # Try to match against each expected file
    for expected_file in expected_files:
        try:
            expected_lines: List[str] = _safe_read_file(expected_file)

            # Process lines based on options
            current_result_lines = result_lines
            current_expected_lines = expected_lines

            if not options.get("strict", True):
                current_result_lines = map(str.strip, current_result_lines)
                current_expected_lines = map(str.strip, current_expected_lines)
            if options.get("ignore_case", False):
                current_result_lines = map(str.lower, current_result_lines)
                current_expected_lines = map(str.lower, current_expected_lines)

            # Check if this expected file matches
            if list(current_result_lines) == list(current_expected_lines):
                return 1.0

        except (FileNotFoundError, IOError):
            # If this expected file doesn't exist, continue to next one
            continue

    # No match found
    return 0.0


def compare_table(result: str, expected: str = None, **options) -> float:
    #  function compare_table {{{ #
    """
    Args:
        result (str): path to result xlsx
        expected (str): path to golden xlsx
        rules (List[Dict[str, Any]]): list of dict like
          {
            "type": str,
            <str as parameters>: anything
          }
          as sequential rules

    Returns:
        float: the score
    """

    if result is None:
        logger.error("Result file path is None")
        return 0.0

    # Check if result file exists
    if not os.path.exists(result):
        logger.error(f"Result file not found: {result}")
        return 0.0

    try:
        logger.info(f"Loading result file: {result}")
        xlworkbookr: Workbook = openpyxl.load_workbook(filename=result)
        pdworkbookr = pd.ExcelFile(result)
        logger.info(
            f"Successfully loaded result file with sheets: {pdworkbookr.sheet_names}"
        )
    except Exception as e:
        logger.error(f"Failed to load result file {result}: {e}")
        return 0.0
    worksheetr_names: List[str] = pdworkbookr.sheet_names

    if expected is not None:
        xlworkbooke: Workbook = openpyxl.load_workbook(filename=expected)
        pdworkbooke = pd.ExcelFile(expected)
        worksheete_names: List[str] = pdworkbooke.sheet_names
    else:
        xlworkbooke: Workbook = None
        pdworkbooke = None
        worksheete_names: List[str] = None

    parse_idx: Callable[[Union[str, int], BOOK, BOOK], Tuple[BOOK, str]] = (
        functools.partial(
            _parse_sheet_idx,
            result_sheet_names=worksheetr_names,
            expected_sheet_names=worksheete_names,
        )
    )

    passes = True
    for r in options["rules"]:
        if r["type"] == "sheet_name":
            #  Compare Sheet Names {{{ #
            metric: bool = worksheetr_names == worksheete_names
            logger.debug(
                "Assertion: %s.sheet_names == %s.sheet_names - %s",
                result,
                expected,
                metric,
            )
            #  }}} Compare Sheet Names #

        elif r["type"] == "sheet_data":
            #  Compare Sheet Data by Internal Value {{{ #
            # sheet_idx0: 0 == "RI0" == "RNSheet1" | "EI0" == "ENSheet1"
            # sheet_idx1: as sheet_idx0
            # precision: int as number of decimal digits, default to 4

            error_limit: int = r.get("precision", 4)
            sheet1: pd.DataFrame = _load_sheet(
                *parse_idx(r["sheet_idx0"], pdworkbookr, pdworkbooke)
            )
            if sheet1 is None:
                return 0.0
            sheet2: pd.DataFrame = _load_sheet(
                *parse_idx(r["sheet_idx1"], pdworkbookr, pdworkbooke)
            )

            sheet1 = sheet1.round(error_limit)
            sheet2 = sheet2.round(error_limit)
            metric: bool = sheet1.equals(sheet2)
            logger.debug("Sheet1: \n%s", str(sheet1))
            logger.debug("Sheet2: \n%s", str(sheet2))
            try:
                logger.debug("Sheet1 =v= Sheet2: \n%s", str(sheet1 == sheet2))
            except:
                logger.debug("Sheet1 =/v= Sheet2")
            logger.debug(
                "Assertion: %s =v= %s - %s", r["sheet_idx0"], r["sheet_idx1"], metric
            )
            #  }}} Compare Sheet Data by Internal Value #

        elif r["type"] == "sheet_print":
            #  Compare Sheet Data by Printed Value {{{ #
            # sheet_idx0: 0 == "RI0" == "RNSheet1" | "EI0" == "ENSheet1"
            # sheet_idx1: as sheet_idx0
            # ignore_case: optional, defaults to False

            sheet1: List[str] = _load_sheet(
                *parse_idx(r["sheet_idx0"], result, expected)
            )
            if sheet1 is None:
                return 0.0
            sheet2: List[str] = _load_sheet(
                *parse_idx(r["sheet_idx1"], result, expected)
            )
            if r.get("ignore_case", False):
                sheet1 = [l.lower() for l in sheet1]
                sheet2 = [l.lower() for l in sheet2]
            metric: bool = sheet1 == sheet2
            logger.debug(
                "Assertion: %s =p= %s - %s", r["sheet_idx0"], r["sheet_idx1"], metric
            )
            #  }}} Compare Sheet Data by Printed Value #

        elif r["type"] == "sheet_fuzzy":
            #  Fuzzy Match for Ranges {{{ #
            # sheet_idx0: 0 == "RI0" == "RNSheet1" | "EI0" == "ENSheet1"
            # sheet_idx1: as sheet_idx0
            # rules: list of dict, each dict is like
            #   { "range": ["A1:B6", "C2:E5"],
            #     "type": "includes" | "included_by" | "fuzzy_match" | "exact_match", # 0 includes 1, 0 includes_by 1
            #     "threshold": 85, // for fuzzy match
            #     "ignore_case": true | false,
            #     "ignore_chars": " ()", # filtered out
            #     "trim_leadings": "+ ", # filtered by lstrip
            #     "trim_trailings": "", # filtered by rstrip
            #     "normalization": [["Rd", "Road"]], # filtered by replace
            #   }

            sheet1: Tuple[BOOK, str] = parse_idx(r["sheet_idx0"], result, expected)
            sheet2: Tuple[BOOK, str] = parse_idx(r["sheet_idx1"], result, expected)
            total_metric = True
            for rl in r["rules"]:
                for rng in MultiCellRange(rl["range"]):
                    for cdn in rng.cells:
                        coordinate: str = "{:}{:d}".format(
                            get_column_letter(cdn[1]), cdn[0]
                        )
                        value1: str = str(read_cell_value(*sheet1, coordinate))
                        value2: str = str(read_cell_value(*sheet2, coordinate))
                        logger.debug("%s: %s vs %s", cdn, value1, value2)

                        for rplc in rl.get("normalization", []):
                            value1 = value1.replace(rplc[0], rplc[1])
                            value2 = value2.replace(rplc[0], rplc[1])
                        if "trim_leadings" in rl:
                            value1 = value1.lstrip(rl["trim_leadings"])
                            value2 = value2.lstrip(rl["trim_leadings"])
                        if "trim_trailings" in rl:
                            value1 = value1.rstrip(rl["trim_trailings"])
                            value2 = value2.rstrip(rl["trim_trailings"])
                        if "ignore_chars" in rl:
                            ignore_chars: Set[str] = set(rl["ignore_chars"])
                            value1 = "".join(
                                filter(lambda ch: ch not in ignore_chars, value1)
                            )
                            value2 = "".join(
                                filter(lambda ch: ch not in ignore_chars, value2)
                            )
                        if rl.get("ignore_case", False):
                            value1 = value1.lower()
                            value2 = value2.lower()

                        if rl["type"] == "includes":
                            metric: bool = value2 in value1
                        elif rl["type"] == "included_by":
                            metric: bool = value1 in value2
                        elif rl["type"] == "fuzzy_match":
                            metric: bool = fuzz.ratio(value1, value2) >= rl.get(
                                "threshold", 85.0
                            )
                        elif rl["type"] == "exact_match":
                            metric: bool = value1 == value2
                        total_metric = total_metric and metric

            metric: bool = total_metric
            logger.debug(
                "Assertion: %s =~= %s - %s", r["sheet_idx0"], r["sheet_idx1"], metric
            )
            #  }}} Fuzzy Match for Ranges #

        elif r["type"] == "sparkline":
            #  Compare Sparklines {{{ #
            # sheet_idx0: 0 == "RI0" == "RNSheet1" | "EI0" == "ENSheet1"
            # sheet_idx1: as sheet_idx0

            sparkline1: Dict[str, str] = load_sparklines(
                *parse_idx(r["sheet_idx0"], result, expected)
            )
            sparkline2: Dict[str, str] = load_sparklines(
                *parse_idx(r["sheet_idx1"], result, expected)
            )
            metric: bool = sparkline1 == sparkline2
            logger.debug(
                "Assertion: %s.sp == %.sp - %s",
                r["sheet_idx0"],
                r["sheet_idx1"],
                metric,
            )
            #  }}} Compare Sparklines #

        elif r["type"] == "chart":
            #  Compare Charts {{{ #
            # sheet_idx0: 0 == "RI0" == "RNSheet1" | "EI0" == "ENSheet1"
            # sheet_idx1: as sheet_idx0
            # chart_props: list of str, see utils.load_charts

            charts1: Dict[str, Any] = load_charts(
                *parse_idx(r["sheet_idx0"], xlworkbookr, xlworkbooke), **r
            )
            charts2: Dict[str, Any] = load_charts(
                *parse_idx(r["sheet_idx1"], xlworkbookr, xlworkbooke), **r
            )
            metric: bool = charts1 == charts2
            logger.debug(
                "Assertion: %s[chart] == %s[chart] - %s",
                r["sheet_idx0"],
                r["sheet_idx1"],
                metric,
            )
            #  }}} Compare Charts #

        elif r["type"] == "style":
            #  Compare Style (Also Conditional Formatiing) {{{ #
            # sheet_idx0: 0 == "RI0" == "RNSheet1" | "EI0" == "ENSheet1"
            # sheet_idx1: as sheet_idx0
            # props: list of str indicating concerned styles, see utils._read_cell_style

            sheet_idx1: Tuple[BOOK, str] = parse_idx(
                r["sheet_idx0"], xlworkbookr, xlworkbooke
            )
            book_name1: str = parse_idx(r["sheet_idx0"], result, expected)[0]
            styles1: Dict[str, List[Any]] = load_xlsx_styles(
                *sheet_idx1, book_name1, **r
            )

            sheet_idx2: Tuple[BOOK, str] = parse_idx(
                r["sheet_idx1"], xlworkbookr, xlworkbooke
            )
            book_name2: str = parse_idx(r["sheet_idx1"], result, expected)[0]
            styles2: Dict[str, List[Any]] = load_xlsx_styles(
                *sheet_idx2, book_name2, **r
            )
            # number_formats1: List[str] = [c.number_format.lower() for col in sheet1.iter_cols() for c in col if c.value is not None and c.data_type=="n"]
            # number_formats2: List[str] = [c.number_format.lower() for col in sheet2.iter_cols() for c in col if c.value is not None and c.data_type=="n"]
            metric: bool = styles1 == styles2
            logger.debug(
                "Assertion: %s.style == %s.style - %s",
                r["sheet_idx0"],
                r["sheet_idx1"],
                metric,
            )
            #  }}} Compare Style (Also Conditional Formatiing) #

        elif r["type"] == "freeze":
            #  Compare Freezing {{{ #
            # sheet_idx0: 0 == "RI0" == "RNSheet1" | "EI0" == "ENSheet1"
            # sheet_idx1: as sheet_idx0

            sheet1: Worksheet = _load_sheet(
                *parse_idx(r["sheet_idx0"], xlworkbookr, xlworkbooke)
            )
            if sheet1 is None:
                return 0.0
            sheet2: Worksheet = _load_sheet(
                *parse_idx(r["sheet_idx1"], xlworkbookr, xlworkbooke)
            )
            metric: bool = sheet1.freeze_panes == sheet2.freeze_panes
            logger.debug(
                "Assertion: %s.freeze(%s) == %s.freeze(%s) - %s",
                r["sheet_idx0"],
                sheet1.freeze_panes,
                r["sheet_idx1"],
                sheet2.freeze_panes,
                metric,
            )
            #  }}} Compare Freezing #

        elif r["type"] == "zoom":
            #  Check Zooming {{{ #
            # sheet_idx: 0 == "RI0" == "RNSheet1" | "EI0" == "ENSheet1"
            # method: str
            # ref: value

            sheet: Worksheet = _load_sheet(
                *parse_idx(r["sheet_idx"], xlworkbookr, xlworkbooke)
            )
            if sheet is None:
                return 0.0
            zoom_scale: Number = sheet.sheet_view.zoomScale or 100.0
            metric: bool = _match_value_to_rule(zoom_scale, r)
            logger.debug(
                "Assertion: %s.zoom(%.1f) %s %.1f - %s",
                r["sheet_idx"],
                zoom_scale,
                r["method"],
                r["ref"],
                metric,
            )
            #  }}} Check Zooming #

        elif r["type"] == "data_validation":
            #  Check Data Validation {{{ #
            # sheet_idx: 0 == "RI0" == "RNSheet1" | "EI0" == "ENSheet1"
            # dv_props: list of dict like {attribute: {"method": str, "ref": anything}}
            #   available attributes:
            #     * ranges
            #     * type
            #     * formula1
            #     * formula2
            #     * operator
            #     * allowBlank
            #     * showDropDown
            #     * showInputMessage
            #     * showErrorMessage
            #     * error
            #     * errorTitle
            #     * errorStyle
            #     * prompt
            #     * promptTitle
            #     * imeMode

            sheet: Worksheet = _load_sheet(
                *parse_idx(r["sheet_idx"], xlworkbookr, xlworkbooke)
            )
            if sheet is None:
                return 0.0
            data_validators: List[DataValidation] = (
                sheet.data_validations.dataValidation
            )

            total_metric = len(data_validators) >= len(r["dv_props"])
            for dat_vldt in data_validators:
                metric = False
                for prpt in r["dv_props"]:
                    metric = metric or all(
                        _match_value_to_rule(getattr(dat_vldt, attrbt), mr)
                        for attrbt, mr in prpt.items()
                    )
                    if metric:
                        break
                total_metric = total_metric and metric
                if not total_metric:
                    break

            logger.debug(
                "Assertion: %s.data_validation - %s", r["sheet_idx"], total_metric
            )
            metric: bool = total_metric
            #  }}} Check Data Validation #

        elif r["type"] == "row_props":
            #  Check Row Properties {{{ #
            # sheet_idx0: 0 == "RI0" == "RNSheet1" | "EI0" == "ENSheet1"
            # sheet_idx1: as sheet_idx0
            # props: list of str, see utils.load_rows_or_cols

            rows1: Dict[str, Any] = load_rows_or_cols(
                *parse_idx(r["sheet_idx0"], xlworkbookr, xlworkbooke), obj="row", **r
            )
            rows2: Dict[str, Any] = load_rows_or_cols(
                *parse_idx(r["sheet_idx1"], xlworkbookr, xlworkbooke), obj="row", **r
            )
            logger.debug("Rows1: %s", repr(rows1))
            logger.debug("Rows2: %s", repr(rows2))
            metric: bool = rows1 == rows2
            logger.debug(
                "Assertion: %s[rows] == %s[rows] - %s",
                r["sheet_idx0"],
                r["sheet_idx1"],
                metric,
            )
            #  }}} Check Row Properties #

        elif r["type"] == "col_props":
            #  Check Row Properties {{{ #
            # sheet_idx0: 0 == "RI0" == "RNSheet1" | "EI0" == "ENSheet1"
            # sheet_idx1: as sheet_idx0
            # props: list of str, see utils.load_rows_or_cols

            cols1: Dict[str, Any] = load_rows_or_cols(
                *parse_idx(r["sheet_idx0"], xlworkbookr, xlworkbooke), obj="column", **r
            )
            cols2: Dict[str, Any] = load_rows_or_cols(
                *parse_idx(r["sheet_idx1"], xlworkbookr, xlworkbooke), obj="column", **r
            )
            metric: bool = cols1 == cols2
            logger.debug(
                "Assertion: %s[cols] == %s[cols] - %s",
                r["sheet_idx0"],
                r["sheet_idx1"],
                metric,
            )
            #  }}} Check Row Properties #

        elif r["type"] == "filter":
            #  Compare Filters {{{ #
            # sheet_idx0: 0 == "RI0" == "RNSheet1" | "EI0" == "ENSheet1"
            # sheet_idx1: as sheet_idx0

            filters1: Dict[str, Any] = load_filters(
                *parse_idx(r["sheet_idx0"], xlworkbookr, xlworkbooke), **r
            )
            filters2: Dict[str, Any] = load_filters(
                *parse_idx(r["sheet_idx1"], xlworkbookr, xlworkbooke), **r
            )
            metric: bool = filters1 == filters2
            logger.debug(
                "Assertion: %s[filter] == %s[filter] - %s",
                r["sheet_idx0"],
                r["sheet_idx1"],
                metric,
            )
            #  }}} Compare Filters #

        elif r["type"] == "pivot_table":
            #  Compare Pivot Tables {{{ #
            # sheet_idx0: 0 == "RI0" == "RNSheet1" | "EI0" == "ENSheet1"
            # sheet_idx1: as sheet_idx0
            # pivot_props: list of str, see utils.load_pivot_tables

            pivots1: Dict[str, Any] = load_pivot_tables(
                *parse_idx(r["sheet_idx0"], xlworkbookr, xlworkbooke), **r
            )
            pivots2: Dict[str, Any] = load_pivot_tables(
                *parse_idx(r["sheet_idx1"], xlworkbookr, xlworkbooke), **r
            )
            metric: bool = pivots1 == pivots2
            logger.debug(
                "Assertion: %s[pivot]==%s[pivot] - %s",
                r["sheet_idx0"],
                r["sheet_idx1"],
                metric,
            )
            #  }}} Compare Pivot Tables #

        elif r["type"] == "check_cell":
            #  Check Cell Properties {{{ #
            # sheet_idx: 0 == "RI0" == "RNSheet1" | "EI0" == "ENSheet1"
            # coordinate: str, "E3"
            # props: dict like {attribute: {"method": str, "ref": anything}}
            #   supported attributes: value & those supported by utils._read_cell_style

            try:
                sheet: Worksheet = _load_sheet(
                    *parse_idx(r["sheet_idx"], xlworkbookr, xlworkbooke)
                )
                if sheet is None:
                    logger.error(
                        f"Failed to load sheet for sheet_idx: {r['sheet_idx']}"
                    )
                    return 0.0
                # data_frame: pd.DataFrame = _load_sheet(*parse_idx(r["sheet_idx"], pdworkbookr, pdworkbooke))
                cell: Cell = sheet[r["coordinate"]]
                metric: bool = True
                for prpt, rule in r["props"].items():
                    if prpt == "value":
                        try:
                            parsed_result = parse_idx(r["sheet_idx"], result, expected)
                            logger.debug(f"parse_idx result: {parsed_result}")
                            val = read_cell_value(*parsed_result, r["coordinate"])
                            logger.debug(f"Cell {r['coordinate']} value: {val}")
                        except Exception as e:
                            logger.error(
                                f"Failed to read cell value at {r['coordinate']}: {e}"
                            )
                            val = None
                    elif prpt == "formula":
                        # Support checking cell formula directly
                        try:
                            if cell.data_type == "f":
                                # For formula cells, get the formula text
                                # In openpyxl, formula is stored in cell.value for formula cells
                                # But we need the actual formula text, not the calculated value
                                # Try to get formula from internal representation
                                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                                    val = cell._value
                                elif hasattr(cell, "formula"):
                                    val = cell.formula
                                else:
                                    # Fallback: try to reconstruct from value if it's a formula
                                    val = f"={cell.value}" if cell.value is not None else None
                            else:
                                val = None
                            logger.debug(f"Cell {r['coordinate']} formula: {val}")
                        except Exception as e:
                            logger.error(
                                f"Failed to read cell formula at {r['coordinate']}: {e}"
                            )
                            val = None
                    else:
                        try:
                            val = _read_cell_style(prpt, cell)
                        except Exception as e:
                            logger.error(
                                f"Failed to read cell style {prpt} at {r['coordinate']}: {e}"
                            )
                            val = None

                    metric = metric and _match_value_to_rule(val, rule)
            except Exception as e:
                logger.error(f"Error in check_cell processing: {e}")
                return 0.0

            logger.debug(
                "Assertion: %s[%s] :%s - %s",
                r["sheet_idx"],
                r["coordinate"],
                repr(r["props"]),
                metric,
            )
            #  }}} Check Cell Properties #

        else:
            raise NotImplementedError(
                "Unimplemented sheet check: {:}".format(r["type"])
            )

        passes = passes and metric
        if not passes:
            break

    return float(passes)
    #  }}} function compare_table #


def compare_conference_city_in_order(actual_city_list_path, expected_city):
    expected_city_list = expected_city["expected"]
    wb = openpyxl.load_workbook(actual_city_list_path)
    sheet = wb.active
    actual_city_list = []
    for row in sheet["C2:C22"]:
        for cell in row:
            actual_city_list.append(cell.value)
    # expected_city is the city that we want to compare with the actual city list
    # must in order index
    # debug
    try:
        for i in range(len(actual_city_list)):
            if isinstance(expected_city_list[i], str):
                if expected_city_list[i] not in actual_city_list[i]:
                    logger.debug(
                        f"Expected city {expected_city_list[i]}; Actual city {actual_city_list[i]}"
                    )
                    print(
                        f"Expected city {expected_city_list[i]}; Actual city {actual_city_list[i]}"
                    )
                    return 0.0

            elif isinstance(expected_city_list[i], List):
                if not any(
                    possible_str in actual_city_list[i]
                    for possible_str in expected_city_list[i]
                ):
                    logger.debug(
                        f"Expected city {expected_city_list[i]}; Actual city {actual_city_list[i]}"
                    )
                    print(
                        f"Expected city {expected_city_list[i]}; Actual city {actual_city_list[i]}"
                    )
                    return 0.0

            else:
                raise TypeError("Expected city should be a string or a list of strings")

    except:
        return 0.0

    return 1.0


def verify_second_row_deleted_without_gold(result: str, expected: str = None, **options) -> float:
    """
    验证 Excel 文件的第二行是否被删除（不需要金标准文件）
    
    通过以下方式验证：
    1. 检查结果文件的行数是否比原始文件少1
    2. 检查原始文件的第二行数据是否在结果文件中不存在
    3. 检查其他所有行是否保持不变
    
    Args:
        result (str): 结果文件路径
        expected (str): 未使用（为了兼容框架接口）
        options (dict): 配置选项，应包含：
            - original_file_url: 原始文件的URL（用于下载和比对）
            - result_file_path: 结果文件的路径（可选，默认使用 result 参数）
            - original_file_cache: 原始文件的本地缓存路径（可选）
    
    Returns:
        float: 如果验证通过返回 1.0，否则返回 0.0
    """
    try:
        import tempfile
        import urllib.request
        
        # result 参数已经是从VM获取到宿主机的文件路径
        # 不应该从 options 中覆盖它，因为 options 中可能包含的是VM路径
        result_file_path = result
        original_file_url = options.get('original_file_url', '')
        
        logger.info(f"开始验证删除第二行任务...")
        logger.info(f"结果文件: {result_file_path}")
        logger.info(f"原始文件URL: {original_file_url}")
        
        if not result_file_path or not os.path.exists(result_file_path):
            logger.error(f"结果文件不存在: {result_file_path}")
            return 0.0
        
        # 下载原始文件到临时位置
        with tempfile.NamedTemporaryFile(delete=False, suffix='.xlsx') as tmp_file:
            original_file_temp = tmp_file.name
        
        try:
            logger.info(f"正在下载原始文件到临时位置: {original_file_temp}")
            urllib.request.urlretrieve(original_file_url, original_file_temp)
        except Exception as e:
            logger.warning(f"下载原始文件失败: {e}")
            # 如果下载失败，尝试从本地缓存读取
            cache_path = options.get('original_file_cache', '')
            if cache_path and os.path.exists(cache_path):
                logger.info(f"使用缓存文件: {cache_path}")
                original_file_temp = cache_path
            else:
                logger.error("无法获取原始文件")
                return 0.0
        
        # 加载原始文件
        logger.info("加载原始文件...")
        original_wb = openpyxl.load_workbook(original_file_temp)
        original_ws = original_wb.active
        
        # 获取原始文件的所有行
        original_rows = list(original_ws.iter_rows(values_only=True))
        original_row_count = len(original_rows)
        
        if original_row_count < 2:
            logger.error(f"原始文件行数不足: {original_row_count}（需要至少2行）")
            return 0.0
        
        # 保存第二行的数据（索引为1）
        second_row_data = original_rows[1]
        logger.info(f"原始文件行数: {original_row_count}")
        logger.info(f"原始文件第二行数据: {second_row_data}")
        
        # 加载结果文件
        logger.info(f"加载结果文件...")
        result_wb = openpyxl.load_workbook(result_file_path)
        result_ws = result_wb.active
        
        # 获取结果文件的所有行
        result_rows = list(result_ws.iter_rows(values_only=True))
        result_row_count = len(result_rows)
        
        logger.info(f"结果文件行数: {result_row_count}")
        
        # 验证1: 检查行数是否减少了1
        if result_row_count != original_row_count - 1:
            logger.error(f"行数验证失败: 期望 {original_row_count - 1} 行，实际 {result_row_count} 行")
            return 0.0
        else:
            logger.info(f"✓ 行数验证通过: {original_row_count} → {result_row_count}")
        
        # 验证2: 检查原始第二行是否存在于结果文件中
        second_row_exists = False
        for i, row in enumerate(result_rows):
            if row == second_row_data:
                logger.error(f"原始第二行数据仍存在于结果文件的第 {i+1} 行")
                second_row_exists = True
                break
        
        if second_row_exists:
            return 0.0
        else:
            logger.info(f"✓ 原始第二行数据已从结果文件中删除")
        
        # 验证3: 检查其他行是否保持不变（第一行和第3行之后）
        # 结果文件的第一行应该等于原始文件的第一行
        if result_rows[0] != original_rows[0]:
            logger.error(f"第一行数据不匹配")
            logger.error(f"  原始: {original_rows[0]}")
            logger.error(f"  结果: {result_rows[0]}")
            return 0.0
        
        # 结果文件的第2行及之后应该等于原始文件的第3行及之后
        for i in range(1, result_row_count):
            if result_rows[i] != original_rows[i+1]:
                logger.error(f"第 {i+1} 行数据不匹配")
                logger.error(f"  期望（原始第 {i+2} 行）: {original_rows[i+1]}")
                logger.error(f"  实际: {result_rows[i]}")
                return 0.0
        
        logger.info(f"✓ 其他行数据保持不变")
        
        # 清理临时文件
        if original_file_temp != options.get('original_file_cache', ''):
            try:
                os.unlink(original_file_temp)
            except:
                pass
        
        logger.info("=" * 60)
        logger.info("✓ 所有验证通过！第二行已成功删除")
        logger.info("=" * 60)
        return 1.0
        
    except Exception as e:
        import traceback
        logger.error(f"评估出错: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_regexp_extract(result: str, expected: str = None, **options) -> float:
    """
    Verify if REGEX formulas exist in specified columns (B and C) with correct patterns.
    
    This function checks:
    1. Whether cells in specified columns contain REGEX formulas
    2. Whether formulas reference the corresponding A column cell (B2->A2, B3->A3, etc.)
    3. Whether formulas contain the correct pattern text (牛肉丸 for B column, 牛筋丸 for C column)
    4. Whether formulas have the correct structure with lookbehind and lookahead
    
    The function automatically detects the number of data rows by checking the data column
    (default: A column) for non-empty cells. It stops checking after finding 3 consecutive
    empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_columns: List of columns to check (e.g., ["B", "C"])
            - start_row: Starting row number (default: 2)
            - end_row: Ending row number (optional, will auto-detect if not provided)
            - expected_pattern: Expected function name (default: "REGEX")
            - column_patterns: Dict mapping column letters to expected pattern text
            - data_column: Column to check for data to determine end_row (default: "A")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_columns = options.get('check_columns', ['B', 'C'])
        start_row = options.get('start_row', 2)
        end_row = options.get('end_row', None)  # Optional, will auto-detect if not provided
        expected_pattern = options.get('expected_pattern', 'REGEX')
        column_patterns = options.get('column_patterns', {'B': '牛肉丸', 'C': '牛筋丸'})
        data_column = options.get('data_column', 'A')  # Column to check for data to determine end_row
        
        if not check_columns:
            logger.error("No columns specified in options")
            return 0.0
        
        logger.info(f"Verifying REGEX formulas in file: {result}")
        logger.info(f"Columns to check: {check_columns}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Expected function: {expected_pattern}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        if end_row is None:
            logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
            max_row = ws.max_row
            end_row = start_row  # Start from start_row
            
            # Find the last row with data in the data column
            # Check up to max_row, but stop if we find 3 consecutive empty rows
            empty_count = 0
            for row_num in range(start_row, max_row + 1):
                data_cell = ws[f"{data_column}{row_num}"]
                if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                    empty_count += 1
                    if empty_count >= 3:  # Stop after 3 consecutive empty rows
                        break
                else:
                    empty_count = 0
                    end_row = row_num  # Update end_row to the last row with data
            
            logger.info(f"Auto-detected end row: {end_row}")
        else:
            logger.info(f"Using specified end row: {end_row}")
        
        # Check each column and row
        all_passed = True
        for col_letter in check_columns:
            expected_pattern_text = column_patterns.get(col_letter)
            if not expected_pattern_text:
                logger.warning(f"No pattern text specified for column {col_letter}, skipping")
                continue
            
            logger.info(f"Checking column {col_letter} with pattern '{expected_pattern_text}' (rows {start_row} to {end_row})")
            
            for row_num in range(start_row, end_row + 1):
                cell_coord = f"{col_letter}{row_num}"
                try:
                    cell = ws[cell_coord]
                    logger.debug(f"Checking cell {cell_coord}")
                    
                    # Check if cell contains a formula
                    if cell.data_type != "f":
                        logger.warning(f"Cell {cell_coord} does not contain a formula")
                        all_passed = False
                        continue
                    
                    # Get formula text
                    formula_text = None
                    if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                        formula_text = cell._value
                    elif hasattr(cell, "formula"):
                        formula_text = cell.formula
                    else:
                        # Try to get from value attribute
                        if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                            formula_text = cell.value
                    
                    if formula_text is None:
                        logger.warning(f"Could not extract formula from cell {cell_coord}")
                        all_passed = False
                        continue
                    
                    # Remove leading = if present for comparison
                    formula_clean = formula_text.lstrip("=")
                    logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                    
                    # Check 1: Formula contains REGEX function
                    if expected_pattern.upper() not in formula_text.upper():
                        logger.warning(f"Cell {cell_coord} formula does not contain {expected_pattern}")
                        logger.warning(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 2: Formula contains expected pattern text (牛肉丸 or 牛筋丸)
                    if expected_pattern_text not in formula_text:
                        logger.warning(f"Cell {cell_coord} formula does not contain pattern text '{expected_pattern_text}'")
                        logger.warning(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 3: Formula contains REGEX function call structure
                    regex_match = re.search(r'REGEX\s*\([^)]+\)', formula_text, re.IGNORECASE)
                    if not regex_match:
                        logger.warning(f"Cell {cell_coord} formula does not have correct REGEX structure")
                        logger.warning(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 4: Formula references the corresponding A column cell (A2, A3, etc.)
                    expected_a_cell = f"A{row_num}"
                    # Check if formula contains A column reference with the same row number
                    a_cell_pattern = rf'A{row_num}\b'
                    if not re.search(a_cell_pattern, formula_text, re.IGNORECASE):
                        logger.warning(f"Cell {cell_coord} formula does not reference {expected_a_cell}")
                        logger.warning(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 5: Formula contains lookbehind pattern (?<=...)
                    if "(?<=" not in formula_text:
                        logger.warning(f"Cell {cell_coord} formula does not contain lookbehind pattern (?<=...)")
                        logger.warning(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 6: Formula contains lookahead pattern (?=,)
                    if "(?=," not in formula_text:
                        logger.warning(f"Cell {cell_coord} formula does not contain lookahead pattern (?=,)")
                        logger.warning(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 7: Formula contains \d+ pattern
                    if "\\d+" not in formula_text:
                        # Also check for unescaped version in the pattern
                        if not re.search(r'\\d\+|d\+', formula_text):
                            logger.warning(f"Cell {cell_coord} formula does not contain digit pattern \\d+")
                            logger.warning(f"Formula: {formula_text}")
                            all_passed = False
                            continue
                    
                    # Check 8: Formula pattern should contain 5 dots after pattern text
                    # Pattern should be like: (?<=牛肉丸.....)
                    pattern_with_dots = expected_pattern_text + "....."
                    if pattern_with_dots not in formula_text:
                        logger.warning(f"Cell {cell_coord} formula pattern may not have 5 dots after '{expected_pattern_text}'")
                        logger.debug(f"Formula: {formula_text}")
                        # Don't fail, just warn - the pattern might be correct but formatted differently
                    
                    logger.info(f"✓ Cell {cell_coord} has valid REGEX formula: {formula_text}")
                    
                except Exception as e:
                    logger.error(f"Error checking cell {cell_coord}: {e}")
                    import traceback
                    logger.error(traceback.format_exc())
                    all_passed = False
        
        if all_passed:
            logger.info("=" * 60)
            logger.info(f"✓ All cells in columns {check_columns} contain correct {expected_pattern} formulas")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ {expected_pattern} formula verification failed")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_regexp_order_extract(result: str, expected: str = None, **options) -> float:
    """
    Verify if REGEXP formulas exist in specified column (C) to extract order numbers from addresses.
    
    This function checks:
    1. Whether cells in specified column contain REGEXP formulas
    2. Whether formulas reference the corresponding A column cell (C2->A2, C3->A3, etc.)
    3. Whether formulas contain the correct regex pattern (\\w{10})
    4. Whether formulas have the correct structure
    
    The function automatically detects the number of data rows by checking the data column
    (default: A column) for non-empty cells. It stops checking after finding 3 consecutive
    empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_column: Column to check (e.g., "C")
            - start_row: Starting row number (default: 2)
            - expected_pattern: Expected function name (default: "REGEXP")
            - expected_formula_pattern: Expected formula pattern (e.g., "REGEXP(A")
            - regex_pattern: Expected regex pattern in formula (e.g., "\\w{10}")
            - data_column: Column to check for data to determine end_row (default: "A")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_column = options.get('check_column', 'C')
        start_row = options.get('start_row', 2)
        expected_pattern = options.get('expected_pattern', 'REGEX')
        expected_formula_pattern = options.get('expected_formula_pattern', 'REGEX(A')
        regex_pattern = options.get('regex_pattern', '[a-zA-Z0-9]{10}')
        data_column = options.get('data_column', 'A')
        
        logger.info(f"Verifying REGEXP order extraction in file: {result}")
        logger.info(f"Column to check: {check_column}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Expected function: {expected_pattern}")
        logger.info(f"Expected regex pattern: {regex_pattern}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row  # Start from start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Check each row in the specified column
        all_passed = True
        logger.info(f"Checking column {check_column} (rows {start_row} to {end_row})")
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{check_column}{row_num}"
            try:
                cell = ws[cell_coord]
                logger.debug(f"Checking cell {cell_coord}")
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.warning(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                else:
                    # Try to get from value attribute
                    if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                # Remove leading = if present for comparison
                formula_clean = formula_text.lstrip("=")
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains REGEX function (support both REGEX and LibreOffice internal format)
                # LibreOffice may save as _xlfn.ORG.LIBREOFFICE.REGEX
                formula_upper = formula_text.upper()
                if expected_pattern.upper() not in formula_upper and '_XLFN.ORG.LIBREOFFICE.REGEX' not in formula_upper:
                    logger.warning(f"Cell {cell_coord} formula does not contain {expected_pattern} or LibreOffice REGEX")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 2: Formula contains expected formula pattern (REGEX(A or _xlfn.ORG.LIBREOFFICE.REGEX(A)
                formula_clean_upper = formula_clean.upper()
                if expected_formula_pattern.upper() not in formula_clean_upper and 'REGEX(A' not in formula_clean_upper:
                    logger.warning(f"Cell {cell_coord} formula does not contain pattern '{expected_formula_pattern}'")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: Formula contains REGEX function call structure (support both formats)
                regexp_match = re.search(r'(REGEX|REGEXP|_XLFN\.ORG\.LIBREOFFICE\.REGEX)\s*\([^)]+\)', formula_text, re.IGNORECASE)
                if not regexp_match:
                    logger.warning(f"Cell {cell_coord} formula does not have correct REGEX structure")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: Formula references the corresponding A column cell (A2, A3, etc.)
                expected_a_cell = f"A{row_num}"
                # Check if formula contains A column reference with the same row number
                a_cell_pattern = rf'A{row_num}\b'
                if not re.search(a_cell_pattern, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {cell_coord} formula does not reference {expected_a_cell}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 5: Formula contains the regex pattern ([a-zA-Z0-9]{10})
                # The pattern might be escaped differently in the formula
                # Check for various escape formats
                pattern_variations = [
                    regex_pattern,  # [a-zA-Z0-9]{10}
                    regex_pattern.replace('\\', '\\\\'),  # [a-zA-Z0-9]{10} with double escape
                    regex_pattern.replace('[', '\\[').replace(']', '\\]'),  # Escaped brackets
                    '[a-zA-Z0-9]{10}',  # Original pattern
                    '\\[a-zA-Z0-9\\]{10}',  # Escaped brackets
                    '\\\\[a-zA-Z0-9\\\\]{10}',  # Double escaped
                ]
                found = False
                for pattern_var in pattern_variations:
                    if pattern_var in formula_text:
                        found = True
                        break
                if not found:
                    # Also check for pattern without escaping brackets
                    simple_pattern = 'a-zA-Z0-9]{10}'
                    if simple_pattern not in formula_text:
                        logger.warning(f"Cell {cell_coord} formula does not contain regex pattern '{regex_pattern}'")
                        logger.warning(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                
                logger.info(f"✓ Cell {cell_coord} has valid REGEXP formula: {formula_text}")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        if all_passed:
            logger.info("=" * 60)
            logger.info(f"✓ All cells in column {check_column} contain correct {expected_pattern} formulas")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ {expected_pattern} formula verification failed")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_sumif_formula(result: str, expected: str = None, **options) -> float:
    """
    Verify if SUMIF formulas exist in specified column (F) to calculate totals.
    
    This function checks:
    1. Whether cells in specified column contain SUMIF formulas
    2. Whether formulas reference the correct ranges (auto-detected from data)
    3. Whether formulas reference the corresponding E column cell (F2->E2, F3->E3, etc.)
    4. Whether formulas have the correct structure
    
    The function automatically detects:
    - end_row: by checking the data column (E) for non-empty cells
    - criteria_range: by detecting the range from the first formula or from criteria_column data
    - sum_range: by detecting the range from the first formula or from sum_column data
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_column: Column to check (e.g., "F")
            - start_row: Starting row number (default: 2)
            - expected_function: Expected function name (default: "SUMIF")
            - criteria_column: Column containing criteria (e.g., "B")
            - sum_column: Column containing values to sum (e.g., "C")
            - criteria_column_start: Starting row for criteria column (default: 2)
            - data_column: Column to check for data to determine end_row (default: "E")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_column = options.get('check_column', 'F')
        start_row = options.get('start_row', 2)
        expected_function = options.get('expected_function', 'SUMIF')
        criteria_column = options.get('criteria_column', 'B')
        sum_column = options.get('sum_column', 'C')
        criteria_column_start = options.get('criteria_column_start', 2)
        data_column = options.get('data_column', 'E')
        
        logger.info(f"Verifying SUMIF formulas in file: {result}")
        logger.info(f"Column to check: {check_column}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Expected function: {expected_function}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row  # Start from start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Auto-detect criteria_range and sum_range by checking the first formula
        criteria_range = None
        sum_range = None
        
        # Try to extract ranges from the first formula
        first_cell_coord = f"{check_column}{start_row}"
        try:
            first_cell = ws[first_cell_coord]
            if first_cell.data_type == "f":
                first_formula_text = None
                if hasattr(first_cell, "_value") and isinstance(first_cell._value, str) and first_cell._value.startswith("="):
                    first_formula_text = first_cell._value
                elif hasattr(first_cell, "formula"):
                    first_formula_text = first_cell.formula
                elif first_cell.value is not None and isinstance(first_cell.value, str) and first_cell.value.startswith("="):
                    first_formula_text = first_cell.value
                
                if first_formula_text:
                    # Extract ranges from SUMIF formula: SUMIF(range1, criteria, range2)
                    # Pattern: SUMIF(range1, criteria, range2)
                    sumif_pattern = r'SUMIF\s*\(\s*([^,]+)\s*,\s*[^,]+\s*,\s*([^)]+)\s*\)'
                    match = re.search(sumif_pattern, first_formula_text, re.IGNORECASE)
                    if match:
                        criteria_range = match.group(1).strip()
                        sum_range = match.group(2).strip()
                        logger.info(f"Extracted from first formula: criteria_range={criteria_range}, sum_range={sum_range}")
        except Exception as e:
            logger.debug(f"Could not extract ranges from first formula: {e}")
        
        # If ranges not found in formula, detect from data columns
        if not criteria_range or not sum_range:
            logger.info(f"Auto-detecting ranges from data columns...")
            # Find the last row with data in criteria_column
            criteria_end_row = criteria_column_start
            empty_count = 0
            for row_num in range(criteria_column_start, max_row + 1):
                criteria_cell = ws[f"{criteria_column}{row_num}"]
                if criteria_cell.value is None or (isinstance(criteria_cell.value, str) and criteria_cell.value.strip() == ""):
                    empty_count += 1
                    if empty_count >= 3:
                        break
                else:
                    empty_count = 0
                    criteria_end_row = row_num
            
            # Find the last row with data in sum_column
            sum_end_row = criteria_column_start
            empty_count = 0
            for row_num in range(criteria_column_start, max_row + 1):
                sum_cell = ws[f"{sum_column}{row_num}"]
                if sum_cell.value is None or (isinstance(sum_cell.value, str) and sum_cell.value.strip() == ""):
                    empty_count += 1
                    if empty_count >= 3:
                        break
                else:
                    empty_count = 0
                    sum_end_row = row_num
            
            # Use the maximum end row for both ranges
            max_end_row = max(criteria_end_row, sum_end_row)
            criteria_range = f"{criteria_column}{criteria_column_start}:{criteria_column}{max_end_row}"
            sum_range = f"{sum_column}{criteria_column_start}:{sum_column}{max_end_row}"
            logger.info(f"Auto-detected ranges: criteria_range={criteria_range}, sum_range={sum_range}")
        
        # Check each row in the specified column
        all_passed = True
        logger.info(f"Checking column {check_column} (rows {start_row} to {end_row})")
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{check_column}{row_num}"
            try:
                cell = ws[cell_coord]
                logger.debug(f"Checking cell {cell_coord}")
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.warning(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                else:
                    # Try to get from value attribute
                    if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                # Remove leading = if present for comparison
                formula_clean = formula_text.lstrip("=")
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains SUMIF function
                formula_upper = formula_text.upper()
                if expected_function.upper() not in formula_upper:
                    logger.warning(f"Cell {cell_coord} formula does not contain {expected_function}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 2: Formula contains SUMIF function call structure
                sumif_match = re.search(r'SUMIF\s*\([^)]+\)', formula_text, re.IGNORECASE)
                if not sumif_match:
                    logger.warning(f"Cell {cell_coord} formula does not have correct SUMIF structure")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: Formula contains criteria range
                if criteria_range and criteria_range.upper() not in formula_upper:
                    logger.warning(f"Cell {cell_coord} formula does not contain criteria range '{criteria_range}'")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: Formula contains sum range
                if sum_range and sum_range.upper() not in formula_upper:
                    logger.warning(f"Cell {cell_coord} formula does not contain sum range '{sum_range}'")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 5: Formula references the corresponding E column cell (E2, E3, etc.)
                expected_e_cell = f"E{row_num}"
                # Check if formula contains E column reference with the same row number
                e_cell_pattern = rf'E{row_num}\b'
                if not re.search(e_cell_pattern, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {cell_coord} formula does not reference {expected_e_cell}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                logger.info(f"✓ Cell {cell_coord} has valid SUMIF formula: {formula_text}")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        if all_passed:
            logger.info("=" * 60)
            logger.info(f"✓ All cells in column {check_column} contain correct {expected_function} formulas")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ {expected_function} formula verification failed")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_networkdays_formula(result: str, expected: str = None, **options) -> float:
    """
    Verify if NETWORKDAYS formulas exist in specified column to calculate working days.
    
    This function checks:
    1. Whether cells in specified column contain NETWORKDAYS formulas
    2. Whether formulas reference the corresponding start date column cell (A2, A3, etc.)
    3. Whether formulas reference the corresponding end date column cell (B2, B3, etc.)
    4. Whether formulas have the correct structure
    
    The function automatically detects the number of data rows by checking the data column
    (default: A column) for non-empty cells. It stops checking after finding 3 consecutive
    empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_column: Column to check (e.g., "C")
            - start_row: Starting row number (default: 2)
            - start_date_column: Column containing start dates (e.g., "A")
            - end_date_column: Column containing end dates (e.g., "B")
            - expected_function: Expected function name (default: "NETWORKDAYS")
            - data_column: Column to check for data to determine end_row (default: "A")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_column = options.get('check_column', 'C')
        start_row = options.get('start_row', 2)
        start_date_column = options.get('start_date_column', 'A')
        end_date_column = options.get('end_date_column', 'B')
        expected_function = options.get('expected_function', 'NETWORKDAYS')
        data_column = options.get('data_column', 'A')
        
        logger.info(f"Verifying NETWORKDAYS formulas in file: {result}")
        logger.info(f"Column to check: {check_column}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Start date column: {start_date_column}")
        logger.info(f"End date column: {end_date_column}")
        logger.info(f"Expected function: {expected_function}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row  # Start from start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Check each row in the specified column
        all_passed = True
        logger.info(f"Checking column {check_column} (rows {start_row} to {end_row})")
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{check_column}{row_num}"
            try:
                cell = ws[cell_coord]
                logger.debug(f"Checking cell {cell_coord}")
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.warning(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                else:
                    # Try to get from value attribute
                    if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                # Remove leading = if present for comparison
                formula_clean = formula_text.lstrip("=")
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains NETWORKDAYS function
                formula_upper = formula_text.upper()
                if expected_function.upper() not in formula_upper:
                    logger.warning(f"Cell {cell_coord} formula does not contain {expected_function}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 2: Formula contains NETWORKDAYS function call structure
                # NETWORKDAYS can have 2 or 3 parameters: NETWORKDAYS(start_date, end_date) or NETWORKDAYS(start_date, end_date, holidays)
                networkdays_pattern = r'NETWORKDAYS\s*\([^)]+\)'
                networkdays_match = re.search(networkdays_pattern, formula_text, re.IGNORECASE)
                if not networkdays_match:
                    logger.warning(f"Cell {cell_coord} formula does not have correct NETWORKDAYS structure")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: Formula references the corresponding start date column cell (A2, A3, etc.)
                expected_start_cell = f"{start_date_column}{row_num}"
                start_cell_pattern = rf'{start_date_column}{row_num}\b'
                if not re.search(start_cell_pattern, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {cell_coord} formula does not reference start date cell {expected_start_cell}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: Formula references the corresponding end date column cell (B2, B3, etc.)
                expected_end_cell = f"{end_date_column}{row_num}"
                end_cell_pattern = rf'{end_date_column}{row_num}\b'
                if not re.search(end_cell_pattern, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {cell_coord} formula does not reference end date cell {expected_end_cell}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                logger.info(f"✓ Cell {cell_coord} has valid NETWORKDAYS formula: {formula_text}")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        if all_passed:
            logger.info("=" * 60)
            logger.info(f"✓ All cells in column {check_column} contain correct {expected_function} formulas")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ {expected_function} formula verification failed")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_conditional_formatting_reconciliation(result: str, expected: str = None, **options) -> float:
    """
    Verify if conditional formatting is correctly set up for reconciliation between two tables.
    
    This function checks:
    1. Whether conditional formatting rules exist in the worksheet
    2. Whether the formula matches the expected pattern (e.g., A1<>E1 to compare cells from two tables)
    3. Whether conditional formatting is applied to the correct range
    4. Whether cells with differences are formatted (highlighted)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_range: Range where conditional formatting should be applied (e.g., "A1:C16")
            - compare_range: Range to compare against (e.g., "E1:G16")
            - expected_formula: Expected formula pattern (e.g., "A1<>E1")
            - format_column: Column to check for formatting (optional, e.g., "B")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        from openpyxl.worksheet.cell_range import CellRange
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_range = options.get('check_range', 'A1:C16')
        compare_range = options.get('compare_range', 'E1:G16')
        expected_formula = options.get('expected_formula', 'A1<>E1')
        format_column = options.get('format_column', None)
        
        logger.info(f"Verifying conditional formatting reconciliation in file: {result}")
        logger.info(f"Check range: {check_range}")
        logger.info(f"Compare range: {compare_range}")
        logger.info(f"Expected formula pattern: {expected_formula}")
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=False)
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check if conditional formatting exists
        conditional_formattings = ws.conditional_formatting
        if not conditional_formattings:
            logger.error("No conditional formatting rules found in the worksheet")
            return 0.0
        
        logger.info(f"Found {len(conditional_formattings)} conditional formatting rule(s)")
        
        # Parse expected formula to extract cell references
        # Expected formula like "A1<>E1" means compare A1 with E1
        expected_formula_clean = expected_formula.replace(" ", "").upper()
        
        # Find matching conditional formatting rule
        found_matching_rule = False
        rule_applied_to_correct_range = False
        
        for fmt in conditional_formattings:
            for rule in fmt.rules:
                # Check if rule has formula
                if not rule.formula:
                    continue
                
                # Check formula pattern
                formula_text = rule.formula[0] if rule.formula else ""
                formula_text_clean = formula_text.replace(" ", "").upper()
                
                logger.debug(f"Checking rule with formula: {formula_text}")
                
                # Check if formula matches expected pattern
                # The formula should contain comparison like A1<>E1, A2<>E2, etc.
                # We need to check if the pattern matches (allowing for relative references)
                if "<>" in expected_formula_clean:
                    # Extract cell references from expected formula
                    # Pattern: A1<>E1 means compare A column with E column
                    expected_parts = expected_formula_clean.split("<>")
                    if len(expected_parts) == 2:
                        expected_cell1 = expected_parts[0]  # e.g., "A1"
                        expected_cell2 = expected_parts[1]   # e.g., "E1"
                        
                        # Extract column letters
                        expected_col1 = re.match(r'([A-Z]+)', expected_cell1)
                        expected_col2 = re.match(r'([A-Z]+)', expected_cell2)
                        
                        if expected_col1 and expected_col2:
                            col1 = expected_col1.group(1)
                            col2 = expected_col2.group(1)
                            
                            # Check if formula contains comparison between these columns
                            # Pattern should be like: A1<>E1, A2<>E2, etc. (relative references)
                            pattern1 = rf'{col1}\d+\s*<>\s*{col2}\d+'
                            pattern2 = rf'{col1}\d+\s*!=\s*{col2}\d+'  # Alternative: !=
                            
                            if re.search(pattern1, formula_text_clean, re.IGNORECASE) or \
                               re.search(pattern2, formula_text_clean, re.IGNORECASE):
                                found_matching_rule = True
                                logger.info(f"✓ Found matching formula pattern: {formula_text}")
                                
                                # Check if rule is applied to correct range
                                fmt_ranges = [str(rng) for rng in fmt.cells]
                                check_range_upper = check_range.upper()
                                
                                # Check if check_range is covered by any of the formatting ranges
                                try:
                                    check_cell_range = CellRange(check_range_upper)
                                    for fmt_range_str in fmt_ranges:
                                        fmt_cell_range = CellRange(fmt_range_str)
                                        # Check if check_range is within or overlaps with fmt_range
                                        if (check_cell_range.min_row >= fmt_cell_range.min_row and
                                            check_cell_range.max_row <= fmt_cell_range.max_row and
                                            check_cell_range.min_col >= fmt_cell_range.min_col and
                                            check_cell_range.max_col <= fmt_cell_range.max_col):
                                            rule_applied_to_correct_range = True
                                            logger.info(f"✓ Rule applied to correct range: {fmt_range_str} covers {check_range}")
                                            break
                                except Exception as e:
                                    logger.debug(f"Error parsing ranges: {e}")
                                    # If range parsing fails, check if range string matches
                                    if check_range_upper in fmt_ranges:
                                        rule_applied_to_correct_range = True
                                        logger.info(f"✓ Rule applied to exact range: {check_range}")
                                
                                break
            
            if found_matching_rule:
                break
        
        if not found_matching_rule:
            logger.error("No conditional formatting rule found with expected formula pattern")
            return 0.0
        
        if not rule_applied_to_correct_range:
            logger.warning("Conditional formatting rule found but may not be applied to correct range")
            # Don't fail completely, as the range might be slightly different but still valid
        
        # Optional: Check if cells with differences are actually formatted
        # This is a more advanced check that verifies the formatting is working
        if format_column:
            logger.info(f"Checking formatting in column {format_column}...")
            # Try to find cells in format_column that have conditional formatting applied
            # This is a simplified check - in practice, we'd need to evaluate the formula
            # for each cell to see if it's formatted
            
        logger.info("=" * 60)
        logger.info("✓ Conditional formatting reconciliation verification passed")
        logger.info("=" * 60)
        return 1.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_right_len_find_extract(result: str, expected: str = None, **options) -> float:
    """
    Verify if RIGHT, LEN, and FIND formulas exist in specified column to extract text.
    
    This function checks:
    1. Whether cells in specified column contain RIGHT, LEN, and FIND functions
    2. Whether formulas reference the corresponding source column cell (C2->B2, C3->B3, etc.)
    3. Whether formulas contain the correct pattern (e.g., RIGHT(B2,LEN(B2)-FIND("班",B2)))
    4. Whether formulas have the correct structure with RIGHT, LEN, and FIND functions
    
    The function automatically detects the number of data rows by checking the data column
    (default: B column) for non-empty cells. It stops checking after finding 3 consecutive
    empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_column: Column to check (e.g., "C")
            - start_row: Starting row number (default: 2)
            - expected_functions: List of expected function names (e.g., ["RIGHT", "LEN", "FIND"])
            - expected_formula_pattern: Expected formula pattern (e.g., "RIGHT(B")
            - find_text: Text to find in FIND function (e.g., "班")
            - data_column: Column to check for data to determine end_row (default: "B")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_column = options.get('check_column', 'C')
        start_row = options.get('start_row', 2)
        expected_functions = options.get('expected_functions', ['RIGHT', 'LEN', 'FIND'])
        expected_formula_pattern = options.get('expected_formula_pattern', 'RIGHT(B')
        find_text = options.get('find_text', '班')
        data_column = options.get('data_column', 'B')
        
        logger.info(f"Verifying RIGHT/LEN/FIND extraction formulas in file: {result}")
        logger.info(f"Column to check: {check_column}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Expected functions: {expected_functions}")
        logger.info(f"Expected formula pattern: {expected_formula_pattern}")
        logger.info(f"Find text: {find_text}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row  # Start from start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Check each row in the specified column
        all_passed = True
        logger.info(f"Checking column {check_column} (rows {start_row} to {end_row})")
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{check_column}{row_num}"
            try:
                cell = ws[cell_coord]
                logger.debug(f"Checking cell {cell_coord}")
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.warning(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                else:
                    # Try to get from value attribute
                    if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                # Remove leading = if present for comparison
                formula_clean = formula_text.lstrip("=")
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains all expected functions
                for func_name in expected_functions:
                    if func_name.upper() not in formula_upper:
                        logger.warning(f"Cell {cell_coord} formula does not contain {func_name}")
                        logger.warning(f"Formula: {formula_text}")
                        all_passed = False
                        break
                
                if not all_passed:
                    continue
                
                # Check 2: Formula contains expected formula pattern (e.g., RIGHT(B)
                if expected_formula_pattern.upper() not in formula_upper:
                    logger.warning(f"Cell {cell_coord} formula does not contain pattern '{expected_formula_pattern}'")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: Formula contains RIGHT function call structure
                right_match = re.search(r'RIGHT\s*\([^)]+\)', formula_text, re.IGNORECASE)
                if not right_match:
                    logger.warning(f"Cell {cell_coord} formula does not have correct RIGHT structure")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: Formula contains LEN function
                len_match = re.search(r'LEN\s*\([^)]+\)', formula_text, re.IGNORECASE)
                if not len_match:
                    logger.warning(f"Cell {cell_coord} formula does not have LEN function")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 5: Formula contains FIND function with find_text
                find_pattern = rf'FIND\s*\([^)]*{re.escape(find_text)}[^)]*\)'
                find_match = re.search(find_pattern, formula_text, re.IGNORECASE)
                if not find_match:
                    logger.warning(f"Cell {cell_coord} formula does not contain FIND function with text '{find_text}'")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 6: Formula references the corresponding source column cell (B2, B3, etc.)
                expected_source_cell = f"{data_column}{row_num}"
                source_cell_pattern = rf'{data_column}{row_num}\b'
                if not re.search(source_cell_pattern, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {cell_coord} formula does not reference source cell {expected_source_cell}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 7: Formula structure should be RIGHT(B2, LEN(B2)-FIND("班",B2))
                # Verify that LEN and FIND are used together in the second parameter of RIGHT
                # This is a pattern check - the formula should have LEN(...)-FIND(...) structure
                len_find_pattern = r'LEN\s*\([^)]+\)\s*-\s*FIND\s*\([^)]+\)'
                if not re.search(len_find_pattern, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {cell_coord} formula does not have LEN(...)-FIND(...) structure")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                logger.info(f"✓ Cell {cell_coord} has valid RIGHT/LEN/FIND formula: {formula_text}")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        if all_passed:
            logger.info("=" * 60)
            logger.info(f"✓ All cells in column {check_column} contain correct RIGHT/LEN/FIND formulas")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ RIGHT/LEN/FIND formula verification failed")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_iferror_regex_extract(result: str, expected: str = None, **options) -> float:
    """
    Verify if IFERROR(REGEX(...)) formulas exist in specified column to extract text with error handling.
    
    This function checks:
    1. Whether cells in specified column contain IFERROR function wrapping REGEX
    2. Whether REGEX function uses capture group pattern (e.g., .*水笔(\d+).*)
    3. Whether REGEX function uses replacement pattern (e.g., $1元)
    4. Whether IFERROR has empty string as second parameter
    5. Whether formulas reference the corresponding source column cell
    
    The function automatically detects the number of data rows by checking the data column
    for non-empty cells. It stops checking after finding 3 consecutive empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_column: Column to check (e.g., "C")
            - start_row: Starting row number (default: 2)
            - expected_pattern_text: Expected text pattern in regex (e.g., "水笔")
            - data_column: Column to check for data to determine end_row (default: "B")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_column = options.get('check_column', 'C')
        start_row = options.get('start_row', 2)
        expected_pattern_text = options.get('expected_pattern_text', '水笔')
        data_column = options.get('data_column', 'B')
        
        logger.info(f"Verifying IFERROR(REGEX(...)) formulas in file: {result}")
        logger.info(f"Column to check: {check_column}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Expected pattern text: {expected_pattern_text}")
        logger.info(f"Data column: {data_column}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row  # Start from start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Check each row in the specified column
        all_passed = True
        logger.info(f"Checking column {check_column} (rows {start_row} to {end_row})")
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{check_column}{row_num}"
            try:
                cell = ws[cell_coord]
                logger.debug(f"Checking cell {cell_coord}")
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.warning(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                else:
                    # Try to get from value attribute
                    if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains IFERROR function
                if 'IFERROR' not in formula_upper:
                    logger.warning(f"Cell {cell_coord} formula does not contain IFERROR function")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 2: Formula contains REGEX function (inside IFERROR)
                # Support both REGEX and LibreOffice internal format _xlfn.ORG.LIBREOFFICE.REGEX
                has_regex = 'REGEX' in formula_upper or '_XLFN.ORG.LIBREOFFICE.REGEX' in formula_upper
                if not has_regex:
                    logger.warning(f"Cell {cell_coord} formula does not contain REGEX function")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: IFERROR structure - should have two parameters
                iferror_match = re.search(r'IFERROR\s*\([^)]+\)', formula_text, re.IGNORECASE)
                if not iferror_match:
                    logger.warning(f"Cell {cell_coord} formula does not have correct IFERROR structure")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: IFERROR second parameter should be empty string ""
                # Handle various formats: ,"" or , "" or ,'' or , ''
                # Also handle LibreOffice format with spaces: REGEX(...) ,""
                # Extract IFERROR parameters: IFERROR(param1, param2)
                iferror_params_match = re.search(r'IFERROR\s*\((.*)\)', formula_text, re.IGNORECASE)
                if iferror_params_match:
                    params_str = iferror_params_match.group(1)
                    # Split by comma, but need to handle nested commas in strings
                    # Simple approach: find the last comma (should separate the two parameters)
                    # For IFERROR(REGEX(...), ""), the last comma separates REGEX call from ""
                    last_comma_pos = params_str.rfind(',')
                    if last_comma_pos != -1:
                        second_param = params_str[last_comma_pos + 1:].strip()
                        # Check if second parameter is empty string "" or ''
                        if second_param in ['""', "''", '""', "''"]:
                            has_empty_string = True
                        else:
                            has_empty_string = False
                    else:
                        has_empty_string = False
                else:
                    has_empty_string = False
                
                if not has_empty_string:
                    logger.warning(f"Cell {cell_coord} IFERROR should have empty string as second parameter")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 5: REGEX function call structure
                # Support both REGEX and LibreOffice internal format
                regex_match = re.search(r'(REGEX|_XLFN\.ORG\.LIBREOFFICE\.REGEX)\s*\([^)]+\)', formula_text, re.IGNORECASE)
                if not regex_match:
                    logger.warning(f"Cell {cell_coord} formula does not have correct REGEX structure")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 6: Formula contains expected pattern text (e.g., "水笔")
                if expected_pattern_text not in formula_text:
                    logger.warning(f"Cell {cell_coord} formula does not contain pattern text '{expected_pattern_text}'")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 7: Formula contains capture group pattern (\d+)
                has_capture_group = bool(re.search(r'\(\\d\+\)|\(\\\\d\+\)', formula_text))
                if not has_capture_group:
                    logger.warning(f"Cell {cell_coord} REGEX formula should contain capture group (\\d+)")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 8: Formula contains replacement pattern $1
                has_replacement = '"$1' in formula_text or "'$1" in formula_text
                if not has_replacement:
                    logger.warning(f"Cell {cell_coord} REGEX formula should contain replacement pattern $1")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 9: Formula references the corresponding source column cell
                expected_source_cell = f"{data_column}{row_num}"
                source_cell_pattern = rf'{data_column}{row_num}\b'
                if not re.search(source_cell_pattern, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {cell_coord} formula does not reference source cell {expected_source_cell}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                logger.info(f"✓ Cell {cell_coord} has valid IFERROR(REGEX(...)) formula: {formula_text}")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        if all_passed:
            logger.info("=" * 60)
            logger.info(f"✓ All cells in column {check_column} contain correct IFERROR(REGEX(...)) formulas")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ IFERROR(REGEX(...)) formula verification failed")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_rept_text_progress_bar(result: str, expected: str = None, **options) -> float:
    """
    Verify if REPT and TEXT formulas exist in specified column to create progress bars with percentage.
    
    This function checks:
    1. Whether cells in specified column contain REPT and TEXT functions
    2. Whether REPT function uses the correct character (e.g., "|")
    3. Whether REPT function uses the correct multiplier (e.g., *50)
    4. Whether TEXT function uses percentage format (e.g., "0%")
    5. Whether formulas reference the correct numerator and denominator columns
    6. Whether formulas use & operator to concatenate REPT and TEXT results
    
    The function automatically detects the number of data rows by checking the data column
    for non-empty cells. It stops checking after finding 3 consecutive empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_column: Column to check (e.g., "D")
            - start_row: Starting row number (default: 2)
            - expected_functions: List of expected function names (e.g., ["REPT", "TEXT"])
            - numerator_column: Column containing numerator values (e.g., "C")
            - denominator_column: Column containing denominator values (e.g., "B")
            - rept_char: Character to repeat in REPT function (e.g., "|")
            - rept_multiplier: Multiplier for REPT function (e.g., 50)
            - data_column: Column to check for data to determine end_row (default: "B")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_column = options.get('check_column', 'D')
        start_row = options.get('start_row', 2)
        expected_functions = options.get('expected_functions', ['REPT', 'TEXT'])
        numerator_column = options.get('numerator_column', 'C')
        denominator_column = options.get('denominator_column', 'B')
        rept_char = options.get('rept_char', '|')
        rept_multiplier = options.get('rept_multiplier', 50)
        data_column = options.get('data_column', 'B')
        
        logger.info(f"Verifying REPT/TEXT progress bar formulas in file: {result}")
        logger.info(f"Column to check: {check_column}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Expected functions: {expected_functions}")
        logger.info(f"Numerator column: {numerator_column}")
        logger.info(f"Denominator column: {denominator_column}")
        logger.info(f"REPT character: {rept_char}")
        logger.info(f"REPT multiplier: {rept_multiplier}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row  # Start from start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Check each row in the specified column
        all_passed = True
        logger.info(f"Checking column {check_column} (rows {start_row} to {end_row})")
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{check_column}{row_num}"
            try:
                cell = ws[cell_coord]
                logger.debug(f"Checking cell {cell_coord}")
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.warning(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                else:
                    # Try to get from value attribute
                    if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains all expected functions (REPT and TEXT)
                for func_name in expected_functions:
                    if func_name.upper() not in formula_upper:
                        logger.warning(f"Cell {cell_coord} formula does not contain {func_name}")
                        logger.warning(f"Formula: {formula_text}")
                        all_passed = False
                        break
                
                if not all_passed:
                    continue
                
                # Check 2: Formula contains REPT function call structure
                rept_match = re.search(r'REPT\s*\([^)]+\)', formula_text, re.IGNORECASE)
                if not rept_match:
                    logger.warning(f"Cell {cell_coord} formula does not have correct REPT structure")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: REPT function contains the correct character (e.g., "|")
                # Support both double quotes and single quotes
                rept_char_pattern1 = rf'REPT\s*\(\s*"{re.escape(rept_char)}"'
                rept_char_pattern2 = rf"REPT\s*\(\s*'{re.escape(rept_char)}'"
                if not re.search(rept_char_pattern1, formula_text, re.IGNORECASE) and \
                   not re.search(rept_char_pattern2, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {cell_coord} REPT function should use character '{rept_char}'")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: REPT function contains the multiplier (e.g., *50)
                rept_multiplier_pattern = rf'\*{rept_multiplier}\b'
                if not re.search(rept_multiplier_pattern, formula_text):
                    logger.warning(f"Cell {cell_coord} REPT function should use multiplier *{rept_multiplier}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 5: Formula contains TEXT function call structure
                text_match = re.search(r'TEXT\s*\([^)]+\)', formula_text, re.IGNORECASE)
                if not text_match:
                    logger.warning(f"Cell {cell_coord} formula does not have correct TEXT structure")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 6: TEXT function contains percentage format ("0%" or '0%')
                text_percent_pattern1 = r'TEXT\s*\([^,]+,\s*"0%"'
                text_percent_pattern2 = r"TEXT\s*\([^,]+,\s*'0%'"
                if not re.search(text_percent_pattern1, formula_text, re.IGNORECASE) and \
                   not re.search(text_percent_pattern2, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {cell_coord} TEXT function should use percentage format \"0%\"")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 7: Formula references the correct numerator column (C2, C3, etc.)
                expected_numerator_cell = f"{numerator_column}{row_num}"
                numerator_cell_pattern = rf'{numerator_column}{row_num}\b'
                if not re.search(numerator_cell_pattern, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {cell_coord} formula does not reference numerator cell {expected_numerator_cell}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 8: Formula references the correct denominator column (B2, B3, etc.)
                expected_denominator_cell = f"{denominator_column}{row_num}"
                denominator_cell_pattern = rf'{denominator_column}{row_num}\b'
                if not re.search(denominator_cell_pattern, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {cell_coord} formula does not reference denominator cell {expected_denominator_cell}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 9: Formula contains & operator to concatenate REPT and TEXT
                if '&' not in formula_text:
                    logger.warning(f"Cell {cell_coord} formula should use & operator to concatenate REPT and TEXT")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 10: Formula structure should be REPT(...)&TEXT(...)
                # Verify that REPT comes before TEXT (or at least both are present)
                rept_pos = formula_text.upper().find('REPT')
                text_pos = formula_text.upper().find('TEXT')
                if rept_pos == -1 or text_pos == -1:
                    logger.warning(f"Cell {cell_coord} formula should contain both REPT and TEXT functions")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                logger.info(f"✓ Cell {cell_coord} has valid REPT/TEXT progress bar formula: {formula_text}")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        if all_passed:
            logger.info("=" * 60)
            logger.info(f"✓ All cells in column {check_column} contain correct REPT/TEXT progress bar formulas")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ REPT/TEXT progress bar formula verification failed")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_id_extract_gender_age_birthday(result: str, expected: str = None, **options) -> float:
    """
    Verify if formulas exist to extract gender, age, and birthday from ID numbers.
    
    This function checks:
    1. Gender column (C): IF(MOD(MID(B3,17,1),2),"男","女")
    2. Age column (D): DATEDIF(TEXT(MID(B3,7,8),"0-00-00"),TODAY(),"Y")
    3. Birthday column (E): --TEXT(MID(B3,7,8),"0-00-00")
    
    The function automatically detects the number of data rows by checking the ID column
    for non-empty cells. It stops checking after finding 3 consecutive empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - id_column: Column containing ID numbers (e.g., "B")
            - gender_column: Column for gender formulas (e.g., "C")
            - age_column: Column for age formulas (e.g., "D")
            - birthday_column: Column for birthday formulas (e.g., "E")
            - start_row: Starting row number (default: 3)
            - data_column: Column to check for data to determine end_row (default: "B")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        id_column = options.get('id_column', 'B')
        gender_column = options.get('gender_column', 'C')
        age_column = options.get('age_column', 'D')
        birthday_column = options.get('birthday_column', 'E')
        start_row = options.get('start_row', 3)
        data_column = options.get('data_column', 'B')
        
        logger.info(f"Verifying ID extraction formulas in file: {result}")
        logger.info(f"ID column: {id_column}")
        logger.info(f"Gender column: {gender_column}")
        logger.info(f"Age column: {age_column}")
        logger.info(f"Birthday column: {birthday_column}")
        logger.info(f"Start row: {start_row}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row  # Start from start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Check each row
        all_passed = True
        logger.info(f"Checking rows {start_row} to {end_row}")
        
        for row_num in range(start_row, end_row + 1):
            try:
                # Check gender column (C)
                gender_cell_coord = f"{gender_column}{row_num}"
                gender_cell = ws[gender_cell_coord]
                
                if gender_cell.data_type != "f":
                    logger.warning(f"Cell {gender_cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                gender_formula_text = None
                if hasattr(gender_cell, "_value") and isinstance(gender_cell._value, str) and gender_cell._value.startswith("="):
                    gender_formula_text = gender_cell._value
                elif hasattr(gender_cell, "formula"):
                    gender_formula_text = gender_cell.formula
                elif gender_cell.value is not None and isinstance(gender_cell.value, str) and gender_cell.value.startswith("="):
                    gender_formula_text = gender_cell.value
                
                if gender_formula_text is None:
                    logger.warning(f"Could not extract formula from cell {gender_cell_coord}")
                    all_passed = False
                    continue
                
                gender_formula_upper = gender_formula_text.upper()
                logger.debug(f"Cell {gender_cell_coord} formula: {gender_formula_text}")
                
                # Check gender formula: IF(MOD(MID(B3,17,1),2),"男","女")
                if 'IF' not in gender_formula_upper:
                    logger.warning(f"Cell {gender_cell_coord} formula does not contain IF function")
                    all_passed = False
                    continue
                
                if 'MOD' not in gender_formula_upper:
                    logger.warning(f"Cell {gender_cell_coord} formula does not contain MOD function")
                    all_passed = False
                    continue
                
                if 'MID' not in gender_formula_upper:
                    logger.warning(f"Cell {gender_cell_coord} formula does not contain MID function")
                    all_passed = False
                    continue
                
                # Check MID(B3,17,1) pattern
                mid_pattern = rf'MID\s*\(\s*{id_column}{row_num}\s*,\s*17\s*,\s*1\s*\)'
                if not re.search(mid_pattern, gender_formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {gender_cell_coord} formula should contain MID({id_column}{row_num},17,1)")
                    logger.warning(f"Formula: {gender_formula_text}")
                    all_passed = False
                    continue
                
                # Check for "男" and "女" in formula
                if '"男"' not in gender_formula_text and "'男'" not in gender_formula_text:
                    logger.warning(f"Cell {gender_cell_coord} formula should contain \"男\"")
                    logger.warning(f"Formula: {gender_formula_text}")
                    all_passed = False
                    continue
                
                if '"女"' not in gender_formula_text and "'女'" not in gender_formula_text:
                    logger.warning(f"Cell {gender_cell_coord} formula should contain \"女\"")
                    logger.warning(f"Formula: {gender_formula_text}")
                    all_passed = False
                    continue
                
                logger.info(f"✓ Cell {gender_cell_coord} has valid gender formula: {gender_formula_text}")
                
                # Check age column (D)
                age_cell_coord = f"{age_column}{row_num}"
                age_cell = ws[age_cell_coord]
                
                if age_cell.data_type != "f":
                    logger.warning(f"Cell {age_cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                age_formula_text = None
                if hasattr(age_cell, "_value") and isinstance(age_cell._value, str) and age_cell._value.startswith("="):
                    age_formula_text = age_cell._value
                elif hasattr(age_cell, "formula"):
                    age_formula_text = age_cell.formula
                elif age_cell.value is not None and isinstance(age_cell.value, str) and age_cell.value.startswith("="):
                    age_formula_text = age_cell.value
                
                if age_formula_text is None:
                    logger.warning(f"Could not extract formula from cell {age_cell_coord}")
                    all_passed = False
                    continue
                
                age_formula_upper = age_formula_text.upper()
                logger.debug(f"Cell {age_cell_coord} formula: {age_formula_text}")
                
                # Check age formula: DATEDIF(TEXT(MID(B3,7,8),"0-00-00"),TODAY(),"Y")
                if 'DATEDIF' not in age_formula_upper:
                    logger.warning(f"Cell {age_cell_coord} formula does not contain DATEDIF function")
                    all_passed = False
                    continue
                
                if 'TEXT' not in age_formula_upper:
                    logger.warning(f"Cell {age_cell_coord} formula does not contain TEXT function")
                    all_passed = False
                    continue
                
                if 'TODAY' not in age_formula_upper:
                    logger.warning(f"Cell {age_cell_coord} formula does not contain TODAY function")
                    all_passed = False
                    continue
                
                if 'MID' not in age_formula_upper:
                    logger.warning(f"Cell {age_cell_coord} formula does not contain MID function")
                    all_passed = False
                    continue
                
                # Check MID(B3,7,8) pattern
                mid_pattern_age = rf'MID\s*\(\s*{id_column}{row_num}\s*,\s*7\s*,\s*8\s*\)'
                if not re.search(mid_pattern_age, age_formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {age_cell_coord} formula should contain MID({id_column}{row_num},7,8)")
                    logger.warning(f"Formula: {age_formula_text}")
                    all_passed = False
                    continue
                
                # Check TEXT format "0-00-00"
                # Use pattern that matches until the quote to handle nested functions like MID(B3,7,8)
                text_format_pattern1 = r'TEXT\s*\([^"]+,\s*"0-00-00"'
                text_format_pattern2 = r"TEXT\s*\([^']+,\s*'0-00-00'"
                if not re.search(text_format_pattern1, age_formula_text, re.IGNORECASE) and \
                   not re.search(text_format_pattern2, age_formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {age_cell_coord} TEXT function should use format \"0-00-00\"")
                    logger.warning(f"Formula: {age_formula_text}")
                    all_passed = False
                    continue
                
                # Check DATEDIF third parameter "Y"
                # Use a more flexible pattern that handles nested functions
                # Check if DATEDIF contains "Y" as the third parameter (after two commas)
                # Pattern: DATEDIF(...,...,"Y") or DATEDIF(...,...,'Y')
                # We'll count commas to find the third parameter
                datedif_match = re.search(r'DATEDIF\s*\((.*)\)', age_formula_text, re.IGNORECASE)
                if datedif_match:
                    datedif_params = datedif_match.group(1)
                    # Count commas to find the third parameter
                    # Simple approach: check if the last part before closing paren is "Y" or 'Y'
                    # More robust: find the pattern ,"Y" or ,'Y' before the closing paren
                    if not re.search(r',\s*"Y"\s*\)', age_formula_text, re.IGNORECASE) and \
                       not re.search(r",\s*'Y'\s*\)", age_formula_text, re.IGNORECASE):
                        logger.warning(f"Cell {age_cell_coord} DATEDIF function should use \"Y\" parameter")
                        logger.warning(f"Formula: {age_formula_text}")
                        all_passed = False
                        continue
                else:
                    logger.warning(f"Cell {age_cell_coord} could not parse DATEDIF function")
                    logger.warning(f"Formula: {age_formula_text}")
                    all_passed = False
                    continue
                
                logger.info(f"✓ Cell {age_cell_coord} has valid age formula: {age_formula_text}")
                
                # Check birthday column (E)
                birthday_cell_coord = f"{birthday_column}{row_num}"
                birthday_cell = ws[birthday_cell_coord]
                
                if birthday_cell.data_type != "f":
                    logger.warning(f"Cell {birthday_cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                birthday_formula_text = None
                if hasattr(birthday_cell, "_value") and isinstance(birthday_cell._value, str) and birthday_cell._value.startswith("="):
                    birthday_formula_text = birthday_cell._value
                elif hasattr(birthday_cell, "formula"):
                    birthday_formula_text = birthday_cell.formula
                elif birthday_cell.value is not None and isinstance(birthday_cell.value, str) and birthday_cell.value.startswith("="):
                    birthday_formula_text = birthday_cell.value
                
                if birthday_formula_text is None:
                    logger.warning(f"Could not extract formula from cell {birthday_cell_coord}")
                    all_passed = False
                    continue
                
                birthday_formula_upper = birthday_formula_text.upper()
                logger.debug(f"Cell {birthday_cell_coord} formula: {birthday_formula_text}")
                
                # Check birthday formula: TEXT(MID(B3,7,8),"0-00-00")
                if 'TEXT' not in birthday_formula_upper:
                    logger.warning(f"Cell {birthday_cell_coord} formula does not contain TEXT function")
                    all_passed = False
                    continue
                
                if 'MID' not in birthday_formula_upper:
                    logger.warning(f"Cell {birthday_cell_coord} formula does not contain MID function")
                    all_passed = False
                    continue
                
                # Check MID(B3,7,8) pattern
                mid_pattern_birthday = rf'MID\s*\(\s*{id_column}{row_num}\s*,\s*7\s*,\s*8\s*\)'
                if not re.search(mid_pattern_birthday, birthday_formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {birthday_cell_coord} formula should contain MID({id_column}{row_num},7,8)")
                    logger.warning(f"Formula: {birthday_formula_text}")
                    all_passed = False
                    continue
                
                # Check TEXT format "0-00-00"
                # Use pattern that matches until the quote to handle nested functions like MID(B3,7,8)
                text_format_pattern1 = r'TEXT\s*\([^"]+,\s*"0-00-00"'
                text_format_pattern2 = r"TEXT\s*\([^']+,\s*'0-00-00'"
                if not re.search(text_format_pattern1, birthday_formula_text, re.IGNORECASE) and \
                   not re.search(text_format_pattern2, birthday_formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {birthday_cell_coord} TEXT function should use format \"0-00-00\"")
                    logger.warning(f"Formula: {birthday_formula_text}")
                    all_passed = False
                    continue
                
                logger.info(f"✓ Cell {birthday_cell_coord} has valid birthday formula: {birthday_formula_text}")
                
            except Exception as e:
                logger.error(f"Error checking row {row_num}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        if all_passed:
            logger.info("=" * 60)
            logger.info(f"✓ All rows contain correct ID extraction formulas (gender, age, birthday)")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ ID extraction formula verification failed")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_line_chart(result: str, expected: str = None, **options) -> float:
    """
    Verify if a line chart exists in the Excel file.
    
    This function checks:
    1. Whether at least one chart exists in the worksheet
    2. Whether the chart type is lineChart
    3. Whether the chart has the expected number of series
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - expected_chart_type: Expected chart type (default: "lineChart")
            - min_series_count: Minimum number of series expected (default: 1)
            - data_range: Data range used for chart (optional, for logging)
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        expected_chart_type = options.get('expected_chart_type', 'lineChart')
        min_series_count = options.get('min_series_count', 1)
        data_range = options.get('data_range', '')
        
        logger.info(f"Verifying line chart in file: {result}")
        logger.info(f"Expected chart type: {expected_chart_type}")
        logger.info(f"Minimum series count: {min_series_count}")
        if data_range:
            logger.info(f"Data range: {data_range}")
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result)
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check if charts exist
        charts = ws._charts
        if not charts or len(charts) == 0:
            logger.error("No charts found in the worksheet")
            return 0.0
        
        logger.info(f"Found {len(charts)} chart(s) in the worksheet")
        
        # Check each chart
        for chart_idx, chart in enumerate(charts):
            logger.info(f"Checking chart {chart_idx + 1}...")
            
        # Check chart type - accept both bar chart and combination chart (bar + line)
        chart_found = False
        has_bar_chart = False
        has_line_chart = False
        
        for chart_idx, chart in enumerate(charts):
            logger.info(f"Checking chart {chart_idx + 1}...")
            
            chart_type = None
            if hasattr(chart, 'tagname'):
                chart_type = chart.tagname
            elif hasattr(chart, 'chart_type'):
                chart_type = str(chart.chart_type)
            
            logger.info(f"Chart type: {chart_type}")
            
            # Check if it's a bar chart, combo chart, or contains bar chart
            if chart_type:
                chart_type_lower = chart_type.lower()
                if expected_chart_type.lower() in chart_type_lower or 'bar' in chart_type_lower or 'column' in chart_type_lower:
                    chart_found = True
                    has_bar_chart = True
                    logger.info(f"✓ Chart {chart_idx + 1} is a bar/column chart")
                elif 'combo' in chart_type_lower or 'combination' in chart_type_lower:
                    chart_found = True
                    logger.info(f"✓ Chart {chart_idx + 1} is a combination chart")
            
            # Check XML for barChart and lineChart in plotArea (for combo charts)
            try:
                from zipfile import ZipFile
                import xml.etree.ElementTree as ET
                
                wb_path = result
                with ZipFile(wb_path, 'r') as zip_file:
                    chart_files = [f for f in zip_file.namelist() if 'charts/chart' in f and f.endswith('.xml')]
                    for chart_file in chart_files:
                        xml_content = zip_file.read(chart_file).decode('utf-8')
                        root = ET.fromstring(xml_content)
                        
                        plot_areas = root.findall('.//{http://schemas.openxmlformats.org/drawingml/2006/chart}plotArea')
                        for plot_area in plot_areas:
                            bar_charts = plot_area.findall('.//{http://schemas.openxmlformats.org/drawingml/2006/chart}barChart')
                            line_charts = plot_area.findall('.//{http://schemas.openxmlformats.org/drawingml/2006/chart}lineChart')
                            
                            if len(bar_charts) > 0:
                                has_bar_chart = True
                                chart_found = True
                                logger.info(f"✓ Chart has barChart in plotArea")
                            
                            if len(line_charts) > 0:
                                has_line_chart = True
                                chart_found = True
                                logger.info(f"✓ Chart has lineChart in plotArea")
                            
                            if has_bar_chart and has_line_chart:
                                logger.info(f"✓ Chart is a combination chart (bar + line)")
                        break
            except Exception as e:
                logger.warning(f"Could not read chart XML: {e}")
            
            if chart_found:
                break
        
        if not chart_found:
            logger.error(f"No bar chart or combination chart found")
            return 0.0
        
        if not has_bar_chart:
            logger.error(f"Chart does not contain bar chart series")
            return 0.0
             
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_salary_growth_chart(result: str, expected: str = None, **options) -> float:
    """
    Verify if the salary growth chart matches the expected specifications.
    
    This function checks the chart itself (not the data table):
    1. Whether a chart exists in the specified sheet
    2. Whether the chart title matches "店长工资增长"
    3. Whether the chart has the expected number of series (at least 3)
    4. Whether the chart is a combination chart (bar + line)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - sheet_idx: Sheet index (default: 0)
            - expected_title: Expected chart title (default: "店长工资增长")
            - min_series_count: Minimum number of series (default: 3)
            - chart_type: Expected chart type (default: "combination")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        sheet_idx = options.get('sheet_idx', 0)
        expected_title = options.get('expected_title', '店长工资增长')
        min_series_count = options.get('min_series_count', 3)
        chart_type = options.get('chart_type', 'combination')
        
        logger.info(f"Verifying salary growth chart in file: {result}")
        logger.info(f"Sheet index: {sheet_idx}")
        logger.info(f"Expected title: {expected_title}")
        logger.info(f"Min series count: {min_series_count}")
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result)
            pdworkbook = pd.ExcelFile(result)
            sheet_names = pdworkbook.sheet_names
            
            if sheet_idx >= len(sheet_names):
                logger.error(f"Sheet index {sheet_idx} out of range. Available sheets: {sheet_names}")
                return 0.0
            
            sheet_name = sheet_names[sheet_idx]
            logger.info(f"Checking sheet: {sheet_name}")
            ws = wb[sheet_name]
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return 0.0
        
        # Check if charts exist
        charts = ws._charts
        if not charts:
            logger.error("No charts found in the sheet")
            return 0.0
        
        logger.info(f"Found {len(charts)} chart(s) in the sheet")
        
        # Load chart information
        chart_props = ['title', 'type', 'legend', 'xtitle', 'ytitle']
        chart_info = load_charts(wb, sheet_name, chart_props=chart_props)
        
        if not chart_info:
            logger.error("Could not load chart information")
            return 0.0
        
        # Check each chart
        chart_passed = False
        for chart_key, chart_data in chart_info.items():
            logger.info(f"Checking chart: {chart_key}")
            logger.debug(f"Chart data: {chart_data}")
            
            # Check 1: Chart title
            chart_title = chart_data.get('title')
            if chart_title != expected_title:
                logger.warning(f"Chart title mismatch: expected '{expected_title}', got '{chart_title}'")
                continue
            else:
                logger.info(f"✓ Chart title matches: {chart_title}")
            
            # Check 2: Chart type (for combination charts, we might see multiple types)
            chart_type_actual = chart_data.get('type')
            logger.info(f"Chart type: {chart_type_actual}")
            # Note: Combination charts might be represented differently in openpyxl
            # We'll be lenient here and just check that a chart exists
            
            # Check 3: Number of series
            # Extract series count from chart_key (format: "value_ref1,category_ref1;value_ref2,category_ref2;...")
            series_parts = chart_key.split(';')
            series_count = len(series_parts)
            logger.info(f"Number of series: {series_count}")
            
            if series_count < min_series_count:
                logger.warning(f"Insufficient series count: expected at least {min_series_count}, got {series_count}")
                continue
            else:
                logger.info(f"✓ Series count sufficient: {series_count} >= {min_series_count}")
            
            # If we get here, this chart passed all checks
            chart_passed = True
            logger.info("=" * 60)
            logger.info(f"✓ Chart verification passed!")
            logger.info("=" * 60)
            break
        
        if chart_passed:
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error("✗ Chart verification failed - no chart matched all criteria")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_project_completion_chart(result: str, expected: str = None, **options) -> float:
    """
    Verify if a combination chart exists with the expected title that contains
    both bar chart series (for project values) and line chart series (for completion rates).
    
    This function checks:
    1. Whether at least one chart exists in the worksheet
    2. Whether the chart title matches expected_title
    3. Whether the chart has at least 16 series (8 projects + 8 completion rates)
    4. Whether at least one series name contains "rate" (for completion rates)
    5. Whether the chart has at least project_count * 5 categories (for 5 quarters per project)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - sheet_idx: Sheet index to check (default: 0)
            - expected_title: Expected chart title (default: "项目")
            - min_series_count: Minimum number of series required (default: 16)
            - project_count: Number of projects (default: 8)
            - quarters_per_project: Number of quarters per project (default: 5)
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        sheet_idx = options.get('sheet_idx', 0)
        expected_title = options.get('expected_title', '项目')
        min_series_count = options.get('min_series_count', 16)
        project_count = options.get('project_count', 8)
        quarters_per_project = options.get('quarters_per_project', 5)
        min_categories = project_count * quarters_per_project
        
        logger.info(f"Verifying project completion chart in file: {result}")
        logger.info(f"Sheet index: {sheet_idx}")
        logger.info(f"Expected title: {expected_title}")
        logger.info(f"Minimum series count: {min_series_count}")
        logger.info(f"Project count: {project_count}")
        logger.info(f"Quarters per project: {quarters_per_project}")
        logger.info(f"Minimum categories: {min_categories}")
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result)
            sheet_names = wb.sheetnames
            if sheet_idx >= len(sheet_names):
                logger.error(f"Sheet index {sheet_idx} out of range. Available sheets: {sheet_names}")
                return 0.0
            sheet_name = sheet_names[sheet_idx]
            ws = wb[sheet_name]
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check if charts exist
        charts = ws._charts
        if not charts:
            logger.error("No charts found in the worksheet")
            return 0.0
        
        logger.info(f"Found {len(charts)} chart(s) in the worksheet")
        
        # Check each chart
        chart_found = False
        for chart in charts:
            # Check chart title
            chart_title = None
            try:
                if chart.title and chart.title.tx:
                    if hasattr(chart.title.tx, 'rich') and chart.title.tx.rich:
                        if hasattr(chart.title.tx.rich, 'p') and chart.title.tx.rich.p:
                            if len(chart.title.tx.rich.p) > 0:
                                if hasattr(chart.title.tx.rich.p[0], 'r') and chart.title.tx.rich.p[0].r:
                                    if len(chart.title.tx.rich.p[0].r) > 0:
                                        if hasattr(chart.title.tx.rich.p[0].r[0], 't'):
                                            chart_title = chart.title.tx.rich.p[0].r[0].t
            except Exception as e:
                logger.debug(f"Error reading chart title: {e}")
            
            logger.info(f"Chart title: {chart_title}")
            
            # Check if title matches
            if chart_title == expected_title:
                logger.info(f"✓ Chart title matches: {chart_title}")
                chart_found = True
                
                # Use load_charts to get all series information (includes both bar and line series)
                # This is more reliable for combination charts
                chart_props = ['title']
                chart_info = load_charts(wb, sheet_name, chart_props=chart_props)
                
                # Find the chart that matches our title
                chart_key = None
                for key, info in chart_info.items():
                    if info.get('title') == expected_title:
                        chart_key = key
                        break
                
                # Get all series from the chart object for detailed inspection
                all_series = list(chart.series) if hasattr(chart, 'series') else []
                logger.info(f"Series count from chart.series: {len(all_series)}")
                
                if not chart_key:
                    logger.warning("Could not find chart in load_charts output, using direct series access")
                    # Fallback to direct series access
                    series_count = len(all_series)
                else:
                    # Extract series count from chart_key (format: "value_ref1,category_ref1;value_ref2,category_ref2;...")
                    # This includes ALL series (both bar and line) in combination charts
                    series_parts = chart_key.split(';')
                    series_count_from_load = len(series_parts)
                    logger.info(f"Series count from load_charts: {series_count_from_load}")
                    
                    # For combination charts, load_charts should give us all series
                    # Use the count from load_charts as it's more reliable for combination charts
                    series_count = series_count_from_load
                    
                    # Also check for sub-charts in case series are stored there
                    if hasattr(chart, '_charts') and chart._charts:
                        # Check for sub-charts (for combination charts)
                        for sub_chart in chart._charts:
                            if hasattr(sub_chart, 'series'):
                                sub_series = list(sub_chart.series)
                                all_series.extend(sub_series)
                                logger.info(f"Found {len(sub_series)} additional series in sub-chart")
                    
                    # If load_charts gave us fewer series than direct access, use the larger count
                    # This handles edge cases where load_charts might miss some series
                    if series_count < len(all_series):
                        logger.warning(f"load_charts found {series_count} series but direct access found {len(all_series)}, using larger count")
                        series_count = len(all_series)
                
                logger.info(f"Chart has {series_count} series (including both bar and line series)")
                
                # Debug: Log all series details
                if all_series:
                    logger.info(f"Detailed series information:")
                    for idx, ser in enumerate(all_series):
                        logger.info(f"  Series {idx}: {type(ser).__name__}")
                        try:
                            if hasattr(ser, 'title'):
                                logger.debug(f"    Title: {ser.title}")
                        except:
                            pass
                
                if series_count < min_series_count:
                    logger.error(f"✗ Chart has only {series_count} series, expected at least {min_series_count}")
                    return 0.0
                
                logger.info(f"✓ Chart has {series_count} series (>= {min_series_count})")
                
                # Check series names for "rate" (completion rate series)
                has_rate_series = False
                series_names = []
                for i, ser in enumerate(all_series):
                    series_name = None
                    try:
                        # Try to get series title/name
                        if hasattr(ser, 'title') and ser.title:
                            if hasattr(ser.title, 'tx') and ser.title.tx:
                                if hasattr(ser.title.tx, 'rich') and ser.title.tx.rich:
                                    if hasattr(ser.title.tx.rich, 'p') and ser.title.tx.rich.p:
                                        if len(ser.title.tx.rich.p) > 0:
                                            if hasattr(ser.title.tx.rich.p[0], 'r') and ser.title.tx.rich.p[0].r:
                                                if len(ser.title.tx.rich.p[0].r) > 0:
                                                    if hasattr(ser.title.tx.rich.p[0].r[0], 't'):
                                                        series_name = ser.title.tx.rich.p[0].r[0].t
                        # Alternative: check if title is a string reference
                        if not series_name and hasattr(ser, 'title') and hasattr(ser.title, 'tx') and hasattr(ser.title.tx, 'strRef'):
                            if hasattr(ser.title.tx.strRef, 'f'):
                                series_name = ser.title.tx.strRef.f
                    except Exception as e:
                        logger.debug(f"Error reading series {i} name: {e}")
                    
                    if series_name:
                        series_names.append(series_name)
                        if "rate" in series_name.lower():
                            has_rate_series = True
                            logger.info(f"✓ Found series with 'rate' in name: {series_name}")
                
                if series_names:
                    logger.info(f"Series names found: {series_names[:10]}...")  # Log first 10
                else:
                    logger.warning("Could not extract series names, will skip rate check")
                
                if not has_rate_series and series_names:
                    logger.error(f"✗ No series found with 'rate' in name. Series names: {series_names}")
                    return 0.0
                elif not has_rate_series:
                    logger.warning("⚠ Could not verify 'rate' in series names (series names not extractable)")
                
                # Check category count
                max_categories = 0
                category_ranges = []
                
                def parse_range_count(range_str):
                    """Parse Excel range string and return count of cells"""
                    try:
                        # Remove sheet name if present (e.g., "Sheet1!$A$2:$A$6" -> "$A$2:$A$6")
                        if '!' in range_str:
                            range_str = range_str.split('!')[1]
                        
                        # Remove $ signs
                        range_str = range_str.replace('$', '')
                        
                        if ':' in range_str:
                            start, end = range_str.split(':')
                            # Parse start and end coordinates
                            # Helper function to parse coordinate like "A1" to (column_index, row_number)
                            from openpyxl.utils import column_index_from_string
                            import re
                            
                            def parse_coordinate(coord):
                                """Parse coordinate string like 'A1' to (column_index, row_number)"""
                                match = re.match(r'([A-Z]+)(\d+)', coord.upper())
                                if match:
                                    col_str, row_str = match.groups()
                                    col_idx = column_index_from_string(col_str)
                                    row_num = int(row_str)
                                    return (col_idx, row_num)
                                raise ValueError(f"Invalid coordinate: {coord}")
                            
                            start_col, start_row = parse_coordinate(start)
                            end_col, end_row = parse_coordinate(end)
                            
                            # Calculate count based on range
                            if start_col == end_col:
                                # Same column, count rows
                                return abs(end_row - start_row) + 1
                            elif start_row == end_row:
                                # Same row, count columns
                                return abs(end_col - start_col) + 1
                            else:
                                # 2D range
                                return (abs(end_row - start_row) + 1) * (abs(end_col - start_col) + 1)
                        else:
                            # Single cell
                            return 1
                    except Exception as e:
                        logger.debug(f"Error parsing range {range_str}: {e}")
                        return 0
                
                for i, ser in enumerate(all_series):
                    try:
                        # Try to get category count from category reference
                        if hasattr(ser, 'cat'):
                            cat_range = None
                            # Check if categories are from a range
                            if hasattr(ser.cat, 'numRef') and hasattr(ser.cat.numRef, 'f'):
                                cat_range = ser.cat.numRef.f
                            elif hasattr(ser.cat, 'strRef') and hasattr(ser.cat.strRef, 'f'):
                                cat_range = ser.cat.strRef.f
                            
                            if cat_range:
                                category_ranges.append(cat_range)
                                cat_count = parse_range_count(cat_range)
                                if cat_count > max_categories:
                                    max_categories = cat_count
                                logger.debug(f"Series {i} category range: {cat_range}, count: {cat_count}")
                    except Exception as e:
                        logger.debug(f"Error reading categories for series {i}: {e}")
                
                if max_categories > 0:
                    logger.info(f"Maximum category count found: {max_categories}")
                    if max_categories < min_categories:
                        logger.error(f"✗ Chart has only {max_categories} categories, expected at least {min_categories} (project_count * quarters_per_project)")
                        return 0.0
                    logger.info(f"✓ Chart has {max_categories} categories (>= {min_categories})")
                else:
                    # If we can't determine category count from ranges, use heuristic
                    # For 8 projects with 5 quarters each, we need at least 40 categories
                    # But since we can't verify directly, we'll log a warning
                    logger.warning(f"⚠ Could not determine exact category count from ranges. Expected at least {min_categories} categories.")
                    logger.info(f"Category ranges found: {category_ranges[:5]}...")  # Log first 5
                
                # Check if it's a combination chart
                if series_count >= 2:
                    logger.info("✓ Chart appears to be a combination chart (has multiple series)")
                else:
                    logger.error(f"✗ Chart has only {series_count} series, expected at least 2 for combination chart")
                    return 0.0
                
                break
        
        if chart_found:
            logger.info("=" * 60)
            logger.info("✓ Project completion combination chart verification passed")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ Chart with title '{expected_title}' not found")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_shipping_boxes_calculation(result: str, expected: str = None, **options) -> float:
    """
    Verify if formulas exist to calculate shipping boxes from product specifications and order quantities.
    
    This function checks:
    1. Whether cells in specified column contain formulas (not just values)
    2. Whether formulas contain required functions: INT, VALUE, LEFT, FIND, MOD, IF
    3. Whether formulas reference the specification column (B) and quantity column (C)
    4. Whether formulas contain Chinese characters "支" and "盒"
    5. Whether formulas use string concatenation (&)
    
    The expected formula pattern:
    =INT(C2/VALUE(LEFT(B2,FIND("支",B2)-1)))&"盒"&IF(MOD(C2,VALUE(LEFT(B2,FIND("支",B2)-1)))=0,"","加"&MOD(C2,VALUE(LEFT(B2,FIND("支",B2)-1)))&"支")
    
    The function automatically detects the number of data rows by checking the data column
    for non-empty cells. It stops checking after finding 3 consecutive empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_column: Column to check (e.g., "D")
            - start_row: Starting row number (default: 2)
            - spec_column: Column containing product specifications (e.g., "B")
            - quantity_column: Column containing order quantities (e.g., "C")
            - expected_functions: List of expected function names (e.g., ["INT", "VALUE", "LEFT", "FIND", "MOD", "IF"])
            - data_column: Column to check for data to determine end_row (default: "B")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_column = options.get('check_column', 'D')
        start_row = options.get('start_row', 2)
        spec_column = options.get('spec_column', 'B')
        quantity_column = options.get('quantity_column', 'C')
        expected_functions = options.get('expected_functions', ['INT', 'VALUE', 'LEFT', 'FIND', 'MOD', 'IF'])
        data_column = options.get('data_column', 'B')
        
        logger.info(f"Verifying shipping boxes calculation formulas in file: {result}")
        logger.info(f"Column to check: {check_column}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Specification column: {spec_column}")
        logger.info(f"Quantity column: {quantity_column}")
        logger.info(f"Expected functions: {expected_functions}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row  # Start from start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        if end_row < start_row:
            logger.error(f"No data rows found starting from row {start_row}")
            return 0.0
        
        # Check formulas in each row
        all_checks_passed = True
        rows_checked = 0
        
        for row_num in range(start_row, end_row + 1):
            check_cell = ws[f"{check_column}{row_num}"]
            spec_cell = ws[f"{spec_column}{row_num}"]
            quantity_cell = ws[f"{quantity_column}{row_num}"]
            
            # Skip if spec or quantity cell is empty
            if spec_cell.value is None or quantity_cell.value is None:
                continue
            
            rows_checked += 1
            formula = check_cell.value
            
            # Check 1: Formula exists (not just a value)
            if formula is None or not isinstance(formula, str) or not formula.startswith('='):
                logger.error(f"Cell {check_column}{row_num} should contain a formula, but got: {formula}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Row {row_num} formula: {formula}")
            
            # Check 2: Contains all required functions
            missing_functions = []
            for func in expected_functions:
                # Check for function name (with word boundary to avoid partial matches)
                func_pattern = r'\b' + re.escape(func) + r'\s*\('
                if not re.search(func_pattern, formula_upper, re.IGNORECASE):
                    missing_functions.append(func)
            
            if missing_functions:
                logger.error(f"Cell {check_column}{row_num} formula missing functions: {missing_functions}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: References specification column (B)
            spec_pattern = rf'{spec_column}\d+'
            if not re.search(spec_pattern, formula_upper):
                logger.error(f"Cell {check_column}{row_num} formula should reference {spec_column} column")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: References quantity column (C)
            quantity_pattern = rf'{quantity_column}\d+'
            if not re.search(quantity_pattern, formula_upper):
                logger.error(f"Cell {check_column}{row_num} formula should reference {quantity_column} column")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 5: Contains Chinese character "支" (for extracting pieces per box)
            if '"支"' not in formula and "'支'" not in formula and '支' not in formula:
                logger.error(f"Cell {check_column}{row_num} formula should contain '支' character")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 6: Contains Chinese character "盒" (for box unit)
            if '"盒"' not in formula and "'盒'" not in formula and '盒' not in formula:
                logger.error(f"Cell {check_column}{row_num} formula should contain '盒' character")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 7: Uses string concatenation (&)
            if '&' not in formula:
                logger.error(f"Cell {check_column}{row_num} formula should use & for string concatenation")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 8: Contains INT function (for calculating integer boxes)
            int_pattern = r'\bINT\s*\('
            if not re.search(int_pattern, formula_upper):
                logger.error(f"Cell {check_column}{row_num} formula should contain INT function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 9: Contains MOD function (for calculating remainder)
            mod_pattern = r'\bMOD\s*\('
            if not re.search(mod_pattern, formula_upper):
                logger.error(f"Cell {check_column}{row_num} formula should contain MOD function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 10: Contains IF function (for conditional formatting)
            if_pattern = r'\bIF\s*\('
            if not re.search(if_pattern, formula_upper):
                logger.error(f"Cell {check_column}{row_num} formula should contain IF function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            logger.debug(f"✓ Row {row_num} formula passed all checks")
        
        if rows_checked == 0:
            logger.error("No rows with data found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ Shipping boxes calculation verification passed")
            logger.info(f"  Rows checked: {rows_checked}")
            logger.info(f"  Column: {check_column}")
            logger.info(f"  Functions verified: {', '.join(expected_functions)}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ Shipping boxes calculation verification failed")
            logger.error(f"  Rows checked: {rows_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_split_content_formula(result: str, expected: str = None, **options) -> float:
    """
    Verify if formulas exist to split content with line breaks into multiple rows.
    
    This function checks:
    1. Whether cells in specified column contain formulas (not just values)
    2. Whether formulas contain required functions: TRIM, MID, SUBSTITUTE, CHAR, REPT, ROW
    3. Whether formulas reference the source column (A)
    4. Whether formulas contain CHAR(10) for line break
    5. Whether formulas contain REPT(" ",100) or similar pattern
    6. Whether formulas use ROW function for position calculation
    
    The expected formula pattern:
    =TRIM(MID(SUBSTITUTE(A2,CHAR(10),REPT(" ",100)),(ROW(A1)-1)*100+1,100))
    
    The function automatically detects the number of data rows by checking the data column
    for non-empty cells. It stops checking after finding 3 consecutive empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_column: Column to check (e.g., "B")
            - start_row: Starting row number (default: 2)
            - source_column: Column containing source data (e.g., "A")
            - expected_functions: List of expected function names (e.g., ["TRIM", "MID", "SUBSTITUTE", "CHAR", "REPT", "ROW"])
            - data_column: Column to check for data to determine end_row (default: "A")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_column = options.get('check_column', 'B')
        start_row = options.get('start_row', 2)
        source_column = options.get('source_column', 'A')
        expected_functions = options.get('expected_functions', ['TRIM', 'MID', 'SUBSTITUTE', 'CHAR', 'REPT', 'ROW'])
        data_column = options.get('data_column', 'A')
        
        logger.info(f"Verifying split content formulas in file: {result}")
        logger.info(f"Column to check: {check_column}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Source column: {source_column}")
        logger.info(f"Expected functions: {expected_functions}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row  # Start from start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        if end_row < start_row:
            logger.error(f"No data rows found starting from row {start_row}")
            return 0.0
        
        # Check formulas in each row
        all_checks_passed = True
        rows_checked = 0
        
        for row_num in range(start_row, end_row + 1):
            check_cell = ws[f"{check_column}{row_num}"]
            
            # Skip if source cell is empty
            source_cell = ws[f"{source_column}{row_num}"]
            if source_cell.value is None:
                continue
            
            rows_checked += 1
            formula = check_cell.value
            
            # Check 1: Formula exists (not just a value)
            if formula is None or not isinstance(formula, str) or not formula.startswith('='):
                logger.error(f"Cell {check_column}{row_num} should contain a formula, but got: {formula}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Row {row_num} formula: {formula}")
            
            # Check 2: Contains all required functions
            missing_functions = []
            for func in expected_functions:
                # Check for function name (with word boundary to avoid partial matches)
                func_pattern = r'\b' + re.escape(func) + r'\s*\('
                if not re.search(func_pattern, formula_upper, re.IGNORECASE):
                    missing_functions.append(func)
            
            if missing_functions:
                logger.error(f"Cell {check_column}{row_num} formula missing functions: {missing_functions}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: References source column (A)
            source_pattern = rf'{source_column}\d+'
            if not re.search(source_pattern, formula_upper):
                logger.error(f"Cell {check_column}{row_num} formula should reference {source_column} column")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3.5: SUBSTITUTE function must reference A2 specifically
            # Pattern: SUBSTITUTE(A2,...
            substitute_a2_pattern = rf'SUBSTITUTE\s*\(\s*{source_column}2\s*,'
            if not re.search(substitute_a2_pattern, formula_upper):
                logger.error(f"Cell {check_column}{row_num} formula SUBSTITUTE function must reference {source_column}2 (not {source_column}3, {source_column}4, etc.)")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Contains CHAR(10) for line break
            char_pattern = r'CHAR\s*\(\s*10\s*\)'
            if not re.search(char_pattern, formula_upper):
                logger.error(f"Cell {check_column}{row_num} formula should contain CHAR(10)")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 5: Contains REPT with space and 100
            rept_pattern = r'REPT\s*\(\s*["\']?\s*["\']?\s*,\s*100\s*\)'
            if not re.search(rept_pattern, formula_upper):
                logger.error(f"Cell {check_column}{row_num} formula should contain REPT(\" \",100) or similar")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 6: Contains ROW function
            row_pattern = r'\bROW\s*\('
            if not re.search(row_pattern, formula_upper):
                logger.error(f"Cell {check_column}{row_num} formula should contain ROW function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 7: Contains TRIM function (outermost)
            trim_pattern = r'\bTRIM\s*\('
            if not re.search(trim_pattern, formula_upper):
                logger.error(f"Cell {check_column}{row_num} formula should contain TRIM function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 8: Contains MID function
            mid_pattern = r'\bMID\s*\('
            if not re.search(mid_pattern, formula_upper):
                logger.error(f"Cell {check_column}{row_num} formula should contain MID function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 9: Contains SUBSTITUTE function
            substitute_pattern = r'\bSUBSTITUTE\s*\('
            if not re.search(substitute_pattern, formula_upper):
                logger.error(f"Cell {check_column}{row_num} formula should contain SUBSTITUTE function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            logger.debug(f"✓ Row {row_num} formula passed all checks")
        
        if rows_checked == 0:
            logger.error("No rows with data found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ Split content formula verification passed")
            logger.info(f"  Rows checked: {rows_checked}")
            logger.info(f"  Column: {check_column}")
            logger.info(f"  Functions verified: {', '.join(expected_functions)}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ Split content formula verification failed")
            logger.error(f"  Rows checked: {rows_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_quote_sheet_with_merged_cells(result: str, expected: str = None, **options) -> float:
    """
    Verify if a quote sheet template exists with the expected structure, fields, and merged cells.
    
    This function checks:
    1. Whether the title "报价单" exists in the worksheet
    2. Whether merged cells exist (especially for the title)
    3. Whether required header fields exist
    4. Whether the product table headers exist
    5. Whether summary fields exist
    6. Whether footer fields exist
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - expected_title: Expected title text (default: "报价单")
            - title_merged_range: Expected merged range for title (default: "G15:H15")
            - required_fields: List of required header field labels
            - table_headers: List of table header labels
            - summary_fields: List of summary field labels
            - footer_fields: List of footer field labels
            - min_merged_cells: Minimum number of merged cell ranges expected (default: 1)
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        expected_title = options.get('expected_title', '报价单')
        title_merged_range = options.get('title_merged_range', 'G15:H15')
        required_fields = options.get('required_fields', ['报价单位', '联系人', '联系电话', '客户名称', '报价日期', '邮箱'])
        table_headers = options.get('table_headers', ['序号', '产品名称', '产品类型', '规格', '数量', '单价', '金额', '备注'])
        summary_fields = options.get('summary_fields', ['合计金额(小写)', '合计金额(大写)'])
        footer_fields = options.get('footer_fields', ['报价人', '审批'])
        min_merged_cells = options.get('min_merged_cells', 1)
        
        logger.info(f"Verifying quote sheet template with merged cells in file: {result}")
        logger.info(f"Expected title: {expected_title}")
        logger.info(f"Title merged range: {title_merged_range}")
        logger.info(f"Required fields: {required_fields}")
        logger.info(f"Table headers: {table_headers}")
        logger.info(f"Summary fields: {summary_fields}")
        logger.info(f"Footer fields: {footer_fields}")
        logger.info(f"Minimum merged cells: {min_merged_cells}")
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=True)
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check merged cells
        merged_cells = list(ws.merged_cells.ranges)
        logger.info(f"Found {len(merged_cells)} merged cell range(s)")
        
        if len(merged_cells) < min_merged_cells:
            logger.error(f"✗ Insufficient merged cells: found {len(merged_cells)}, expected at least {min_merged_cells}")
            return 0.0
        
        # Check if title merged range exists
        title_merged_found = False
        for merged_range in merged_cells:
            merged_str = str(merged_range)
            logger.debug(f"Merged range: {merged_str}")
            if merged_str.upper() == title_merged_range.upper():
                title_merged_found = True
                logger.info(f"✓ Found title merged range: {merged_str}")
                break
        
        if not title_merged_found:
            logger.warning(f"⚠ Title merged range '{title_merged_range}' not found, but other merged cells exist")
            logger.info(f"  Available merged ranges: {[str(r) for r in merged_cells]}")
            # Don't fail completely, as the range might be slightly different
        
        # Search through all cells to find required text
        # Also check merged cells specifically
        max_row = ws.max_row
        max_col = ws.max_column
        
        # Convert all cell values to strings for searching
        # Include both individual cells and merged cell ranges
        all_text = []
        cell_text_map = {}  # Map cell coordinates to text for debugging
        
        for row in ws.iter_rows(min_row=1, max_row=max_row, min_col=1, max_col=max_col, values_only=False):
            for cell in row:
                if cell.value is not None:
                    cell_text = str(cell.value).strip()
                    all_text.append(cell_text)
                    cell_coord = cell.coordinate
                    cell_text_map[cell_coord] = cell_text
                    
                    # Also check if cell contains newlines (for merged cells with multiple fields)
                    if '\n' in cell_text or '\r' in cell_text:
                        # Split by newlines and add each line
                        lines = cell_text.replace('\r', '\n').split('\n')
                        for line in lines:
                            line = line.strip()
                            if line:
                                all_text.append(line)
        
        # Check merged cells - get text from the top-left cell of each merged range
        for merged_range in merged_cells:
            try:
                # Get the top-left cell of the merged range
                top_left_cell = ws[merged_range.min_row][merged_range.min_col - 1]
                if top_left_cell.value is not None:
                    merged_text = str(top_left_cell.value).strip()
                    all_text.append(merged_text)
                    # Also split by newlines if present
                    if '\n' in merged_text or '\r' in merged_text:
                        lines = merged_text.replace('\r', '\n').split('\n')
                        for line in lines:
                            line = line.strip()
                            if line:
                                all_text.append(line)
                    logger.debug(f"Merged range {merged_range} contains text: {merged_text[:100]}")
            except Exception as e:
                logger.debug(f"Error reading merged range {merged_range}: {e}")
        
        # Check 1: Title exists
        title_found = False
        for text in all_text:
            if expected_title in text:
                title_found = True
                logger.info(f"✓ Found title: {expected_title}")
                break
        
        if not title_found:
            logger.error(f"✗ Title '{expected_title}' not found")
            return 0.0
        
        # Check 2: Required header fields
        # Since fields may be in merged cells together, we need to check if all fields exist
        # even if they're in the same cell
        found_fields = []
        missing_fields = []
        for field in required_fields:
            field_found = False
            for text in all_text:
                if field in text:
                    field_found = True
                    found_fields.append(field)
                    logger.debug(f"Found field '{field}' in text: {text[:80]}...")
                    break
            if not field_found:
                missing_fields.append(field)
        
        # Log all text for debugging if fields are missing
        if missing_fields:
            logger.warning(f"⚠ Missing required fields: {missing_fields}")
            # Show some sample text that might contain the fields
            logger.debug(f"Sample text from worksheet (showing text with Chinese characters):")
            chinese_text_samples = [t for t in all_text if any('\u4e00' <= c <= '\u9fff' for c in t)][:20]
            for sample in chinese_text_samples:
                logger.debug(f"  {sample[:100]}")
        
        # Since fields may be grouped in merged cells, we're more lenient
        # Check if at least most fields are found
        found_ratio = len(found_fields) / len(required_fields) if required_fields else 1.0
        
        if found_ratio < 0.5:  # Less than 50% found
            logger.error(f"✗ Too many required fields missing: found {len(found_fields)}/{len(required_fields)}")
            logger.error(f"  Missing: {missing_fields}")
            return 0.0
        elif missing_fields:
            logger.warning(f"⚠ Some fields missing: {missing_fields}, but found {len(found_fields)}/{len(required_fields)} fields")
            # Don't fail if most fields are found (fields might be in merged cells together)
        else:
            logger.info(f"✓ Found all required fields: {found_fields}")
        
        # Check 3: Table headers
        found_headers = []
        missing_headers = []
        for header in table_headers:
            header_found = False
            for text in all_text:
                if header in text:
                    header_found = True
                    found_headers.append(header)
                    break
            if not header_found:
                missing_headers.append(header)
        
        if missing_headers:
            logger.error(f"✗ Missing table headers: {missing_headers}")
            return 0.0
        else:
            logger.info(f"✓ Found all table headers: {found_headers}")
        
        # Check 4: Summary fields
        found_summary = []
        missing_summary = []
        for field in summary_fields:
            field_found = False
            for text in all_text:
                if field in text:
                    field_found = True
                    found_summary.append(field)
                    break
            if not field_found:
                missing_summary.append(field)
        
        if missing_summary:
            logger.warning(f"⚠ Missing summary fields: {missing_summary}")
            # Don't fail completely, as these might be optional
        else:
            logger.info(f"✓ Found summary fields: {found_summary}")
        
        # Check 5: Footer fields
        found_footer = []
        missing_footer = []
        for field in footer_fields:
            field_found = False
            for text in all_text:
                if field in text:
                    field_found = True
                    found_footer.append(field)
                    break
            if not field_found:
                missing_footer.append(field)
        
        if missing_footer:
            logger.warning(f"⚠ Missing footer fields: {missing_footer}")
            # Don't fail completely, as these might be optional
        else:
            logger.info(f"✓ Found footer fields: {found_footer}")
        
        # Check 6: Borders on table cells
        # Check if cells in the product table area have borders
        # Typically, table headers and data rows should have borders
        logger.info("Checking borders on table cells...")
        
        # Find the table header row (should contain table headers)
        table_header_row = None
        for row_num in range(1, max_row + 1):
            for col_num in range(1, max_col + 1):
                cell = ws.cell(row=row_num, column=col_num)
                if cell.value is not None:
                    cell_text = str(cell.value).strip()
                    # Check if this row contains table headers
                    if any(header in cell_text for header in table_headers):
                        table_header_row = row_num
                        break
            if table_header_row:
                break
        
        borders_found = False
        cells_with_borders = 0
        total_table_cells_checked = 0
        
        if table_header_row:
            logger.info(f"Table header row found at row {table_header_row}")
            # Check borders in table area (header row and a few data rows)
            # Table typically spans from column C to K (based on headers)
            check_start_col = 3  # Column C
            check_end_col = min(11, max_col)  # Column K or max_col
            check_start_row = table_header_row
            check_end_row = min(table_header_row + 7, max_row)  # Header + 6 data rows
            
            for row_num in range(check_start_row, check_end_row + 1):
                for col_num in range(check_start_col, check_end_col + 1):
                    cell = ws.cell(row=row_num, column=col_num)
                    total_table_cells_checked += 1
                    
                    # Check if cell has any border
                    has_border = False
                    try:
                        border = cell.border
                        # Check if any side has a border style (not None and not empty)
                        if border:
                            if (border.top and border.top.style) or \
                               (border.bottom and border.bottom.style) or \
                               (border.left and border.left.style) or \
                               (border.right and border.right.style):
                                has_border = True
                                cells_with_borders += 1
                    except Exception as e:
                        logger.debug(f"Error checking border for cell {cell.coordinate}: {e}")
                    
                    if has_border:
                        borders_found = True
                        logger.debug(f"Cell {cell.coordinate} has borders")
            
            if total_table_cells_checked > 0:
                border_ratio = cells_with_borders / total_table_cells_checked
                logger.info(f"Borders found: {cells_with_borders}/{total_table_cells_checked} cells ({border_ratio:.1%})")
                
                # Require at least 30% of table cells to have borders
                if border_ratio < 0.3:
                    logger.warning(f"⚠ Low border coverage: only {border_ratio:.1%} of table cells have borders")
                    # Don't fail completely, as borders might be applied differently
                else:
                    logger.info(f"✓ Sufficient borders found in table area")
            else:
                logger.warning("⚠ Could not check borders: no table cells found")
        else:
            logger.warning("⚠ Could not find table header row for border checking")
        
        # If we get here, all critical checks passed
        logger.info("=" * 60)
        logger.info(f"✓ Quote sheet template with merged cells verification passed")
        logger.info(f"  Title: {expected_title}")
        logger.info(f"  Merged cells: {len(merged_cells)} (minimum required: {min_merged_cells})")
        if title_merged_found:
            logger.info(f"  Title merged range: {title_merged_range}")
        logger.info(f"  Required fields: {len(found_fields)}/{len(required_fields)}")
        logger.info(f"  Table headers: {len(found_headers)}/{len(table_headers)}")
        logger.info(f"  Summary fields: {len(found_summary)}/{len(summary_fields)}")
        logger.info(f"  Footer fields: {len(found_footer)}/{len(footer_fields)}")
        if borders_found:
            logger.info(f"  Borders: {cells_with_borders}/{total_table_cells_checked} cells have borders")
        logger.info("=" * 60)
        return 1.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


import functools
import itertools
import logging
import os.path

# import operator
from numbers import Number
from typing import Any, Union, cast, Callable, Iterable
from typing import Dict, List, Tuple, Set

import openpyxl
import pandas as pd
from openpyxl import Workbook
from openpyxl.cell.cell import Cell
from openpyxl.utils import get_column_letter
from openpyxl.worksheet.cell_range import MultiCellRange
from openpyxl.worksheet.datavalidation import DataValidation
from openpyxl.worksheet.worksheet import Worksheet
from rapidfuzz import fuzz

from desktop_env.evaluators.metrics.utils import (
    _match_value_to_rule,
    _read_cell_style,
    read_cell_value,
)
from desktop_env.evaluators.metrics.utils import (
    load_charts,
    load_sparklines,
    load_rows_or_cols,
    load_xlsx_styles,
    load_filters,
    load_pivot_tables,
)

# from openpyxl.utils import coordinate_to_tuple

logger = logging.getLogger("desktopenv.metric.table")

BOOK = Union[pd.ExcelFile, Workbook, str]


def _parse_sheet_idx(
    sheet_idx: Union[int, str],
    result: BOOK,
    expected: BOOK,
    result_sheet_names: List[str],
    expected_sheet_names: List[str],
) -> Tuple[BOOK, str]:
    #  function _parse_sheet_idx {{{ #
    if isinstance(sheet_idx, int):
        try:
            if not result_sheet_names or sheet_idx >= len(result_sheet_names):
                logger.error(
                    f"Sheet index {sheet_idx} out of range. Available sheets: {result_sheet_names}"
                )
                index = ""
            else:
                index: str = result_sheet_names[sheet_idx]
                logger.debug(f"Sheet index {sheet_idx} resolved to sheet: {index}")
        except Exception as e:
            logger.error(f"Error resolving sheet index {sheet_idx}: {e}")
            index = ""
        book: BOOK = result
    elif sheet_idx.startswith("RI"):
        try:
            index: str = result_sheet_names[int(sheet_idx[2:])]
        except:
            index = ""
        book: BOOK = result
    elif sheet_idx.startswith("RN"):
        index: str = sheet_idx[2:]
        book: BOOK = result
    elif sheet_idx.startswith("EI"):
        try:
            index: str = expected_sheet_names[int(sheet_idx[2:])]
        except:
            index = ""
        book: BOOK = expected
    elif sheet_idx.startswith("EN"):
        index: str = sheet_idx[2:]
        book: BOOK = expected
    else:
        logger.error("Unrecognized sheet index")
        raise ValueError("Unrecognized sheet index")
    return book, index
    #  }}} function _parse_sheet_idx #


SHEET = Union[pd.DataFrame, Worksheet, List[str]]


def _load_sheet(book: BOOK, index: str) -> SHEET:
    #  function _load_sheet {{{ #
    try:
        if isinstance(book, str):
            book: str = cast(str, book)
            csv_name: str = "{:}-{:}.csv".format(os.path.splitext(book)[0], index)

            try:
                all_lines: List[str] = _safe_read_file(csv_name)
                csv_lines: List[str] = list(
                    itertools.dropwhile(
                        lambda l: len(l) == 0,
                        map(lambda l: l.strip(), reversed(all_lines)),
                    )
                )
                return csv_lines
            except (FileNotFoundError, IOError) as e:
                logger.error(f"Failed to read CSV file {csv_name}: {e}")
                return None
        if isinstance(book, pd.ExcelFile):
            return pd.read_excel(book, index)
        if isinstance(book, Workbook):
            return book[index]
        logger.error("Not supported workbook format")
        raise NotImplementedError("Not supported workbook format")
    except NotImplementedError as e:
        raise e
    except:
        return None
    #  }}} function _load_sheet #


def _safe_read_file(file_path: str) -> List[str]:
    """
    Safely read a file with multiple encoding attempts.

    Args:
        file_path: Path to the file to read

    Returns:
        List of lines from the file

    Raises:
        FileNotFoundError: If file doesn't exist
        IOError: If file cannot be read with any encoding
    """
    # Common encodings to try in order of preference
    encodings = [
        "utf-8",  # Most common modern encoding
        "utf-8-sig",  # UTF-8 with BOM
        "latin-1",  # ISO-8859-1, works with any byte sequence
        "windows-1252",  # Common Windows encoding
        "gbk",  # Chinese encoding
        "cp1251",  # Cyrillic encoding
        "iso-8859-1",  # Alternative latin-1
    ]

    last_error = None

    for encoding in encodings:
        try:
            with open(file_path, "r", encoding=encoding) as f:
                lines = f.read().splitlines()
                logger.debug(
                    f"Successfully read file {file_path} with encoding {encoding}"
                )
                return lines
        except UnicodeDecodeError as e:
            last_error = e
            logger.debug(f"Failed to read {file_path} with encoding {encoding}: {e}")
            continue
        except (FileNotFoundError, IOError) as e:
            # These are non-encoding related errors, re-raise immediately
            raise e

    # If all encodings fail, try with error handling as last resort
    try:
        with open(file_path, "r", encoding="utf-8", errors="replace") as f:
            lines = f.read().splitlines()
            logger.warning(f"Read file {file_path} with UTF-8 and error replacement")
            return lines
    except Exception as e:
        logger.error(
            f"Failed to read file {file_path} with any encoding. Last error: {last_error}"
        )
        raise IOError(
            f"Cannot read file {file_path} with any supported encoding"
        ) from last_error


def compare_csv(result: str, expected: Union[str, List[str]], **options) -> float:
    """
    Compare CSV files. If expected is a list, returns 1.0 if result matches any of the expected files.

    Args:
        result: Path to result CSV file
        expected: Path to expected CSV file or list of paths to expected CSV files
        options: Additional options (strict, ignore_case)

    Returns:
        1.0 if result matches expected (or any file in expected list), 0.0 otherwise
    """
    if result is None:
        return 0.0

    try:
        result_lines: List[str] = _safe_read_file(result)
    except (FileNotFoundError, IOError) as e:
        logger.error(f"Failed to read result file {result}: {e}")
        return 0.0

    # Convert expected to list if it's a single string (for backward compatibility)
    if isinstance(expected, str):
        expected_files = [expected]
    else:
        expected_files = expected

    # Try to match against each expected file
    for expected_file in expected_files:
        try:
            expected_lines: List[str] = _safe_read_file(expected_file)

            # Process lines based on options
            current_result_lines = result_lines
            current_expected_lines = expected_lines

            if not options.get("strict", True):
                current_result_lines = map(str.strip, current_result_lines)
                current_expected_lines = map(str.strip, current_expected_lines)
            if options.get("ignore_case", False):
                current_result_lines = map(str.lower, current_result_lines)
                current_expected_lines = map(str.lower, current_expected_lines)

            # Check if this expected file matches
            if list(current_result_lines) == list(current_expected_lines):
                return 1.0

        except (FileNotFoundError, IOError):
            # If this expected file doesn't exist, continue to next one
            continue

    # No match found
    return 0.0


def compare_table(result: str, expected: str = None, **options) -> float:
    #  function compare_table {{{ #
    """
    Args:
        result (str): path to result xlsx
        expected (str): path to golden xlsx
        rules (List[Dict[str, Any]]): list of dict like
          {
            "type": str,
            <str as parameters>: anything
          }
          as sequential rules

    Returns:
        float: the score
    """

    if result is None:
        logger.error("Result file path is None")
        return 0.0

    # Check if result file exists
    if not os.path.exists(result):
        logger.error(f"Result file not found: {result}")
        return 0.0

    try:
        logger.info(f"Loading result file: {result}")
        xlworkbookr: Workbook = openpyxl.load_workbook(filename=result)
        pdworkbookr = pd.ExcelFile(result)
        logger.info(
            f"Successfully loaded result file with sheets: {pdworkbookr.sheet_names}"
        )
    except Exception as e:
        logger.error(f"Failed to load result file {result}: {e}")
        return 0.0
    worksheetr_names: List[str] = pdworkbookr.sheet_names

    if expected is not None:
        xlworkbooke: Workbook = openpyxl.load_workbook(filename=expected)
        pdworkbooke = pd.ExcelFile(expected)
        worksheete_names: List[str] = pdworkbooke.sheet_names
    else:
        xlworkbooke: Workbook = None
        pdworkbooke = None
        worksheete_names: List[str] = None

    parse_idx: Callable[[Union[str, int], BOOK, BOOK], Tuple[BOOK, str]] = (
        functools.partial(
            _parse_sheet_idx,
            result_sheet_names=worksheetr_names,
            expected_sheet_names=worksheete_names,
        )
    )

    passes = True
    for r in options["rules"]:
        if r["type"] == "sheet_name":
            #  Compare Sheet Names {{{ #
            metric: bool = worksheetr_names == worksheete_names
            logger.debug(
                "Assertion: %s.sheet_names == %s.sheet_names - %s",
                result,
                expected,
                metric,
            )
            #  }}} Compare Sheet Names #

        elif r["type"] == "sheet_data":
            #  Compare Sheet Data by Internal Value {{{ #
            # sheet_idx0: 0 == "RI0" == "RNSheet1" | "EI0" == "ENSheet1"
            # sheet_idx1: as sheet_idx0
            # precision: int as number of decimal digits, default to 4

            error_limit: int = r.get("precision", 4)
            sheet1: pd.DataFrame = _load_sheet(
                *parse_idx(r["sheet_idx0"], pdworkbookr, pdworkbooke)
            )
            if sheet1 is None:
                return 0.0
            sheet2: pd.DataFrame = _load_sheet(
                *parse_idx(r["sheet_idx1"], pdworkbookr, pdworkbooke)
            )

            sheet1 = sheet1.round(error_limit)
            sheet2 = sheet2.round(error_limit)
            metric: bool = sheet1.equals(sheet2)
            logger.debug("Sheet1: \n%s", str(sheet1))
            logger.debug("Sheet2: \n%s", str(sheet2))
            try:
                logger.debug("Sheet1 =v= Sheet2: \n%s", str(sheet1 == sheet2))
            except:
                logger.debug("Sheet1 =/v= Sheet2")
            logger.debug(
                "Assertion: %s =v= %s - %s", r["sheet_idx0"], r["sheet_idx1"], metric
            )
            #  }}} Compare Sheet Data by Internal Value #

        elif r["type"] == "sheet_print":
            #  Compare Sheet Data by Printed Value {{{ #
            # sheet_idx0: 0 == "RI0" == "RNSheet1" | "EI0" == "ENSheet1"
            # sheet_idx1: as sheet_idx0
            # ignore_case: optional, defaults to False

            sheet1: List[str] = _load_sheet(
                *parse_idx(r["sheet_idx0"], result, expected)
            )
            if sheet1 is None:
                return 0.0
            sheet2: List[str] = _load_sheet(
                *parse_idx(r["sheet_idx1"], result, expected)
            )
            if r.get("ignore_case", False):
                sheet1 = [l.lower() for l in sheet1]
                sheet2 = [l.lower() for l in sheet2]
            metric: bool = sheet1 == sheet2
            logger.debug(
                "Assertion: %s =p= %s - %s", r["sheet_idx0"], r["sheet_idx1"], metric
            )
            #  }}} Compare Sheet Data by Printed Value #

        elif r["type"] == "sheet_fuzzy":
            #  Fuzzy Match for Ranges {{{ #
            # sheet_idx0: 0 == "RI0" == "RNSheet1" | "EI0" == "ENSheet1"
            # sheet_idx1: as sheet_idx0
            # rules: list of dict, each dict is like
            #   { "range": ["A1:B6", "C2:E5"],
            #     "type": "includes" | "included_by" | "fuzzy_match" | "exact_match", # 0 includes 1, 0 includes_by 1
            #     "threshold": 85, // for fuzzy match
            #     "ignore_case": true | false,
            #     "ignore_chars": " ()", # filtered out
            #     "trim_leadings": "+ ", # filtered by lstrip
            #     "trim_trailings": "", # filtered by rstrip
            #     "normalization": [["Rd", "Road"]], # filtered by replace
            #   }

            sheet1: Tuple[BOOK, str] = parse_idx(r["sheet_idx0"], result, expected)
            sheet2: Tuple[BOOK, str] = parse_idx(r["sheet_idx1"], result, expected)
            total_metric = True
            for rl in r["rules"]:
                for rng in MultiCellRange(rl["range"]):
                    for cdn in rng.cells:
                        coordinate: str = "{:}{:d}".format(
                            get_column_letter(cdn[1]), cdn[0]
                        )
                        value1: str = str(read_cell_value(*sheet1, coordinate))
                        value2: str = str(read_cell_value(*sheet2, coordinate))
                        logger.debug("%s: %s vs %s", cdn, value1, value2)

                        for rplc in rl.get("normalization", []):
                            value1 = value1.replace(rplc[0], rplc[1])
                            value2 = value2.replace(rplc[0], rplc[1])
                        if "trim_leadings" in rl:
                            value1 = value1.lstrip(rl["trim_leadings"])
                            value2 = value2.lstrip(rl["trim_leadings"])
                        if "trim_trailings" in rl:
                            value1 = value1.rstrip(rl["trim_trailings"])
                            value2 = value2.rstrip(rl["trim_trailings"])
                        if "ignore_chars" in rl:
                            ignore_chars: Set[str] = set(rl["ignore_chars"])
                            value1 = "".join(
                                filter(lambda ch: ch not in ignore_chars, value1)
                            )
                            value2 = "".join(
                                filter(lambda ch: ch not in ignore_chars, value2)
                            )
                        if rl.get("ignore_case", False):
                            value1 = value1.lower()
                            value2 = value2.lower()

                        if rl["type"] == "includes":
                            metric: bool = value2 in value1
                        elif rl["type"] == "included_by":
                            metric: bool = value1 in value2
                        elif rl["type"] == "fuzzy_match":
                            metric: bool = fuzz.ratio(value1, value2) >= rl.get(
                                "threshold", 85.0
                            )
                        elif rl["type"] == "exact_match":
                            metric: bool = value1 == value2
                        total_metric = total_metric and metric

            metric: bool = total_metric
            logger.debug(
                "Assertion: %s =~= %s - %s", r["sheet_idx0"], r["sheet_idx1"], metric
            )
            #  }}} Fuzzy Match for Ranges #

        elif r["type"] == "sparkline":
            #  Compare Sparklines {{{ #
            # sheet_idx0: 0 == "RI0" == "RNSheet1" | "EI0" == "ENSheet1"
            # sheet_idx1: as sheet_idx0

            sparkline1: Dict[str, str] = load_sparklines(
                *parse_idx(r["sheet_idx0"], result, expected)
            )
            sparkline2: Dict[str, str] = load_sparklines(
                *parse_idx(r["sheet_idx1"], result, expected)
            )
            metric: bool = sparkline1 == sparkline2
            logger.debug(
                "Assertion: %s.sp == %.sp - %s",
                r["sheet_idx0"],
                r["sheet_idx1"],
                metric,
            )
            #  }}} Compare Sparklines #

        elif r["type"] == "chart":
            #  Compare Charts {{{ #
            # sheet_idx0: 0 == "RI0" == "RNSheet1" | "EI0" == "ENSheet1"
            # sheet_idx1: as sheet_idx0
            # chart_props: list of str, see utils.load_charts

            charts1: Dict[str, Any] = load_charts(
                *parse_idx(r["sheet_idx0"], xlworkbookr, xlworkbooke), **r
            )
            charts2: Dict[str, Any] = load_charts(
                *parse_idx(r["sheet_idx1"], xlworkbookr, xlworkbooke), **r
            )
            metric: bool = charts1 == charts2
            logger.debug(
                "Assertion: %s[chart] == %s[chart] - %s",
                r["sheet_idx0"],
                r["sheet_idx1"],
                metric,
            )
            #  }}} Compare Charts #

        elif r["type"] == "style":
            #  Compare Style (Also Conditional Formatiing) {{{ #
            # sheet_idx0: 0 == "RI0" == "RNSheet1" | "EI0" == "ENSheet1"
            # sheet_idx1: as sheet_idx0
            # props: list of str indicating concerned styles, see utils._read_cell_style

            sheet_idx1: Tuple[BOOK, str] = parse_idx(
                r["sheet_idx0"], xlworkbookr, xlworkbooke
            )
            book_name1: str = parse_idx(r["sheet_idx0"], result, expected)[0]
            styles1: Dict[str, List[Any]] = load_xlsx_styles(
                *sheet_idx1, book_name1, **r
            )

            sheet_idx2: Tuple[BOOK, str] = parse_idx(
                r["sheet_idx1"], xlworkbookr, xlworkbooke
            )
            book_name2: str = parse_idx(r["sheet_idx1"], result, expected)[0]
            styles2: Dict[str, List[Any]] = load_xlsx_styles(
                *sheet_idx2, book_name2, **r
            )
            # number_formats1: List[str] = [c.number_format.lower() for col in sheet1.iter_cols() for c in col if c.value is not None and c.data_type=="n"]
            # number_formats2: List[str] = [c.number_format.lower() for col in sheet2.iter_cols() for c in col if c.value is not None and c.data_type=="n"]
            metric: bool = styles1 == styles2
            logger.debug(
                "Assertion: %s.style == %s.style - %s",
                r["sheet_idx0"],
                r["sheet_idx1"],
                metric,
            )
            #  }}} Compare Style (Also Conditional Formatiing) #

        elif r["type"] == "freeze":
            #  Compare Freezing {{{ #
            # sheet_idx0: 0 == "RI0" == "RNSheet1" | "EI0" == "ENSheet1"
            # sheet_idx1: as sheet_idx0

            sheet1: Worksheet = _load_sheet(
                *parse_idx(r["sheet_idx0"], xlworkbookr, xlworkbooke)
            )
            if sheet1 is None:
                return 0.0
            sheet2: Worksheet = _load_sheet(
                *parse_idx(r["sheet_idx1"], xlworkbookr, xlworkbooke)
            )
            metric: bool = sheet1.freeze_panes == sheet2.freeze_panes
            logger.debug(
                "Assertion: %s.freeze(%s) == %s.freeze(%s) - %s",
                r["sheet_idx0"],
                sheet1.freeze_panes,
                r["sheet_idx1"],
                sheet2.freeze_panes,
                metric,
            )
            #  }}} Compare Freezing #

        elif r["type"] == "zoom":
            #  Check Zooming {{{ #
            # sheet_idx: 0 == "RI0" == "RNSheet1" | "EI0" == "ENSheet1"
            # method: str
            # ref: value

            sheet: Worksheet = _load_sheet(
                *parse_idx(r["sheet_idx"], xlworkbookr, xlworkbooke)
            )
            if sheet is None:
                return 0.0
            zoom_scale: Number = sheet.sheet_view.zoomScale or 100.0
            metric: bool = _match_value_to_rule(zoom_scale, r)
            logger.debug(
                "Assertion: %s.zoom(%.1f) %s %.1f - %s",
                r["sheet_idx"],
                zoom_scale,
                r["method"],
                r["ref"],
                metric,
            )
            #  }}} Check Zooming #

        elif r["type"] == "data_validation":
            #  Check Data Validation {{{ #
            # sheet_idx: 0 == "RI0" == "RNSheet1" | "EI0" == "ENSheet1"
            # dv_props: list of dict like {attribute: {"method": str, "ref": anything}}
            #   available attributes:
            #     * ranges
            #     * type
            #     * formula1
            #     * formula2
            #     * operator
            #     * allowBlank
            #     * showDropDown
            #     * showInputMessage
            #     * showErrorMessage
            #     * error
            #     * errorTitle
            #     * errorStyle
            #     * prompt
            #     * promptTitle
            #     * imeMode

            sheet: Worksheet = _load_sheet(
                *parse_idx(r["sheet_idx"], xlworkbookr, xlworkbooke)
            )
            if sheet is None:
                return 0.0
            data_validators: List[DataValidation] = (
                sheet.data_validations.dataValidation
            )

            total_metric = len(data_validators) >= len(r["dv_props"])
            for dat_vldt in data_validators:
                metric = False
                for prpt in r["dv_props"]:
                    metric = metric or all(
                        _match_value_to_rule(getattr(dat_vldt, attrbt), mr)
                        for attrbt, mr in prpt.items()
                    )
                    if metric:
                        break
                total_metric = total_metric and metric
                if not total_metric:
                    break

            logger.debug(
                "Assertion: %s.data_validation - %s", r["sheet_idx"], total_metric
            )
            metric: bool = total_metric
            #  }}} Check Data Validation #

        elif r["type"] == "row_props":
            #  Check Row Properties {{{ #
            # sheet_idx0: 0 == "RI0" == "RNSheet1" | "EI0" == "ENSheet1"
            # sheet_idx1: as sheet_idx0
            # props: list of str, see utils.load_rows_or_cols

            rows1: Dict[str, Any] = load_rows_or_cols(
                *parse_idx(r["sheet_idx0"], xlworkbookr, xlworkbooke), obj="row", **r
            )
            rows2: Dict[str, Any] = load_rows_or_cols(
                *parse_idx(r["sheet_idx1"], xlworkbookr, xlworkbooke), obj="row", **r
            )
            logger.debug("Rows1: %s", repr(rows1))
            logger.debug("Rows2: %s", repr(rows2))
            metric: bool = rows1 == rows2
            logger.debug(
                "Assertion: %s[rows] == %s[rows] - %s",
                r["sheet_idx0"],
                r["sheet_idx1"],
                metric,
            )
            #  }}} Check Row Properties #

        elif r["type"] == "col_props":
            #  Check Row Properties {{{ #
            # sheet_idx0: 0 == "RI0" == "RNSheet1" | "EI0" == "ENSheet1"
            # sheet_idx1: as sheet_idx0
            # props: list of str, see utils.load_rows_or_cols

            cols1: Dict[str, Any] = load_rows_or_cols(
                *parse_idx(r["sheet_idx0"], xlworkbookr, xlworkbooke), obj="column", **r
            )
            cols2: Dict[str, Any] = load_rows_or_cols(
                *parse_idx(r["sheet_idx1"], xlworkbookr, xlworkbooke), obj="column", **r
            )
            metric: bool = cols1 == cols2
            logger.debug(
                "Assertion: %s[cols] == %s[cols] - %s",
                r["sheet_idx0"],
                r["sheet_idx1"],
                metric,
            )
            #  }}} Check Row Properties #

        elif r["type"] == "filter":
            #  Compare Filters {{{ #
            # sheet_idx0: 0 == "RI0" == "RNSheet1" | "EI0" == "ENSheet1"
            # sheet_idx1: as sheet_idx0

            filters1: Dict[str, Any] = load_filters(
                *parse_idx(r["sheet_idx0"], xlworkbookr, xlworkbooke), **r
            )
            filters2: Dict[str, Any] = load_filters(
                *parse_idx(r["sheet_idx1"], xlworkbookr, xlworkbooke), **r
            )
            metric: bool = filters1 == filters2
            logger.debug(
                "Assertion: %s[filter] == %s[filter] - %s",
                r["sheet_idx0"],
                r["sheet_idx1"],
                metric,
            )
            #  }}} Compare Filters #

        elif r["type"] == "pivot_table":
            #  Compare Pivot Tables {{{ #
            # sheet_idx0: 0 == "RI0" == "RNSheet1" | "EI0" == "ENSheet1"
            # sheet_idx1: as sheet_idx0
            # pivot_props: list of str, see utils.load_pivot_tables

            pivots1: Dict[str, Any] = load_pivot_tables(
                *parse_idx(r["sheet_idx0"], xlworkbookr, xlworkbooke), **r
            )
            pivots2: Dict[str, Any] = load_pivot_tables(
                *parse_idx(r["sheet_idx1"], xlworkbookr, xlworkbooke), **r
            )
            metric: bool = pivots1 == pivots2
            logger.debug(
                "Assertion: %s[pivot]==%s[pivot] - %s",
                r["sheet_idx0"],
                r["sheet_idx1"],
                metric,
            )
            #  }}} Compare Pivot Tables #

        elif r["type"] == "check_cell":
            #  Check Cell Properties {{{ #
            # sheet_idx: 0 == "RI0" == "RNSheet1" | "EI0" == "ENSheet1"
            # coordinate: str, "E3"
            # props: dict like {attribute: {"method": str, "ref": anything}}
            #   supported attributes: value & those supported by utils._read_cell_style

            try:
                sheet: Worksheet = _load_sheet(
                    *parse_idx(r["sheet_idx"], xlworkbookr, xlworkbooke)
                )
                if sheet is None:
                    logger.error(
                        f"Failed to load sheet for sheet_idx: {r['sheet_idx']}"
                    )
                    return 0.0
                # data_frame: pd.DataFrame = _load_sheet(*parse_idx(r["sheet_idx"], pdworkbookr, pdworkbooke))
                cell: Cell = sheet[r["coordinate"]]
                metric: bool = True
                for prpt, rule in r["props"].items():
                    if prpt == "value":
                        try:
                            parsed_result = parse_idx(r["sheet_idx"], result, expected)
                            logger.debug(f"parse_idx result: {parsed_result}")
                            val = read_cell_value(*parsed_result, r["coordinate"])
                            logger.debug(f"Cell {r['coordinate']} value: {val}")
                        except Exception as e:
                            logger.error(
                                f"Failed to read cell value at {r['coordinate']}: {e}"
                            )
                            val = None
                    elif prpt == "formula":
                        # Support checking cell formula directly
                        try:
                            if cell.data_type == "f":
                                # For formula cells, get the formula text
                                # In openpyxl, formula is stored in cell.value for formula cells
                                # But we need the actual formula text, not the calculated value
                                # Try to get formula from internal representation
                                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                                    val = cell._value
                                elif hasattr(cell, "formula"):
                                    val = cell.formula
                                else:
                                    # Fallback: try to reconstruct from value if it's a formula
                                    val = f"={cell.value}" if cell.value is not None else None
                            else:
                                val = None
                            logger.debug(f"Cell {r['coordinate']} formula: {val}")
                        except Exception as e:
                            logger.error(
                                f"Failed to read cell formula at {r['coordinate']}: {e}"
                            )
                            val = None
                    else:
                        try:
                            val = _read_cell_style(prpt, cell)
                        except Exception as e:
                            logger.error(
                                f"Failed to read cell style {prpt} at {r['coordinate']}: {e}"
                            )
                            val = None

                    metric = metric and _match_value_to_rule(val, rule)
            except Exception as e:
                logger.error(f"Error in check_cell processing: {e}")
                return 0.0

            logger.debug(
                "Assertion: %s[%s] :%s - %s",
                r["sheet_idx"],
                r["coordinate"],
                repr(r["props"]),
                metric,
            )
            #  }}} Check Cell Properties #

        else:
            raise NotImplementedError(
                "Unimplemented sheet check: {:}".format(r["type"])
            )

        passes = passes and metric
        if not passes:
            break

    return float(passes)
    #  }}} function compare_table #


def compare_conference_city_in_order(actual_city_list_path, expected_city):
    expected_city_list = expected_city["expected"]
    wb = openpyxl.load_workbook(actual_city_list_path)
    sheet = wb.active
    actual_city_list = []
    for row in sheet["C2:C22"]:
        for cell in row:
            actual_city_list.append(cell.value)
    # expected_city is the city that we want to compare with the actual city list
    # must in order index
    # debug
    try:
        for i in range(len(actual_city_list)):
            if isinstance(expected_city_list[i], str):
                if expected_city_list[i] not in actual_city_list[i]:
                    logger.debug(
                        f"Expected city {expected_city_list[i]}; Actual city {actual_city_list[i]}"
                    )
                    print(
                        f"Expected city {expected_city_list[i]}; Actual city {actual_city_list[i]}"
                    )
                    return 0.0

            elif isinstance(expected_city_list[i], List):
                if not any(
                    possible_str in actual_city_list[i]
                    for possible_str in expected_city_list[i]
                ):
                    logger.debug(
                        f"Expected city {expected_city_list[i]}; Actual city {actual_city_list[i]}"
                    )
                    print(
                        f"Expected city {expected_city_list[i]}; Actual city {actual_city_list[i]}"
                    )
                    return 0.0

            else:
                raise TypeError("Expected city should be a string or a list of strings")

    except:
        return 0.0

    return 1.0


def verify_second_row_deleted_without_gold(result: str, expected: str = None, **options) -> float:
    """
    验证 Excel 文件的第二行是否被删除（不需要金标准文件）
    
    通过以下方式验证：
    1. 检查结果文件的行数是否比原始文件少1
    2. 检查原始文件的第二行数据是否在结果文件中不存在
    3. 检查其他所有行是否保持不变
    
    Args:
        result (str): 结果文件路径
        expected (str): 未使用（为了兼容框架接口）
        options (dict): 配置选项，应包含：
            - original_file_url: 原始文件的URL（用于下载和比对）
            - result_file_path: 结果文件的路径（可选，默认使用 result 参数）
            - original_file_cache: 原始文件的本地缓存路径（可选）
    
    Returns:
        float: 如果验证通过返回 1.0，否则返回 0.0
    """
    try:
        import tempfile
        import urllib.request
        
        # result 参数已经是从VM获取到宿主机的文件路径
        # 不应该从 options 中覆盖它，因为 options 中可能包含的是VM路径
        result_file_path = result
        original_file_url = options.get('original_file_url', '')
        
        logger.info(f"开始验证删除第二行任务...")
        logger.info(f"结果文件: {result_file_path}")
        logger.info(f"原始文件URL: {original_file_url}")
        
        if not result_file_path or not os.path.exists(result_file_path):
            logger.error(f"结果文件不存在: {result_file_path}")
            return 0.0
        
        # 下载原始文件到临时位置
        with tempfile.NamedTemporaryFile(delete=False, suffix='.xlsx') as tmp_file:
            original_file_temp = tmp_file.name
        
        try:
            logger.info(f"正在下载原始文件到临时位置: {original_file_temp}")
            urllib.request.urlretrieve(original_file_url, original_file_temp)
        except Exception as e:
            logger.warning(f"下载原始文件失败: {e}")
            # 如果下载失败，尝试从本地缓存读取
            cache_path = options.get('original_file_cache', '')
            if cache_path and os.path.exists(cache_path):
                logger.info(f"使用缓存文件: {cache_path}")
                original_file_temp = cache_path
            else:
                logger.error("无法获取原始文件")
                return 0.0
        
        # 加载原始文件
        logger.info("加载原始文件...")
        original_wb = openpyxl.load_workbook(original_file_temp)
        original_ws = original_wb.active
        
        # 获取原始文件的所有行
        original_rows = list(original_ws.iter_rows(values_only=True))
        original_row_count = len(original_rows)
        
        if original_row_count < 2:
            logger.error(f"原始文件行数不足: {original_row_count}（需要至少2行）")
            return 0.0
        
        # 保存第二行的数据（索引为1）
        second_row_data = original_rows[1]
        logger.info(f"原始文件行数: {original_row_count}")
        logger.info(f"原始文件第二行数据: {second_row_data}")
        
        # 加载结果文件
        logger.info(f"加载结果文件...")
        result_wb = openpyxl.load_workbook(result_file_path)
        result_ws = result_wb.active
        
        # 获取结果文件的所有行
        result_rows = list(result_ws.iter_rows(values_only=True))
        result_row_count = len(result_rows)
        
        logger.info(f"结果文件行数: {result_row_count}")
        
        # 验证1: 检查行数是否减少了1
        if result_row_count != original_row_count - 1:
            logger.error(f"行数验证失败: 期望 {original_row_count - 1} 行，实际 {result_row_count} 行")
            return 0.0
        else:
            logger.info(f"✓ 行数验证通过: {original_row_count} → {result_row_count}")
        
        # 验证2: 检查原始第二行是否存在于结果文件中
        second_row_exists = False
        for i, row in enumerate(result_rows):
            if row == second_row_data:
                logger.error(f"原始第二行数据仍存在于结果文件的第 {i+1} 行")
                second_row_exists = True
                break
        
        if second_row_exists:
            return 0.0
        else:
            logger.info(f"✓ 原始第二行数据已从结果文件中删除")
        
        # 验证3: 检查其他行是否保持不变（第一行和第3行之后）
        # 结果文件的第一行应该等于原始文件的第一行
        if result_rows[0] != original_rows[0]:
            logger.error(f"第一行数据不匹配")
            logger.error(f"  原始: {original_rows[0]}")
            logger.error(f"  结果: {result_rows[0]}")
            return 0.0
        
        # 结果文件的第2行及之后应该等于原始文件的第3行及之后
        for i in range(1, result_row_count):
            if result_rows[i] != original_rows[i+1]:
                logger.error(f"第 {i+1} 行数据不匹配")
                logger.error(f"  期望（原始第 {i+2} 行）: {original_rows[i+1]}")
                logger.error(f"  实际: {result_rows[i]}")
                return 0.0
        
        logger.info(f"✓ 其他行数据保持不变")
        
        # 清理临时文件
        if original_file_temp != options.get('original_file_cache', ''):
            try:
                os.unlink(original_file_temp)
            except:
                pass
        
        logger.info("=" * 60)
        logger.info("✓ 所有验证通过！第二行已成功删除")
        logger.info("=" * 60)
        return 1.0
        
    except Exception as e:
        import traceback
        logger.error(f"评估出错: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_regexp_extract(result: str, expected: str = None, **options) -> float:
    """
    Verify if REGEX formulas exist in specified columns (B and C) with correct patterns.
    
    This function checks:
    1. Whether cells in specified columns contain REGEX formulas
    2. Whether formulas reference the corresponding A column cell (B2->A2, B3->A3, etc.)
    3. Whether formulas contain the correct pattern text (牛肉丸 for B column, 牛筋丸 for C column)
    4. Whether formulas have the correct structure with lookbehind and lookahead
    
    The function automatically detects the number of data rows by checking the data column
    (default: A column) for non-empty cells. It stops checking after finding 3 consecutive
    empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_columns: List of columns to check (e.g., ["B", "C"])
            - start_row: Starting row number (default: 2)
            - end_row: Ending row number (optional, will auto-detect if not provided)
            - expected_pattern: Expected function name (default: "REGEX")
            - column_patterns: Dict mapping column letters to expected pattern text
            - data_column: Column to check for data to determine end_row (default: "A")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_columns = options.get('check_columns', ['B', 'C'])
        start_row = options.get('start_row', 2)
        end_row = options.get('end_row', None)  # Optional, will auto-detect if not provided
        expected_pattern = options.get('expected_pattern', 'REGEX')
        column_patterns = options.get('column_patterns', {'B': '牛肉丸', 'C': '牛筋丸'})
        data_column = options.get('data_column', 'A')  # Column to check for data to determine end_row
        
        if not check_columns:
            logger.error("No columns specified in options")
            return 0.0
        
        logger.info(f"Verifying REGEX formulas in file: {result}")
        logger.info(f"Columns to check: {check_columns}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Expected function: {expected_pattern}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        if end_row is None:
            logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
            max_row = ws.max_row
            end_row = start_row  # Start from start_row
            
            # Find the last row with data in the data column
            # Check up to max_row, but stop if we find 3 consecutive empty rows
            empty_count = 0
            for row_num in range(start_row, max_row + 1):
                data_cell = ws[f"{data_column}{row_num}"]
                if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                    empty_count += 1
                    if empty_count >= 3:  # Stop after 3 consecutive empty rows
                        break
                else:
                    empty_count = 0
                    end_row = row_num  # Update end_row to the last row with data
            
            logger.info(f"Auto-detected end row: {end_row}")
        else:
            logger.info(f"Using specified end row: {end_row}")
        
        # Check each column and row
        all_passed = True
        for col_letter in check_columns:
            expected_pattern_text = column_patterns.get(col_letter)
            if not expected_pattern_text:
                logger.warning(f"No pattern text specified for column {col_letter}, skipping")
                continue
            
            logger.info(f"Checking column {col_letter} with pattern '{expected_pattern_text}' (rows {start_row} to {end_row})")
            
            for row_num in range(start_row, end_row + 1):
                cell_coord = f"{col_letter}{row_num}"
                try:
                    cell = ws[cell_coord]
                    logger.debug(f"Checking cell {cell_coord}")
                    
                    # Check if cell contains a formula
                    if cell.data_type != "f":
                        logger.warning(f"Cell {cell_coord} does not contain a formula")
                        all_passed = False
                        continue
                    
                    # Get formula text
                    formula_text = None
                    if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                        formula_text = cell._value
                    elif hasattr(cell, "formula"):
                        formula_text = cell.formula
                    else:
                        # Try to get from value attribute
                        if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                            formula_text = cell.value
                    
                    if formula_text is None:
                        logger.warning(f"Could not extract formula from cell {cell_coord}")
                        all_passed = False
                        continue
                    
                    # Remove leading = if present for comparison
                    formula_clean = formula_text.lstrip("=")
                    logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                    
                    # Check 1: Formula contains REGEX function
                    if expected_pattern.upper() not in formula_text.upper():
                        logger.warning(f"Cell {cell_coord} formula does not contain {expected_pattern}")
                        logger.warning(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 2: Formula contains expected pattern text (牛肉丸 or 牛筋丸)
                    if expected_pattern_text not in formula_text:
                        logger.warning(f"Cell {cell_coord} formula does not contain pattern text '{expected_pattern_text}'")
                        logger.warning(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 3: Formula contains REGEX function call structure
                    regex_match = re.search(r'REGEX\s*\([^)]+\)', formula_text, re.IGNORECASE)
                    if not regex_match:
                        logger.warning(f"Cell {cell_coord} formula does not have correct REGEX structure")
                        logger.warning(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 4: Formula references the corresponding A column cell (A2, A3, etc.)
                    expected_a_cell = f"A{row_num}"
                    # Check if formula contains A column reference with the same row number
                    a_cell_pattern = rf'A{row_num}\b'
                    if not re.search(a_cell_pattern, formula_text, re.IGNORECASE):
                        logger.warning(f"Cell {cell_coord} formula does not reference {expected_a_cell}")
                        logger.warning(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 5: Formula contains lookbehind pattern (?<=...)
                    if "(?<=" not in formula_text:
                        logger.warning(f"Cell {cell_coord} formula does not contain lookbehind pattern (?<=...)")
                        logger.warning(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 6: Formula contains lookahead pattern (?=,)
                    if "(?=," not in formula_text:
                        logger.warning(f"Cell {cell_coord} formula does not contain lookahead pattern (?=,)")
                        logger.warning(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 7: Formula contains \d+ pattern
                    if "\\d+" not in formula_text:
                        # Also check for unescaped version in the pattern
                        if not re.search(r'\\d\+|d\+', formula_text):
                            logger.warning(f"Cell {cell_coord} formula does not contain digit pattern \\d+")
                            logger.warning(f"Formula: {formula_text}")
                            all_passed = False
                            continue
                    
                    # Check 8: Formula pattern should contain 5 dots after pattern text
                    # Pattern should be like: (?<=牛肉丸.....)
                    pattern_with_dots = expected_pattern_text + "....."
                    if pattern_with_dots not in formula_text:
                        logger.warning(f"Cell {cell_coord} formula pattern may not have 5 dots after '{expected_pattern_text}'")
                        logger.debug(f"Formula: {formula_text}")
                        # Don't fail, just warn - the pattern might be correct but formatted differently
                    
                    logger.info(f"✓ Cell {cell_coord} has valid REGEX formula: {formula_text}")
                    
                except Exception as e:
                    logger.error(f"Error checking cell {cell_coord}: {e}")
                    import traceback
                    logger.error(traceback.format_exc())
                    all_passed = False
        
        if all_passed:
            logger.info("=" * 60)
            logger.info(f"✓ All cells in columns {check_columns} contain correct {expected_pattern} formulas")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ {expected_pattern} formula verification failed")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_regexp_order_extract(result: str, expected: str = None, **options) -> float:
    """
    Verify if REGEXP formulas exist in specified column (C) to extract order numbers from addresses.
    
    This function checks:
    1. Whether cells in specified column contain REGEXP formulas
    2. Whether formulas reference the corresponding A column cell (C2->A2, C3->A3, etc.)
    3. Whether formulas contain the correct regex pattern (\\w{10})
    4. Whether formulas have the correct structure
    
    The function automatically detects the number of data rows by checking the data column
    (default: A column) for non-empty cells. It stops checking after finding 3 consecutive
    empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_column: Column to check (e.g., "C")
            - start_row: Starting row number (default: 2)
            - expected_pattern: Expected function name (default: "REGEXP")
            - expected_formula_pattern: Expected formula pattern (e.g., "REGEXP(A")
            - regex_pattern: Expected regex pattern in formula (e.g., "\\w{10}")
            - data_column: Column to check for data to determine end_row (default: "A")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_column = options.get('check_column', 'C')
        start_row = options.get('start_row', 2)
        expected_pattern = options.get('expected_pattern', 'REGEX')
        expected_formula_pattern = options.get('expected_formula_pattern', 'REGEX(A')
        regex_pattern = options.get('regex_pattern', '[a-zA-Z0-9]{10}')
        data_column = options.get('data_column', 'A')
        
        logger.info(f"Verifying REGEXP order extraction in file: {result}")
        logger.info(f"Column to check: {check_column}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Expected function: {expected_pattern}")
        logger.info(f"Expected regex pattern: {regex_pattern}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row  # Start from start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Check each row in the specified column
        all_passed = True
        logger.info(f"Checking column {check_column} (rows {start_row} to {end_row})")
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{check_column}{row_num}"
            try:
                cell = ws[cell_coord]
                logger.debug(f"Checking cell {cell_coord}")
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.warning(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                else:
                    # Try to get from value attribute
                    if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                # Remove leading = if present for comparison
                formula_clean = formula_text.lstrip("=")
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains REGEX function (support both REGEX and LibreOffice internal format)
                # LibreOffice may save as _xlfn.ORG.LIBREOFFICE.REGEX
                formula_upper = formula_text.upper()
                if expected_pattern.upper() not in formula_upper and '_XLFN.ORG.LIBREOFFICE.REGEX' not in formula_upper:
                    logger.warning(f"Cell {cell_coord} formula does not contain {expected_pattern} or LibreOffice REGEX")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 2: Formula contains expected formula pattern (REGEX(A or _xlfn.ORG.LIBREOFFICE.REGEX(A)
                formula_clean_upper = formula_clean.upper()
                if expected_formula_pattern.upper() not in formula_clean_upper and 'REGEX(A' not in formula_clean_upper:
                    logger.warning(f"Cell {cell_coord} formula does not contain pattern '{expected_formula_pattern}'")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: Formula contains REGEX function call structure (support both formats)
                regexp_match = re.search(r'(REGEX|REGEXP|_XLFN\.ORG\.LIBREOFFICE\.REGEX)\s*\([^)]+\)', formula_text, re.IGNORECASE)
                if not regexp_match:
                    logger.warning(f"Cell {cell_coord} formula does not have correct REGEX structure")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: Formula references the corresponding A column cell (A2, A3, etc.)
                expected_a_cell = f"A{row_num}"
                # Check if formula contains A column reference with the same row number
                a_cell_pattern = rf'A{row_num}\b'
                if not re.search(a_cell_pattern, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {cell_coord} formula does not reference {expected_a_cell}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 5: Formula contains the regex pattern ([a-zA-Z0-9]{10})
                # The pattern might be escaped differently in the formula
                # Check for various escape formats
                pattern_variations = [
                    regex_pattern,  # [a-zA-Z0-9]{10}
                    regex_pattern.replace('\\', '\\\\'),  # [a-zA-Z0-9]{10} with double escape
                    regex_pattern.replace('[', '\\[').replace(']', '\\]'),  # Escaped brackets
                    '[a-zA-Z0-9]{10}',  # Original pattern
                    '\\[a-zA-Z0-9\\]{10}',  # Escaped brackets
                    '\\\\[a-zA-Z0-9\\\\]{10}',  # Double escaped
                ]
                found = False
                for pattern_var in pattern_variations:
                    if pattern_var in formula_text:
                        found = True
                        break
                if not found:
                    # Also check for pattern without escaping brackets
                    simple_pattern = 'a-zA-Z0-9]{10}'
                    if simple_pattern not in formula_text:
                        logger.warning(f"Cell {cell_coord} formula does not contain regex pattern '{regex_pattern}'")
                        logger.warning(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                
                logger.info(f"✓ Cell {cell_coord} has valid REGEXP formula: {formula_text}")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        if all_passed:
            logger.info("=" * 60)
            logger.info(f"✓ All cells in column {check_column} contain correct {expected_pattern} formulas")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ {expected_pattern} formula verification failed")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_sumif_formula(result: str, expected: str = None, **options) -> float:
    """
    Verify if SUMIF formulas exist in specified column (F) to calculate totals.
    
    This function checks:
    1. Whether cells in specified column contain SUMIF formulas
    2. Whether formulas reference the correct ranges (auto-detected from data)
    3. Whether formulas reference the corresponding E column cell (F2->E2, F3->E3, etc.)
    4. Whether formulas have the correct structure
    
    The function automatically detects:
    - end_row: by checking the data column (E) for non-empty cells
    - criteria_range: by detecting the range from the first formula or from criteria_column data
    - sum_range: by detecting the range from the first formula or from sum_column data
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_column: Column to check (e.g., "F")
            - start_row: Starting row number (default: 2)
            - expected_function: Expected function name (default: "SUMIF")
            - criteria_column: Column containing criteria (e.g., "B")
            - sum_column: Column containing values to sum (e.g., "C")
            - criteria_column_start: Starting row for criteria column (default: 2)
            - data_column: Column to check for data to determine end_row (default: "E")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_column = options.get('check_column', 'F')
        start_row = options.get('start_row', 2)
        expected_function = options.get('expected_function', 'SUMIF')
        criteria_column = options.get('criteria_column', 'B')
        sum_column = options.get('sum_column', 'C')
        criteria_column_start = options.get('criteria_column_start', 2)
        data_column = options.get('data_column', 'E')
        
        logger.info(f"Verifying SUMIF formulas in file: {result}")
        logger.info(f"Column to check: {check_column}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Expected function: {expected_function}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row  # Start from start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Auto-detect criteria_range and sum_range by checking the first formula
        criteria_range = None
        sum_range = None
        
        # Try to extract ranges from the first formula
        first_cell_coord = f"{check_column}{start_row}"
        try:
            first_cell = ws[first_cell_coord]
            if first_cell.data_type == "f":
                first_formula_text = None
                if hasattr(first_cell, "_value") and isinstance(first_cell._value, str) and first_cell._value.startswith("="):
                    first_formula_text = first_cell._value
                elif hasattr(first_cell, "formula"):
                    first_formula_text = first_cell.formula
                elif first_cell.value is not None and isinstance(first_cell.value, str) and first_cell.value.startswith("="):
                    first_formula_text = first_cell.value
                
                if first_formula_text:
                    # Extract ranges from SUMIF formula: SUMIF(range1, criteria, range2)
                    # Pattern: SUMIF(range1, criteria, range2)
                    sumif_pattern = r'SUMIF\s*\(\s*([^,]+)\s*,\s*[^,]+\s*,\s*([^)]+)\s*\)'
                    match = re.search(sumif_pattern, first_formula_text, re.IGNORECASE)
                    if match:
                        criteria_range = match.group(1).strip()
                        sum_range = match.group(2).strip()
                        logger.info(f"Extracted from first formula: criteria_range={criteria_range}, sum_range={sum_range}")
        except Exception as e:
            logger.debug(f"Could not extract ranges from first formula: {e}")
        
        # If ranges not found in formula, detect from data columns
        if not criteria_range or not sum_range:
            logger.info(f"Auto-detecting ranges from data columns...")
            # Find the last row with data in criteria_column
            criteria_end_row = criteria_column_start
            empty_count = 0
            for row_num in range(criteria_column_start, max_row + 1):
                criteria_cell = ws[f"{criteria_column}{row_num}"]
                if criteria_cell.value is None or (isinstance(criteria_cell.value, str) and criteria_cell.value.strip() == ""):
                    empty_count += 1
                    if empty_count >= 3:
                        break
                else:
                    empty_count = 0
                    criteria_end_row = row_num
            
            # Find the last row with data in sum_column
            sum_end_row = criteria_column_start
            empty_count = 0
            for row_num in range(criteria_column_start, max_row + 1):
                sum_cell = ws[f"{sum_column}{row_num}"]
                if sum_cell.value is None or (isinstance(sum_cell.value, str) and sum_cell.value.strip() == ""):
                    empty_count += 1
                    if empty_count >= 3:
                        break
                else:
                    empty_count = 0
                    sum_end_row = row_num
            
            # Use the maximum end row for both ranges
            max_end_row = max(criteria_end_row, sum_end_row)
            criteria_range = f"{criteria_column}{criteria_column_start}:{criteria_column}{max_end_row}"
            sum_range = f"{sum_column}{criteria_column_start}:{sum_column}{max_end_row}"
            logger.info(f"Auto-detected ranges: criteria_range={criteria_range}, sum_range={sum_range}")
        
        # Check each row in the specified column
        all_passed = True
        logger.info(f"Checking column {check_column} (rows {start_row} to {end_row})")
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{check_column}{row_num}"
            try:
                cell = ws[cell_coord]
                logger.debug(f"Checking cell {cell_coord}")
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.warning(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                else:
                    # Try to get from value attribute
                    if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                # Remove leading = if present for comparison
                formula_clean = formula_text.lstrip("=")
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains SUMIF function
                formula_upper = formula_text.upper()
                if expected_function.upper() not in formula_upper:
                    logger.warning(f"Cell {cell_coord} formula does not contain {expected_function}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 2: Formula contains SUMIF function call structure
                sumif_match = re.search(r'SUMIF\s*\([^)]+\)', formula_text, re.IGNORECASE)
                if not sumif_match:
                    logger.warning(f"Cell {cell_coord} formula does not have correct SUMIF structure")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: Formula contains criteria range
                if criteria_range and criteria_range.upper() not in formula_upper:
                    logger.warning(f"Cell {cell_coord} formula does not contain criteria range '{criteria_range}'")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: Formula contains sum range
                if sum_range and sum_range.upper() not in formula_upper:
                    logger.warning(f"Cell {cell_coord} formula does not contain sum range '{sum_range}'")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 5: Formula references the corresponding E column cell (E2, E3, etc.)
                expected_e_cell = f"E{row_num}"
                # Check if formula contains E column reference with the same row number
                e_cell_pattern = rf'E{row_num}\b'
                if not re.search(e_cell_pattern, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {cell_coord} formula does not reference {expected_e_cell}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                logger.info(f"✓ Cell {cell_coord} has valid SUMIF formula: {formula_text}")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        if all_passed:
            logger.info("=" * 60)
            logger.info(f"✓ All cells in column {check_column} contain correct {expected_function} formulas")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ {expected_function} formula verification failed")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_networkdays_formula(result: str, expected: str = None, **options) -> float:
    """
    Verify if NETWORKDAYS formulas exist in specified column to calculate working days.
    
    This function checks:
    1. Whether cells in specified column contain NETWORKDAYS formulas
    2. Whether formulas reference the corresponding start date column cell (A2, A3, etc.)
    3. Whether formulas reference the corresponding end date column cell (B2, B3, etc.)
    4. Whether formulas have the correct structure
    
    The function automatically detects the number of data rows by checking the data column
    (default: A column) for non-empty cells. It stops checking after finding 3 consecutive
    empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_column: Column to check (e.g., "C")
            - start_row: Starting row number (default: 2)
            - start_date_column: Column containing start dates (e.g., "A")
            - end_date_column: Column containing end dates (e.g., "B")
            - expected_function: Expected function name (default: "NETWORKDAYS")
            - data_column: Column to check for data to determine end_row (default: "A")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_column = options.get('check_column', 'C')
        start_row = options.get('start_row', 2)
        start_date_column = options.get('start_date_column', 'A')
        end_date_column = options.get('end_date_column', 'B')
        expected_function = options.get('expected_function', 'NETWORKDAYS')
        data_column = options.get('data_column', 'A')
        
        logger.info(f"Verifying NETWORKDAYS formulas in file: {result}")
        logger.info(f"Column to check: {check_column}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Start date column: {start_date_column}")
        logger.info(f"End date column: {end_date_column}")
        logger.info(f"Expected function: {expected_function}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row  # Start from start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Check each row in the specified column
        all_passed = True
        logger.info(f"Checking column {check_column} (rows {start_row} to {end_row})")
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{check_column}{row_num}"
            try:
                cell = ws[cell_coord]
                logger.debug(f"Checking cell {cell_coord}")
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.warning(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                else:
                    # Try to get from value attribute
                    if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                # Remove leading = if present for comparison
                formula_clean = formula_text.lstrip("=")
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains NETWORKDAYS function
                formula_upper = formula_text.upper()
                if expected_function.upper() not in formula_upper:
                    logger.warning(f"Cell {cell_coord} formula does not contain {expected_function}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 2: Formula contains NETWORKDAYS function call structure
                # NETWORKDAYS can have 2 or 3 parameters: NETWORKDAYS(start_date, end_date) or NETWORKDAYS(start_date, end_date, holidays)
                networkdays_pattern = r'NETWORKDAYS\s*\([^)]+\)'
                networkdays_match = re.search(networkdays_pattern, formula_text, re.IGNORECASE)
                if not networkdays_match:
                    logger.warning(f"Cell {cell_coord} formula does not have correct NETWORKDAYS structure")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: Formula references the corresponding start date column cell (A2, A3, etc.)
                expected_start_cell = f"{start_date_column}{row_num}"
                start_cell_pattern = rf'{start_date_column}{row_num}\b'
                if not re.search(start_cell_pattern, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {cell_coord} formula does not reference start date cell {expected_start_cell}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: Formula references the corresponding end date column cell (B2, B3, etc.)
                expected_end_cell = f"{end_date_column}{row_num}"
                end_cell_pattern = rf'{end_date_column}{row_num}\b'
                if not re.search(end_cell_pattern, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {cell_coord} formula does not reference end date cell {expected_end_cell}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                logger.info(f"✓ Cell {cell_coord} has valid NETWORKDAYS formula: {formula_text}")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        if all_passed:
            logger.info("=" * 60)
            logger.info(f"✓ All cells in column {check_column} contain correct {expected_function} formulas")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ {expected_function} formula verification failed")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_conditional_formatting_reconciliation(result: str, expected: str = None, **options) -> float:
    """
    Verify if conditional formatting is correctly set up for reconciliation between two tables.
    
    This function checks:
    1. Whether conditional formatting rules exist in the worksheet
    2. Whether the formula matches the expected pattern (e.g., A1<>E1 to compare cells from two tables)
    3. Whether conditional formatting is applied to the correct range
    4. Whether cells with differences are formatted (highlighted)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_range: Range where conditional formatting should be applied (e.g., "A1:C16")
            - compare_range: Range to compare against (e.g., "E1:G16")
            - expected_formula: Expected formula pattern (e.g., "A1<>E1")
            - format_column: Column to check for formatting (optional, e.g., "B")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        from openpyxl.worksheet.cell_range import CellRange
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_range = options.get('check_range', 'A1:C16')
        compare_range = options.get('compare_range', 'E1:G16')
        expected_formula = options.get('expected_formula', 'A1<>E1')
        format_column = options.get('format_column', None)
        
        logger.info(f"Verifying conditional formatting reconciliation in file: {result}")
        logger.info(f"Check range: {check_range}")
        logger.info(f"Compare range: {compare_range}")
        logger.info(f"Expected formula pattern: {expected_formula}")
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=False)
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check if conditional formatting exists
        conditional_formattings = ws.conditional_formatting
        if not conditional_formattings:
            logger.error("No conditional formatting rules found in the worksheet")
            return 0.0
        
        logger.info(f"Found {len(conditional_formattings)} conditional formatting rule(s)")
        
        # Parse expected formula to extract cell references
        # Expected formula like "A1<>E1" means compare A1 with E1
        expected_formula_clean = expected_formula.replace(" ", "").upper()
        
        # Find matching conditional formatting rule
        found_matching_rule = False
        rule_applied_to_correct_range = False
        
        for fmt in conditional_formattings:
            for rule in fmt.rules:
                # Check if rule has formula
                if not rule.formula:
                    continue
                
                # Check formula pattern
                formula_text = rule.formula[0] if rule.formula else ""
                formula_text_clean = formula_text.replace(" ", "").upper()
                
                logger.debug(f"Checking rule with formula: {formula_text}")
                
                # Check if formula matches expected pattern
                # The formula should contain comparison like A1<>E1, A2<>E2, etc.
                # We need to check if the pattern matches (allowing for relative references)
                if "<>" in expected_formula_clean:
                    # Extract cell references from expected formula
                    # Pattern: A1<>E1 means compare A column with E column
                    expected_parts = expected_formula_clean.split("<>")
                    if len(expected_parts) == 2:
                        expected_cell1 = expected_parts[0]  # e.g., "A1"
                        expected_cell2 = expected_parts[1]   # e.g., "E1"
                        
                        # Extract column letters
                        expected_col1 = re.match(r'([A-Z]+)', expected_cell1)
                        expected_col2 = re.match(r'([A-Z]+)', expected_cell2)
                        
                        if expected_col1 and expected_col2:
                            col1 = expected_col1.group(1)
                            col2 = expected_col2.group(1)
                            
                            # Check if formula contains comparison between these columns
                            # Pattern should be like: A1<>E1, A2<>E2, etc. (relative references)
                            pattern1 = rf'{col1}\d+\s*<>\s*{col2}\d+'
                            pattern2 = rf'{col1}\d+\s*!=\s*{col2}\d+'  # Alternative: !=
                            
                            if re.search(pattern1, formula_text_clean, re.IGNORECASE) or \
                               re.search(pattern2, formula_text_clean, re.IGNORECASE):
                                found_matching_rule = True
                                logger.info(f"✓ Found matching formula pattern: {formula_text}")
                                
                                # Check if rule is applied to correct range
                                fmt_ranges = [str(rng) for rng in fmt.cells]
                                check_range_upper = check_range.upper()
                                
                                # Check if check_range is covered by any of the formatting ranges
                                try:
                                    check_cell_range = CellRange(check_range_upper)
                                    for fmt_range_str in fmt_ranges:
                                        fmt_cell_range = CellRange(fmt_range_str)
                                        # Check if check_range is within or overlaps with fmt_range
                                        if (check_cell_range.min_row >= fmt_cell_range.min_row and
                                            check_cell_range.max_row <= fmt_cell_range.max_row and
                                            check_cell_range.min_col >= fmt_cell_range.min_col and
                                            check_cell_range.max_col <= fmt_cell_range.max_col):
                                            rule_applied_to_correct_range = True
                                            logger.info(f"✓ Rule applied to correct range: {fmt_range_str} covers {check_range}")
                                            break
                                except Exception as e:
                                    logger.debug(f"Error parsing ranges: {e}")
                                    # If range parsing fails, check if range string matches
                                    if check_range_upper in fmt_ranges:
                                        rule_applied_to_correct_range = True
                                        logger.info(f"✓ Rule applied to exact range: {check_range}")
                                
                                break
            
            if found_matching_rule:
                break
        
        if not found_matching_rule:
            logger.error("No conditional formatting rule found with expected formula pattern")
            return 0.0
        
        if not rule_applied_to_correct_range:
            logger.warning("Conditional formatting rule found but may not be applied to correct range")
            # Don't fail completely, as the range might be slightly different but still valid
        
        # Optional: Check if cells with differences are actually formatted
        # This is a more advanced check that verifies the formatting is working
        if format_column:
            logger.info(f"Checking formatting in column {format_column}...")
            # Try to find cells in format_column that have conditional formatting applied
            # This is a simplified check - in practice, we'd need to evaluate the formula
            # for each cell to see if it's formatted
            
        logger.info("=" * 60)
        logger.info("✓ Conditional formatting reconciliation verification passed")
        logger.info("=" * 60)
        return 1.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_right_len_find_extract(result: str, expected: str = None, **options) -> float:
    """
    Verify if RIGHT, LEN, and FIND formulas exist in specified column to extract text.
    
    This function checks:
    1. Whether cells in specified column contain RIGHT, LEN, and FIND functions
    2. Whether formulas reference the corresponding source column cell (C2->B2, C3->B3, etc.)
    3. Whether formulas contain the correct pattern (e.g., RIGHT(B2,LEN(B2)-FIND("班",B2)))
    4. Whether formulas have the correct structure with RIGHT, LEN, and FIND functions
    
    The function automatically detects the number of data rows by checking the data column
    (default: B column) for non-empty cells. It stops checking after finding 3 consecutive
    empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_column: Column to check (e.g., "C")
            - start_row: Starting row number (default: 2)
            - expected_functions: List of expected function names (e.g., ["RIGHT", "LEN", "FIND"])
            - expected_formula_pattern: Expected formula pattern (e.g., "RIGHT(B")
            - find_text: Text to find in FIND function (e.g., "班")
            - data_column: Column to check for data to determine end_row (default: "B")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_column = options.get('check_column', 'C')
        start_row = options.get('start_row', 2)
        expected_functions = options.get('expected_functions', ['RIGHT', 'LEN', 'FIND'])
        expected_formula_pattern = options.get('expected_formula_pattern', 'RIGHT(B')
        find_text = options.get('find_text', '班')
        data_column = options.get('data_column', 'B')
        
        logger.info(f"Verifying RIGHT/LEN/FIND extraction formulas in file: {result}")
        logger.info(f"Column to check: {check_column}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Expected functions: {expected_functions}")
        logger.info(f"Expected formula pattern: {expected_formula_pattern}")
        logger.info(f"Find text: {find_text}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row  # Start from start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Check each row in the specified column
        all_passed = True
        logger.info(f"Checking column {check_column} (rows {start_row} to {end_row})")
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{check_column}{row_num}"
            try:
                cell = ws[cell_coord]
                logger.debug(f"Checking cell {cell_coord}")
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.warning(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                else:
                    # Try to get from value attribute
                    if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                # Remove leading = if present for comparison
                formula_clean = formula_text.lstrip("=")
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains all expected functions
                for func_name in expected_functions:
                    if func_name.upper() not in formula_upper:
                        logger.warning(f"Cell {cell_coord} formula does not contain {func_name}")
                        logger.warning(f"Formula: {formula_text}")
                        all_passed = False
                        break
                
                if not all_passed:
                    continue
                
                # Check 2: Formula contains expected formula pattern (e.g., RIGHT(B)
                if expected_formula_pattern.upper() not in formula_upper:
                    logger.warning(f"Cell {cell_coord} formula does not contain pattern '{expected_formula_pattern}'")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: Formula contains RIGHT function call structure
                right_match = re.search(r'RIGHT\s*\([^)]+\)', formula_text, re.IGNORECASE)
                if not right_match:
                    logger.warning(f"Cell {cell_coord} formula does not have correct RIGHT structure")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: Formula contains LEN function
                len_match = re.search(r'LEN\s*\([^)]+\)', formula_text, re.IGNORECASE)
                if not len_match:
                    logger.warning(f"Cell {cell_coord} formula does not have LEN function")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 5: Formula contains FIND function with find_text
                find_pattern = rf'FIND\s*\([^)]*{re.escape(find_text)}[^)]*\)'
                find_match = re.search(find_pattern, formula_text, re.IGNORECASE)
                if not find_match:
                    logger.warning(f"Cell {cell_coord} formula does not contain FIND function with text '{find_text}'")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 6: Formula references the corresponding source column cell (B2, B3, etc.)
                expected_source_cell = f"{data_column}{row_num}"
                source_cell_pattern = rf'{data_column}{row_num}\b'
                if not re.search(source_cell_pattern, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {cell_coord} formula does not reference source cell {expected_source_cell}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 7: Formula structure should be RIGHT(B2, LEN(B2)-FIND("班",B2))
                # Verify that LEN and FIND are used together in the second parameter of RIGHT
                # This is a pattern check - the formula should have LEN(...)-FIND(...) structure
                len_find_pattern = r'LEN\s*\([^)]+\)\s*-\s*FIND\s*\([^)]+\)'
                if not re.search(len_find_pattern, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {cell_coord} formula does not have LEN(...)-FIND(...) structure")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                logger.info(f"✓ Cell {cell_coord} has valid RIGHT/LEN/FIND formula: {formula_text}")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        if all_passed:
            logger.info("=" * 60)
            logger.info(f"✓ All cells in column {check_column} contain correct RIGHT/LEN/FIND formulas")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ RIGHT/LEN/FIND formula verification failed")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_iferror_regex_extract(result: str, expected: str = None, **options) -> float:
    """
    Verify if IFERROR(REGEX(...)) formulas exist in specified column to extract text with error handling.
    
    This function checks:
    1. Whether cells in specified column contain IFERROR function wrapping REGEX
    2. Whether REGEX function uses capture group pattern (e.g., .*水笔(\d+).*)
    3. Whether REGEX function uses replacement pattern (e.g., $1元)
    4. Whether IFERROR has empty string as second parameter
    5. Whether formulas reference the corresponding source column cell
    
    The function automatically detects the number of data rows by checking the data column
    for non-empty cells. It stops checking after finding 3 consecutive empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_column: Column to check (e.g., "C")
            - start_row: Starting row number (default: 2)
            - expected_pattern_text: Expected text pattern in regex (e.g., "水笔")
            - data_column: Column to check for data to determine end_row (default: "B")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_column = options.get('check_column', 'C')
        start_row = options.get('start_row', 2)
        expected_pattern_text = options.get('expected_pattern_text', '水笔')
        data_column = options.get('data_column', 'B')
        
        logger.info(f"Verifying IFERROR(REGEX(...)) formulas in file: {result}")
        logger.info(f"Column to check: {check_column}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Expected pattern text: {expected_pattern_text}")
        logger.info(f"Data column: {data_column}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row  # Start from start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Check each row in the specified column
        all_passed = True
        logger.info(f"Checking column {check_column} (rows {start_row} to {end_row})")
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{check_column}{row_num}"
            try:
                cell = ws[cell_coord]
                logger.debug(f"Checking cell {cell_coord}")
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.warning(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                else:
                    # Try to get from value attribute
                    if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains IFERROR function
                if 'IFERROR' not in formula_upper:
                    logger.warning(f"Cell {cell_coord} formula does not contain IFERROR function")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 2: Formula contains REGEX function (inside IFERROR)
                # Support both REGEX and LibreOffice internal format _xlfn.ORG.LIBREOFFICE.REGEX
                has_regex = 'REGEX' in formula_upper or '_XLFN.ORG.LIBREOFFICE.REGEX' in formula_upper
                if not has_regex:
                    logger.warning(f"Cell {cell_coord} formula does not contain REGEX function")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: IFERROR structure - should have two parameters
                iferror_match = re.search(r'IFERROR\s*\([^)]+\)', formula_text, re.IGNORECASE)
                if not iferror_match:
                    logger.warning(f"Cell {cell_coord} formula does not have correct IFERROR structure")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: IFERROR second parameter should be empty string ""
                # Handle various formats: ,"" or , "" or ,'' or , ''
                # Also handle LibreOffice format with spaces: REGEX(...) ,""
                # Extract IFERROR parameters: IFERROR(param1, param2)
                iferror_params_match = re.search(r'IFERROR\s*\((.*)\)', formula_text, re.IGNORECASE)
                if iferror_params_match:
                    params_str = iferror_params_match.group(1)
                    # Split by comma, but need to handle nested commas in strings
                    # Simple approach: find the last comma (should separate the two parameters)
                    # For IFERROR(REGEX(...), ""), the last comma separates REGEX call from ""
                    last_comma_pos = params_str.rfind(',')
                    if last_comma_pos != -1:
                        second_param = params_str[last_comma_pos + 1:].strip()
                        # Check if second parameter is empty string "" or ''
                        if second_param in ['""', "''", '""', "''"]:
                            has_empty_string = True
                        else:
                            has_empty_string = False
                    else:
                        has_empty_string = False
                else:
                    has_empty_string = False
                
                if not has_empty_string:
                    logger.warning(f"Cell {cell_coord} IFERROR should have empty string as second parameter")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 5: REGEX function call structure
                # Support both REGEX and LibreOffice internal format
                regex_match = re.search(r'(REGEX|_XLFN\.ORG\.LIBREOFFICE\.REGEX)\s*\([^)]+\)', formula_text, re.IGNORECASE)
                if not regex_match:
                    logger.warning(f"Cell {cell_coord} formula does not have correct REGEX structure")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 6: Formula contains expected pattern text (e.g., "水笔")
                if expected_pattern_text not in formula_text:
                    logger.warning(f"Cell {cell_coord} formula does not contain pattern text '{expected_pattern_text}'")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 7: Formula contains capture group pattern (\d+)
                has_capture_group = bool(re.search(r'\(\\d\+\)|\(\\\\d\+\)', formula_text))
                if not has_capture_group:
                    logger.warning(f"Cell {cell_coord} REGEX formula should contain capture group (\\d+)")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 8: Formula contains replacement pattern $1
                has_replacement = '"$1' in formula_text or "'$1" in formula_text
                if not has_replacement:
                    logger.warning(f"Cell {cell_coord} REGEX formula should contain replacement pattern $1")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 9: Formula references the corresponding source column cell
                expected_source_cell = f"{data_column}{row_num}"
                source_cell_pattern = rf'{data_column}{row_num}\b'
                if not re.search(source_cell_pattern, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {cell_coord} formula does not reference source cell {expected_source_cell}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                logger.info(f"✓ Cell {cell_coord} has valid IFERROR(REGEX(...)) formula: {formula_text}")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        if all_passed:
            logger.info("=" * 60)
            logger.info(f"✓ All cells in column {check_column} contain correct IFERROR(REGEX(...)) formulas")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ IFERROR(REGEX(...)) formula verification failed")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_rept_text_progress_bar(result: str, expected: str = None, **options) -> float:
    """
    Verify if REPT and TEXT formulas exist in specified column to create progress bars with percentage.
    
    This function checks:
    1. Whether cells in specified column contain REPT and TEXT functions
    2. Whether REPT function uses the correct character (e.g., "|")
    3. Whether REPT function uses the correct multiplier (e.g., *50)
    4. Whether TEXT function uses percentage format (e.g., "0%")
    5. Whether formulas reference the correct numerator and denominator columns
    6. Whether formulas use & operator to concatenate REPT and TEXT results
    
    The function automatically detects the number of data rows by checking the data column
    for non-empty cells. It stops checking after finding 3 consecutive empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_column: Column to check (e.g., "D")
            - start_row: Starting row number (default: 2)
            - expected_functions: List of expected function names (e.g., ["REPT", "TEXT"])
            - numerator_column: Column containing numerator values (e.g., "C")
            - denominator_column: Column containing denominator values (e.g., "B")
            - rept_char: Character to repeat in REPT function (e.g., "|")
            - rept_multiplier: Multiplier for REPT function (e.g., 50)
            - data_column: Column to check for data to determine end_row (default: "B")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_column = options.get('check_column', 'D')
        start_row = options.get('start_row', 2)
        expected_functions = options.get('expected_functions', ['REPT', 'TEXT'])
        numerator_column = options.get('numerator_column', 'C')
        denominator_column = options.get('denominator_column', 'B')
        rept_char = options.get('rept_char', '|')
        rept_multiplier = options.get('rept_multiplier', 50)
        data_column = options.get('data_column', 'B')
        
        logger.info(f"Verifying REPT/TEXT progress bar formulas in file: {result}")
        logger.info(f"Column to check: {check_column}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Expected functions: {expected_functions}")
        logger.info(f"Numerator column: {numerator_column}")
        logger.info(f"Denominator column: {denominator_column}")
        logger.info(f"REPT character: {rept_char}")
        logger.info(f"REPT multiplier: {rept_multiplier}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row  # Start from start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Check each row in the specified column
        all_passed = True
        logger.info(f"Checking column {check_column} (rows {start_row} to {end_row})")
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{check_column}{row_num}"
            try:
                cell = ws[cell_coord]
                logger.debug(f"Checking cell {cell_coord}")
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.warning(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                else:
                    # Try to get from value attribute
                    if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains all expected functions (REPT and TEXT)
                for func_name in expected_functions:
                    if func_name.upper() not in formula_upper:
                        logger.warning(f"Cell {cell_coord} formula does not contain {func_name}")
                        logger.warning(f"Formula: {formula_text}")
                        all_passed = False
                        break
                
                if not all_passed:
                    continue
                
                # Check 2: Formula contains REPT function call structure
                rept_match = re.search(r'REPT\s*\([^)]+\)', formula_text, re.IGNORECASE)
                if not rept_match:
                    logger.warning(f"Cell {cell_coord} formula does not have correct REPT structure")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: REPT function contains the correct character (e.g., "|")
                # Support both double quotes and single quotes
                rept_char_pattern1 = rf'REPT\s*\(\s*"{re.escape(rept_char)}"'
                rept_char_pattern2 = rf"REPT\s*\(\s*'{re.escape(rept_char)}'"
                if not re.search(rept_char_pattern1, formula_text, re.IGNORECASE) and \
                   not re.search(rept_char_pattern2, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {cell_coord} REPT function should use character '{rept_char}'")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: REPT function contains the multiplier (e.g., *50)
                rept_multiplier_pattern = rf'\*{rept_multiplier}\b'
                if not re.search(rept_multiplier_pattern, formula_text):
                    logger.warning(f"Cell {cell_coord} REPT function should use multiplier *{rept_multiplier}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 5: Formula contains TEXT function call structure
                text_match = re.search(r'TEXT\s*\([^)]+\)', formula_text, re.IGNORECASE)
                if not text_match:
                    logger.warning(f"Cell {cell_coord} formula does not have correct TEXT structure")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 6: TEXT function contains percentage format ("0%" or '0%')
                text_percent_pattern1 = r'TEXT\s*\([^,]+,\s*"0%"'
                text_percent_pattern2 = r"TEXT\s*\([^,]+,\s*'0%'"
                if not re.search(text_percent_pattern1, formula_text, re.IGNORECASE) and \
                   not re.search(text_percent_pattern2, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {cell_coord} TEXT function should use percentage format \"0%\"")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 7: Formula references the correct numerator column (C2, C3, etc.)
                expected_numerator_cell = f"{numerator_column}{row_num}"
                numerator_cell_pattern = rf'{numerator_column}{row_num}\b'
                if not re.search(numerator_cell_pattern, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {cell_coord} formula does not reference numerator cell {expected_numerator_cell}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 8: Formula references the correct denominator column (B2, B3, etc.)
                expected_denominator_cell = f"{denominator_column}{row_num}"
                denominator_cell_pattern = rf'{denominator_column}{row_num}\b'
                if not re.search(denominator_cell_pattern, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {cell_coord} formula does not reference denominator cell {expected_denominator_cell}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 9: Formula contains & operator to concatenate REPT and TEXT
                if '&' not in formula_text:
                    logger.warning(f"Cell {cell_coord} formula should use & operator to concatenate REPT and TEXT")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 10: Formula structure should be REPT(...)&TEXT(...)
                # Verify that REPT comes before TEXT (or at least both are present)
                rept_pos = formula_text.upper().find('REPT')
                text_pos = formula_text.upper().find('TEXT')
                if rept_pos == -1 or text_pos == -1:
                    logger.warning(f"Cell {cell_coord} formula should contain both REPT and TEXT functions")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                logger.info(f"✓ Cell {cell_coord} has valid REPT/TEXT progress bar formula: {formula_text}")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        if all_passed:
            logger.info("=" * 60)
            logger.info(f"✓ All cells in column {check_column} contain correct REPT/TEXT progress bar formulas")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ REPT/TEXT progress bar formula verification failed")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_id_extract_gender_age_birthday(result: str, expected: str = None, **options) -> float:
    """
    Verify if formulas exist to extract gender, age, and birthday from ID numbers.
    
    This function checks:
    1. Gender column (C): IF(MOD(MID(B3,17,1),2),"男","女")
    2. Age column (D): DATEDIF(TEXT(MID(B3,7,8),"0-00-00"),TODAY(),"Y")
    3. Birthday column (E): --TEXT(MID(B3,7,8),"0-00-00")
    
    The function automatically detects the number of data rows by checking the ID column
    for non-empty cells. It stops checking after finding 3 consecutive empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - id_column: Column containing ID numbers (e.g., "B")
            - gender_column: Column for gender formulas (e.g., "C")
            - age_column: Column for age formulas (e.g., "D")
            - birthday_column: Column for birthday formulas (e.g., "E")
            - start_row: Starting row number (default: 3)
            - data_column: Column to check for data to determine end_row (default: "B")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        id_column = options.get('id_column', 'B')
        gender_column = options.get('gender_column', 'C')
        age_column = options.get('age_column', 'D')
        birthday_column = options.get('birthday_column', 'E')
        start_row = options.get('start_row', 3)
        data_column = options.get('data_column', 'B')
        
        logger.info(f"Verifying ID extraction formulas in file: {result}")
        logger.info(f"ID column: {id_column}")
        logger.info(f"Gender column: {gender_column}")
        logger.info(f"Age column: {age_column}")
        logger.info(f"Birthday column: {birthday_column}")
        logger.info(f"Start row: {start_row}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row  # Start from start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Check each row
        all_passed = True
        logger.info(f"Checking rows {start_row} to {end_row}")
        
        for row_num in range(start_row, end_row + 1):
            try:
                # Check gender column (C)
                gender_cell_coord = f"{gender_column}{row_num}"
                gender_cell = ws[gender_cell_coord]
                
                if gender_cell.data_type != "f":
                    logger.warning(f"Cell {gender_cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                gender_formula_text = None
                if hasattr(gender_cell, "_value") and isinstance(gender_cell._value, str) and gender_cell._value.startswith("="):
                    gender_formula_text = gender_cell._value
                elif hasattr(gender_cell, "formula"):
                    gender_formula_text = gender_cell.formula
                elif gender_cell.value is not None and isinstance(gender_cell.value, str) and gender_cell.value.startswith("="):
                    gender_formula_text = gender_cell.value
                
                if gender_formula_text is None:
                    logger.warning(f"Could not extract formula from cell {gender_cell_coord}")
                    all_passed = False
                    continue
                
                gender_formula_upper = gender_formula_text.upper()
                logger.debug(f"Cell {gender_cell_coord} formula: {gender_formula_text}")
                
                # Check gender formula: IF(MOD(MID(B3,17,1),2),"男","女")
                if 'IF' not in gender_formula_upper:
                    logger.warning(f"Cell {gender_cell_coord} formula does not contain IF function")
                    all_passed = False
                    continue
                
                if 'MOD' not in gender_formula_upper:
                    logger.warning(f"Cell {gender_cell_coord} formula does not contain MOD function")
                    all_passed = False
                    continue
                
                if 'MID' not in gender_formula_upper:
                    logger.warning(f"Cell {gender_cell_coord} formula does not contain MID function")
                    all_passed = False
                    continue
                
                # Check MID(B3,17,1) pattern
                mid_pattern = rf'MID\s*\(\s*{id_column}{row_num}\s*,\s*17\s*,\s*1\s*\)'
                if not re.search(mid_pattern, gender_formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {gender_cell_coord} formula should contain MID({id_column}{row_num},17,1)")
                    logger.warning(f"Formula: {gender_formula_text}")
                    all_passed = False
                    continue
                
                # Check for "男" and "女" in formula
                if '"男"' not in gender_formula_text and "'男'" not in gender_formula_text:
                    logger.warning(f"Cell {gender_cell_coord} formula should contain \"男\"")
                    logger.warning(f"Formula: {gender_formula_text}")
                    all_passed = False
                    continue
                
                if '"女"' not in gender_formula_text and "'女'" not in gender_formula_text:
                    logger.warning(f"Cell {gender_cell_coord} formula should contain \"女\"")
                    logger.warning(f"Formula: {gender_formula_text}")
                    all_passed = False
                    continue
                
                logger.info(f"✓ Cell {gender_cell_coord} has valid gender formula: {gender_formula_text}")
                
                # Check age column (D)
                age_cell_coord = f"{age_column}{row_num}"
                age_cell = ws[age_cell_coord]
                
                if age_cell.data_type != "f":
                    logger.warning(f"Cell {age_cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                age_formula_text = None
                if hasattr(age_cell, "_value") and isinstance(age_cell._value, str) and age_cell._value.startswith("="):
                    age_formula_text = age_cell._value
                elif hasattr(age_cell, "formula"):
                    age_formula_text = age_cell.formula
                elif age_cell.value is not None and isinstance(age_cell.value, str) and age_cell.value.startswith("="):
                    age_formula_text = age_cell.value
                
                if age_formula_text is None:
                    logger.warning(f"Could not extract formula from cell {age_cell_coord}")
                    all_passed = False
                    continue
                
                age_formula_upper = age_formula_text.upper()
                logger.debug(f"Cell {age_cell_coord} formula: {age_formula_text}")
                
                # Check age formula: DATEDIF(TEXT(MID(B3,7,8),"0-00-00"),TODAY(),"Y")
                if 'DATEDIF' not in age_formula_upper:
                    logger.warning(f"Cell {age_cell_coord} formula does not contain DATEDIF function")
                    all_passed = False
                    continue
                
                if 'TEXT' not in age_formula_upper:
                    logger.warning(f"Cell {age_cell_coord} formula does not contain TEXT function")
                    all_passed = False
                    continue
                
                if 'TODAY' not in age_formula_upper:
                    logger.warning(f"Cell {age_cell_coord} formula does not contain TODAY function")
                    all_passed = False
                    continue
                
                if 'MID' not in age_formula_upper:
                    logger.warning(f"Cell {age_cell_coord} formula does not contain MID function")
                    all_passed = False
                    continue
                
                # Check MID(B3,7,8) pattern
                mid_pattern_age = rf'MID\s*\(\s*{id_column}{row_num}\s*,\s*7\s*,\s*8\s*\)'
                if not re.search(mid_pattern_age, age_formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {age_cell_coord} formula should contain MID({id_column}{row_num},7,8)")
                    logger.warning(f"Formula: {age_formula_text}")
                    all_passed = False
                    continue
                
                # Check TEXT format "0-00-00"
                # Use pattern that matches until the quote to handle nested functions like MID(B3,7,8)
                text_format_pattern1 = r'TEXT\s*\([^"]+,\s*"0-00-00"'
                text_format_pattern2 = r"TEXT\s*\([^']+,\s*'0-00-00'"
                if not re.search(text_format_pattern1, age_formula_text, re.IGNORECASE) and \
                   not re.search(text_format_pattern2, age_formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {age_cell_coord} TEXT function should use format \"0-00-00\"")
                    logger.warning(f"Formula: {age_formula_text}")
                    all_passed = False
                    continue
                
                # Check DATEDIF third parameter "Y"
                # Use a more flexible pattern that handles nested functions
                # Check if DATEDIF contains "Y" as the third parameter (after two commas)
                # Pattern: DATEDIF(...,...,"Y") or DATEDIF(...,...,'Y')
                # We'll count commas to find the third parameter
                datedif_match = re.search(r'DATEDIF\s*\((.*)\)', age_formula_text, re.IGNORECASE)
                if datedif_match:
                    datedif_params = datedif_match.group(1)
                    # Count commas to find the third parameter
                    # Simple approach: check if the last part before closing paren is "Y" or 'Y'
                    # More robust: find the pattern ,"Y" or ,'Y' before the closing paren
                    if not re.search(r',\s*"Y"\s*\)', age_formula_text, re.IGNORECASE) and \
                       not re.search(r",\s*'Y'\s*\)", age_formula_text, re.IGNORECASE):
                        logger.warning(f"Cell {age_cell_coord} DATEDIF function should use \"Y\" parameter")
                        logger.warning(f"Formula: {age_formula_text}")
                        all_passed = False
                        continue
                else:
                    logger.warning(f"Cell {age_cell_coord} could not parse DATEDIF function")
                    logger.warning(f"Formula: {age_formula_text}")
                    all_passed = False
                    continue
                
                logger.info(f"✓ Cell {age_cell_coord} has valid age formula: {age_formula_text}")
                
                # Check birthday column (E)
                birthday_cell_coord = f"{birthday_column}{row_num}"
                birthday_cell = ws[birthday_cell_coord]
                
                if birthday_cell.data_type != "f":
                    logger.warning(f"Cell {birthday_cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                birthday_formula_text = None
                if hasattr(birthday_cell, "_value") and isinstance(birthday_cell._value, str) and birthday_cell._value.startswith("="):
                    birthday_formula_text = birthday_cell._value
                elif hasattr(birthday_cell, "formula"):
                    birthday_formula_text = birthday_cell.formula
                elif birthday_cell.value is not None and isinstance(birthday_cell.value, str) and birthday_cell.value.startswith("="):
                    birthday_formula_text = birthday_cell.value
                
                if birthday_formula_text is None:
                    logger.warning(f"Could not extract formula from cell {birthday_cell_coord}")
                    all_passed = False
                    continue
                
                birthday_formula_upper = birthday_formula_text.upper()
                logger.debug(f"Cell {birthday_cell_coord} formula: {birthday_formula_text}")
                
                # Check birthday formula: TEXT(MID(B3,7,8),"0-00-00")
                if 'TEXT' not in birthday_formula_upper:
                    logger.warning(f"Cell {birthday_cell_coord} formula does not contain TEXT function")
                    all_passed = False
                    continue
                
                if 'MID' not in birthday_formula_upper:
                    logger.warning(f"Cell {birthday_cell_coord} formula does not contain MID function")
                    all_passed = False
                    continue
                
                # Check MID(B3,7,8) pattern
                mid_pattern_birthday = rf'MID\s*\(\s*{id_column}{row_num}\s*,\s*7\s*,\s*8\s*\)'
                if not re.search(mid_pattern_birthday, birthday_formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {birthday_cell_coord} formula should contain MID({id_column}{row_num},7,8)")
                    logger.warning(f"Formula: {birthday_formula_text}")
                    all_passed = False
                    continue
                
                # Check TEXT format "0-00-00"
                # Use pattern that matches until the quote to handle nested functions like MID(B3,7,8)
                text_format_pattern1 = r'TEXT\s*\([^"]+,\s*"0-00-00"'
                text_format_pattern2 = r"TEXT\s*\([^']+,\s*'0-00-00'"
                if not re.search(text_format_pattern1, birthday_formula_text, re.IGNORECASE) and \
                   not re.search(text_format_pattern2, birthday_formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {birthday_cell_coord} TEXT function should use format \"0-00-00\"")
                    logger.warning(f"Formula: {birthday_formula_text}")
                    all_passed = False
                    continue
                
                logger.info(f"✓ Cell {birthday_cell_coord} has valid birthday formula: {birthday_formula_text}")
                
            except Exception as e:
                logger.error(f"Error checking row {row_num}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        if all_passed:
            logger.info("=" * 60)
            logger.info(f"✓ All rows contain correct ID extraction formulas (gender, age, birthday)")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ ID extraction formula verification failed")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_line_chart(result: str, expected: str = None, **options) -> float:
    """
    Verify if a line chart exists in the Excel file.
    
    This function checks:
    1. Whether at least one chart exists in the worksheet
    2. Whether the chart type is lineChart
    3. Whether the chart has the expected number of series
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - expected_chart_type: Expected chart type (default: "lineChart")
            - min_series_count: Minimum number of series expected (default: 1)
            - data_range: Data range used for chart (optional, for logging)
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        expected_chart_type = options.get('expected_chart_type', 'lineChart')
        min_series_count = options.get('min_series_count', 1)
        data_range = options.get('data_range', '')
        
        logger.info(f"Verifying line chart in file: {result}")
        logger.info(f"Expected chart type: {expected_chart_type}")
        logger.info(f"Minimum series count: {min_series_count}")
        if data_range:
            logger.info(f"Data range: {data_range}")
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result)
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check if charts exist
        charts = ws._charts
        if not charts or len(charts) == 0:
            logger.error("No charts found in the worksheet")
            return 0.0
        
        logger.info(f"Found {len(charts)} chart(s) in the worksheet")
        
        # Check each chart
        for chart_idx, chart in enumerate(charts):
            logger.info(f"Checking chart {chart_idx + 1}...")
            
            # Check chart type
            chart_type = None
            if hasattr(chart, 'tagname'):
                chart_type = chart.tagname
            logger.info(f"Chart type: {chart_type}")
            
            # Check if it's a line chart
            if chart_type and expected_chart_type.lower() in chart_type.lower():
                logger.info(f"✓ Chart {chart_idx + 1} is a line chart")
                
                # Check if it has series
                if not hasattr(chart, 'series') or not chart.series:
                    logger.warning(f"Chart {chart_idx + 1} has no series")
                    continue
                
                series_count = len(chart.series)
                logger.info(f"Chart {chart_idx + 1} has {series_count} series")
                
                # Verify series count
                if series_count >= min_series_count:
                    logger.info("=" * 60)
                    logger.info(f"✓ Line chart verification passed")
                    logger.info(f"  Chart type: {chart_type}")
                    logger.info(f"  Series count: {series_count} (minimum required: {min_series_count})")
                    logger.info("=" * 60)
                    return 1.0
                else:
                    logger.warning(f"Chart {chart_idx + 1} has {series_count} series, but minimum required is {min_series_count}")
            else:
                logger.warning(f"Chart {chart_idx + 1} is not a line chart (type: {chart_type})")
        
        # If we get here, verification failed
        logger.error("=" * 60)
        logger.error(f"✗ Line chart verification failed")
        logger.error(f"  Expected chart type: {expected_chart_type}")
        logger.error(f"  Minimum series count: {min_series_count}")
        logger.error("=" * 60)
        return 0.0
             
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_salary_growth_chart(result: str, expected: str = None, **options) -> float:
    """
    Verify if the salary growth chart matches the expected specifications.
    
    This function checks the chart itself (not the data table):
    1. Whether a chart exists in the specified sheet
    2. Whether the chart title matches "店长工资增长"
    3. Whether the chart has the expected number of series (at least 3)
    4. Whether the chart is a combination chart (bar + line)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - sheet_idx: Sheet index (default: 0)
            - expected_title: Expected chart title (default: "店长工资增长")
            - min_series_count: Minimum number of series (default: 3)
            - chart_type: Expected chart type (default: "combination")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        sheet_idx = options.get('sheet_idx', 0)
        expected_title = options.get('expected_title', '店长工资增长')
        min_series_count = options.get('min_series_count', 3)
        chart_type = options.get('chart_type', 'combination')
        
        logger.info(f"Verifying salary growth chart in file: {result}")
        logger.info(f"Sheet index: {sheet_idx}")
        logger.info(f"Expected title: {expected_title}")
        logger.info(f"Min series count: {min_series_count}")
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result)
            pdworkbook = pd.ExcelFile(result)
            sheet_names = pdworkbook.sheet_names
            
            if sheet_idx >= len(sheet_names):
                logger.error(f"Sheet index {sheet_idx} out of range. Available sheets: {sheet_names}")
                return 0.0
            
            sheet_name = sheet_names[sheet_idx]
            logger.info(f"Checking sheet: {sheet_name}")
            ws = wb[sheet_name]
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return 0.0
        
        # Check if charts exist
        charts = ws._charts
        if not charts:
            logger.error("No charts found in the sheet")
            return 0.0
        
        logger.info(f"Found {len(charts)} chart(s) in the sheet")
        
        # Load chart information
        chart_props = ['title', 'type', 'legend', 'xtitle', 'ytitle']
        chart_info = load_charts(wb, sheet_name, chart_props=chart_props)
        
        if not chart_info:
            logger.error("Could not load chart information")
            return 0.0
        
        # Check each chart
        chart_passed = False
        for chart_key, chart_data in chart_info.items():
            logger.info(f"Checking chart: {chart_key}")
            logger.debug(f"Chart data: {chart_data}")
            
            # Check 1: Chart title
            chart_title = chart_data.get('title')
            if chart_title != expected_title:
                logger.warning(f"Chart title mismatch: expected '{expected_title}', got '{chart_title}'")
                continue
            else:
                logger.info(f"✓ Chart title matches: {chart_title}")
            
            # Check 2: Chart type (for combination charts, we might see multiple types)
            chart_type_actual = chart_data.get('type')
            logger.info(f"Chart type: {chart_type_actual}")
            # Note: Combination charts might be represented differently in openpyxl
            # We'll be lenient here and just check that a chart exists
            
            # Check 3: Number of series
            # Extract series count from chart_key (format: "value_ref1,category_ref1;value_ref2,category_ref2;...")
            series_parts = chart_key.split(';')
            series_count = len(series_parts)
            logger.info(f"Number of series: {series_count}")
            
            if series_count < min_series_count:
                logger.warning(f"Insufficient series count: expected at least {min_series_count}, got {series_count}")
                continue
            else:
                logger.info(f"✓ Series count sufficient: {series_count} >= {min_series_count}")
            
            # If we get here, this chart passed all checks
            chart_passed = True
            logger.info("=" * 60)
            logger.info(f"✓ Chart verification passed!")
            logger.info("=" * 60)
            break
        
        if chart_passed:
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error("✗ Chart verification failed - no chart matched all criteria")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_project_completion_chart(result: str, expected: str = None, **options) -> float:
    """
    Verify if a combination chart exists with the expected title that contains
    both bar chart series (for project values) and line chart series (for completion rates).
    
    This function checks:
    1. Whether at least one chart exists in the worksheet
    2. Whether the chart title matches expected_title
    3. Whether the chart has at least 16 series (8 projects + 8 completion rates)
    4. Whether at least one series name contains "rate" (for completion rates)
    5. Whether the chart has at least project_count * 5 categories (for 5 quarters per project)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - sheet_idx: Sheet index to check (default: 0)
            - expected_title: Expected chart title (default: "项目")
            - min_series_count: Minimum number of series required (default: 16)
            - project_count: Number of projects (default: 8)
            - quarters_per_project: Number of quarters per project (default: 5)
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        sheet_idx = options.get('sheet_idx', 0)
        expected_title = options.get('expected_title', '项目')
        min_series_count = options.get('min_series_count', 16)
        project_count = options.get('project_count', 8)
        quarters_per_project = options.get('quarters_per_project', 5)
        min_categories = project_count * quarters_per_project
        
        logger.info(f"Verifying project completion chart in file: {result}")
        logger.info(f"Sheet index: {sheet_idx}")
        logger.info(f"Expected title: {expected_title}")
        logger.info(f"Minimum series count: {min_series_count}")
        logger.info(f"Project count: {project_count}")
        logger.info(f"Quarters per project: {quarters_per_project}")
        logger.info(f"Minimum categories: {min_categories}")
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result)
            sheet_names = wb.sheetnames
            if sheet_idx >= len(sheet_names):
                logger.error(f"Sheet index {sheet_idx} out of range. Available sheets: {sheet_names}")
                return 0.0
            sheet_name = sheet_names[sheet_idx]
            ws = wb[sheet_name]
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check if charts exist
        charts = ws._charts
        if not charts:
            logger.error("No charts found in the worksheet")
            return 0.0
        
        logger.info(f"Found {len(charts)} chart(s) in the worksheet")
        
        # Check each chart
        chart_found = False
        for chart in charts:
            # Check chart title
            chart_title = None
            try:
                if chart.title and chart.title.tx:
                    if hasattr(chart.title.tx, 'rich') and chart.title.tx.rich:
                        if hasattr(chart.title.tx.rich, 'p') and chart.title.tx.rich.p:
                            if len(chart.title.tx.rich.p) > 0:
                                if hasattr(chart.title.tx.rich.p[0], 'r') and chart.title.tx.rich.p[0].r:
                                    if len(chart.title.tx.rich.p[0].r) > 0:
                                        if hasattr(chart.title.tx.rich.p[0].r[0], 't'):
                                            chart_title = chart.title.tx.rich.p[0].r[0].t
            except Exception as e:
                logger.debug(f"Error reading chart title: {e}")
            
            logger.info(f"Chart title: {chart_title}")
            
            # Check if title matches
            if chart_title == expected_title:
                logger.info(f"✓ Chart title matches: {chart_title}")
                chart_found = True
                
                # Use load_charts to get all series information (includes both bar and line series)
                # This is more reliable for combination charts
                chart_props = ['title']
                chart_info = load_charts(wb, sheet_name, chart_props=chart_props)
                
                # Find the chart that matches our title
                chart_key = None
                for key, info in chart_info.items():
                    if info.get('title') == expected_title:
                        chart_key = key
                        break
                
                # Get all series from the chart object for detailed inspection
                all_series = list(chart.series) if hasattr(chart, 'series') else []
                logger.info(f"Series count from chart.series: {len(all_series)}")
                
                if not chart_key:
                    logger.warning("Could not find chart in load_charts output, using direct series access")
                    # Fallback to direct series access
                    series_count = len(all_series)
                else:
                    # Extract series count from chart_key (format: "value_ref1,category_ref1;value_ref2,category_ref2;...")
                    # This includes ALL series (both bar and line) in combination charts
                    series_parts = chart_key.split(';')
                    series_count_from_load = len(series_parts)
                    logger.info(f"Series count from load_charts: {series_count_from_load}")
                    
                    # For combination charts, load_charts should give us all series
                    # Use the count from load_charts as it's more reliable for combination charts
                    series_count = series_count_from_load
                    
                    # Also check for sub-charts in case series are stored there
                    if hasattr(chart, '_charts') and chart._charts:
                        # Check for sub-charts (for combination charts)
                        for sub_chart in chart._charts:
                            if hasattr(sub_chart, 'series'):
                                sub_series = list(sub_chart.series)
                                all_series.extend(sub_series)
                                logger.info(f"Found {len(sub_series)} additional series in sub-chart")
                    
                    # If load_charts gave us fewer series than direct access, use the larger count
                    # This handles edge cases where load_charts might miss some series
                    if series_count < len(all_series):
                        logger.warning(f"load_charts found {series_count} series but direct access found {len(all_series)}, using larger count")
                        series_count = len(all_series)
                
                logger.info(f"Chart has {series_count} series (including both bar and line series)")
                
                # Debug: Log all series details
                if all_series:
                    logger.info(f"Detailed series information:")
                    for idx, ser in enumerate(all_series):
                        logger.info(f"  Series {idx}: {type(ser).__name__}")
                        try:
                            if hasattr(ser, 'title'):
                                logger.debug(f"    Title: {ser.title}")
                        except:
                            pass
                
                if series_count < min_series_count:
                    logger.error(f"✗ Chart has only {series_count} series, expected at least {min_series_count}")
                    return 0.0
                
                logger.info(f"✓ Chart has {series_count} series (>= {min_series_count})")
                
                # Check series names for "rate" (completion rate series)
                has_rate_series = False
                series_names = []
                for i, ser in enumerate(all_series):
                    series_name = None
                    try:
                        # Try to get series title/name
                        if hasattr(ser, 'title') and ser.title:
                            if hasattr(ser.title, 'tx') and ser.title.tx:
                                if hasattr(ser.title.tx, 'rich') and ser.title.tx.rich:
                                    if hasattr(ser.title.tx.rich, 'p') and ser.title.tx.rich.p:
                                        if len(ser.title.tx.rich.p) > 0:
                                            if hasattr(ser.title.tx.rich.p[0], 'r') and ser.title.tx.rich.p[0].r:
                                                if len(ser.title.tx.rich.p[0].r) > 0:
                                                    if hasattr(ser.title.tx.rich.p[0].r[0], 't'):
                                                        series_name = ser.title.tx.rich.p[0].r[0].t
                        # Alternative: check if title is a string reference
                        if not series_name and hasattr(ser, 'title') and hasattr(ser.title, 'tx') and hasattr(ser.title.tx, 'strRef'):
                            if hasattr(ser.title.tx.strRef, 'f'):
                                series_name = ser.title.tx.strRef.f
                    except Exception as e:
                        logger.debug(f"Error reading series {i} name: {e}")
                    
                    if series_name:
                        series_names.append(series_name)
                        if "rate" in series_name.lower():
                            has_rate_series = True
                            logger.info(f"✓ Found series with 'rate' in name: {series_name}")
                
                if series_names:
                    logger.info(f"Series names found: {series_names[:10]}...")  # Log first 10
                else:
                    logger.warning("Could not extract series names, will skip rate check")
                
                if not has_rate_series and series_names:
                    logger.error(f"✗ No series found with 'rate' in name. Series names: {series_names}")
                    return 0.0
                elif not has_rate_series:
                    logger.warning("⚠ Could not verify 'rate' in series names (series names not extractable)")
                
                # Check category count
                max_categories = 0
                category_ranges = []
                
                def parse_range_count(range_str):
                    """Parse Excel range string and return count of cells"""
                    try:
                        # Remove sheet name if present (e.g., "Sheet1!$A$2:$A$6" -> "$A$2:$A$6")
                        if '!' in range_str:
                            range_str = range_str.split('!')[1]
                        
                        # Remove $ signs
                        range_str = range_str.replace('$', '')
                        
                        if ':' in range_str:
                            start, end = range_str.split(':')
                            # Parse start and end coordinates
                            start_col, start_row = coordinate_to_tuple(start)
                            end_col, end_row = coordinate_to_tuple(end)
                            
                            # Calculate count based on range
                            if start_col == end_col:
                                # Same column, count rows
                                return abs(end_row - start_row) + 1
                            elif start_row == end_row:
                                # Same row, count columns
                                return abs(end_col - start_col) + 1
                            else:
                                # 2D range
                                return (abs(end_row - start_row) + 1) * (abs(end_col - start_col) + 1)
                        else:
                            # Single cell
                            return 1
                    except Exception as e:
                        logger.debug(f"Error parsing range {range_str}: {e}")
                        return 0
                
                for i, ser in enumerate(all_series):
                    try:
                        # Try to get category count from category reference
                        if hasattr(ser, 'cat'):
                            cat_range = None
                            # Check if categories are from a range
                            if hasattr(ser.cat, 'numRef') and hasattr(ser.cat.numRef, 'f'):
                                cat_range = ser.cat.numRef.f
                            elif hasattr(ser.cat, 'strRef') and hasattr(ser.cat.strRef, 'f'):
                                cat_range = ser.cat.strRef.f
                            
                            if cat_range:
                                category_ranges.append(cat_range)
                                cat_count = parse_range_count(cat_range)
                                if cat_count > max_categories:
                                    max_categories = cat_count
                                logger.debug(f"Series {i} category range: {cat_range}, count: {cat_count}")
                    except Exception as e:
                        logger.debug(f"Error reading categories for series {i}: {e}")
                
                if max_categories > 0:
                    logger.info(f"Maximum category count found: {max_categories}")
                    if max_categories < min_categories:
                        logger.error(f"✗ Chart has only {max_categories} categories, expected at least {min_categories} (project_count * quarters_per_project)")
                        return 0.0
                    logger.info(f"✓ Chart has {max_categories} categories (>= {min_categories})")
                else:
                    # If we can't determine category count from ranges, use heuristic
                    # For 8 projects with 5 quarters each, we need at least 40 categories
                    # But since we can't verify directly, we'll log a warning
                    logger.warning(f"⚠ Could not determine exact category count from ranges. Expected at least {min_categories} categories.")
                    logger.info(f"Category ranges found: {category_ranges[:5]}...")  # Log first 5
                
                # Check if it's a combination chart
                if series_count >= 2:
                    logger.info("✓ Chart appears to be a combination chart (has multiple series)")
                else:
                    logger.error(f"✗ Chart has only {series_count} series, expected at least 2 for combination chart")
                    return 0.0
                
                break
        
        if chart_found:
            logger.info("=" * 60)
            logger.info("✓ Project completion combination chart verification passed")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ Chart with title '{expected_title}' not found")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_shipping_boxes_calculation(result: str, expected: str = None, **options) -> float:
    """
    Verify if formulas exist to calculate shipping boxes from product specifications and order quantities.
    
    This function checks:
    1. Whether cells in specified column contain formulas (not just values)
    2. Whether formulas contain required functions: INT, VALUE, LEFT, FIND, MOD, IF
    3. Whether formulas reference the specification column (B) and quantity column (C)
    4. Whether formulas contain Chinese characters "支" and "盒"
    5. Whether formulas use string concatenation (&)
    
    The expected formula pattern:
    =INT(C2/VALUE(LEFT(B2,FIND("支",B2)-1)))&"盒"&IF(MOD(C2,VALUE(LEFT(B2,FIND("支",B2)-1)))=0,"","加"&MOD(C2,VALUE(LEFT(B2,FIND("支",B2)-1)))&"支")
    
    The function automatically detects the number of data rows by checking the data column
    for non-empty cells. It stops checking after finding 3 consecutive empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_column: Column to check (e.g., "D")
            - start_row: Starting row number (default: 2)
            - spec_column: Column containing product specifications (e.g., "B")
            - quantity_column: Column containing order quantities (e.g., "C")
            - expected_functions: List of expected function names (e.g., ["INT", "VALUE", "LEFT", "FIND", "MOD", "IF"])
            - data_column: Column to check for data to determine end_row (default: "B")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_column = options.get('check_column', 'D')
        start_row = options.get('start_row', 2)
        spec_column = options.get('spec_column', 'B')
        quantity_column = options.get('quantity_column', 'C')
        expected_functions = options.get('expected_functions', ['INT', 'VALUE', 'LEFT', 'FIND', 'MOD', 'IF'])
        data_column = options.get('data_column', 'B')
        
        logger.info(f"Verifying shipping boxes calculation formulas in file: {result}")
        logger.info(f"Column to check: {check_column}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Specification column: {spec_column}")
        logger.info(f"Quantity column: {quantity_column}")
        logger.info(f"Expected functions: {expected_functions}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row  # Start from start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        if end_row < start_row:
            logger.error(f"No data rows found starting from row {start_row}")
            return 0.0
        
        # Check formulas in each row
        all_checks_passed = True
        rows_checked = 0
        
        for row_num in range(start_row, end_row + 1):
            check_cell = ws[f"{check_column}{row_num}"]
            spec_cell = ws[f"{spec_column}{row_num}"]
            quantity_cell = ws[f"{quantity_column}{row_num}"]
            
            # Skip if spec or quantity cell is empty
            if spec_cell.value is None or quantity_cell.value is None:
                continue
            
            rows_checked += 1
            formula = check_cell.value
            
            # Check 1: Formula exists (not just a value)
            if formula is None or not isinstance(formula, str) or not formula.startswith('='):
                logger.error(f"Cell {check_column}{row_num} should contain a formula, but got: {formula}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Row {row_num} formula: {formula}")
            
            # Check 2: Contains all required functions
            missing_functions = []
            for func in expected_functions:
                # Check for function name (with word boundary to avoid partial matches)
                func_pattern = r'\b' + re.escape(func) + r'\s*\('
                if not re.search(func_pattern, formula_upper, re.IGNORECASE):
                    missing_functions.append(func)
            
            if missing_functions:
                logger.error(f"Cell {check_column}{row_num} formula missing functions: {missing_functions}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: References specification column (B)
            spec_pattern = rf'{spec_column}\d+'
            if not re.search(spec_pattern, formula_upper):
                logger.error(f"Cell {check_column}{row_num} formula should reference {spec_column} column")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: References quantity column (C)
            quantity_pattern = rf'{quantity_column}\d+'
            if not re.search(quantity_pattern, formula_upper):
                logger.error(f"Cell {check_column}{row_num} formula should reference {quantity_column} column")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 5: Contains Chinese character "支" (for extracting pieces per box)
            if '"支"' not in formula and "'支'" not in formula and '支' not in formula:
                logger.error(f"Cell {check_column}{row_num} formula should contain '支' character")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 6: Contains Chinese character "盒" (for box unit)
            if '"盒"' not in formula and "'盒'" not in formula and '盒' not in formula:
                logger.error(f"Cell {check_column}{row_num} formula should contain '盒' character")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 7: Uses string concatenation (&)
            if '&' not in formula:
                logger.error(f"Cell {check_column}{row_num} formula should use & for string concatenation")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 8: Contains INT function (for calculating integer boxes)
            int_pattern = r'\bINT\s*\('
            if not re.search(int_pattern, formula_upper):
                logger.error(f"Cell {check_column}{row_num} formula should contain INT function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 9: Contains MOD function (for calculating remainder)
            mod_pattern = r'\bMOD\s*\('
            if not re.search(mod_pattern, formula_upper):
                logger.error(f"Cell {check_column}{row_num} formula should contain MOD function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 10: Contains IF function (for conditional formatting)
            if_pattern = r'\bIF\s*\('
            if not re.search(if_pattern, formula_upper):
                logger.error(f"Cell {check_column}{row_num} formula should contain IF function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            logger.debug(f"✓ Row {row_num} formula passed all checks")
        
        if rows_checked == 0:
            logger.error("No rows with data found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ Shipping boxes calculation verification passed")
            logger.info(f"  Rows checked: {rows_checked}")
            logger.info(f"  Column: {check_column}")
            logger.info(f"  Functions verified: {', '.join(expected_functions)}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ Shipping boxes calculation verification failed")
            logger.error(f"  Rows checked: {rows_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_split_content_formula(result: str, expected: str = None, **options) -> float:
    """
    Verify if formulas exist to split content with line breaks into multiple rows.
    
    This function checks:
    1. Whether cells in specified column contain formulas (not just values)
    2. Whether formulas contain required functions: TRIM, MID, SUBSTITUTE, CHAR, REPT, ROW
    3. Whether formulas reference the source column (A)
    4. Whether formulas contain CHAR(10) for line break
    5. Whether formulas contain REPT(" ",100) or similar pattern
    6. Whether formulas use ROW function for position calculation
    
    The expected formula pattern:
    =TRIM(MID(SUBSTITUTE(A2,CHAR(10),REPT(" ",100)),(ROW(A1)-1)*100+1,100))
    
    The function automatically detects the number of data rows by checking the data column
    for non-empty cells. It stops checking after finding 3 consecutive empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_column: Column to check (e.g., "B")
            - start_row: Starting row number (default: 2)
            - source_column: Column containing source data (e.g., "A")
            - expected_functions: List of expected function names (e.g., ["TRIM", "MID", "SUBSTITUTE", "CHAR", "REPT", "ROW"])
            - data_column: Column to check for data to determine end_row (default: "A")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_column = options.get('check_column', 'B')
        start_row = options.get('start_row', 2)
        source_column = options.get('source_column', 'A')
        expected_functions = options.get('expected_functions', ['TRIM', 'MID', 'SUBSTITUTE', 'CHAR', 'REPT', 'ROW'])
        data_column = options.get('data_column', 'A')
        
        logger.info(f"Verifying split content formulas in file: {result}")
        logger.info(f"Column to check: {check_column}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Source column: {source_column}")
        logger.info(f"Expected functions: {expected_functions}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row  # Start from start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        if end_row < start_row:
            logger.error(f"No data rows found starting from row {start_row}")
            return 0.0
        
        # Check formulas in each row
        all_checks_passed = True
        rows_checked = 0
        
        for row_num in range(start_row, end_row + 1):
            check_cell = ws[f"{check_column}{row_num}"]
            
            # Skip if source cell is empty
            source_cell = ws[f"{source_column}{row_num}"]
            if source_cell.value is None:
                continue
            
            rows_checked += 1
            formula = check_cell.value
            
            # Check 1: Formula exists (not just a value)
            if formula is None or not isinstance(formula, str) or not formula.startswith('='):
                logger.error(f"Cell {check_column}{row_num} should contain a formula, but got: {formula}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Row {row_num} formula: {formula}")
            
            # Check 2: Contains all required functions
            missing_functions = []
            for func in expected_functions:
                # Check for function name (with word boundary to avoid partial matches)
                func_pattern = r'\b' + re.escape(func) + r'\s*\('
                if not re.search(func_pattern, formula_upper, re.IGNORECASE):
                    missing_functions.append(func)
            
            if missing_functions:
                logger.error(f"Cell {check_column}{row_num} formula missing functions: {missing_functions}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: References source column (A)
            source_pattern = rf'{source_column}\d+'
            if not re.search(source_pattern, formula_upper):
                logger.error(f"Cell {check_column}{row_num} formula should reference {source_column} column")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3.5: SUBSTITUTE function must reference A2 specifically
            # Pattern: SUBSTITUTE(A2,...
            substitute_a2_pattern = rf'SUBSTITUTE\s*\(\s*{source_column}2\s*,'
            if not re.search(substitute_a2_pattern, formula_upper):
                logger.error(f"Cell {check_column}{row_num} formula SUBSTITUTE function must reference {source_column}2 (not {source_column}3, {source_column}4, etc.)")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Contains CHAR(10) for line break
            char_pattern = r'CHAR\s*\(\s*10\s*\)'
            if not re.search(char_pattern, formula_upper):
                logger.error(f"Cell {check_column}{row_num} formula should contain CHAR(10)")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 5: Contains REPT with space and 100
            rept_pattern = r'REPT\s*\(\s*["\']?\s*["\']?\s*,\s*100\s*\)'
            if not re.search(rept_pattern, formula_upper):
                logger.error(f"Cell {check_column}{row_num} formula should contain REPT(\" \",100) or similar")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 6: Contains ROW function
            row_pattern = r'\bROW\s*\('
            if not re.search(row_pattern, formula_upper):
                logger.error(f"Cell {check_column}{row_num} formula should contain ROW function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 7: Contains TRIM function (outermost)
            trim_pattern = r'\bTRIM\s*\('
            if not re.search(trim_pattern, formula_upper):
                logger.error(f"Cell {check_column}{row_num} formula should contain TRIM function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 8: Contains MID function
            mid_pattern = r'\bMID\s*\('
            if not re.search(mid_pattern, formula_upper):
                logger.error(f"Cell {check_column}{row_num} formula should contain MID function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 9: Contains SUBSTITUTE function
            substitute_pattern = r'\bSUBSTITUTE\s*\('
            if not re.search(substitute_pattern, formula_upper):
                logger.error(f"Cell {check_column}{row_num} formula should contain SUBSTITUTE function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            logger.debug(f"✓ Row {row_num} formula passed all checks")
        
        if rows_checked == 0:
            logger.error("No rows with data found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ Split content formula verification passed")
            logger.info(f"  Rows checked: {rows_checked}")
            logger.info(f"  Column: {check_column}")
            logger.info(f"  Functions verified: {', '.join(expected_functions)}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ Split content formula verification failed")
            logger.error(f"  Rows checked: {rows_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_quote_sheet_with_merged_cells(result: str, expected: str = None, **options) -> float:
    """
    Verify if a quote sheet template exists with the expected structure, fields, and merged cells.
    
    This function checks:
    1. Whether the title "报价单" exists in the worksheet
    2. Whether merged cells exist (especially for the title)
    3. Whether required header fields exist
    4. Whether the product table headers exist
    5. Whether summary fields exist
    6. Whether footer fields exist
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - expected_title: Expected title text (default: "报价单")
            - title_merged_range: Expected merged range for title (default: "G15:H15")
            - required_fields: List of required header field labels
            - table_headers: List of table header labels
            - summary_fields: List of summary field labels
            - footer_fields: List of footer field labels
            - min_merged_cells: Minimum number of merged cell ranges expected (default: 1)
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        expected_title = options.get('expected_title', '报价单')
        title_merged_range = options.get('title_merged_range', 'G15:H15')
        required_fields = options.get('required_fields', ['报价单位', '联系人', '联系电话', '客户名称', '报价日期', '邮箱'])
        table_headers = options.get('table_headers', ['序号', '产品名称', '产品类型', '规格', '数量', '单价', '金额', '备注'])
        summary_fields = options.get('summary_fields', ['合计金额(小写)', '合计金额(大写)'])
        footer_fields = options.get('footer_fields', ['报价人', '审批'])
        min_merged_cells = options.get('min_merged_cells', 1)
        
        logger.info(f"Verifying quote sheet template with merged cells in file: {result}")
        logger.info(f"Expected title: {expected_title}")
        logger.info(f"Title merged range: {title_merged_range}")
        logger.info(f"Required fields: {required_fields}")
        logger.info(f"Table headers: {table_headers}")
        logger.info(f"Summary fields: {summary_fields}")
        logger.info(f"Footer fields: {footer_fields}")
        logger.info(f"Minimum merged cells: {min_merged_cells}")
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=True)
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check merged cells
        merged_cells = list(ws.merged_cells.ranges)
        logger.info(f"Found {len(merged_cells)} merged cell range(s)")
        
        if len(merged_cells) < min_merged_cells:
            logger.error(f"✗ Insufficient merged cells: found {len(merged_cells)}, expected at least {min_merged_cells}")
            return 0.0
        
        # Check if title merged range exists
        title_merged_found = False
        for merged_range in merged_cells:
            merged_str = str(merged_range)
            logger.debug(f"Merged range: {merged_str}")
            if merged_str.upper() == title_merged_range.upper():
                title_merged_found = True
                logger.info(f"✓ Found title merged range: {merged_str}")
                break
        
        if not title_merged_found:
            logger.warning(f"⚠ Title merged range '{title_merged_range}' not found, but other merged cells exist")
            logger.info(f"  Available merged ranges: {[str(r) for r in merged_cells]}")
            # Don't fail completely, as the range might be slightly different
        
        # Search through all cells to find required text
        # Also check merged cells specifically
        max_row = ws.max_row
        max_col = ws.max_column
        
        # Convert all cell values to strings for searching
        # Include both individual cells and merged cell ranges
        all_text = []
        cell_text_map = {}  # Map cell coordinates to text for debugging
        
        for row in ws.iter_rows(min_row=1, max_row=max_row, min_col=1, max_col=max_col, values_only=False):
            for cell in row:
                if cell.value is not None:
                    cell_text = str(cell.value).strip()
                    all_text.append(cell_text)
                    cell_coord = cell.coordinate
                    cell_text_map[cell_coord] = cell_text
                    
                    # Also check if cell contains newlines (for merged cells with multiple fields)
                    if '\n' in cell_text or '\r' in cell_text:
                        # Split by newlines and add each line
                        lines = cell_text.replace('\r', '\n').split('\n')
                        for line in lines:
                            line = line.strip()
                            if line:
                                all_text.append(line)
        
        # Check merged cells - get text from the top-left cell of each merged range
        for merged_range in merged_cells:
            try:
                # Get the top-left cell of the merged range
                top_left_cell = ws[merged_range.min_row][merged_range.min_col - 1]
                if top_left_cell.value is not None:
                    merged_text = str(top_left_cell.value).strip()
                    all_text.append(merged_text)
                    # Also split by newlines if present
                    if '\n' in merged_text or '\r' in merged_text:
                        lines = merged_text.replace('\r', '\n').split('\n')
                        for line in lines:
                            line = line.strip()
                            if line:
                                all_text.append(line)
                    logger.debug(f"Merged range {merged_range} contains text: {merged_text[:100]}")
            except Exception as e:
                logger.debug(f"Error reading merged range {merged_range}: {e}")
        
        # Check 1: Title exists
        title_found = False
        for text in all_text:
            if expected_title in text:
                title_found = True
                logger.info(f"✓ Found title: {expected_title}")
                break
        
        if not title_found:
            logger.error(f"✗ Title '{expected_title}' not found")
            return 0.0
        
        # Check 2: Required header fields
        # Since fields may be in merged cells together, we need to check if all fields exist
        # even if they're in the same cell
        found_fields = []
        missing_fields = []
        for field in required_fields:
            field_found = False
            for text in all_text:
                if field in text:
                    field_found = True
                    found_fields.append(field)
                    logger.debug(f"Found field '{field}' in text: {text[:80]}...")
                    break
            if not field_found:
                missing_fields.append(field)
        
        # Log all text for debugging if fields are missing
        if missing_fields:
            logger.warning(f"⚠ Missing required fields: {missing_fields}")
            # Show some sample text that might contain the fields
            logger.debug(f"Sample text from worksheet (showing text with Chinese characters):")
            chinese_text_samples = [t for t in all_text if any('\u4e00' <= c <= '\u9fff' for c in t)][:20]
            for sample in chinese_text_samples:
                logger.debug(f"  {sample[:100]}")
        
        # Since fields may be grouped in merged cells, we're more lenient
        # Check if at least most fields are found
        found_ratio = len(found_fields) / len(required_fields) if required_fields else 1.0
        
        if found_ratio < 0.5:  # Less than 50% found
            logger.error(f"✗ Too many required fields missing: found {len(found_fields)}/{len(required_fields)}")
            logger.error(f"  Missing: {missing_fields}")
            return 0.0
        elif missing_fields:
            logger.warning(f"⚠ Some fields missing: {missing_fields}, but found {len(found_fields)}/{len(required_fields)} fields")
            # Don't fail if most fields are found (fields might be in merged cells together)
        else:
            logger.info(f"✓ Found all required fields: {found_fields}")
        
        # Check 3: Table headers
        found_headers = []
        missing_headers = []
        for header in table_headers:
            header_found = False
            for text in all_text:
                if header in text:
                    header_found = True
                    found_headers.append(header)
                    break
            if not header_found:
                missing_headers.append(header)
        
        if missing_headers:
            logger.error(f"✗ Missing table headers: {missing_headers}")
            return 0.0
        else:
            logger.info(f"✓ Found all table headers: {found_headers}")
        
        # Check 4: Summary fields
        found_summary = []
        missing_summary = []
        for field in summary_fields:
            field_found = False
            for text in all_text:
                if field in text:
                    field_found = True
                    found_summary.append(field)
                    break
            if not field_found:
                missing_summary.append(field)
        
        if missing_summary:
            logger.warning(f"⚠ Missing summary fields: {missing_summary}")
            # Don't fail completely, as these might be optional
        else:
            logger.info(f"✓ Found summary fields: {found_summary}")
        
        # Check 5: Footer fields
        found_footer = []
        missing_footer = []
        for field in footer_fields:
            field_found = False
            for text in all_text:
                if field in text:
                    field_found = True
                    found_footer.append(field)
                    break
            if not field_found:
                missing_footer.append(field)
        
        if missing_footer:
            logger.warning(f"⚠ Missing footer fields: {missing_footer}")
            # Don't fail completely, as these might be optional
        else:
            logger.info(f"✓ Found footer fields: {found_footer}")
        
        # Check 6: Borders on table cells
        # Check if cells in the product table area have borders
        # Typically, table headers and data rows should have borders
        logger.info("Checking borders on table cells...")
        
        # Find the table header row (should contain table headers)
        table_header_row = None
        for row_num in range(1, max_row + 1):
            for col_num in range(1, max_col + 1):
                cell = ws.cell(row=row_num, column=col_num)
                if cell.value is not None:
                    cell_text = str(cell.value).strip()
                    # Check if this row contains table headers
                    if any(header in cell_text for header in table_headers):
                        table_header_row = row_num
                        break
            if table_header_row:
                break
        
        borders_found = False
        cells_with_borders = 0
        total_table_cells_checked = 0
        
        if table_header_row:
            logger.info(f"Table header row found at row {table_header_row}")
            # Check borders in table area (header row and a few data rows)
            # Table typically spans from column C to K (based on headers)
            check_start_col = 3  # Column C
            check_end_col = min(11, max_col)  # Column K or max_col
            check_start_row = table_header_row
            check_end_row = min(table_header_row + 7, max_row)  # Header + 6 data rows
            
            for row_num in range(check_start_row, check_end_row + 1):
                for col_num in range(check_start_col, check_end_col + 1):
                    cell = ws.cell(row=row_num, column=col_num)
                    total_table_cells_checked += 1
                    
                    # Check if cell has any border
                    has_border = False
                    try:
                        border = cell.border
                        # Check if any side has a border style (not None and not empty)
                        if border:
                            if (border.top and border.top.style) or \
                               (border.bottom and border.bottom.style) or \
                               (border.left and border.left.style) or \
                               (border.right and border.right.style):
                                has_border = True
                                cells_with_borders += 1
                    except Exception as e:
                        logger.debug(f"Error checking border for cell {cell.coordinate}: {e}")
                    
                    if has_border:
                        borders_found = True
                        logger.debug(f"Cell {cell.coordinate} has borders")
            
            if total_table_cells_checked > 0:
                border_ratio = cells_with_borders / total_table_cells_checked
                logger.info(f"Borders found: {cells_with_borders}/{total_table_cells_checked} cells ({border_ratio:.1%})")
                
                # Require at least 30% of table cells to have borders
                if border_ratio < 0.3:
                    logger.warning(f"⚠ Low border coverage: only {border_ratio:.1%} of table cells have borders")
                    # Don't fail completely, as borders might be applied differently
                else:
                    logger.info(f"✓ Sufficient borders found in table area")
            else:
                logger.warning("⚠ Could not check borders: no table cells found")
        else:
            logger.warning("⚠ Could not find table header row for border checking")
        
        # If we get here, all critical checks passed
        logger.info("=" * 60)
        logger.info(f"✓ Quote sheet template with merged cells verification passed")
        logger.info(f"  Title: {expected_title}")
        logger.info(f"  Merged cells: {len(merged_cells)} (minimum required: {min_merged_cells})")
        if title_merged_found:
            logger.info(f"  Title merged range: {title_merged_range}")
        logger.info(f"  Required fields: {len(found_fields)}/{len(required_fields)}")
        logger.info(f"  Table headers: {len(found_headers)}/{len(table_headers)}")
        logger.info(f"  Summary fields: {len(found_summary)}/{len(summary_fields)}")
        logger.info(f"  Footer fields: {len(found_footer)}/{len(footer_fields)}")
        if borders_found:
            logger.info(f"  Borders: {cells_with_borders}/{total_table_cells_checked} cells have borders")
        logger.info("=" * 60)
        return 1.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_nested_regex_price_extract(result: str, expected: str = None, **options) -> float:
    """
    Verify if nested REGEX(REGEX(SUBSTITUTE(...))) formulas exist to extract prices from inconsistently formatted text.
    
    This function checks:
    1. Whether cells in specified column contain nested REGEX functions
    2. Whether formulas contain SUBSTITUTE function to remove spaces
    3. Whether inner REGEX function uses pattern to replace Chinese punctuation with dots
    4. Whether outer REGEX function extracts numeric values with pattern [\d.]+
    5. Whether formulas reference the corresponding source column cell (A1, A2, A3, etc.)
    
    Expected formula pattern: =REGEX(REGEX(SUBSTITUTE(A1," ",),"[-，。]",2,"."),"[\d.]+")
    
    The function automatically detects the number of data rows by checking the data column
    for non-empty cells. It stops checking after finding 3 consecutive empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_column: Column to check (e.g., "B")
            - start_row: Starting row number (default: 1)
            - source_column: Column containing source data (e.g., "A")
            - expected_functions: List of expected function names (default: ["REGEX", "SUBSTITUTE"])
            - data_column: Column to check for data to determine end_row (default: "A")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_column = options.get('check_column', 'B')
        start_row = options.get('start_row', 1)
        source_column = options.get('source_column', 'A')
        expected_functions = options.get('expected_functions', ['REGEX', 'SUBSTITUTE'])
        data_column = options.get('data_column', 'A')
        
        logger.info(f"Verifying nested REGEX price extraction formulas in file: {result}")
        logger.info(f"Column to check: {check_column}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Source column: {source_column}")
        logger.info(f"Expected functions: {expected_functions}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Check each row
        all_checks_passed = True
        rows_checked = 0
        
        for row_num in range(start_row, end_row + 1):
            check_cell = ws[f"{check_column}{row_num}"]
            source_cell = ws[f"{source_column}{row_num}"]
            
            # Skip if source cell is empty
            if source_cell.value is None:
                continue
            
            rows_checked += 1
            formula = check_cell.value
            
            # Check 1: Formula exists (not just a value)
            if formula is None or not isinstance(formula, str) or not formula.startswith('='):
                logger.error(f"Cell {check_column}{row_num} should contain a formula, but got: {formula}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Row {row_num} formula: {formula}")
            
            # Check 2: Contains all required functions
            missing_functions = []
            for func in expected_functions:
                # Check for function name (with word boundary to avoid partial matches)
                func_pattern = r'\b' + re.escape(func) + r'\s*\('
                if not re.search(func_pattern, formula_upper, re.IGNORECASE):
                    missing_functions.append(func)
            
            if missing_functions:
                logger.error(f"Cell {check_column}{row_num} formula missing functions: {missing_functions}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains nested REGEX functions (at least 2 REGEX calls)
            regex_count = len(re.findall(r'\bREGEX\s*\(', formula_upper, re.IGNORECASE))
            if regex_count < 2:
                logger.error(f"Cell {check_column}{row_num} formula should contain at least 2 nested REGEX functions")
                logger.error(f"  Formula: {formula}")
                logger.error(f"  Found {regex_count} REGEX function(s)")
                all_checks_passed = False
                continue
            
            # Check 4: Contains SUBSTITUTE function
            substitute_pattern = r'\bSUBSTITUTE\s*\('
            if not re.search(substitute_pattern, formula_upper, re.IGNORECASE):
                logger.error(f"Cell {check_column}{row_num} formula should contain SUBSTITUTE function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 5: SUBSTITUTE function references source column and removes spaces
            # Pattern: SUBSTITUTE(A1," ",) or SUBSTITUTE(A1," ","")
            substitute_pattern = rf'SUBSTITUTE\s*\(\s*{source_column}{row_num}\s*,\s*["\']?\s*["\']?\s*,'
            if not re.search(substitute_pattern, formula_upper, re.IGNORECASE):
                logger.error(f"Cell {check_column}{row_num} SUBSTITUTE should reference {source_column}{row_num} and remove spaces")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 6: Inner REGEX function contains pattern to replace Chinese punctuation
            # Pattern should contain something like "[-，。]" or similar Chinese punctuation
            # and replacement pattern like "2,"." or "2,\"."
            inner_regex_pattern = r'REGEX\s*\([^)]*["\']?[-，。，。、]["\']?\s*,\s*\d+\s*,\s*["\']?\.["\']?'
            if not re.search(inner_regex_pattern, formula_upper, re.IGNORECASE):
                logger.warning(f"Cell {check_column}{row_num} inner REGEX may not have correct pattern for replacing Chinese punctuation")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the pattern might be correct but formatted differently
            
            # Check 7: Outer REGEX function contains pattern to extract numbers
            # Pattern should contain [\d.]+ or similar
            outer_regex_pattern = r'REGEX\s*\([^)]*["\']?\[\\?d\.\]\+["\']?'
            if not re.search(outer_regex_pattern, formula_upper, re.IGNORECASE):
                # Also check for unescaped version
                if not re.search(r'REGEX\s*\([^)]*\[.*d.*\.?.*\]', formula_upper, re.IGNORECASE):
                    logger.warning(f"Cell {check_column}{row_num} outer REGEX may not have correct pattern [\\d.]+")
                    logger.debug(f"  Formula: {formula}")
                    # Don't fail, just warn
            
            # Check 8: Formula references the corresponding source column cell
            source_pattern = rf'{source_column}{row_num}\b'
            if not re.search(source_pattern, formula_upper):
                logger.error(f"Cell {check_column}{row_num} formula should reference {source_column}{row_num}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            logger.debug(f"✓ Row {row_num} formula passed all checks")
        
        if rows_checked == 0:
            logger.error("No rows with data found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ Nested REGEX price extraction verification passed")
            logger.info(f"  Rows checked: {rows_checked}")
            logger.info(f"  Column: {check_column}")
            logger.info(f"  Functions verified: {', '.join(expected_functions)}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ Nested REGEX price extraction verification failed")
            logger.error(f"  Rows checked: {rows_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_text_datetime_format(result: str, expected: str = None, **options) -> float:
    """
    Verify if TEXT formulas exist to convert numbers to datetime format.
    
    This function checks:
    1. Whether cells in specified column contain TEXT formulas
    2. Whether formulas use TEXT function with datetime format pattern "0-00-00 00:00:00"
    3. Whether formulas reference the corresponding source column cell (A2, A3, etc.)
    
    Expected formula pattern: =TEXT(A2,"0-00-00 00:00:00")
    
    The function automatically detects the number of data rows by checking the data column
    for non-empty cells. It stops checking after finding 3 consecutive empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_column: Column to check (e.g., "C")
            - start_row: Starting row number (default: 2)
            - source_column: Column containing source data (e.g., "A")
            - expected_functions: List of expected function names (default: ["TEXT"])
            - expected_format: Expected TEXT format pattern (default: "0-00-00 00:00:00")
            - data_column: Column to check for data to determine end_row (default: "A")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_column = options.get('check_column', 'C')
        start_row = options.get('start_row', 2)
        source_column = options.get('source_column', 'A')
        expected_functions = options.get('expected_functions', ['TEXT'])
        expected_format = options.get('expected_format', '0-00-00 00:00:00')
        data_column = options.get('data_column', 'A')
        
        logger.info(f"Verifying TEXT datetime format formulas in file: {result}")
        logger.info(f"Column to check: {check_column}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Source column: {source_column}")
        logger.info(f"Expected functions: {expected_functions}")
        logger.info(f"Expected format: {expected_format}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Check each row
        all_checks_passed = True
        rows_checked = 0
        
        for row_num in range(start_row, end_row + 1):
            check_cell = ws[f"{check_column}{row_num}"]
            source_cell = ws[f"{source_column}{row_num}"]
            
            # Skip if source cell is empty
            if source_cell.value is None:
                continue
            
            rows_checked += 1
            
            # Check 1: Cell contains a formula
            if check_cell.data_type != "f":
                logger.error(f"Cell {check_column}{row_num} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(check_cell, "_value") and isinstance(check_cell._value, str) and check_cell._value.startswith("="):
                formula = check_cell._value
            elif hasattr(check_cell, "formula"):
                formula = check_cell.formula
            else:
                # Try to get from value attribute
                if check_cell.value is not None and isinstance(check_cell.value, str) and check_cell.value.startswith("="):
                    formula = check_cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {check_column}{row_num}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Row {row_num} formula: {formula}")
            
            # Check 2: Contains TEXT function
            if 'TEXT' not in formula_upper:
                logger.error(f"Cell {check_column}{row_num} formula should contain TEXT function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: TEXT function contains the expected format pattern
            # Pattern: TEXT(A2,"0-00-00 00:00:00") or TEXT(A2,'0-00-00 00:00:00')
            # Escape special characters in format pattern for regex
            format_escaped = re.escape(expected_format)
            text_format_pattern1 = rf'TEXT\s*\([^,]+,\s*"{format_escaped}"'
            text_format_pattern2 = rf"TEXT\s*\([^,]+,\s*'{format_escaped}'"
            if not re.search(text_format_pattern1, formula, re.IGNORECASE) and \
               not re.search(text_format_pattern2, formula, re.IGNORECASE):
                logger.error(f"Cell {check_column}{row_num} TEXT function should use format \"{expected_format}\"")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Formula references the corresponding source column cell
            source_pattern = rf'{source_column}{row_num}\b'
            if not re.search(source_pattern, formula_upper):
                logger.error(f"Cell {check_column}{row_num} formula should reference {source_column}{row_num}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            logger.debug(f"✓ Row {row_num} formula passed all checks")
        
        if rows_checked == 0:
            logger.error("No rows with data found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ TEXT datetime format verification passed")
            logger.info(f"  Rows checked: {rows_checked}")
            logger.info(f"  Column: {check_column}")
            logger.info(f"  Format: {expected_format}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ TEXT datetime format verification failed")
            logger.error(f"  Rows checked: {rows_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_if_counta_payment_receipt_numbering(result: str, expected: str = None, **options) -> float:
    """
    Verify if IF(COUNTA(...)) formulas exist to auto-generate payment/receipt numbering.
    
    This function checks:
    1. Whether cells in specified column contain IF formulas
    2. Whether formulas contain required functions: IF, COUNTA
    3. Whether formulas check if payment column (C) is empty
    4. Whether formulas use COUNTA to count receipt column (C) or payment column (D)
    5. Whether formulas generate "收" or "付" prefixed numbers
    6. Whether formulas reference the correct ranges ($C$2:C2 and $D$2:D2)
    
    Expected formula pattern: =IF(C2="","付"&COUNTA($D$2:D2),"收"&COUNTA($C$2:C2))
    
    The function automatically detects the number of data rows by checking the data column
    for non-empty cells. It stops checking after finding 3 consecutive empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_column: Column to check (e.g., "A")
            - start_row: Starting row number (default: 2)
            - receipt_column: Column containing receipt amounts (e.g., "C")
            - payment_column: Column containing payment amounts (e.g., "D")
            - expected_functions: List of expected function names (default: ["IF", "COUNTA"])
            - receipt_prefix: Prefix for receipt numbers (default: "收")
            - payment_prefix: Prefix for payment numbers (default: "付")
            - data_column: Column to check for data to determine end_row (default: "A")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_column = options.get('check_column', 'A')
        start_row = options.get('start_row', 2)
        receipt_column = options.get('receipt_column', 'C')
        payment_column = options.get('payment_column', 'D')
        expected_functions = options.get('expected_functions', ['IF', 'COUNTA'])
        receipt_prefix = options.get('receipt_prefix', '收')
        payment_prefix = options.get('payment_prefix', '付')
        data_column = options.get('data_column', 'A')
        
        logger.info(f"Verifying IF/COUNTA payment/receipt numbering formulas in file: {result}")
        logger.info(f"Column to check: {check_column}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Receipt column: {receipt_column}")
        logger.info(f"Payment column: {payment_column}")
        logger.info(f"Expected functions: {expected_functions}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Check each row
        all_checks_passed = True
        rows_checked = 0
        
        for row_num in range(start_row, end_row + 1):
            check_cell = ws[f"{check_column}{row_num}"]
            
            # Skip if cell is empty
            if check_cell.value is None:
                continue
            
            rows_checked += 1
            
            # Check if cell contains a formula
            if check_cell.data_type != "f":
                logger.error(f"Cell {check_column}{row_num} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(check_cell, "_value") and isinstance(check_cell._value, str) and check_cell._value.startswith("="):
                formula = check_cell._value
            elif hasattr(check_cell, "formula"):
                formula = check_cell.formula
            else:
                # Try to get from value attribute
                if check_cell.value is not None and isinstance(check_cell.value, str) and check_cell.value.startswith("="):
                    formula = check_cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {check_column}{row_num}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Row {row_num} formula: {formula}")
            
            # Check 1: Contains all required functions
            missing_functions = []
            for func in expected_functions:
                # Check for function name (with word boundary to avoid partial matches)
                func_pattern = r'\b' + re.escape(func) + r'\s*\('
                if not re.search(func_pattern, formula_upper, re.IGNORECASE):
                    missing_functions.append(func)
            
            if missing_functions:
                logger.error(f"Cell {check_column}{row_num} formula missing functions: {missing_functions}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: Formula structure - IF(...)
            if_pattern = r'IF\s*\('
            if not re.search(if_pattern, formula_upper, re.IGNORECASE):
                logger.error(f"Cell {check_column}{row_num} formula should contain IF function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: IF condition checks if receipt column is empty (C2="")
            # Pattern: IF(C2="",... or IF(C2="",...
            if_condition_pattern = rf'IF\s*\(\s*{receipt_column}{row_num}\s*=\s*["\']?\s*["\']?'
            if not re.search(if_condition_pattern, formula_upper, re.IGNORECASE):
                logger.error(f"Cell {check_column}{row_num} IF should check if {receipt_column}{row_num} is empty")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Formula contains COUNTA with payment column range ($D$2:D2)
            # Pattern: COUNTA($D$2:D2) or COUNTA($D$2:D{row_num})
            payment_counta_pattern = rf'COUNTA\s*\(\s*\${payment_column}\$\d+:\s*{payment_column}{row_num}\s*\)'
            if not re.search(payment_counta_pattern, formula_upper, re.IGNORECASE):
                logger.error(f"Cell {check_column}{row_num} should contain COUNTA(${payment_column}$2:{payment_column}{row_num})")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 5: Formula contains COUNTA with receipt column range ($C$2:C2)
            # Pattern: COUNTA($C$2:C2) or COUNTA($C$2:C{row_num})
            receipt_counta_pattern = rf'COUNTA\s*\(\s*\${receipt_column}\$\d+:\s*{receipt_column}{row_num}\s*\)'
            if not re.search(receipt_counta_pattern, formula_upper, re.IGNORECASE):
                logger.error(f"Cell {check_column}{row_num} should contain COUNTA(${receipt_column}$2:{receipt_column}{row_num})")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 6: Formula contains payment prefix (付)
            if payment_prefix not in formula:
                logger.error(f"Cell {check_column}{row_num} formula should contain payment prefix '{payment_prefix}'")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 7: Formula contains receipt prefix (收)
            if receipt_prefix not in formula:
                logger.error(f"Cell {check_column}{row_num} formula should contain receipt prefix '{receipt_prefix}'")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            logger.debug(f"✓ Row {row_num} formula passed all checks")
        
        if rows_checked == 0:
            logger.error("No rows with data found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ IF/COUNTA payment/receipt numbering formula verification passed")
            logger.info(f"  Rows checked: {rows_checked}")
            logger.info(f"  Column: {check_column}")
            logger.info(f"  Functions verified: {', '.join(expected_functions)}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ IF/COUNTA payment/receipt numbering formula verification failed")
            logger.error(f"  Rows checked: {rows_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_if_or_row_check(result: str, expected: str = None, **options) -> float:
    """
    Verify if IF(COUNTIF(...)) formulas exist to check if a row contains a specific character.
    
    This function checks:
    1. Whether cells in specified column contain IF formulas
    2. Whether formulas contain required functions: IF, COUNTIF
    3. Whether formulas use COUNTIF to count occurrences (e.g., COUNTIF(A2:Z2, "连")>0)
    4. Whether formulas return "连" if found, "断" if not found
    5. Whether formulas reference the correct row range
    
    Expected formula pattern: =IF(COUNTIF(A2:Z2, "连")>0, "连", "断")
    
    The function automatically detects the number of data rows by checking the data column
    for non-empty cells. It stops checking after finding 3 consecutive empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_column: Column to check (e.g., "T")
            - start_row: Starting row number (default: 2)
            - check_range_start: Start column of range to check (e.g., "A")
            - check_range_end: End column of range to check (e.g., "Z")
            - search_text: Text to search for (default: "连")
            - found_text: Text to return if found (default: "连")
            - not_found_text: Text to return if not found (default: "断")
            - expected_functions: List of expected function names (default: ["IF", "OR"])
            - data_column: Column to check for data to determine end_row (default: "T")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_column = options.get('check_column', 'T')
        start_row = options.get('start_row', 2)
        check_range_start = options.get('check_range_start', 'A')
        check_range_end = options.get('check_range_end', 'Z')
        search_text = options.get('search_text', '连')
        found_text = options.get('found_text', '连')
        not_found_text = options.get('not_found_text', '断')
        expected_functions = options.get('expected_functions', ['IF', 'COUNTIF'])
        data_column = options.get('data_column', 'T')
        
        logger.info(f"Verifying IF/COUNTIF row check formulas in file: {result}")
        logger.info(f"Column to check: {check_column}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Check range: {check_range_start} to {check_range_end}")
        logger.info(f"Search text: {search_text}")
        logger.info(f"Expected functions: {expected_functions}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Check each row
        all_checks_passed = True
        rows_checked = 0
        
        for row_num in range(start_row, end_row + 1):
            check_cell = ws[f"{check_column}{row_num}"]
            
            # Skip if cell is empty
            if check_cell.value is None:
                continue
            
            rows_checked += 1
            
            # Check if cell contains a formula
            if check_cell.data_type != "f":
                logger.error(f"Cell {check_column}{row_num} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(check_cell, "_value") and isinstance(check_cell._value, str) and check_cell._value.startswith("="):
                formula = check_cell._value
            elif hasattr(check_cell, "formula"):
                formula = check_cell.formula
            else:
                # Try to get from value attribute
                if check_cell.value is not None and isinstance(check_cell.value, str) and check_cell.value.startswith("="):
                    formula = check_cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {check_column}{row_num}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Row {row_num} formula: {formula}")
            
            # Check 1: Contains all required functions
            missing_functions = []
            for func in expected_functions:
                # Check for function name (with word boundary to avoid partial matches)
                func_pattern = r'\b' + re.escape(func) + r'\s*\('
                if not re.search(func_pattern, formula_upper, re.IGNORECASE):
                    missing_functions.append(func)
            
            if missing_functions:
                logger.error(f"Cell {check_column}{row_num} formula missing functions: {missing_functions}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: Formula structure - IF(COUNTIF(...))
            if_countif_pattern = r'IF\s*\(\s*COUNTIF\s*\('
            if not re.search(if_countif_pattern, formula_upper, re.IGNORECASE):
                logger.error(f"Cell {check_column}{row_num} formula should have structure IF(COUNTIF(...))")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: COUNTIF contains row range
            # Pattern: COUNTIF(A2:Z2, ...)
            row_range_pattern = rf'{check_range_start}{row_num}:{check_range_end}{row_num}'
            if row_range_pattern.upper() not in formula_upper:
                logger.error(f"Cell {check_column}{row_num} COUNTIF should contain range {row_range_pattern}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: COUNTIF contains search text
            # Pattern: COUNTIF(A2:Z2, "连") or COUNTIF(A2:Z2, '连')
            countif_search_pattern1 = rf'COUNTIF\s*\(\s*{row_range_pattern}\s*,\s*["\']?{re.escape(search_text)}["\']?'
            countif_search_pattern2 = rf'COUNTIF\s*\(\s*{row_range_pattern}\s*,\s*["\']?{re.escape(search_text)}["\']?'
            if not re.search(countif_search_pattern1, formula, re.IGNORECASE) and \
               not re.search(countif_search_pattern2, formula, re.IGNORECASE):
                logger.error(f"Cell {check_column}{row_num} COUNTIF should search for '{search_text}'")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 5: COUNTIF result is compared with >0
            # Pattern: COUNTIF(...)>0
            countif_gt_pattern = r'COUNTIF\s*\([^)]+\)\s*>\s*0'
            if not re.search(countif_gt_pattern, formula_upper, re.IGNORECASE):
                logger.error(f"Cell {check_column}{row_num} COUNTIF result should be compared with >0")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 5: IF contains found_text ("连")
            if found_text not in formula:
                logger.error(f"Cell {check_column}{row_num} IF should return '{found_text}' if found")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 6: IF contains not_found_text ("断")
            if not_found_text not in formula:
                logger.error(f"Cell {check_column}{row_num} IF should return '{not_found_text}' if not found")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            logger.debug(f"✓ Row {row_num} formula passed all checks")
        
        if rows_checked == 0:
            logger.error("No rows with data found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ IF/COUNTIF row check formula verification passed")
            logger.info(f"  Rows checked: {rows_checked}")
            logger.info(f"  Column: {check_column}")
            logger.info(f"  Functions verified: {', '.join(expected_functions)}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ IF/COUNTIF row check formula verification failed")
            logger.error(f"  Rows checked: {rows_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_counta_sort_amount(result: str, expected: str = None, **options) -> float:
    """
    Verify if COUNTA helper column exists and data is sorted by amount in descending order.
    
    This function checks:
    1. Whether helper column (E) contains COUNTA formulas starting from E3
    2. Whether COUNTA formulas reference the correct range (e.g., $B$2:B3)
    3. Whether data is sorted by amount column (D) in descending order
    4. Whether the sorting maintains data integrity (all rows are present)
    
    Expected helper formula: =COUNTA($B$2:B3) in E3, then copied down
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - helper_column: Helper column with COUNTA formula (e.g., "E")
            - helper_start_row: Starting row for helper formula (default: 3)
            - count_range_column: Column to count in COUNTA (e.g., "B")
            - amount_column: Column containing amounts to sort (e.g., "D")
            - data_start_row: Starting row of data (default: 2)
            - data_end_row: Ending row of data (default: 14)
            - sort_order: Expected sort order "descending" or "ascending" (default: "descending")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        helper_column = options.get('helper_column', 'E')
        helper_start_row = options.get('helper_start_row', 3)
        count_range_column = options.get('count_range_column', 'B')
        amount_column = options.get('amount_column', 'D')
        data_start_row = options.get('data_start_row', 2)
        data_end_row = options.get('data_end_row', 14)
        sort_order = options.get('sort_order', 'descending')
        
        logger.info(f"Verifying COUNTA helper column and amount sorting in file: {result}")
        logger.info(f"Helper column: {helper_column}")
        logger.info(f"Helper start row: {helper_start_row}")
        logger.info(f"Amount column: {amount_column}")
        logger.info(f"Data range: {data_start_row} to {data_end_row}")
        logger.info(f"Sort order: {sort_order}")
        
        # Load workbook to get formulas and values
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check 1: Verify COUNTA formulas in helper column
        logger.info(f"Checking COUNTA formulas in column {helper_column}...")
        helper_formulas_ok = True
        
        for row_num in range(helper_start_row, data_end_row + 1):
            helper_cell = ws[f"{helper_column}{row_num}"]
            
            # Check if cell contains a formula
            if helper_cell.data_type != "f":
                logger.error(f"Cell {helper_column}{row_num} does not contain a formula")
                helper_formulas_ok = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(helper_cell, "_value") and isinstance(helper_cell._value, str) and helper_cell._value.startswith("="):
                formula = helper_cell._value
            elif hasattr(helper_cell, "formula"):
                formula = helper_cell.formula
            else:
                if helper_cell.value is not None and isinstance(helper_cell.value, str) and helper_cell.value.startswith("="):
                    formula = helper_cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {helper_column}{row_num}")
                helper_formulas_ok = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Row {row_num} formula: {formula}")
            
            # Check if formula contains COUNTA
            if 'COUNTA' not in formula_upper:
                logger.error(f"Cell {helper_column}{row_num} formula should contain COUNTA function")
                logger.error(f"  Formula: {formula}")
                helper_formulas_ok = False
                continue
            
            # Check if COUNTA references the correct range
            # Pattern: COUNTA($B$2:B3) or COUNTA($B$2:B{row_num})
            counta_pattern = rf'COUNTA\s*\(\s*\${count_range_column}\$\d+:\s*{count_range_column}{row_num}\s*\)'
            if not re.search(counta_pattern, formula_upper, re.IGNORECASE):
                logger.error(f"Cell {helper_column}{row_num} COUNTA should reference ${count_range_column}$2:{count_range_column}{row_num}")
                logger.error(f"  Formula: {formula}")
                helper_formulas_ok = False
                continue
        
        if not helper_formulas_ok:
            logger.error("COUNTA helper column verification failed")
            return 0.0
        
        logger.info("✓ COUNTA helper column verification passed")
        
        # Check 2: Verify data is sorted by amount column within each group (grouped by helper column)
        # The sorting is done by grouping rows with the same E column value, then sorting D column within each group
        logger.info(f"Checking if data is sorted by column {amount_column} within groups (grouped by {helper_column} column)...")
        
        # Collect data: (row_num, helper_value, amount_value)
        # We need to read calculated values, so load workbook again with data_only=True for values
        try:
            wb_values = openpyxl.load_workbook(result, data_only=True)
            ws_values = wb_values.active
        except Exception as e:
            logger.warning(f"Failed to load workbook with data_only=True, using formula values: {e}")
            ws_values = ws  # Fallback to formula worksheet
        
        data_rows = []
        # Start from helper_start_row to skip header row
        actual_start_row = max(data_start_row, helper_start_row)
        logger.debug(f"Collecting data from row {actual_start_row} to {data_end_row}")
        
        for row_num in range(actual_start_row, data_end_row + 1):
            helper_cell = ws_values[f"{helper_column}{row_num}"]
            amount_cell = ws_values[f"{amount_column}{row_num}"]
            
            helper_value = helper_cell.value
            amount_value = amount_cell.value
            
            logger.debug(f"Row {row_num}: {helper_column}={helper_value}, {amount_column}={amount_value}")
            
            # Skip if helper or amount is None or empty
            if helper_value is None or amount_value is None:
                logger.debug(f"Row {row_num}: Skipping due to None values")
                continue
            
            # Try to convert helper value to number
            try:
                if isinstance(helper_value, str):
                    helper_value = float(helper_value.replace(',', ''))
                else:
                    helper_value = float(helper_value)
            except (ValueError, TypeError) as e:
                logger.debug(f"Cell {helper_column}{row_num} contains non-numeric value: {helper_value} (type: {type(helper_value)}), skipping: {e}")
                continue
            
            # Try to convert amount to number
            try:
                if isinstance(amount_value, str):
                    # Skip if it's a header text (contains Chinese characters that might be headers)
                    if any('\u4e00' <= char <= '\u9fff' for char in amount_value):
                        logger.debug(f"Skipping header text in cell {amount_column}{row_num}: {amount_value}")
                        continue
                    amount_value = float(amount_value.replace(',', ''))
                else:
                    amount_value = float(amount_value)
                data_rows.append((row_num, helper_value, amount_value))
                logger.debug(f"Row {row_num}: Added to data_rows - helper={helper_value}, amount={amount_value}")
            except (ValueError, TypeError) as e:
                logger.debug(f"Cell {amount_column}{row_num} contains non-numeric value: {amount_value} (type: {type(amount_value)}), skipping: {e}")
                continue
        
        logger.info(f"Collected {len(data_rows)} data rows for sorting verification")
        
        if len(data_rows) < 2:
            logger.error(f"Not enough data rows to verify sorting: only {len(data_rows)} rows collected")
            logger.error(f"  Expected data from row {actual_start_row} to {data_end_row}")
            return 0.0
        
        # Group data by helper column value
        from collections import defaultdict
        groups = defaultdict(list)
        for row_num, helper_val, amount_val in data_rows:
            groups[helper_val].append((row_num, amount_val))
        
        logger.info(f"Found {len(groups)} groups based on {helper_column} column values")
        
        # Check if amounts are sorted within each group
        all_groups_sorted = True
        for group_key in sorted(groups.keys()):
            group_data = groups[group_key]
            if len(group_data) < 2:
                # Single row groups are always sorted
                continue
            
            # Check if amounts in this group are sorted
            group_sorted = True
            for i in range(len(group_data) - 1):
                current_amount = group_data[i][1]
                next_amount = group_data[i + 1][1]
                
                if sort_order == "descending":
                    if current_amount < next_amount:
                        logger.error(f"Group {group_key}: row {group_data[i][0]} ({current_amount}) < row {group_data[i+1][0]} ({next_amount}) - not descending")
                        group_sorted = False
                        break
                else:  # ascending
                    if current_amount > next_amount:
                        logger.error(f"Group {group_key}: row {group_data[i][0]} ({current_amount}) > row {group_data[i+1][0]} ({next_amount}) - not ascending")
                        group_sorted = False
                        break
            
            if not group_sorted:
                all_groups_sorted = False
                logger.error(f"Group {group_key} is not sorted in {sort_order} order")
            else:
                logger.debug(f"Group {group_key} is sorted correctly")
        
        if not all_groups_sorted:
            logger.error("Sorting verification failed: not all groups are sorted correctly")
            return 0.0
        
        logger.info("✓ Amount sorting verification passed: all groups are sorted correctly")
        
        logger.info("=" * 60)
        logger.info(f"✓ COUNTA helper column and amount sorting verification passed")
        logger.info(f"  Helper column: {helper_column}")
        logger.info(f"  Amount column: {amount_column}")
        logger.info(f"  Sort order: {sort_order}")
        logger.info("=" * 60)
        return 1.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_if_iferror_find_text_search(result: str, expected: str = None, **options) -> float:
    """
    Verify if IF(IFERROR(FIND(...))) formulas exist to search for text within a row range.
    
    This function checks:
    1. Whether cells in specified column contain IF formulas
    2. Whether formulas contain required functions: IF, IFERROR, FIND
    3. Whether FIND function searches for the specified text (e.g., "AB")
    4. Whether FIND function searches in concatenated text from multiple columns (e.g., A2&B2)
    5. Whether IF function returns 1 if found, empty string if not found
    
    Expected formula pattern: =IF(IFERROR(FIND("AB",A2&B2),)>0,1,)
    
    The function automatically detects the number of data rows by checking the data column
    for non-empty cells. It stops checking after finding 3 consecutive empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_column: Column to check (e.g., "C")
            - start_row: Starting row number (default: 2)
            - search_columns: List of columns to concatenate and search (e.g., ["A", "B"])
            - search_text: Text to search for (e.g., "AB")
            - return_value: Value to return if found (default: "1")
            - expected_functions: List of expected function names (default: ["IF", "IFERROR", "FIND"])
            - data_column: Column to check for data to determine end_row (default: "A")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_column = options.get('check_column', 'C')
        start_row = options.get('start_row', 2)
        search_columns = options.get('search_columns', ['A', 'B'])
        search_text = options.get('search_text', 'AB')
        return_value = options.get('return_value', '1')
        expected_functions = options.get('expected_functions', ['IF', 'IFERROR', 'FIND'])
        data_column = options.get('data_column', 'A')
        
        logger.info(f"Verifying IF/IFERROR/FIND text search formulas in file: {result}")
        logger.info(f"Column to check: {check_column}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Search columns: {search_columns}")
        logger.info(f"Search text: {search_text}")
        logger.info(f"Return value: {return_value}")
        logger.info(f"Expected functions: {expected_functions}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Check each row
        all_checks_passed = True
        rows_checked = 0
        
        for row_num in range(start_row, end_row + 1):
            check_cell = ws[f"{check_column}{row_num}"]
            
            # Skip if cell is empty
            if check_cell.value is None:
                continue
            
            rows_checked += 1
            
            # Check if cell contains a formula
            if check_cell.data_type != "f":
                logger.error(f"Cell {check_column}{row_num} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(check_cell, "_value") and isinstance(check_cell._value, str) and check_cell._value.startswith("="):
                formula = check_cell._value
            elif hasattr(check_cell, "formula"):
                formula = check_cell.formula
            else:
                # Try to get from value attribute
                if check_cell.value is not None and isinstance(check_cell.value, str) and check_cell.value.startswith("="):
                    formula = check_cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {check_column}{row_num}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Row {row_num} formula: {formula}")
            
            # Check 1: Contains all required functions
            missing_functions = []
            for func in expected_functions:
                # Check for function name (with word boundary to avoid partial matches)
                func_pattern = r'\b' + re.escape(func) + r'\s*\('
                if not re.search(func_pattern, formula_upper, re.IGNORECASE):
                    missing_functions.append(func)
            
            if missing_functions:
                logger.error(f"Cell {check_column}{row_num} formula missing functions: {missing_functions}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: Formula structure - IF(IFERROR(FIND(...)))
            if_iferror_pattern = r'IF\s*\(\s*IFERROR\s*\('
            if not re.search(if_iferror_pattern, formula_upper, re.IGNORECASE):
                logger.error(f"Cell {check_column}{row_num} formula should have structure IF(IFERROR(...))")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: IFERROR contains FIND
            iferror_find_pattern = r'IFERROR\s*\(\s*FIND\s*\('
            if not re.search(iferror_find_pattern, formula_upper, re.IGNORECASE):
                logger.error(f"Cell {check_column}{row_num} IFERROR should contain FIND function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: FIND contains search text
            # Pattern: FIND("AB",...) or FIND('AB',...)
            find_search_pattern1 = rf'FIND\s*\(\s*["\']?{re.escape(search_text)}["\']?\s*,'
            find_search_pattern2 = rf'FIND\s*\(\s*["\']?{re.escape(search_text)}["\']?\s*,'
            if not re.search(find_search_pattern1, formula, re.IGNORECASE) and \
               not re.search(find_search_pattern2, formula, re.IGNORECASE):
                logger.error(f"Cell {check_column}{row_num} FIND should search for '{search_text}'")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 5: FIND searches in concatenated columns (e.g., A2&B2)
            # Build pattern for concatenated columns: A2&B2 or A{row_num}&B{row_num}
            concat_pattern_parts = []
            for col in search_columns:
                concat_pattern_parts.append(rf'{col}{row_num}')
            concat_pattern = r'&'.join(concat_pattern_parts)
            if concat_pattern.upper() not in formula_upper:
                logger.error(f"Cell {check_column}{row_num} FIND should search in concatenated columns {concat_pattern}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 6: IFERROR has empty second parameter or no second parameter
            # Pattern: IFERROR(...,) or IFERROR(...,"")
            iferror_empty_pattern = r'IFERROR\s*\([^,]+,\s*\)|IFERROR\s*\([^,]+,\s*["\']?\s*["\']?'
            if not re.search(iferror_empty_pattern, formula_upper, re.IGNORECASE):
                logger.warning(f"Cell {check_column}{row_num} IFERROR may not have empty second parameter")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn
            
            # Check 7: IF condition checks if result > 0
            # Pattern: IFERROR(...)>0
            # Since IFERROR may have nested parentheses, we'll check more flexibly:
            # 1. Check that IFERROR exists
            # 2. Check that >0 exists after IFERROR
            # 3. Check that there's a closing parenthesis before >0
            iferror_pos = formula_upper.find('IFERROR')
            gt_zero_pos = formula_upper.find('>0')
            
            if iferror_pos == -1 or gt_zero_pos == -1:
                logger.error(f"Cell {check_column}{row_num} formula should contain IFERROR and >0")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check that >0 comes after IFERROR
            if gt_zero_pos <= iferror_pos:
                logger.error(f"Cell {check_column}{row_num} >0 should come after IFERROR")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check that there's a closing parenthesis for IFERROR before >0
            # Find the position of IFERROR's opening parenthesis
            iferror_open = formula_upper.find('(', iferror_pos)
            if iferror_open == -1:
                logger.error(f"Cell {check_column}{row_num} IFERROR should have opening parenthesis")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Count parentheses to find IFERROR's closing parenthesis
            paren_count = 0
            iferror_close = -1
            for i in range(iferror_open, min(gt_zero_pos, len(formula_upper))):
                if formula_upper[i] == '(':
                    paren_count += 1
                elif formula_upper[i] == ')':
                    paren_count -= 1
                    if paren_count == 0:
                        iferror_close = i
                        break
            
            if iferror_close == -1 or iferror_close >= gt_zero_pos:
                logger.error(f"Cell {check_column}{row_num} IFERROR should be closed before >0")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 8: IF returns return_value if found
            # Pattern: IF(...,1,) or IF(...,"1",)
            # Since IF condition may contain commas (e.g., IFERROR(...)), we need to find the second parameter
            # Find the position of IF's opening parenthesis and the comma before return_value
            if_pos = formula_upper.find('IF(')
            if if_pos == -1:
                if_pos = formula_upper.find('IF (')
            
            if if_pos != -1:
                # Find the opening parenthesis of IF
                if_open = formula_upper.find('(', if_pos)
                if if_open != -1:
                    # Count parentheses to find the comma that separates condition from return_value
                    paren_count = 0
                    comma_pos = -1
                    for i in range(if_open + 1, len(formula_upper)):
                        if formula_upper[i] == '(':
                            paren_count += 1
                        elif formula_upper[i] == ')':
                            paren_count -= 1
                            if paren_count < 0:
                                break
                        elif formula_upper[i] == ',' and paren_count == 0:
                            comma_pos = i
                            break
                    
                    if comma_pos != -1:
                        # Check if return_value appears after this comma
                        after_comma = formula_upper[comma_pos + 1:].strip()
                        # Check for return_value (with or without quotes)
                        return_pattern1 = rf'^{re.escape(return_value)}\s*,'
                        return_pattern2 = rf'^["\']?{re.escape(return_value)}["\']?\s*,'
                        if not re.match(return_pattern1, after_comma, re.IGNORECASE) and \
                           not re.match(return_pattern2, after_comma, re.IGNORECASE):
                            logger.error(f"Cell {check_column}{row_num} IF should return '{return_value}' if found")
                            logger.error(f"  Formula: {formula}")
                            logger.error(f"  After comma: {after_comma[:20]}")
                            all_checks_passed = False
                            continue
                    else:
                        logger.error(f"Cell {check_column}{row_num} Could not find comma separating IF condition from return value")
                        logger.error(f"  Formula: {formula}")
                        all_checks_passed = False
                        continue
                else:
                    logger.error(f"Cell {check_column}{row_num} IF should have opening parenthesis")
                    logger.error(f"  Formula: {formula}")
                    all_checks_passed = False
                    continue
            else:
                logger.error(f"Cell {check_column}{row_num} Formula should contain IF function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 9: IF has empty third parameter (else case)
            # Pattern: IF(...,1,) or IF(...,"1","")
            if_empty_else_pattern = r'IF\s*\([^,]+,\s*[^,]+,\s*\)|IF\s*\([^,]+,\s*[^,]+,\s*["\']?\s*["\']?'
            if not re.search(if_empty_else_pattern, formula_upper, re.IGNORECASE):
                logger.warning(f"Cell {check_column}{row_num} IF may not have empty else parameter")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn
            
            logger.debug(f"✓ Row {row_num} formula passed all checks")
        
        if rows_checked == 0:
            logger.error("No rows with data found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ IF/IFERROR/FIND text search formula verification passed")
            logger.info(f"  Rows checked: {rows_checked}")
            logger.info(f"  Column: {check_column}")
            logger.info(f"  Search text: {search_text}")
            logger.info(f"  Functions verified: {', '.join(expected_functions)}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ IF/IFERROR/FIND text search formula verification failed")
            logger.error(f"  Rows checked: {rows_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_countif_if_household_sort(result: str, expected: str = None, **options) -> float:
    """
    Verify if COUNTIF and IF formulas exist in helper column for household sorting, and verify sorting.
    
    This function checks:
    1. Whether helper column contains COUNTIF and IF formulas
    2. Whether COUNTIF counts "户主" (household head) from start to current row
    3. Whether IF function assigns values: 1 for "户主", 2 for "夫妻", 3 for others
    4. Whether data is sorted by helper column (ascending) and birth date (ascending)
    
    Expected formula pattern: =COUNTIF($E$1:E1,"户主")*10+IF(E1="户主",1,IF(E1="夫妻",2,3))
    
    The function automatically detects the number of data rows by checking the data column
    for non-empty cells. It stops checking after finding 3 consecutive empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - helper_column: Helper column with formula (e.g., "F")
            - start_row: Starting row for formula (default: 1)
            - relationship_column: Column containing relationships (e.g., "E")
            - birth_date_column: Column containing birth dates (e.g., "D")
            - expected_functions: List of expected function names (default: ["COUNTIF", "IF"])
            - household_head_text: Text for household head (default: "户主")
            - spouse_text: Text for spouse (default: "夫妻")
            - data_column: Column to check for data to determine end_row (default: "E")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        helper_column = options.get('helper_column', 'F')
        start_row = options.get('start_row', 1)
        relationship_column = options.get('relationship_column', 'E')
        birth_date_column = options.get('birth_date_column', 'D')
        expected_functions = options.get('expected_functions', ['COUNTIF', 'IF'])
        household_head_text = options.get('household_head_text', '户主')
        spouse_text = options.get('spouse_text', '夫妻')
        data_column = options.get('data_column', 'E')
        
        logger.info(f"Verifying COUNTIF/IF household sorting formulas in file: {result}")
        logger.info(f"Helper column: {helper_column}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Relationship column: {relationship_column}")
        logger.info(f"Birth date column: {birth_date_column}")
        logger.info(f"Expected functions: {expected_functions}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Check 1: Verify formulas in helper column
        logger.info(f"Checking formulas in column {helper_column}...")
        helper_formulas_ok = True
        
        for row_num in range(start_row, end_row + 1):
            helper_cell = ws[f"{helper_column}{row_num}"]
            
            # Skip if cell is empty
            if helper_cell.value is None:
                continue
            
            # Check if cell contains a formula
            if helper_cell.data_type != "f":
                logger.error(f"Cell {helper_column}{row_num} does not contain a formula")
                helper_formulas_ok = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(helper_cell, "_value") and isinstance(helper_cell._value, str) and helper_cell._value.startswith("="):
                formula = helper_cell._value
            elif hasattr(helper_cell, "formula"):
                formula = helper_cell.formula
            else:
                if helper_cell.value is not None and isinstance(helper_cell.value, str) and helper_cell.value.startswith("="):
                    formula = helper_cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {helper_column}{row_num}")
                helper_formulas_ok = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Row {row_num} formula: {formula}")
            
            # Check if formula contains required functions
            missing_functions = []
            for func in expected_functions:
                func_pattern = r'\b' + re.escape(func) + r'\s*\('
                if not re.search(func_pattern, formula_upper, re.IGNORECASE):
                    missing_functions.append(func)
            
            if missing_functions:
                logger.error(f"Cell {helper_column}{row_num} formula missing functions: {missing_functions}")
                logger.error(f"  Formula: {formula}")
                helper_formulas_ok = False
                continue
            
            # Check if COUNTIF references relationship column with "户主"
            countif_pattern = rf'COUNTIF\s*\(\s*\${relationship_column}\$\d+:\s*{relationship_column}{row_num}\s*,\s*["\']?{re.escape(household_head_text)}["\']?'
            if not re.search(countif_pattern, formula_upper, re.IGNORECASE):
                logger.error(f"Cell {helper_column}{row_num} COUNTIF should count '{household_head_text}' in {relationship_column} column")
                logger.error(f"  Formula: {formula}")
                helper_formulas_ok = False
                continue
            
            # Check if COUNTIF result is multiplied by 10
            countif_multiply_pattern = rf'COUNTIF\s*\([^)]+\)\s*\*\s*10'
            if not re.search(countif_multiply_pattern, formula_upper, re.IGNORECASE):
                logger.error(f"Cell {helper_column}{row_num} COUNTIF result should be multiplied by 10")
                logger.error(f"  Formula: {formula}")
                helper_formulas_ok = False
                continue
            
            # Check if IF function checks for "户主" and assigns 1
            if_household_head_pattern = rf'IF\s*\(\s*{relationship_column}{row_num}\s*=\s*["\']?{re.escape(household_head_text)}["\']?\s*,\s*1'
            if not re.search(if_household_head_pattern, formula_upper, re.IGNORECASE):
                logger.error(f"Cell {helper_column}{row_num} IF should check for '{household_head_text}' and return 1")
                logger.error(f"  Formula: {formula}")
                helper_formulas_ok = False
                continue
            
            # Check if nested IF checks for "夫妻" and assigns 2
            if_spouse_pattern = rf'IF\s*\(\s*{relationship_column}{row_num}\s*=\s*["\']?{re.escape(spouse_text)}["\']?\s*,\s*2'
            if not re.search(if_spouse_pattern, formula_upper, re.IGNORECASE):
                logger.error(f"Cell {helper_column}{row_num} IF should check for '{spouse_text}' and return 2")
                logger.error(f"  Formula: {formula}")
                helper_formulas_ok = False
                continue
            
            # Check if nested IF has else value 3
            if_else_3_pattern = r'IF\s*\([^,]+,\s*[^,]+,\s*3\s*\)'
            if not re.search(if_else_3_pattern, formula_upper, re.IGNORECASE):
                logger.warning(f"Cell {helper_column}{row_num} IF else value may not be 3")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn
        
        if not helper_formulas_ok:
            logger.error("Helper column formula verification failed")
            return 0.0
        
        logger.info("✓ Helper column formula verification passed")
        
        # Check 2: Verify sorting by helper column and birth date
        logger.info(f"Checking if data is sorted by {helper_column} column (ascending) and {birth_date_column} column (ascending)...")
        
        # Load workbook with calculated values for sorting check
        try:
            wb_values = openpyxl.load_workbook(result, data_only=True)
            ws_values = wb_values.active
        except Exception as e:
            logger.warning(f"Failed to load workbook with data_only=True, using formula values: {e}")
            ws_values = ws
        
        # Collect data: (row_num, helper_value, birth_date_value, relationship)
        data_rows = []
        for row_num in range(start_row, end_row + 1):
            helper_cell = ws_values[f"{helper_column}{row_num}"]
            birth_date_cell = ws_values[f"{birth_date_column}{row_num}"]
            relationship_cell = ws_values[f"{relationship_column}{row_num}"]
            
            helper_value = helper_cell.value
            birth_date_value = birth_date_cell.value
            relationship_value = relationship_cell.value
            
            # Skip if essential data is missing
            if helper_value is None or relationship_value is None:
                continue
            
            # Try to convert helper value to number
            try:
                if isinstance(helper_value, str):
                    helper_value = float(helper_value.replace(',', ''))
                else:
                    helper_value = float(helper_value)
            except (ValueError, TypeError):
                logger.debug(f"Cell {helper_column}{row_num} contains non-numeric value: {helper_value}, skipping")
                continue
            
            # Try to convert birth date to comparable value
            birth_date_comparable = None
            if birth_date_value is not None:
                try:
                    if isinstance(birth_date_value, (int, float)):
                        birth_date_comparable = float(birth_date_value)
                    elif isinstance(birth_date_value, str):
                        # Try to parse date string
                        from datetime import datetime
                        try:
                            dt = datetime.strptime(birth_date_value, '%Y-%m-%d')
                            birth_date_comparable = dt.timestamp()
                        except:
                            try:
                                dt = datetime.strptime(birth_date_value, '%Y/%m/%d')
                                birth_date_comparable = dt.timestamp()
                            except:
                                birth_date_comparable = None
                    else:
                        birth_date_comparable = float(birth_date_value)
                except (ValueError, TypeError):
                    logger.debug(f"Cell {birth_date_column}{row_num} contains non-comparable date: {birth_date_value}")
            
            data_rows.append((row_num, helper_value, birth_date_comparable, relationship_value))
        
        if len(data_rows) < 2:
            logger.warning("Not enough data rows to verify sorting")
            logger.info("✓ Sorting verification passed (minimal data, helper column formula verified)")
            return 1.0
        
        # Check sorting: first by helper column (ascending), then by birth date (ascending)
        is_sorted = True
        for i in range(len(data_rows) - 1):
            current_helper = data_rows[i][1]
            next_helper = data_rows[i + 1][1]
            current_birth = data_rows[i][2]
            next_birth = data_rows[i + 1][2]
            
            # First sort key: helper column (ascending)
            if current_helper > next_helper:
                logger.error(f"Data not sorted by helper column: row {data_rows[i][0]} ({current_helper}) > row {data_rows[i+1][0]} ({next_helper})")
                is_sorted = False
                break
            elif current_helper == next_helper:
                # Second sort key: birth date (ascending) - only if both have dates
                if current_birth is not None and next_birth is not None:
                    if current_birth > next_birth:
                        logger.error(f"Data not sorted by birth date within same helper value: row {data_rows[i][0]} ({current_birth}) > row {data_rows[i+1][0]} ({next_birth})")
                        is_sorted = False
                        break
        
        if not is_sorted:
            logger.error("Sorting verification failed")
            return 0.0
        
        logger.info("✓ Sorting verification passed")
        
        logger.info("=" * 60)
        logger.info(f"✓ COUNTIF/IF household sorting verification passed")
        logger.info(f"  Helper column: {helper_column}")
        logger.info(f"  Relationship column: {relationship_column}")
        logger.info(f"  Birth date column: {birth_date_column}")
        logger.info("=" * 60)
        return 1.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_regex_airport_extract(result: str, expected: str = None, **options) -> float:
    """
    Verify if REGEX formulas exist in specified columns (E and F) to extract airport names.
    
    This function checks:
    1. Whether cells in E and F columns contain REGEX formulas
    2. Whether E column formulas reference B column (departure location)
    3. Whether F column formulas reference C column (arrival location)
    4. Whether formulas contain the pattern "\\p{Han}{2,4}" to extract 2-4 Chinese characters
    
    Expected formula patterns:
    - E column: =REGEX(B2,"\\p{Han}{2,4}")
    - F column: =REGEX(C2,"\\p{Han}{2,4}")
    
    The function automatically detects the number of data rows by checking the data column
    for non-empty cells. It stops checking after finding 3 consecutive empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - departure_extract_column: Column with departure airport extraction formulas (e.g., "E")
            - arrival_extract_column: Column with arrival airport extraction formulas (e.g., "F")
            - departure_source_column: Column containing departure location data (e.g., "B")
            - arrival_source_column: Column containing arrival location data (e.g., "C")
            - start_row: Starting row number (default: 2)
            - expected_pattern: Expected regex pattern (default: "\\p{Han}{2,4}")
            - data_column: Column to check for data to determine end_row (default: "B")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        departure_extract_column = options.get('departure_extract_column', 'E')
        arrival_extract_column = options.get('arrival_extract_column', 'F')
        departure_source_column = options.get('departure_source_column', 'B')
        arrival_source_column = options.get('arrival_source_column', 'C')
        start_row = options.get('start_row', 2)
        expected_pattern = options.get('expected_pattern', '\\p{Han}{2,4}')
        data_column = options.get('data_column', 'B')
        
        logger.info(f"Verifying REGEX airport extraction formulas in file: {result}")
        logger.info(f"Departure extract column: {departure_extract_column}")
        logger.info(f"Arrival extract column: {arrival_extract_column}")
        logger.info(f"Departure source column: {departure_source_column}")
        logger.info(f"Arrival source column: {arrival_source_column}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Expected pattern: {expected_pattern}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Check formulas in both columns
        all_checks_passed = True
        rows_checked = 0
        
        for row_num in range(start_row, end_row + 1):
            # Check departure column (E)
            departure_cell = ws[f"{departure_extract_column}{row_num}"]
            departure_source_cell = ws[f"{departure_source_column}{row_num}"]
            
            # Check arrival column (F)
            arrival_cell = ws[f"{arrival_extract_column}{row_num}"]
            arrival_source_cell = ws[f"{arrival_source_column}{row_num}"]
            
            # Skip if source cells are empty
            if departure_source_cell.value is None and arrival_source_cell.value is None:
                continue
            
            rows_checked += 1
            
            # Check departure column formula
            if departure_source_cell.value is not None:
                if departure_cell.data_type != "f":
                    logger.error(f"Cell {departure_extract_column}{row_num} does not contain a formula")
                    all_checks_passed = False
                    continue
                
                # Get formula text
                formula = None
                if hasattr(departure_cell, "_value") and isinstance(departure_cell._value, str) and departure_cell._value.startswith("="):
                    formula = departure_cell._value
                elif hasattr(departure_cell, "formula"):
                    formula = departure_cell.formula
                else:
                    if departure_cell.value is not None and isinstance(departure_cell.value, str) and departure_cell.value.startswith("="):
                        formula = departure_cell.value
                
                if formula is None:
                    logger.error(f"Could not extract formula from cell {departure_extract_column}{row_num}")
                    all_checks_passed = False
                    continue
                
                formula_upper = formula.upper()
                logger.debug(f"Row {row_num} departure formula: {formula}")
                
                # Check 1: Contains REGEX function
                if 'REGEX' not in formula_upper:
                    logger.error(f"Cell {departure_extract_column}{row_num} formula should contain REGEX function")
                    logger.error(f"  Formula: {formula}")
                    all_checks_passed = False
                    continue
                
                # Check 2: References departure source column
                source_pattern = rf'{departure_source_column}{row_num}\b'
                if not re.search(source_pattern, formula_upper):
                    logger.error(f"Cell {departure_extract_column}{row_num} formula should reference {departure_source_column}{row_num}")
                    logger.error(f"  Formula: {formula}")
                    all_checks_passed = False
                    continue
                
                # Check 3: Contains expected pattern
                # Pattern in formula might be: "\\p{Han}{2,4}" or '\\p{Han}{2,4}' or "\p{Han}{2,4}"
                # We need to check for the pattern with proper escaping
                # The pattern might appear as: \p{Han}{2,4} (with backslash) or \\p{Han}{2,4} (with double backslash)
                pattern_variants = [
                    re.escape(expected_pattern),  # Exact match with escaping
                    expected_pattern.replace('\\', '\\\\'),  # Double backslash version
                    expected_pattern.replace('\\\\', '\\'),  # Single backslash version
                ]
                pattern_found = False
                for variant in pattern_variants:
                    # Check for pattern in quotes (single or double)
                    pattern_check = rf'["\']{re.escape(variant)}["\']'
                    if re.search(pattern_check, formula):
                        pattern_found = True
                        break
                    # Also check without quotes (less common but possible)
                    pattern_check2 = rf'\b{re.escape(variant)}\b'
                    if re.search(pattern_check2, formula):
                        pattern_found = True
                        break
                
                if not pattern_found:
                    logger.error(f"Cell {departure_extract_column}{row_num} formula should contain pattern '{expected_pattern}'")
                    logger.error(f"  Formula: {formula}")
                    all_checks_passed = False
                    continue
            
            # Check arrival column formula
            if arrival_source_cell.value is not None:
                if arrival_cell.data_type != "f":
                    logger.error(f"Cell {arrival_extract_column}{row_num} does not contain a formula")
                    all_checks_passed = False
                    continue
                
                # Get formula text
                formula = None
                if hasattr(arrival_cell, "_value") and isinstance(arrival_cell._value, str) and arrival_cell._value.startswith("="):
                    formula = arrival_cell._value
                elif hasattr(arrival_cell, "formula"):
                    formula = arrival_cell.formula
                else:
                    if arrival_cell.value is not None and isinstance(arrival_cell.value, str) and arrival_cell.value.startswith("="):
                        formula = arrival_cell.value
                
                if formula is None:
                    logger.error(f"Could not extract formula from cell {arrival_extract_column}{row_num}")
                    all_checks_passed = False
                    continue
                
                formula_upper = formula.upper()
                logger.debug(f"Row {row_num} arrival formula: {formula}")
                
                # Check 1: Contains REGEX function
                if 'REGEX' not in formula_upper:
                    logger.error(f"Cell {arrival_extract_column}{row_num} formula should contain REGEX function")
                    logger.error(f"  Formula: {formula}")
                    all_checks_passed = False
                    continue
                
                # Check 2: References arrival source column
                source_pattern = rf'{arrival_source_column}{row_num}\b'
                if not re.search(source_pattern, formula_upper):
                    logger.error(f"Cell {arrival_extract_column}{row_num} formula should reference {arrival_source_column}{row_num}")
                    logger.error(f"  Formula: {formula}")
                    all_checks_passed = False
                    continue
                
                # Check 3: Contains expected pattern
                # Pattern in formula might be: "\\p{Han}{2,4}" or '\\p{Han}{2,4}' or "\p{Han}{2,4}"
                # We need to check for the pattern with proper escaping
                # The pattern might appear as: \p{Han}{2,4} (with backslash) or \\p{Han}{2,4} (with double backslash)
                pattern_variants = [
                    re.escape(expected_pattern),  # Exact match with escaping
                    expected_pattern.replace('\\', '\\\\'),  # Double backslash version
                    expected_pattern.replace('\\\\', '\\'),  # Single backslash version
                ]
                pattern_found = False
                for variant in pattern_variants:
                    # Check for pattern in quotes (single or double)
                    pattern_check = rf'["\']{re.escape(variant)}["\']'
                    if re.search(pattern_check, formula):
                        pattern_found = True
                        break
                    # Also check without quotes (less common but possible)
                    pattern_check2 = rf'\b{re.escape(variant)}\b'
                    if re.search(pattern_check2, formula):
                        pattern_found = True
                        break
                
                if not pattern_found:
                    logger.error(f"Cell {arrival_extract_column}{row_num} formula should contain pattern '{expected_pattern}'")
                    logger.error(f"  Formula: {formula}")
                    all_checks_passed = False
                    continue
            
            logger.debug(f"✓ Row {row_num} formulas passed all checks")
        
        if rows_checked == 0:
            logger.error("No rows with data found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ REGEX airport extraction verification passed")
            logger.info(f"  Rows checked: {rows_checked}")
            logger.info(f"  Departure column: {departure_extract_column} (from {departure_source_column})")
            logger.info(f"  Arrival column: {arrival_extract_column} (from {arrival_source_column})")
            logger.info(f"  Pattern: {expected_pattern}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ REGEX airport extraction verification failed")
            logger.error(f"  Rows checked: {rows_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_sumproduct_cross_sheet_lookup(result: str, expected: str = None, **options) -> float:
    """
    Verify if SUMPRODUCT formulas exist in target sheet to lookup data from source sheet.
    
    This function checks:
    1. Whether cells in target column contain SUMPRODUCT formulas
    2. Whether formulas reference source sheet with correct sheet name
    3. Whether formulas match two conditions: source column A equals target column A, source column B equals target column B
    4. Whether formulas return values from source column C
    
    Expected formula pattern: =SUMPRODUCT((source_sheet.$A$2:$A$19=A2)*(source_sheet.$B$2:$B$19=B2),source_sheet.$C$2:$C$19)
    
    The function automatically detects the number of data rows by checking the data column
    for non-empty cells. It stops checking after finding 3 consecutive empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - target_sheet: Target sheet name (e.g., "本周销售")
            - source_sheet: Source sheet name (e.g., "上周销售")
            - target_column: Column with formulas (e.g., "D")
            - source_column_a: Source column for first condition (e.g., "A")
            - source_column_b: Source column for second condition (e.g., "B")
            - source_column_c: Source column for return values (e.g., "C")
            - target_column_a: Target column for first condition (e.g., "A")
            - target_column_b: Target column for second condition (e.g., "B")
            - start_row: Starting row number (default: 2)
            - data_range_start: Source data range start row (default: 2)
            - data_range_end: Source data range end row (default: 19)
            - data_column: Column to check for data to determine end_row (default: "A")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        target_sheet = options.get('target_sheet', '本周销售')
        source_sheet = options.get('source_sheet', '上周销售')
        target_column = options.get('target_column', 'D')
        source_column_a = options.get('source_column_a', 'A')
        source_column_b = options.get('source_column_b', 'B')
        source_column_c = options.get('source_column_c', 'C')
        target_column_a = options.get('target_column_a', 'A')
        target_column_b = options.get('target_column_b', 'B')
        start_row = options.get('start_row', 2)
        data_range_start = options.get('data_range_start', 2)
        data_range_end = options.get('data_range_end', 19)
        data_column = options.get('data_column', 'A')
        
        logger.info(f"Verifying SUMPRODUCT cross-sheet lookup formulas in file: {result}")
        logger.info(f"Target sheet: {target_sheet}")
        logger.info(f"Source sheet: {source_sheet}")
        logger.info(f"Target column: {target_column}")
        logger.info(f"Source columns: {source_column_a}, {source_column_b}, {source_column_c}")
        logger.info(f"Target columns: {target_column_a}, {target_column_b}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Data range: {data_range_start} to {data_range_end}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            if target_sheet not in wb.sheetnames:
                logger.error(f"Target sheet '{target_sheet}' not found in workbook")
                return 0.0
            ws_target = wb[target_sheet]
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws_target.max_row
        end_row = start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws_target[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Check formulas in target column
        all_checks_passed = True
        rows_checked = 0
        
        for row_num in range(start_row, end_row + 1):
            target_cell = ws_target[f"{target_column}{row_num}"]
            target_cell_a = ws_target[f"{target_column_a}{row_num}"]
            
            # Skip if target column A is empty
            if target_cell_a.value is None:
                continue
            
            rows_checked += 1
            
            # Check if cell contains a formula
            if target_cell.data_type != "f":
                logger.error(f"Cell {target_column}{row_num} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(target_cell, "_value") and isinstance(target_cell._value, str) and target_cell._value.startswith("="):
                formula = target_cell._value
            elif hasattr(target_cell, "formula"):
                formula = target_cell.formula
            else:
                if target_cell.value is not None and isinstance(target_cell.value, str) and target_cell.value.startswith("="):
                    formula = target_cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {target_column}{row_num}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Row {row_num} formula: {formula}")
            
            # Check 1: Contains SUMPRODUCT function
            if 'SUMPRODUCT' not in formula_upper:
                logger.error(f"Cell {target_column}{row_num} formula should contain SUMPRODUCT function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References source sheet
            # Sheet name might be quoted or unquoted, and might have spaces
            # Excel/LibreOffice uses ! (exclamation mark) for sheet references
            source_sheet_pattern = rf'["\']?{re.escape(source_sheet)}["\']?[!\.]'
            if not re.search(source_sheet_pattern, formula, re.IGNORECASE):
                logger.error(f"Cell {target_column}{row_num} formula should reference source sheet '{source_sheet}'")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: First condition - source column A equals target column A
            # Pattern: source_sheet!$A$2:$A$19=A2 (or similar row references)
            # Note: Excel/LibreOffice uses ! (exclamation mark) not . (dot) for sheet references
            condition1_pattern = rf'{re.escape(source_sheet)}[!\.][\$]?{source_column_a}[\$]?\d+:\$?{source_column_a}[\$]?\d+\s*=\s*{target_column_a}{row_num}'
            if not re.search(condition1_pattern, formula_upper):
                logger.error(f"Cell {target_column}{row_num} formula should have condition: {source_sheet}!{source_column_a}...={target_column_a}{row_num}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Second condition - source column B equals target column B
            # Pattern: source_sheet!$B$2:$B$19=B2 (or similar row references)
            condition2_pattern = rf'{re.escape(source_sheet)}[!\.][\$]?{source_column_b}[\$]?\d+:\$?{source_column_b}[\$]?\d+\s*=\s*{target_column_b}{row_num}'
            if not re.search(condition2_pattern, formula_upper):
                logger.error(f"Cell {target_column}{row_num} formula should have condition: {source_sheet}!{source_column_b}...={target_column_b}{row_num}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 5: Returns values from source column C
            # Pattern: source_sheet!$C$2:$C$19 (or similar row references)
            return_pattern = rf'{re.escape(source_sheet)}[!\.][\$]?{source_column_c}[\$]?\d+:\$?{source_column_c}[\$]?\d+'
            if not re.search(return_pattern, formula_upper):
                logger.error(f"Cell {target_column}{row_num} formula should return values from {source_sheet}!{source_column_c}...")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 6: Data range should match expected range
            range_pattern = rf'{re.escape(source_sheet)}[!\.][\$]?{source_column_a}[\$]?{data_range_start}:\$?{source_column_a}[\$]?{data_range_end}'
            if not re.search(range_pattern, formula_upper):
                logger.warning(f"Cell {target_column}{row_num} formula may not use expected data range {data_range_start}:{data_range_end}")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn
            
            logger.debug(f"✓ Row {row_num} formula passed all checks")
        
        if rows_checked == 0:
            logger.error("No rows with data found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ SUMPRODUCT cross-sheet lookup verification passed")
            logger.info(f"  Rows checked: {rows_checked}")
            logger.info(f"  Target sheet: {target_sheet}, Column: {target_column}")
            logger.info(f"  Source sheet: {source_sheet}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ SUMPRODUCT cross-sheet lookup verification failed")
            logger.error(f"  Rows checked: {rows_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_substitute_remove_spaces(result: str, expected: str = None, **options) -> float:
    """
    Verify if SUBSTITUTE formulas exist in specified columns to remove spaces.
    
    This function checks:
    1. Whether cells in specified columns contain SUBSTITUTE formulas
    2. Whether formulas reference the corresponding source column cells
    3. Whether formulas use SUBSTITUTE to replace space with empty string
    
    Expected formula pattern: =SUBSTITUTE(A2," ",) or =SUBSTITUTE(A2," ","")
    
    The function automatically detects the number of data rows by checking the data column
    for non-empty cells. It stops checking after finding 3 consecutive empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_columns: List of columns to check (e.g., ["C", "D"])
            - source_columns: List of corresponding source columns (e.g., ["A", "B"])
            - start_row: Starting row number (default: 2)
            - expected_functions: List of expected function names (default: ["SUBSTITUTE"])
            - data_column: Column to check for data to determine end_row (default: "A")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_columns = options.get('check_columns', ['C', 'D'])
        source_columns = options.get('source_columns', ['A', 'B'])
        start_row = options.get('start_row', 2)
        expected_functions = options.get('expected_functions', ['SUBSTITUTE'])
        data_column = options.get('data_column', 'A')
        
        if len(check_columns) != len(source_columns):
            logger.error("check_columns and source_columns must have the same length")
            return 0.0
        
        logger.info(f"Verifying SUBSTITUTE remove spaces formulas in file: {result}")
        logger.info(f"Check columns: {check_columns}")
        logger.info(f"Source columns: {source_columns}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Expected functions: {expected_functions}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Check formulas in each column
        all_checks_passed = True
        rows_checked = 0
        
        for col_idx, check_column in enumerate(check_columns):
            source_column = source_columns[col_idx]
            logger.info(f"Checking column {check_column} (from {source_column})...")
            
            for row_num in range(start_row, end_row + 1):
                check_cell = ws[f"{check_column}{row_num}"]
                source_cell = ws[f"{source_column}{row_num}"]
                
                # Skip if source cell is empty
                if source_cell.value is None:
                    continue
                
                rows_checked += 1
                
                # Check if cell contains a formula
                if check_cell.data_type != "f":
                    logger.error(f"Cell {check_column}{row_num} does not contain a formula")
                    all_checks_passed = False
                    continue
                
                # Get formula text
                formula = None
                if hasattr(check_cell, "_value") and isinstance(check_cell._value, str) and check_cell._value.startswith("="):
                    formula = check_cell._value
                elif hasattr(check_cell, "formula"):
                    formula = check_cell.formula
                else:
                    if check_cell.value is not None and isinstance(check_cell.value, str) and check_cell.value.startswith("="):
                        formula = check_cell.value
                
                if formula is None:
                    logger.error(f"Could not extract formula from cell {check_column}{row_num}")
                    all_checks_passed = False
                    continue
                
                formula_upper = formula.upper()
                logger.debug(f"Row {row_num} {check_column} formula: {formula}")
                
                # Check 1: Contains SUBSTITUTE function
                if 'SUBSTITUTE' not in formula_upper:
                    logger.error(f"Cell {check_column}{row_num} formula should contain SUBSTITUTE function")
                    logger.error(f"  Formula: {formula}")
                    all_checks_passed = False
                    continue
                
                # Check 2: References source column cell
                source_pattern = rf'{source_column}{row_num}\b'
                if not re.search(source_pattern, formula_upper):
                    logger.error(f"Cell {check_column}{row_num} formula should reference {source_column}{row_num}")
                    logger.error(f"  Formula: {formula}")
                    all_checks_passed = False
                    continue
                
                # Check 3: SUBSTITUTE replaces space with empty string
                # Pattern: SUBSTITUTE(...," ",) or SUBSTITUTE(...," ","")
                # The space might be in single or double quotes
                substitute_pattern1 = r'SUBSTITUTE\s*\([^,]+,\s*["\']?\s+["\']?\s*,\s*\)'  # SUBSTITUTE(...," ",)
                substitute_pattern2 = r'SUBSTITUTE\s*\([^,]+,\s*["\']?\s+["\']?\s*,\s*["\']?\s*["\']?\s*\)'  # SUBSTITUTE(...," ","")
                if not re.search(substitute_pattern1, formula_upper) and not re.search(substitute_pattern2, formula_upper):
                    logger.error(f"Cell {check_column}{row_num} SUBSTITUTE should replace space with empty string")
                    logger.error(f"  Formula: {formula}")
                    all_checks_passed = False
                    continue
                
                logger.debug(f"✓ Row {row_num} {check_column} formula passed all checks")
        
        if rows_checked == 0:
            logger.error("No rows with data found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ SUBSTITUTE remove spaces verification passed")
            logger.info(f"  Rows checked: {rows_checked}")
            logger.info(f"  Check columns: {check_columns}")
            logger.info(f"  Source columns: {source_columns}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ SUBSTITUTE remove spaces verification failed")
            logger.error(f"  Rows checked: {rows_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_substitute_remove_spaces(result: str, expected: str = None, **options) -> float:
    """
    Verify if SUBSTITUTE formulas exist in specified columns to remove spaces.
    
    This function checks:
    1. Whether cells in specified columns contain SUBSTITUTE formulas
    2. Whether formulas reference the corresponding source column cells
    3. Whether formulas use SUBSTITUTE to replace space with empty string
    
    Expected formula pattern: =SUBSTITUTE(A2," ",) or =SUBSTITUTE(A2," ","")
    
    The function automatically detects the number of data rows by checking the data column
    for non-empty cells. It stops checking after finding 3 consecutive empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_columns: List of columns to check (e.g., ["C", "D"])
            - source_columns: List of corresponding source columns (e.g., ["A", "B"])
            - start_row: Starting row number (default: 2)
            - expected_functions: List of expected function names (default: ["SUBSTITUTE"])
            - data_column: Column to check for data to determine end_row (default: "A")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_columns = options.get('check_columns', ['C', 'D'])
        source_columns = options.get('source_columns', ['A', 'B'])
        start_row = options.get('start_row', 2)
        expected_functions = options.get('expected_functions', ['SUBSTITUTE'])
        data_column = options.get('data_column', 'A')
        
        if len(check_columns) != len(source_columns):
            logger.error("check_columns and source_columns must have the same length")
            return 0.0
        
        logger.info(f"Verifying SUBSTITUTE remove spaces formulas in file: {result}")
        logger.info(f"Check columns: {check_columns}")
        logger.info(f"Source columns: {source_columns}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Expected functions: {expected_functions}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Check formulas in each column
        all_checks_passed = True
        rows_checked = 0
        
        for col_idx, check_column in enumerate(check_columns):
            source_column = source_columns[col_idx]
            logger.info(f"Checking column {check_column} (from {source_column})...")
            
            for row_num in range(start_row, end_row + 1):
                check_cell = ws[f"{check_column}{row_num}"]
                source_cell = ws[f"{source_column}{row_num}"]
                
                # Skip if source cell is empty
                if source_cell.value is None:
                    continue
                
                rows_checked += 1
                
                # Check if cell contains a formula
                if check_cell.data_type != "f":
                    logger.error(f"Cell {check_column}{row_num} does not contain a formula")
                    all_checks_passed = False
                    continue
                
                # Get formula text
                formula = None
                if hasattr(check_cell, "_value") and isinstance(check_cell._value, str) and check_cell._value.startswith("="):
                    formula = check_cell._value
                elif hasattr(check_cell, "formula"):
                    formula = check_cell.formula
                else:
                    if check_cell.value is not None and isinstance(check_cell.value, str) and check_cell.value.startswith("="):
                        formula = check_cell.value
                
                if formula is None:
                    logger.error(f"Could not extract formula from cell {check_column}{row_num}")
                    all_checks_passed = False
                    continue
                
                formula_upper = formula.upper()
                logger.debug(f"Row {row_num} {check_column} formula: {formula}")
                
                # Check 1: Contains SUBSTITUTE function
                if 'SUBSTITUTE' not in formula_upper:
                    logger.error(f"Cell {check_column}{row_num} formula should contain SUBSTITUTE function")
                    logger.error(f"  Formula: {formula}")
                    all_checks_passed = False
                    continue
                
                # Check 2: References source column cell
                source_pattern = rf'{source_column}{row_num}\b'
                if not re.search(source_pattern, formula_upper):
                    logger.error(f"Cell {check_column}{row_num} formula should reference {source_column}{row_num}")
                    logger.error(f"  Formula: {formula}")
                    all_checks_passed = False
                    continue
                
                # Check 3: SUBSTITUTE replaces space with empty string
                # Pattern: SUBSTITUTE(...," ",) or SUBSTITUTE(...," ","")
                # The space might be in single or double quotes
                substitute_pattern1 = r'SUBSTITUTE\s*\([^,]+,\s*["\']?\s+["\']?\s*,\s*\)'  # SUBSTITUTE(...," ",)
                substitute_pattern2 = r'SUBSTITUTE\s*\([^,]+,\s*["\']?\s+["\']?\s*,\s*["\']?\s*["\']?\s*\)'  # SUBSTITUTE(...," ","")
                if not re.search(substitute_pattern1, formula_upper) and not re.search(substitute_pattern2, formula_upper):
                    logger.error(f"Cell {check_column}{row_num} SUBSTITUTE should replace space with empty string")
                    logger.error(f"  Formula: {formula}")
                    all_checks_passed = False
                    continue
                
                logger.debug(f"✓ Row {row_num} {check_column} formula passed all checks")
        
        if rows_checked == 0:
            logger.error("No rows with data found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ SUBSTITUTE remove spaces verification passed")
            logger.info(f"  Rows checked: {rows_checked}")
            logger.info(f"  Check columns: {check_columns}")
            logger.info(f"  Source columns: {source_columns}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ SUBSTITUTE remove spaces verification failed")
            logger.error(f"  Rows checked: {rows_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_concatenate_columns_with_separator(result: str, expected: str = None, **options) -> float:
    """
    Verify if columns are concatenated with a separator using the & operator.
    
    This function checks:
    1. Whether the target column contains formulas that concatenate source columns
    2. Whether the formula uses the & operator for concatenation
    3. Whether the formula includes the specified separator
    4. Whether the formula is applied to all data rows
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - target_column: Column where concatenated results should appear (e.g., "C")
            - source_columns: List of source columns to concatenate (e.g., ["A", "B"])
            - separator: Separator string between columns (e.g., " ")
            - start_row: First data row (default: 1)
            - header_row: Header row number (default: 1)
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        target_column = options.get('target_column', 'C')
        source_columns = options.get('source_columns', ['A', 'B'])
        separator = options.get('separator', ' ')
        start_row = options.get('start_row', 1)
        header_row = options.get('header_row', 1)
        
        # Load workbook to get formulas
        wb = openpyxl.load_workbook(result, data_only=False)
        ws = wb.active
        
        # Auto-detect data rows by checking for consecutive empty rows
        max_check_row = 1000
        data_end_row = start_row
        consecutive_empty = 0
        
        for row_idx in range(start_row, max_check_row):
            # Check if source columns are empty
            all_empty = True
            for col in source_columns:
                cell_value = ws[f"{col}{row_idx}"].value
                if cell_value is not None and str(cell_value).strip() != "":
                    all_empty = False
                    break
            
            if all_empty:
                consecutive_empty += 1
                if consecutive_empty >= 3:  # 3 consecutive empty rows means end of data
                    break
            else:
                consecutive_empty = 0
                data_end_row = row_idx
        
        logger.info(f"Detected data rows from {start_row} to {data_end_row}")
        
        if data_end_row < start_row:
            logger.error(f"No data rows found starting from row {start_row}")
            return 0.0
        
        # Check formulas in target column
        formula_count = 0
        valid_formula_count = 0
        
        for row_idx in range(start_row, data_end_row + 1):
            target_cell = ws[f"{target_column}{row_idx}"]
            
            # Get formula text
            formula_text = None
            if hasattr(target_cell, "_value") and isinstance(target_cell._value, str) and target_cell._value.startswith("="):
                formula_text = target_cell._value
            elif hasattr(target_cell, "formula"):
                formula_text = target_cell.formula
            elif target_cell.value is not None and isinstance(target_cell.value, str) and target_cell.value.startswith("="):
                formula_text = target_cell.value
            
            if formula_text is None:
                # Check if cell has a value (might be calculated)
                if target_cell.value is not None and str(target_cell.value).strip() != "":
                    # Check if the value matches expected concatenation
                    source_values = []
                    for col in source_columns:
                        val = ws[f"{col}{row_idx}"].value
                        if val is not None:
                            source_values.append(str(val))
                    
                    expected_value = separator.join(source_values)
                    actual_value = str(target_cell.value).strip()
                    
                    if actual_value == expected_value:
                        valid_formula_count += 1
                continue
            
            formula_count += 1
            
            # Remove leading = sign
            formula_clean = formula_text[1:] if formula_text.startswith("=") else formula_text
            formula_upper = formula_clean.upper()
            
            # Check 1: Formula contains & operator
            if "&" not in formula_clean:
                logger.warning(f"Row {row_idx}: Formula does not contain & operator")
                continue
            
            # Check 2: Formula references source columns
            all_columns_referenced = True
            for col in source_columns:
                # Check for column reference (e.g., A1, A2, etc.)
                col_pattern = rf'\b{col}{row_idx}\b'
                if not re.search(col_pattern, formula_upper):
                    logger.warning(f"Row {row_idx}: Formula does not reference column {col}")
                    all_columns_referenced = False
                    break
            
            if not all_columns_referenced:
                continue
            
            # Check 3: Formula contains separator (if not empty)
            if separator:
                # Escape special regex characters in separator
                escaped_sep = re.escape(separator)
                # Check for separator in quotes
                sep_pattern = rf'["\'].*{escaped_sep}.*["\']'
                if not re.search(sep_pattern, formula_clean):
                    logger.warning(f"Row {row_idx}: Formula does not contain separator '{separator}'")
                    continue
            
            valid_formula_count += 1
        
        # Calculate success rate
        total_rows = data_end_row - start_row + 1
        success_rate = valid_formula_count / total_rows if total_rows > 0 else 0.0
        
        logger.info(f"Valid formulas: {valid_formula_count}/{total_rows} (success rate: {success_rate:.2%})")
        
        # Require at least 90% of rows to have valid formulas
        if success_rate >= 0.9:
            logger.info(f"✓ Column concatenation verification passed")
            return 1.0
        else:
            logger.error(f"Column concatenation verification failed: only {success_rate:.2%} of rows have valid formulas")
            return 0.0
    
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_tocol_torow_merge(result: str, expected: str = None, **options) -> float:
    """
    Verify if formulas exist to merge two columns using TOCOL/TOROW or INDEX/ROUNDUP/ROW/MOD/ROWS.
    
    This function checks:
    1. Whether the result column contains appropriate formulas
    2. Whether formulas reference the correct source columns
    3. Whether formulas use concatenation operator (&) to merge the columns
    
    Expected formula patterns:
    - Pattern 1: =TOCOL(C1:C20&","&TOROW(G1:G6))
    - Pattern 2: =INDEX($C$1:$C$20,ROUNDUP(ROW(A1)/ROWS($G$1:$G$6),0))&","&INDEX($G$1:$G$6,MOD(ROW(A1)-1,ROWS($G$1:$G$6))+1)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - result_column: Column with merged results (e.g., "H")
            - result_cell: Starting cell for the formula (e.g., "H1")
            - source_column1: First source column (e.g., "C")
            - source_range1: First source range (e.g., "C1:C20")
            - source_column2: Second source column (e.g., "G")
            - source_range2: Second source range (e.g., "G1:G6")
            - separator: Separator used in concatenation (e.g., ",")
            - expected_functions: List of expected function names (default: ["TOCOL", "TOROW"] or ["INDEX", "ROUNDUP", "ROW", "MOD", "ROWS"])
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        result_column = options.get('result_column', 'H')
        result_cell = options.get('result_cell', 'H1')
        source_column1 = options.get('source_column1', 'C')
        source_range1 = options.get('source_range1', 'C1:C20')
        source_column2 = options.get('source_column2', 'G')
        source_range2 = options.get('source_range2', 'G1:G6')
        separator = options.get('separator', ',')
        expected_functions = options.get('expected_functions', ['TOCOL', 'TOROW'])
        
        logger.info(f"Verifying TOCOL/TOROW merge formulas in file: {result}")
        logger.info(f"Result cell: {result_cell}")
        logger.info(f"Source range 1: {source_range1}")
        logger.info(f"Source range 2: {source_range2}")
        logger.info(f"Separator: {separator}")
        logger.info(f"Expected functions: {expected_functions}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check the result cell and nearby cells (in case formula starts from H2, H3, etc.)
        # For INDEX/ROUNDUP/ROW/MOD/ROWS pattern, formula should be in multiple rows
        formula = None
        checked_cell = None
        
        # Try to find formula in result_cell and nearby rows (up to 10 rows)
        result_col = result_column
        result_row = int(re.search(r'\d+', result_cell).group()) if re.search(r'\d+', result_cell) else 1
        
        for row_offset in range(10):  # Check up to 10 rows
            try:
                check_row = result_row + row_offset
                check_cell_coord = f"{result_col}{check_row}"
                cell = ws[check_cell_coord]
                
                # Check if cell contains a formula
                if cell.data_type == "f":
                    # Get formula text
                    if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                        formula = cell._value
                        checked_cell = check_cell_coord
                        break
                    elif hasattr(cell, "formula"):
                        formula = cell.formula
                        checked_cell = check_cell_coord
                        break
                    elif cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula = cell.value
                        checked_cell = check_cell_coord
                        break
            except Exception:
                continue
        
        if formula is None:
            logger.error(f"Could not find formula in {result_column} column (checked rows {result_row} to {result_row + 9})")
            return 0.0
        
        logger.info(f"Found formula in cell {checked_cell}")
        
        formula_upper = formula.upper()
        logger.debug(f"Cell {checked_cell} formula: {formula}")
        
        # Check which pattern is used
        has_tocol = 'TOCOL' in formula_upper
        has_torow = 'TOROW' in formula_upper
        has_index = 'INDEX' in formula_upper
        has_roundup = 'ROUNDUP' in formula_upper
        has_row = 'ROW' in formula_upper
        has_mod = 'MOD' in formula_upper
        has_rows = 'ROWS' in formula_upper
        
        # Pattern 1: TOCOL/TOROW pattern
        if has_tocol and has_torow:
            logger.info("Detected TOCOL/TOROW pattern")
            
            # Check 1: References first source range
            range1_escaped = re.escape(source_range1)
            if not re.search(range1_escaped, formula_upper):
                logger.error(f"Cell {result_cell} formula should reference range {source_range1}")
                logger.error(f"  Formula: {formula}")
                return 0.0
            
            # Check 2: References second source range (within TOROW)
            range2_escaped = re.escape(source_range2)
            torow_pattern = rf'TOROW\s*\(\s*{range2_escaped}\s*\)'
            if not re.search(torow_pattern, formula_upper):
                logger.error(f"Cell {result_cell} TOROW function should reference range {source_range2}")
                logger.error(f"  Formula: {formula}")
                return 0.0
            
            # Check 3: Contains concatenation operator (&)
            if '&' not in formula:
                logger.error(f"Cell {result_cell} formula should use concatenation operator (&)")
                logger.error(f"  Formula: {formula}")
                return 0.0
        
        # Pattern 2: INDEX/ROUNDUP/ROW/MOD/ROWS pattern
        elif has_index and has_roundup and has_row and has_mod and has_rows:
            logger.info("Detected INDEX/ROUNDUP/ROW/MOD/ROWS pattern")
            
            # Check 1: References first source range (in INDEX)
            # The range might use absolute references like $C$1:$C$20
            range1_escaped = re.escape(source_range1)
            range1_abs_escaped = re.escape(source_range1.replace('C', '\\$?C').replace(':', '\\$?:'))
            index1_pattern = rf'INDEX\s*\(\s*[\$]?{source_column1}[\$]?\d+:\$?{source_column1}[\$]?\d+'
            if not re.search(index1_pattern, formula_upper):
                logger.error(f"Cell {checked_cell} first INDEX should reference range {source_range1}")
                logger.error(f"  Formula: {formula}")
                return 0.0
            
            # Check 2: References second source range (in second INDEX)
            range2_escaped = re.escape(source_range2)
            index2_pattern = rf'INDEX\s*\(\s*[\$]?{source_column2}[\$]?\d+:\$?{source_column2}[\$]?\d+'
            if not re.search(index2_pattern, formula_upper):
                logger.error(f"Cell {checked_cell} second INDEX should reference range {source_range2}")
                logger.error(f"  Formula: {formula}")
                return 0.0
            
            # Check 3: Contains ROUNDUP with ROW and ROWS
            # ROWS might reference the second range with absolute references
            rows_pattern = rf'ROWS\s*\(\s*[\$]?{source_column2}[\$]?\d+:\$?{source_column2}[\$]?\d+\s*\)'
            roundup_pattern = rf'ROUNDUP\s*\(\s*ROW\s*\([^)]+\)\s*/\s*{rows_pattern}'
            if not re.search(roundup_pattern, formula_upper):
                logger.warning(f"Cell {checked_cell} ROUNDUP may not have correct structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn
            
            # Check 4: Contains MOD with ROW and ROWS
            mod_pattern = rf'MOD\s*\(\s*ROW\s*\([^)]+\)\s*-\s*\d+\s*,\s*{rows_pattern}'
            if not re.search(mod_pattern, formula_upper):
                logger.warning(f"Cell {checked_cell} MOD may not have correct structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn
            
            # Check 5: Contains concatenation operator (&)
            if '&' not in formula:
                logger.error(f"Cell {checked_cell} formula should use concatenation operator (&)")
                logger.error(f"  Formula: {formula}")
                return 0.0
        
        else:
            # Check if at least some expected functions are present
            missing_functions = []
            for func in expected_functions:
                if func.upper() not in formula_upper:
                    missing_functions.append(func)
            
            if missing_functions:
                logger.error(f"Cell {checked_cell} formula missing functions: {missing_functions}")
                logger.error(f"  Formula: {formula}")
                logger.error(f"  Expected pattern: TOCOL/TOROW or INDEX/ROUNDUP/ROW/MOD/ROWS")
                return 0.0
        
        # Common check: Contains separator in concatenation
        separator_escaped = re.escape(separator)
        separator_pattern = rf'&\s*["\']?{separator_escaped}["\']?\s*&'
        if not re.search(separator_pattern, formula_upper):
            logger.warning(f"Cell {checked_cell} formula may not use separator '{separator}' correctly")
            logger.debug(f"  Formula: {formula}")
            # Don't fail, just warn - separator might be in quotes or formatted differently
        
        logger.info("=" * 60)
        logger.info(f"✓ TOCOL/TOROW merge verification passed")
        logger.info(f"  Result cell: {checked_cell}")
        logger.info(f"  Source range 1: {source_range1}")
        logger.info(f"  Source range 2: {source_range2}")
        logger.info(f"  Formula: {formula}")
        logger.info("=" * 60)
        return 1.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_text_prefix_format(result: str, expected: str = None, **options) -> float:
    """
    Verify if formulas exist to add text prefix (like apostrophe) to values.
    
    This function checks:
    1. Whether cells in result column contain formulas
    2. Whether formulas use concatenation operator (&) to add prefix
    3. Whether formulas reference the corresponding source column cells
    
    Expected formula pattern: ="'"&A3
    
    The function automatically detects the number of data rows by checking the source column
    for non-empty cells. It stops checking after finding 3 consecutive empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - result_column: Column with formulas (e.g., "F")
            - source_column: Source column (e.g., "A")
            - start_row: Starting row number (default: 2)
            - prefix: Prefix text to add (e.g., "'")
            - data_column: Column to check for data to determine end_row (default: source_column)
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        result_column = options.get('result_column', 'F')
        source_column = options.get('source_column', 'A')
        start_row = options.get('start_row', 2)
        prefix = options.get('prefix', "'")
        data_column = options.get('data_column', source_column)
        
        logger.info(f"Verifying text prefix format formulas in file: {result}")
        logger.info(f"Result column: {result_column}")
        logger.info(f"Source column: {source_column}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Prefix: {prefix}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Check formulas in result column
        all_checks_passed = True
        rows_checked = 0
        
        for row_num in range(start_row, end_row + 1):
            result_cell = ws[f"{result_column}{row_num}"]
            source_cell = ws[f"{source_column}{row_num}"]
            
            # Skip if source cell is empty
            if source_cell.value is None:
                continue
            
            rows_checked += 1
            
            # Check if cell contains a formula
            if result_cell.data_type != "f":
                logger.error(f"Cell {result_column}{row_num} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(result_cell, "_value") and isinstance(result_cell._value, str) and result_cell._value.startswith("="):
                formula = result_cell._value
            elif hasattr(result_cell, "formula"):
                formula = result_cell.formula
            else:
                if result_cell.value is not None and isinstance(result_cell.value, str) and result_cell.value.startswith("="):
                    formula = result_cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {result_column}{row_num}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Row {row_num} formula: {formula}")
            
            # Check 1: Contains concatenation operator (&)
            if '&' not in formula:
                logger.error(f"Cell {result_column}{row_num} formula should use concatenation operator (&)")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References source column cell
            source_pattern = rf'{source_column}{row_num}\b'
            if not re.search(source_pattern, formula_upper):
                logger.error(f"Cell {result_column}{row_num} formula should reference {source_column}{row_num}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains prefix in formula
            # Prefix might be in quotes: "'" or '"' or just '
            prefix_escaped = re.escape(prefix)
            # Pattern: ="'"&A3 or ='"'&A3 or ='&A3
            prefix_pattern1 = rf'=\s*["\']{prefix_escaped}["\']\s*&'
            prefix_pattern2 = rf'=\s*{prefix_escaped}\s*&'
            if not re.search(prefix_pattern1, formula) and not re.search(prefix_pattern2, formula):
                logger.error(f"Cell {result_column}{row_num} formula should contain prefix '{prefix}'")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            logger.debug(f"✓ Row {row_num} formula passed all checks")
        
        if rows_checked == 0:
            logger.error("No rows with data found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ Text prefix format verification passed")
            logger.info(f"  Rows checked: {rows_checked}")
            logger.info(f"  Result column: {result_column}")
            logger.info(f"  Source column: {source_column}")
            logger.info(f"  Prefix: {prefix}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ Text prefix format verification failed")
            logger.error(f"  Rows checked: {rows_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_match_percentile_filter(result: str, expected: str = None, **options) -> float:
    """
    Verify if MATCH and PERCENTILE formulas exist to filter top 10% and bottom 10% data.
    
    This function checks:
    1. Whether cells in result column contain MATCH and PERCENTILE formulas
    2. Whether formulas reference the correct source column
    3. Whether PERCENTILE uses correct percentiles array {0,10,90}%
    
    Expected formula pattern: =MATCH(A2,PERCENTILE(A:A,{0,10,90}%))
    
    The function automatically detects the number of data rows by checking the source column
    for non-empty cells. It stops checking after finding 3 consecutive empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - result_column: Column with formulas (e.g., "D")
            - source_column: Source column (e.g., "A")
            - start_row: Starting row number (default: 1)
            - expected_functions: List of expected function names (default: ["MATCH", "PERCENTILE"])
            - expected_percentiles: Expected percentiles array (default: "{0,10,90}%")
            - data_column: Column to check for data to determine end_row (default: source_column)
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        result_column = options.get('result_column', 'D')
        source_column = options.get('source_column', 'A')
        start_row = options.get('start_row', 1)
        expected_functions = options.get('expected_functions', ['MATCH', 'PERCENTILE'])
        expected_percentiles = options.get('expected_percentiles', '{0,10,90}%')
        data_column = options.get('data_column', source_column)
        
        logger.info(f"Verifying MATCH/PERCENTILE filter formulas in file: {result}")
        logger.info(f"Result column: {result_column}")
        logger.info(f"Source column: {source_column}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Expected functions: {expected_functions}")
        logger.info(f"Expected percentiles: {expected_percentiles}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Check formulas in result column
        all_checks_passed = True
        rows_checked = 0
        
        for row_num in range(start_row, end_row + 1):
            result_cell = ws[f"{result_column}{row_num}"]
            source_cell = ws[f"{source_column}{row_num}"]
            
            # Skip if source cell is empty
            if source_cell.value is None:
                continue
            
            rows_checked += 1
            
            # Check if cell contains a formula
            if result_cell.data_type != "f":
                logger.error(f"Cell {result_column}{row_num} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(result_cell, "_value") and isinstance(result_cell._value, str) and result_cell._value.startswith("="):
                formula = result_cell._value
            elif hasattr(result_cell, "formula"):
                formula = result_cell.formula
            else:
                if result_cell.value is not None and isinstance(result_cell.value, str) and result_cell.value.startswith("="):
                    formula = result_cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {result_column}{row_num}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Row {row_num} formula: {formula}")
            
            # Check 1: Contains MATCH function
            if 'MATCH' not in formula_upper:
                logger.error(f"Cell {result_column}{row_num} formula should contain MATCH function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: Contains PERCENTILE function
            if 'PERCENTILE' not in formula_upper:
                logger.error(f"Cell {result_column}{row_num} formula should contain PERCENTILE function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: MATCH references source column cell
            source_pattern = rf'{source_column}{row_num}\b'
            if not re.search(source_pattern, formula_upper):
                logger.error(f"Cell {result_column}{row_num} MATCH should reference {source_column}{row_num}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: PERCENTILE references source column range
            percentile_range_pattern = rf'PERCENTILE\s*\(\s*{source_column}\s*:\s*{source_column}'
            if not re.search(percentile_range_pattern, formula_upper):
                logger.error(f"Cell {result_column}{row_num} PERCENTILE should reference {source_column}:{source_column}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 5: PERCENTILE contains expected percentiles array
            # Pattern: {0,10,90}% or {0, 10, 90}% (with or without spaces)
            percentiles_pattern = r'\{[^}]*0[^}]*,[^}]*10[^}]*,[^}]*90[^}]*\}'
            if not re.search(percentiles_pattern, formula_upper):
                logger.warning(f"Cell {result_column}{row_num} PERCENTILE may not have correct percentiles array")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the array format might vary
            
            # Check 6: PERCENTILE percentiles array ends with %
            percent_pattern = r'\{[^}]*\}\s*%'
            if not re.search(percent_pattern, formula_upper):
                logger.warning(f"Cell {result_column}{row_num} PERCENTILE percentiles array should end with %")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn
            
            logger.debug(f"✓ Row {row_num} formula passed all checks")
        
        if rows_checked == 0:
            logger.error("No rows with data found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MATCH/PERCENTILE filter verification passed")
            logger.info(f"  Rows checked: {rows_checked}")
            logger.info(f"  Result column: {result_column}")
            logger.info(f"  Source column: {source_column}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MATCH/PERCENTILE filter verification failed")
            logger.error(f"  Rows checked: {rows_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_sumproduct_month_customer_count(result: str, expected: str = None, **options) -> float:
    """
    Verify if SUMPRODUCT formulas exist to count contracts and sum amounts for a specific month and customer.
    
    This function checks:
    1. Whether specified cells contain SUMPRODUCT formulas
    2. Whether formulas use MONTH function to check month
    3. Whether formulas use double negation (--) to convert boolean to number
    4. Whether formulas check customer name match
    
    Expected formula patterns:
    - B28: =SUMPRODUCT(--(MONTH(A2:A24)=6),--(B2:B24=A28)) (count contracts)
    - C28: =SUMPRODUCT(--(MONTH(A2:A24)=6),--(B2:B24=A28),C2:C24) (sum amounts)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "B28": {"type": "count", "date_range": "A2:A24", "customer_range": "B2:B24", "customer_cell": "A28", "month": 6},
                  "C28": {"type": "sum", "date_range": "A2:A24", "customer_range": "B2:B24", "customer_cell": "A28", "amount_range": "C2:C24", "month": 6}
              }
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying SUMPRODUCT month/customer count formulas in file: {result}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            formula_type = formula_info.get('type', '')  # 'count' or 'sum'
            date_range = formula_info.get('date_range', 'A2:A24')
            customer_range = formula_info.get('customer_range', 'B2:B24')
            customer_cell = formula_info.get('customer_cell', 'A28')
            month = formula_info.get('month', 6)
            amount_range = formula_info.get('amount_range', 'C2:C24')
            
            logger.info(f"Checking cell {cell_coord}: {formula_type} formula")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains SUMPRODUCT function
            if 'SUMPRODUCT' not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain SUMPRODUCT function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: Contains MONTH function
            if 'MONTH' not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain MONTH function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: MONTH references date range (support both absolute and relative references)
            # Pattern: MONTH($A$2:$A$24) or MONTH(A2:A24)
            date_col_start = date_range.split(':')[0]  # e.g., "A2" or "$A$2"
            date_col_end = date_range.split(':')[1] if ':' in date_range else date_range  # e.g., "A24" or "$A$24"
            # Extract column letter and row numbers
            date_col_match = re.match(r'[\$]?([A-Z]+)[\$]?(\d+)', date_col_start)
            if date_col_match:
                date_col = date_col_match.group(1)
                date_start_row = date_col_match.group(2)
            else:
                date_col = 'A'
                date_start_row = '2'
            
            date_end_match = re.match(r'[\$]?([A-Z]+)[\$]?(\d+)', date_col_end)
            if date_end_match:
                date_end_row = date_end_match.group(2)
            else:
                date_end_row = '24'
            
            # Pattern: MONTH($A$2:$A$24) or MONTH(A2:A24) - support both absolute and relative
            month_pattern = rf'MONTH\s*\(\s*[\$]?{date_col}[\$]?\d+:\$?{date_col}[\$]?\d+\s*\)'
            if not re.search(month_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} MONTH should reference range like {date_range} (absolute or relative)")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: MONTH equals specified month
            month_check_pattern = rf'MONTH\s*\(\s*[\$]?{date_col}[\$]?\d+:\$?{date_col}[\$]?\d+\s*\)\s*=\s*{month}'
            if not re.search(month_check_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} MONTH should equal {month}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 5: Contains double negation (--)
            if '--' not in formula:
                logger.error(f"Cell {cell_coord} formula should use double negation (--) to convert boolean to number")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 6: Customer range equals customer cell (support both absolute and relative references)
            # Pattern: $B$2:$B$24=A28 or B2:B24=A28
            customer_col_start = customer_range.split(':')[0] if ':' in customer_range else customer_range
            customer_col_match = re.match(r'[\$]?([A-Z]+)[\$]?(\d+)', customer_col_start)
            if customer_col_match:
                customer_col = customer_col_match.group(1)
            else:
                customer_col = 'B'
            
            customer_cell_match = re.match(r'[\$]?([A-Z]+)[\$]?(\d+)', customer_cell)
            if customer_cell_match:
                customer_cell_col = customer_cell_match.group(1)
                customer_cell_row = customer_cell_match.group(2)
            else:
                customer_cell_col = 'A'
                customer_cell_row = '28'
            
            # Pattern: $B$2:$B$24=A28 or B2:B24=A28
            customer_pattern = rf'[\$]?{customer_col}[\$]?\d+:\$?{customer_col}[\$]?\d+\s*=\s*{customer_cell_col}{customer_cell_row}'
            if not re.search(customer_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should check {customer_range}={customer_cell}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 7: For sum type, should reference amount range (support both absolute and relative)
            if formula_type == 'sum':
                amount_col_start = amount_range.split(':')[0] if ':' in amount_range else amount_range
                amount_col_match = re.match(r'[\$]?([A-Z]+)[\$]?(\d+)', amount_col_start)
                if amount_col_match:
                    amount_col = amount_col_match.group(1)
                else:
                    amount_col = 'C'
                
                # Pattern: $C$2:$C$24 or C2:C24
                amount_pattern = rf'[\$]?{amount_col}[\$]?\d+:\$?{amount_col}[\$]?\d+'
                if not re.search(amount_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} sum formula should reference amount range {amount_range} (absolute or relative)")
                    logger.error(f"  Formula: {formula}")
                    all_checks_passed = False
                    continue
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ SUMPRODUCT month/customer count verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ SUMPRODUCT month/customer count verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_sum_value_text_conversion(result: str, expected: str = None, **options) -> float:
    """
    Verify if SUM(VALUE(...), ...) formulas exist in specified column to sum text and number values.
    
    This function checks:
    1. Whether specified cells contain SUM formulas
    2. Whether formulas contain VALUE function to convert text to number
    3. Whether formulas reference the correct text column and number column cells
    4. Whether formulas have the correct structure: SUM(VALUE(text_cell), number_cell)
    
    Expected formula pattern:
    - D2: =SUM(VALUE(B2), C2) (sum of text value in B2 converted to number and number value in C2)
    - D3: =SUM(VALUE(B3), C3) (and so on for other rows)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_column: Column to check (e.g., "D")
            - start_row: Starting row number (e.g., 2)
            - text_column: Column containing text values (e.g., "B")
            - number_column: Column containing number values (e.g., "C")
            - expected_functions: List of expected function names (default: ["SUM", "VALUE"])
            - data_column: Column to use for auto-detecting end row (e.g., "B")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_column = options.get('check_column', 'D')
        start_row = options.get('start_row', 2)
        text_column = options.get('text_column', 'B')
        number_column = options.get('number_column', 'C')
        expected_functions = options.get('expected_functions', ['SUM', 'VALUE'])
        data_column = options.get('data_column', 'B')
        
        logger.info(f"Verifying SUM(VALUE) text conversion formulas in file: {result}")
        logger.info(f"Column to check: {check_column}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Text column: {text_column}")
        logger.info(f"Number column: {number_column}")
        logger.info(f"Expected functions: {expected_functions}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row  # Start from start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Check each row in the specified column
        all_passed = True
        logger.info(f"Checking column {check_column} (rows {start_row} to {end_row})")
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{check_column}{row_num}"
            try:
                cell = ws[cell_coord]
                logger.debug(f"Checking cell {cell_coord}")
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.warning(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                else:
                    # Try to get from value attribute
                    if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains SUM function
                sum_pattern = r'\bSUM\s*\('
                if not re.search(sum_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not contain SUM function")
                    logger.warning(f"  Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 2: Formula contains VALUE function
                value_pattern = r'\bVALUE\s*\('
                if not re.search(value_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not contain VALUE function")
                    logger.warning(f"  Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: Formula structure is SUM(VALUE(...), ...)
                # Check that VALUE is inside SUM
                sum_value_pattern = r'SUM\s*\(\s*VALUE\s*\('
                if not re.search(sum_value_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not have correct SUM(VALUE(...)) structure")
                    logger.warning(f"  Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: VALUE function references the text column cell (e.g., B2, B3, etc.)
                expected_text_cell = f"{text_column}{row_num}"
                text_cell_pattern = rf'{text_column}{row_num}\b'
                if not re.search(text_cell_pattern, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {cell_coord} formula does not reference text column cell {expected_text_cell}")
                    logger.warning(f"  Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 5: Formula references the number column cell (e.g., C2, C3, etc.)
                expected_number_cell = f"{number_column}{row_num}"
                number_cell_pattern = rf'{number_column}{row_num}\b'
                if not re.search(number_cell_pattern, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {cell_coord} formula does not reference number column cell {expected_number_cell}")
                    logger.warning(f"  Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 6: Formula closes parentheses correctly
                open_count = formula_text.count('(')
                close_count = formula_text.count(')')
                if open_count != close_count:
                    logger.warning(f"Cell {cell_coord} formula has mismatched parentheses")
                    logger.warning(f"  Formula: {formula_text}")
                    all_passed = False
                    continue
                
                logger.info(f"✓ Cell {cell_coord} has valid SUM(VALUE) formula: {formula_text}")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        if all_passed:
            logger.info("=" * 60)
            logger.info(f"✓ All cells in column {check_column} contain correct SUM(VALUE) formulas")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ SUM(VALUE) formula verification failed")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0

def verify_sumif_offset_match(result: str, expected: str = None, **options) -> float:
    """
    Verify if SUMIF(OFFSET(MATCH(...))) formulas exist in specified range with correct structure.
    
    This function checks:
    1. Whether cells in specified range contain formulas
    2. Whether formulas contain SUMIF, OFFSET, and MATCH functions
    3. Whether SUMIF references the correct range (e.g., $A:$A)
    4. Whether SUMIF criteria references the correct column (e.g., $Q2)
    5. Whether OFFSET base is correct (e.g., $A$1)
    6. Whether MATCH lookup value references the correct row (e.g., R$1)
    7. Whether MATCH lookup array is correct (e.g., $B$1:$N$1)
    8. Whether formula structure is correct: SUMIF(range, criteria, OFFSET(base, , MATCH(...)))
    
    The function automatically detects the number of data rows by checking for non-empty cells
    in the specified range. It stops checking after finding 3 consecutive empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_range: Range to check (e.g., "R2:Y16")
            - expected_functions: List of expected function names (default: ["SUMIF", "OFFSET", "MATCH"])
            - sumif_range: SUMIF range reference (default: "$A:$A")
            - sumif_criteria_col: Column letter for SUMIF criteria (default: "Q")
            - offset_base: OFFSET base cell (default: "$A$1")
            - match_lookup_value_row: Row number for MATCH lookup value (default: 1)
            - match_lookup_array: MATCH lookup array range (default: "$B$1:$N$1")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_range = options.get('check_range', 'R2:Y16')
        expected_functions = options.get('expected_functions', ['SUMIF', 'OFFSET', 'MATCH'])
        sumif_range = options.get('sumif_range', '$A:$A')
        sumif_criteria_col = options.get('sumif_criteria_col', 'Q')
        offset_base = options.get('offset_base', '$A$1')
        match_lookup_value_row = options.get('match_lookup_value_row', 1)
        match_lookup_array = options.get('match_lookup_array', '$B$1:$N$1')
        
        logger.info(f"Verifying SUMIF(OFFSET(MATCH)) formulas in file: {result}")
        logger.info(f"Range to check: {check_range}")
        logger.info(f"Expected functions: {expected_functions}")
        
        # Parse the range manually
        try:
            # Remove $ signs and split by :
            range_clean = check_range.replace('$', '')
            if ':' in range_clean:
                start_cell, end_cell = range_clean.split(':')
                # Parse start cell
                start_col_letter = ''.join([c for c in start_cell if c.isalpha()])
                start_row = int(''.join([c for c in start_cell if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                # Parse end cell
                end_col_letter = ''.join([c for c in end_cell if c.isalpha()])
                end_row = int(''.join([c for c in end_cell if c.isdigit()]))
                end_col = column_index_from_string(end_col_letter)
            else:
                # Single cell
                start_col_letter = ''.join([c for c in range_clean if c.isalpha()])
                start_row = int(''.join([c for c in range_clean if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                end_col_letter = start_col_letter
                end_row = start_row
                end_col = start_col
        except Exception as e:
            logger.error(f"Failed to parse range {check_range}: {e}")
            return 0.0
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end row by checking for consecutive empty rows
        logger.info(f"Auto-detecting end row in range {check_range}...")
        detected_end_row = start_row
        empty_count = 0
        
        for row_num in range(start_row, end_row + 1):
            has_data = False
            for col_num in range(start_col, end_col + 1):
                col_letter = get_column_letter(col_num)
                cell = ws[f"{col_letter}{row_num}"]
                if cell.value is not None or (cell.data_type == "f"):
                    has_data = True
                    break
            
            if has_data:
                empty_count = 0
                detected_end_row = row_num
            else:
                empty_count += 1
                if empty_count >= 3:
                    break
        
        logger.info(f"Auto-detected end row: {detected_end_row}")
        actual_end_row = min(detected_end_row, end_row)
        
        # Check each cell in the range
        all_passed = True
        checked_count = 0
        passed_count = 0
        
        for row_num in range(start_row, actual_end_row + 1):
            for col_num in range(start_col, end_col + 1):
                col_letter = get_column_letter(col_num)
                cell_coord = f"{col_letter}{row_num}"
                
                try:
                    cell = ws[cell_coord]
                    checked_count += 1
                    
                    # Check if cell contains a formula
                    if cell.data_type != "f":
                        logger.warning(f"Cell {cell_coord} does not contain a formula")
                        all_passed = False
                        continue
                    
                    # Get formula text
                    formula_text = None
                    if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                        formula_text = cell._value
                    elif hasattr(cell, "formula"):
                        formula_text = cell.formula
                    else:
                        if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                            formula_text = cell.value
                    
                    if formula_text is None:
                        logger.warning(f"Could not extract formula from cell {cell_coord}")
                        all_passed = False
                        continue
                    
                    formula_upper = formula_text.upper()
                    logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                    
                    # Check 1: Formula contains all expected functions
                    for func_name in expected_functions:
                        func_pattern = rf'\b{func_name}\s*\('
                        if not re.search(func_pattern, formula_upper):
                            logger.warning(f"Cell {cell_coord} formula does not contain {func_name} function")
                            logger.warning(f"Formula: {formula_text}")
                            all_passed = False
                            break
                    else:
                        # Continue if all functions found
                        pass
                    
                    if not all_passed:
                        continue
                    
                    # Check 2: Formula contains SUMIF function
                    sumif_pattern = r'\bSUMIF\s*\('
                    if not re.search(sumif_pattern, formula_upper):
                        logger.warning(f"Cell {cell_coord} formula does not contain SUMIF function")
                        all_passed = False
                        continue
                    
                    # Check 3: Formula contains OFFSET function
                    offset_pattern = r'\bOFFSET\s*\('
                    if not re.search(offset_pattern, formula_upper):
                        logger.warning(f"Cell {cell_coord} formula does not contain OFFSET function")
                        all_passed = False
                        continue
                    
                    # Check 4: Formula contains MATCH function
                    match_pattern = r'\bMATCH\s*\('
                    if not re.search(match_pattern, formula_upper):
                        logger.warning(f"Cell {cell_coord} formula does not contain MATCH function")
                        all_passed = False
                        continue
                    
                    # Check 5: SUMIF references the correct range (e.g., $A:$A)
                    # Allow for variations in spacing
                    sumif_range_pattern = re.escape(sumif_range).replace('\\$', '\\$?')
                    if not re.search(sumif_range_pattern, formula_text, re.IGNORECASE):
                        logger.warning(f"Cell {cell_coord} formula SUMIF does not reference range {sumif_range}")
                        logger.debug(f"Formula: {formula_text}")
                        # Don't fail, just warn - the range might be correct but formatted differently
                    
                    # Check 6: SUMIF criteria references the correct column (e.g., $Q2, Q2)
                    # The criteria should reference the same row as the current cell
                    criteria_pattern = rf'\${sumif_criteria_col}{row_num}\b|{sumif_criteria_col}{row_num}\b'
                    if not re.search(criteria_pattern, formula_text, re.IGNORECASE):
                        logger.warning(f"Cell {cell_coord} formula SUMIF criteria may not reference {sumif_criteria_col}{row_num}")
                        logger.debug(f"Formula: {formula_text}")
                        # Don't fail, just warn - the criteria might be correct but formatted differently
                    
                    # Check 7: OFFSET base is correct (e.g., $A$1)
                    offset_base_pattern = re.escape(offset_base).replace('\\$', '\\$?')
                    if not re.search(offset_base_pattern, formula_text, re.IGNORECASE):
                        logger.warning(f"Cell {cell_coord} formula OFFSET base may not be {offset_base}")
                        logger.debug(f"Formula: {formula_text}")
                        # Don't fail, just warn
                    
                    # Check 8: MATCH lookup value references the correct row (e.g., R$1, $R$1)
                    # The lookup value should reference the same column as the current cell, row 1
                    match_lookup_pattern = rf'\${col_letter}\${match_lookup_value_row}\b|{col_letter}\${match_lookup_value_row}\b'
                    if not re.search(match_lookup_pattern, formula_text, re.IGNORECASE):
                        logger.warning(f"Cell {cell_coord} formula MATCH lookup value may not reference {col_letter}${match_lookup_value_row}")
                        logger.debug(f"Formula: {formula_text}")
                        # Don't fail, just warn
                    
                    # Check 9: MATCH lookup array is correct (e.g., $B$1:$N$1)
                    match_array_pattern = re.escape(match_lookup_array).replace('\\$', '\\$?')
                    if not re.search(match_array_pattern, formula_text, re.IGNORECASE):
                        logger.warning(f"Cell {cell_coord} formula MATCH lookup array may not be {match_lookup_array}")
                        logger.debug(f"Formula: {formula_text}")
                        # Don't fail, just warn
                    
                    # Check 10: Formula structure is SUMIF(..., ..., OFFSET(..., MATCH(...)))
                    # Check that OFFSET is inside SUMIF
                    sumif_offset_pattern = r'SUMIF\s*\([^,]+,\s*[^,]+,\s*OFFSET\s*\('
                    if not re.search(sumif_offset_pattern, formula_upper):
                        logger.warning(f"Cell {cell_coord} formula does not have correct SUMIF(..., ..., OFFSET(...)) structure")
                        logger.debug(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 11: MATCH is inside OFFSET
                    offset_match_pattern = r'OFFSET\s*\([^,]+,\s*,\s*MATCH\s*\('
                    if not re.search(offset_match_pattern, formula_upper):
                        logger.warning(f"Cell {cell_coord} formula does not have correct OFFSET(..., , MATCH(...)) structure")
                        logger.debug(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 12: Formula closes parentheses correctly
                    open_count = formula_text.count('(')
                    close_count = formula_text.count(')')
                    if open_count != close_count:
                        logger.warning(f"Cell {cell_coord} formula has mismatched parentheses (open: {open_count}, close: {close_count})")
                        all_passed = False
                        continue
                    
                    passed_count += 1
                    logger.debug(f"✓ Cell {cell_coord} has valid SUMIF(OFFSET(MATCH)) formula")
                    
                except Exception as e:
                    logger.error(f"Error checking cell {cell_coord}: {e}")
                    import traceback
                    logger.error(traceback.format_exc())
                    all_passed = False
        
        # Require at least 90% of checked cells to pass
        if checked_count > 0:
            pass_rate = passed_count / checked_count
            logger.info(f"Pass rate: {passed_count}/{checked_count} ({pass_rate*100:.1f}%)")
            
            if pass_rate >= 0.9 and all_passed:
                logger.info("=" * 60)
                logger.info(f"✓ All cells in range {check_range} contain correct SUMIF(OFFSET(MATCH)) formulas")
                logger.info("=" * 60)
                return 1.0
            elif pass_rate >= 0.9:
                logger.warning("=" * 60)
                logger.warning(f"⚠ {pass_rate*100:.1f}% of cells passed, but some checks had warnings")
                logger.warning("=" * 60)
                return 1.0  # Still pass if 90%+ cells are correct
            else:
                logger.error("=" * 60)
                logger.error(f"✗ Only {pass_rate*100:.1f}% of cells passed verification")
                logger.error("=" * 60)
                return 0.0
        else:
            logger.error("=" * 60)
            logger.error("✗ No cells were checked")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_merge_center_cells(result: str, expected: str = None, **options) -> float:
    """
    Verify if specified cell range is merged and horizontally centered.
    
    This function checks:
    1. Whether the specified cell range (e.g., A2:F2) is merged into a single cell
    2. Whether the merged cell has horizontal center alignment
    3. Whether the merge range exactly matches the expected range (not larger, not smaller)
       For example, if checking A2:F2, a merged range of A2:G2 will NOT pass verification.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_range: Cell range to check (e.g., "A2:F2")
            - expected_horizontal: Expected horizontal alignment (default: "center")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        from openpyxl.utils import get_column_letter, column_index_from_string
        from openpyxl.cell.cell import MergedCell
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_range = options.get('check_range', 'A2:F2')
        expected_horizontal = options.get('expected_horizontal', 'center')
        
        logger.info(f"Verifying merged and centered cells in file: {result}")
        logger.info(f"Range to check: {check_range}")
        logger.info(f"Expected horizontal alignment: {expected_horizontal}")
        
        # Parse the range
        try:
            range_clean = check_range.replace('$', '')
            if ':' in range_clean:
                start_cell, end_cell = range_clean.split(':')
                # Parse start cell
                start_col_letter = ''.join([c for c in start_cell if c.isalpha()])
                start_row = int(''.join([c for c in start_cell if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                # Parse end cell
                end_col_letter = ''.join([c for c in end_cell if c.isalpha()])
                end_row = int(''.join([c for c in end_cell if c.isdigit()]))
                end_col = column_index_from_string(end_col_letter)
            else:
                logger.error(f"Invalid range format: {check_range}. Expected format like 'A2:F2'")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse range {check_range}: {e}")
            return 0.0
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=False)
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check if the range is merged
        # Get the top-left cell of the range
        top_left_cell = ws[f"{start_col_letter}{start_row}"]
        
        # Check merged cells
        merged_ranges = list(ws.merged_cells.ranges)
        found_merge = False
        matching_range = None
        
        for merged_range in merged_ranges:
            # Check if the merged range exactly matches the expected range
            merged_start_col = merged_range.min_col
            merged_start_row = merged_range.min_row
            merged_end_col = merged_range.max_col
            merged_end_row = merged_range.max_row
            
            # Check if the merged range exactly matches the expected range (not larger, not smaller)
            if (merged_start_col == start_col and merged_start_row == start_row and
                merged_end_col == end_col and merged_end_row == end_row):
                found_merge = True
                matching_range = merged_range
                logger.info(f"Found exact matching merged range: {merged_range}")
                break
        
        if not found_merge:
            logger.error(f"Range {check_range} is not merged")
            return 0.0
        
        # Check horizontal alignment
        # Get alignment from the top-left cell (the actual cell in merged range)
        cell_alignment = top_left_cell.alignment
        
        if cell_alignment is None:
            logger.error(f"Cell {start_col_letter}{start_row} has no alignment information")
            return 0.0
        
        horizontal_alignment = cell_alignment.horizontal
        
        # Normalize alignment values
        # openpyxl uses constants like 'center', 'centerContinuous', 'left', 'right', etc.
        expected_horizontal_lower = expected_horizontal.lower()
        
        # Check alignment
        if horizontal_alignment is None:
            logger.warning(f"Cell {start_col_letter}{start_row} has no horizontal alignment set (defaults to left)")
            # In Excel/LibreOffice, default alignment is left, so None means left
            if expected_horizontal_lower == 'left':
                pass  # This is acceptable
            else:
                logger.error(f"Expected horizontal alignment '{expected_horizontal}', but got None (default left)")
                return 0.0
        else:
            horizontal_alignment_lower = str(horizontal_alignment).lower()
            
            # Handle different alignment representations
            alignment_map = {
                'center': ['center', 'centre', 'centercontinuous'],
                'left': ['left', 'general'],
                'right': ['right'],
                'justify': ['justify', 'justified'],
                'distributed': ['distributed']
            }
            
            # Check if alignment matches
            alignment_matched = False
            for key, values in alignment_map.items():
                if expected_horizontal_lower == key:
                    if any(horizontal_alignment_lower.startswith(v) for v in values):
                        alignment_matched = True
                        break
            
            if not alignment_matched:
                # Direct string comparison as fallback
                if expected_horizontal_lower not in horizontal_alignment_lower and horizontal_alignment_lower not in expected_horizontal_lower:
                    logger.error(f"Expected horizontal alignment '{expected_horizontal}', but got '{horizontal_alignment}'")
                    return 0.0
                else:
                    alignment_matched = True
        
        logger.info(f"✓ Merged range {check_range} verification passed")
        logger.info(f"  - Merged range: {matching_range}")
        logger.info(f"  - Horizontal alignment: {horizontal_alignment}")
        return 1.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_countif_conditional_formatting(result: str, expected: str = None, **options) -> float:
    """
    Verify if conditional formatting with COUNTIF formula exists in specified range and fills cells with yellow.
    
    This function checks:
    1. Whether the specified range (e.g., F2:O29) has conditional formatting
    2. Whether the conditional formatting formula matches the expected pattern: COUNTIF($A2:$D2,F2)>0
    3. Whether the formatting fills cells with yellow color
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_range: Range to check (e.g., "F2:O29")
            - expected_formula_pattern: Expected formula pattern (default: "COUNTIF($A2:$D2,F2)>0")
            - expected_color: Expected fill color in aRGB format (default: yellow, "FFFFFF00" or "FFFF00")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        from openpyxl.worksheet.cell_range import CellRange
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_range = options.get('check_range', 'F2:O29')
        expected_formula_pattern = options.get('expected_formula_pattern', 'COUNTIF($A2:$D2,F2)>0')
        expected_color = options.get('expected_color', 'yellow')  # Can be "yellow" or aRGB like "FFFFFF00"
        
        logger.info(f"Verifying conditional formatting in file: {result}")
        logger.info(f"Range to check: {check_range}")
        logger.info(f"Expected formula pattern: {expected_formula_pattern}")
        logger.info(f"Expected color: {expected_color}")
        
        # Parse the range
        try:
            range_clean = check_range.replace('$', '')
            if ':' in range_clean:
                start_cell, end_cell = range_clean.split(':')
                # Parse start cell
                start_col_letter = ''.join([c for c in start_cell if c.isalpha()])
                start_row = int(''.join([c for c in start_cell if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                # Parse end cell
                end_col_letter = ''.join([c for c in end_cell if c.isalpha()])
                end_row = int(''.join([c for c in end_cell if c.isdigit()]))
                end_col = column_index_from_string(end_col_letter)
            else:
                logger.error(f"Invalid range format: {check_range}. Expected format like 'F2:O29'")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse range {check_range}: {e}")
            return 0.0
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=False)
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check conditional formatting
        conditional_formattings = ws.conditional_formatting
        
        if not conditional_formattings:
            logger.error("No conditional formatting found in worksheet")
            return 0.0
        
        found_matching_cf = False
        matching_formula = None
        matching_color = None
        matching_range_cells = None
        
        # Check each conditional formatting rule
        for fmt in conditional_formattings:
            # Check if this formatting applies to any cell in our target range
            fmt_applies_to_range = False
            for rge in fmt.cells:
                # Check if this range overlaps with our target range
                cf_start_col = rge.min_col
                cf_start_row = rge.min_row
                cf_end_col = rge.max_col
                cf_end_row = rge.max_row
                
                # Check if ranges overlap
                if not (cf_end_col < start_col or cf_start_col > end_col or 
                        cf_end_row < start_row or cf_start_row > end_row):
                    fmt_applies_to_range = True
                    matching_range_cells = rge
                    break
            
            if not fmt_applies_to_range:
                continue
            
            # Check each rule in this formatting
            for r in fmt.rules:
                # Check formula
                if not r.formula:
                    continue
                
                formula_text = r.formula[0] if isinstance(r.formula, list) else str(r.formula)
                formula_upper = formula_text.upper()
                
                logger.debug(f"Found conditional formatting formula: {formula_text}")
                
                # Check if formula contains COUNTIF
                countif_pattern = r'\bCOUNTIF\s*\('
                if not re.search(countif_pattern, formula_upper):
                    logger.debug(f"Formula does not contain COUNTIF: {formula_text}")
                    continue
                
                # Check if formula matches the expected pattern
                # Expected: COUNTIF($A2:$D2,F2)>0
                # Allow for variations in spacing and case
                expected_pattern_upper = expected_formula_pattern.upper()
                
                # Normalize both formulas for comparison (remove extra spaces, handle case)
                def normalize_formula(fml):
                    # Remove extra spaces around operators and parentheses
                    fml = re.sub(r'\s+', '', fml.upper())
                    return fml
                
                normalized_expected = normalize_formula(expected_formula_pattern)
                normalized_actual = normalize_formula(formula_text)
                
                # Check if the pattern matches (allowing for row variations in the pattern)
                # The pattern should have COUNTIF($A2:$D2,F2)>0 structure
                # We'll check for COUNTIF, the range pattern, and >0
                countif_match = re.search(r'COUNTIF\s*\(\s*\$?A\$?\d+\s*:\s*\$?D\$?\d+\s*,\s*\$?F\$?\d+\s*\)\s*>\s*0', formula_upper)
                
                if not countif_match:
                    logger.debug(f"Formula does not match COUNTIF pattern: {formula_text}")
                    continue
                
                # Check fill color
                fill_color = None
                if r.dxf and r.dxf.fill:
                    try:
                        if r.dxf.fill.bgColor:
                            fill_color = r.dxf.fill.bgColor.rgb
                        elif r.dxf.fill.fgColor:
                            fill_color = r.dxf.fill.fgColor.rgb
                    except:
                        pass
                
                if fill_color is None:
                    logger.warning(f"Conditional formatting rule has no fill color")
                    continue
                
                logger.debug(f"Found fill color: {fill_color}")
                
                # Check if color is yellow
                # Yellow can be represented as FFFF00, FFFFFF00, or similar
                is_yellow = False
                if isinstance(expected_color, str) and expected_color.lower() == 'yellow':
                    # Check if color is yellow (high red and green, low blue)
                    if fill_color:
                        # Convert aRGB to RGB values
                        # aRGB format: AARRGGBB (e.g., FFFFFF00 for yellow)
                        color_str = str(fill_color).upper()
                        if len(color_str) >= 6:
                            # Extract RGB values (last 6 characters, or handle 8-char format)
                            if len(color_str) == 8:
                                r_val = int(color_str[2:4], 16)
                                g_val = int(color_str[4:6], 16)
                                b_val = int(color_str[6:8], 16)
                            elif len(color_str) == 6:
                                r_val = int(color_str[0:2], 16)
                                g_val = int(color_str[2:4], 16)
                                b_val = int(color_str[4:6], 16)
                            else:
                                logger.warning(f"Unexpected color format: {color_str}")
                                continue
                            
                            # Yellow: high red and green (close to 255), low blue (close to 0)
                            # Allow some tolerance
                            if r_val > 200 and g_val > 200 and b_val < 100:
                                is_yellow = True
                                logger.info(f"Color is yellow: RGB({r_val}, {g_val}, {b_val})")
                else:
                    # Direct color comparison
                    if fill_color and str(fill_color).upper() == str(expected_color).upper():
                        is_yellow = True
                
                if not is_yellow:
                    logger.warning(f"Fill color is not yellow: {fill_color}")
                    continue
                
                # All checks passed
                found_matching_cf = True
                matching_formula = formula_text
                matching_color = fill_color
                logger.info(f"✓ Found matching conditional formatting")
                logger.info(f"  - Formula: {formula_text}")
                logger.info(f"  - Color: {fill_color}")
                logger.info(f"  - Range: {matching_range_cells}")
                break
            
            if found_matching_cf:
                break
        
        if not found_matching_cf:
            logger.error("=" * 60)
            logger.error("✗ No matching conditional formatting found")
            logger.error("=" * 60)
            return 0.0
        
        # Strictly verify that the conditional formatting applies to EXACTLY the expected range
        # Must be 100% coverage, no missing cells allowed
        if not matching_range_cells:
            logger.error("=" * 60)
            logger.error("✗ Conditional formatting range not found")
            logger.error("=" * 60)
            return 0.0
        
        # Check if the conditional formatting range exactly matches the target range
        cf_start_col = matching_range_cells.min_col
        cf_start_row = matching_range_cells.min_row
        cf_end_col = matching_range_cells.max_col
        cf_end_row = matching_range_cells.max_row
        
        # The conditional formatting range must exactly match the target range
        # Allow the CF range to be larger (it can include more cells), but it must include ALL target cells
        if cf_start_col > start_col or cf_end_col < end_col or \
           cf_start_row > start_row or cf_end_row < end_row:
            logger.error("=" * 60)
            logger.error("✗ Conditional formatting range does not fully cover target range")
            logger.error(f"  Target range: {check_range} (cols {start_col}-{end_col}, rows {start_row}-{end_row})")
            logger.error(f"  CF range: cols {cf_start_col}-{cf_end_col}, rows {cf_start_row}-{cf_end_row}")
            logger.error("=" * 60)
            return 0.0
        
        # Verify that ALL cells in the target range have the conditional formatting
        # We need to check each cell individually to ensure it's covered
        total_target_cells = (end_row - start_row + 1) * (end_col - start_col + 1)
        cells_with_cf = set()
        
        # Collect all cells covered by the matching conditional formatting
        for fmt in conditional_formattings:
            for rge in fmt.cells:
                # Check if this range overlaps with our target range
                if not (rge.max_col < start_col or rge.min_col > end_col or 
                        rge.max_row < start_row or rge.min_row > end_row):
                    # This range overlaps, check if it has the matching rule
                    for r in fmt.rules:
                        if not r.formula:
                            continue
                        formula_text = r.formula[0] if isinstance(r.formula, list) else str(r.formula)
                        formula_upper = formula_text.upper()
                        
                        # Check if this is the matching rule
                        countif_pattern = r'\bCOUNTIF\s*\('
                        if not re.search(countif_pattern, formula_upper):
                            continue
                        
                        countif_match = re.search(r'COUNTIF\s*\(\s*\$?A\$?\d+\s*:\s*\$?D\$?\d+\s*,\s*\$?F\$?\d+\s*\)\s*>\s*0', formula_upper)
                        if not countif_match:
                            continue
                        
                        # Check color
                        fill_color = None
                        if r.dxf and r.dxf.fill:
                            try:
                                if r.dxf.fill.bgColor:
                                    fill_color = r.dxf.fill.bgColor.rgb
                                elif r.dxf.fill.fgColor:
                                    fill_color = r.dxf.fill.fgColor.rgb
                            except:
                                pass
                        
                        if fill_color is None:
                            continue
                        
                        # Check if color is yellow
                        is_yellow = False
                        if isinstance(expected_color, str) and expected_color.lower() == 'yellow':
                            if fill_color:
                                color_str = str(fill_color).upper()
                                if len(color_str) >= 6:
                                    if len(color_str) == 8:
                                        r_val = int(color_str[2:4], 16)
                                        g_val = int(color_str[4:6], 16)
                                        b_val = int(color_str[6:8], 16)
                                    elif len(color_str) == 6:
                                        r_val = int(color_str[0:2], 16)
                                        g_val = int(color_str[2:4], 16)
                                        b_val = int(color_str[4:6], 16)
                                    else:
                                        continue
                                    
                                    if r_val > 200 and g_val > 200 and b_val < 100:
                                        is_yellow = True
                        else:
                            if fill_color and str(fill_color).upper() == str(expected_color).upper():
                                is_yellow = True
                        
                        if not is_yellow:
                            continue
                        
                        # This is a matching rule, add all cells in the range to the set
                        for row in range(max(start_row, rge.min_row), min(end_row, rge.max_row) + 1):
                            for col in range(max(start_col, rge.min_col), min(end_col, rge.max_col) + 1):
                                cells_with_cf.add((row, col))
                        break
        
        # Check if all target cells are covered
        missing_cells = []
        for row in range(start_row, end_row + 1):
            for col in range(start_col, end_col + 1):
                if (row, col) not in cells_with_cf:
                    col_letter = get_column_letter(col)
                    missing_cells.append(f"{col_letter}{row}")
        
        if missing_cells:
            logger.error("=" * 60)
            logger.error(f"✗ {len(missing_cells)} cells in target range do not have conditional formatting")
            logger.error(f"  Missing cells (first 20): {', '.join(missing_cells[:20])}")
            if len(missing_cells) > 20:
                logger.error(f"  ... and {len(missing_cells) - 20} more cells")
            logger.error(f"  Total target cells: {total_target_cells}")
            logger.error(f"  Cells with CF: {len(cells_with_cf)}")
            logger.error("=" * 60)
            return 0.0
        
        if len(cells_with_cf) < total_target_cells:
            logger.error("=" * 60)
            logger.error(f"✗ Not all target cells have conditional formatting")
            logger.error(f"  Expected: {total_target_cells} cells")
            logger.error(f"  Found: {len(cells_with_cf)} cells")
            logger.error("=" * 60)
            return 0.0
        
        logger.info("=" * 60)
        logger.info(f"✓ Conditional formatting verification passed")
        logger.info(f"  - Formula: {matching_formula}")
        logger.info(f"  - Color: {matching_color}")
        logger.info(f"  - Range: {check_range} (all {total_target_cells} cells verified)")
        logger.info("=" * 60)
        return 1.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_student_grade_sum_average(result: str, expected: str = None, **options) -> float:
    """
    Verify if SUM and AVERAGE formulas exist in specified ranges for calculating student grades.
    
    This function STRICTLY checks ALL cells in the specified ranges - no tolerance, no auto-detection.
    Every single cell in the specified ranges must contain the correct formula.
    
    This function checks:
    1. Whether ALL cells in the SUM range (e.g., H2:H13) contain SUM formulas
    2. Whether ALL cells in the AVERAGE range (e.g., I2:I13) contain AVERAGE formulas
    3. Whether SUM formulas reference the correct source range (e.g., B2:G2, B3:G3, etc.)
    4. Whether AVERAGE formulas reference the correct source range (e.g., B2:G2, B3:G3, etc.)
    5. Whether formulas use relative references correctly (each row references its own data)
    
    IMPORTANT: This function checks ALL cells in the specified ranges, regardless of whether they
    appear to be empty. If any cell in the specified range is missing a formula, verification fails.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - sum_range: Range containing SUM formulas (e.g., "H2:H13") - ALL cells must have formulas
            - average_range: Range containing AVERAGE formulas (e.g., "I2:I13") - ALL cells must have formulas
            - source_range_start: Starting cell of source range (e.g., "B2")
            - source_range_end: Ending cell of source range (e.g., "G2")
            - start_row: Starting row number (default: 2, but will use range from sum_range/average_range)
            - end_row: Ending row number (default: 13, but will use range from sum_range/average_range)
    
    Returns:
        float: 1.0 if ALL cells in specified ranges contain correct formulas, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        sum_range = options.get('sum_range', 'H2:H13')
        average_range = options.get('average_range', 'I2:I13')
        source_range_start = options.get('source_range_start', 'B2')
        source_range_end = options.get('source_range_end', 'G2')
        start_row = options.get('start_row', 2)
        end_row = options.get('end_row', 13)
        
        logger.info(f"Verifying student grade SUM and AVERAGE formulas in file: {result}")
        logger.info(f"SUM range: {sum_range}, AVERAGE range: {average_range}")
        logger.info(f"Source range: {source_range_start}:{source_range_end}")
        
        # Parse SUM range - strictly use the specified range
        try:
            sum_range_clean = sum_range.replace('$', '')
            if ':' in sum_range_clean:
                sum_start_cell, sum_end_cell = sum_range_clean.split(':')
                sum_start_col_letter = ''.join([c for c in sum_start_cell if c.isalpha()])
                sum_start_row = int(''.join([c for c in sum_start_cell if c.isdigit()]))
                sum_start_col = column_index_from_string(sum_start_col_letter)
                sum_end_col_letter = ''.join([c for c in sum_end_cell if c.isalpha()])
                sum_end_row = int(''.join([c for c in sum_end_cell if c.isdigit()]))
                sum_end_col = column_index_from_string(sum_end_col_letter)
            else:
                logger.error(f"Invalid SUM range format: {sum_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse SUM range {sum_range}: {e}")
            return 0.0
        
        # Parse AVERAGE range - strictly use the specified range
        try:
            avg_range_clean = average_range.replace('$', '')
            if ':' in avg_range_clean:
                avg_start_cell, avg_end_cell = avg_range_clean.split(':')
                avg_start_col_letter = ''.join([c for c in avg_start_cell if c.isalpha()])
                avg_start_row = int(''.join([c for c in avg_start_cell if c.isdigit()]))
                avg_start_col = column_index_from_string(avg_start_col_letter)
                avg_end_col_letter = ''.join([c for c in avg_end_cell if c.isalpha()])
                avg_end_row = int(''.join([c for c in avg_end_cell if c.isdigit()]))
                avg_end_col = column_index_from_string(avg_end_col_letter)
            else:
                logger.error(f"Invalid AVERAGE range format: {average_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse AVERAGE range {average_range}: {e}")
            return 0.0
        
        # Parse source range
        try:
            source_start_col_letter = ''.join([c for c in source_range_start if c.isalpha()])
            source_start_row = int(''.join([c for c in source_range_start if c.isdigit()]))
            source_start_col = column_index_from_string(source_start_col_letter)
            source_end_col_letter = ''.join([c for c in source_range_end if c.isalpha()])
            source_end_row = int(''.join([c for c in source_range_end if c.isdigit()]))
            source_end_col = column_index_from_string(source_end_col_letter)
        except Exception as e:
            logger.error(f"Failed to parse source range: {e}")
            return 0.0
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Strictly check ALL cells in the specified ranges - no auto-detection
        logger.info(f"Checking all cells in SUM range {sum_range} (rows {sum_start_row} to {sum_end_row})")
        logger.info(f"Checking all cells in AVERAGE range {average_range} (rows {avg_start_row} to {avg_end_row})")
        
        # Verify that ranges match expected rows
        if sum_start_row != avg_start_row or sum_end_row != avg_end_row:
            logger.warning(f"SUM and AVERAGE ranges have different row ranges, but will check both")
        
        # Check SUM formulas - check ALL rows in the specified range
        all_passed = True
        checked_count = 0
        passed_count = 0
        
        for row_num in range(sum_start_row, sum_end_row + 1):
            sum_cell_coord = f"{sum_start_col_letter}{row_num}"
            
            try:
                sum_cell = ws[sum_cell_coord]
                checked_count += 1
                
                # Check if cell contains a formula
                if sum_cell.data_type != "f":
                    logger.warning(f"Cell {sum_cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(sum_cell, "_value") and isinstance(sum_cell._value, str) and sum_cell._value.startswith("="):
                    formula_text = sum_cell._value
                elif hasattr(sum_cell, "formula"):
                    formula_text = sum_cell.formula
                else:
                    if sum_cell.value is not None and isinstance(sum_cell.value, str) and sum_cell.value.startswith("="):
                        formula_text = sum_cell.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {sum_cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {sum_cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains SUM function
                sum_pattern = r'\bSUM\s*\('
                if not re.search(sum_pattern, formula_upper):
                    logger.warning(f"Cell {sum_cell_coord} formula does not contain SUM function")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 2: Formula references the correct source range for this row
                # Expected: SUM(B{row_num}:G{row_num}) or similar
                expected_source_start = f"{source_start_col_letter}{row_num}"
                expected_source_end = f"{source_end_col_letter}{row_num}"
                expected_range_pattern = rf'{re.escape(expected_source_start)}\s*:\s*{re.escape(expected_source_end)}'
                
                if not re.search(expected_range_pattern, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {sum_cell_coord} formula does not reference correct range {expected_source_start}:{expected_source_end}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: Formula closes parentheses correctly
                open_count = formula_text.count('(')
                close_count = formula_text.count(')')
                if open_count != close_count:
                    logger.warning(f"Cell {sum_cell_coord} formula has mismatched parentheses")
                    all_passed = False
                    continue
                
                passed_count += 1
                logger.debug(f"✓ Cell {sum_cell_coord} has valid SUM formula")
                
            except Exception as e:
                logger.error(f"Error checking SUM cell {sum_cell_coord}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        # Check AVERAGE formulas - check ALL rows in the specified range
        for row_num in range(avg_start_row, avg_end_row + 1):
            avg_cell_coord = f"{avg_start_col_letter}{row_num}"
            
            try:
                avg_cell = ws[avg_cell_coord]
                checked_count += 1
                
                # Check if cell contains a formula
                if avg_cell.data_type != "f":
                    logger.warning(f"Cell {avg_cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(avg_cell, "_value") and isinstance(avg_cell._value, str) and avg_cell._value.startswith("="):
                    formula_text = avg_cell._value
                elif hasattr(avg_cell, "formula"):
                    formula_text = avg_cell.formula
                else:
                    if avg_cell.value is not None and isinstance(avg_cell.value, str) and avg_cell.value.startswith("="):
                        formula_text = avg_cell.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {avg_cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {avg_cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains AVERAGE function
                avg_pattern = r'\bAVERAGE\s*\('
                if not re.search(avg_pattern, formula_upper):
                    logger.warning(f"Cell {avg_cell_coord} formula does not contain AVERAGE function")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 2: Formula references the correct source range for this row
                # Expected: AVERAGE(B{row_num}:G{row_num}) or similar
                expected_source_start = f"{source_start_col_letter}{row_num}"
                expected_source_end = f"{source_end_col_letter}{row_num}"
                expected_range_pattern = rf'{re.escape(expected_source_start)}\s*:\s*{re.escape(expected_source_end)}'
                
                if not re.search(expected_range_pattern, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {avg_cell_coord} formula does not reference correct range {expected_source_start}:{expected_source_end}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: Formula closes parentheses correctly
                open_count = formula_text.count('(')
                close_count = formula_text.count(')')
                if open_count != close_count:
                    logger.warning(f"Cell {avg_cell_coord} formula has mismatched parentheses")
                    all_passed = False
                    continue
                
                passed_count += 1
                logger.debug(f"✓ Cell {avg_cell_coord} has valid AVERAGE formula")
                
            except Exception as e:
                logger.error(f"Error checking AVERAGE cell {avg_cell_coord}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        # Require all specified cells to have correct formulas (no tolerance)
        if checked_count > 0:
            if all_passed and passed_count == checked_count:
                logger.info("=" * 60)
                logger.info(f"✓ All {checked_count} cells contain correct SUM and AVERAGE formulas")
                logger.info("=" * 60)
                return 1.0
            else:
                logger.error("=" * 60)
                logger.error(f"✗ Verification failed: {passed_count}/{checked_count} cells passed")
                logger.error(f"  All specified cells must contain correct formulas")
                logger.error("=" * 60)
                return 0.0
        else:
            logger.error("=" * 60)
            logger.error("✗ No cells were checked")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_student_grade_sum(result: str, expected: str = None, **options) -> float:
    """
    Verify if SUM formulas exist in specified range for calculating student grade totals.
    
    This function STRICTLY checks ALL cells in the specified range - no tolerance, no auto-detection.
    Every single cell in the specified range must contain the correct SUM formula.
    
    This function checks:
    1. Whether ALL cells in the SUM range (e.g., E2:E10) contain SUM formulas
    2. Whether SUM formulas reference the correct source range (e.g., B2:D2, B3:D3, etc.)
    3. Whether formulas use relative references correctly (each row references its own data)
    
    IMPORTANT: This function checks ALL cells in the specified range, regardless of whether they
    appear to be empty. If any cell in the specified range is missing a formula, verification fails.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - sum_range: Range containing SUM formulas (e.g., "E2:E10") - ALL cells must have formulas
            - source_range_start: Starting cell of source range (e.g., "B2")
            - source_range_end: Ending cell of source range (e.g., "D2")
            - start_row: Starting row number (default: 2, but will use range from sum_range)
            - end_row: Ending row number (default: 10, but will use range from sum_range)
    
    Returns:
        float: 1.0 if ALL cells in specified range contain correct SUM formulas, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        sum_range = options.get('sum_range', 'E2:E10')
        source_range_start = options.get('source_range_start', 'B2')
        source_range_end = options.get('source_range_end', 'D2')
        start_row = options.get('start_row', 2)
        end_row = options.get('end_row', 10)
        
        logger.info(f"Verifying student grade SUM formulas in file: {result}")
        logger.info(f"SUM range: {sum_range}")
        logger.info(f"Source range: {source_range_start}:{source_range_end}")
        
        # Parse SUM range - strictly use the specified range
        try:
            sum_range_clean = sum_range.replace('$', '')
            if ':' in sum_range_clean:
                sum_start_cell, sum_end_cell = sum_range_clean.split(':')
                sum_start_col_letter = ''.join([c for c in sum_start_cell if c.isalpha()])
                sum_start_row = int(''.join([c for c in sum_start_cell if c.isdigit()]))
                sum_start_col = column_index_from_string(sum_start_col_letter)
                sum_end_col_letter = ''.join([c for c in sum_end_cell if c.isalpha()])
                sum_end_row = int(''.join([c for c in sum_end_cell if c.isdigit()]))
                sum_end_col = column_index_from_string(sum_end_col_letter)
            else:
                logger.error(f"Invalid SUM range format: {sum_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse SUM range {sum_range}: {e}")
            return 0.0
        
        # Parse source range
        try:
            source_start_col_letter = ''.join([c for c in source_range_start if c.isalpha()])
            source_start_row = int(''.join([c for c in source_range_start if c.isdigit()]))
            source_start_col = column_index_from_string(source_start_col_letter)
            source_end_col_letter = ''.join([c for c in source_range_end if c.isalpha()])
            source_end_row = int(''.join([c for c in source_range_end if c.isdigit()]))
            source_end_col = column_index_from_string(source_end_col_letter)
        except Exception as e:
            logger.error(f"Failed to parse source range: {e}")
            return 0.0
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Strictly check ALL cells in the specified range - no auto-detection
        logger.info(f"Checking all cells in SUM range {sum_range} (rows {sum_start_row} to {sum_end_row})")
        
        # Check SUM formulas - check ALL rows in the specified range
        all_passed = True
        checked_count = 0
        passed_count = 0
        
        for row_num in range(sum_start_row, sum_end_row + 1):
            sum_cell_coord = f"{sum_start_col_letter}{row_num}"
            
            try:
                sum_cell = ws[sum_cell_coord]
                checked_count += 1
                
                # Check if cell contains a formula
                if sum_cell.data_type != "f":
                    logger.warning(f"Cell {sum_cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(sum_cell, "_value") and isinstance(sum_cell._value, str) and sum_cell._value.startswith("="):
                    formula_text = sum_cell._value
                elif hasattr(sum_cell, "formula"):
                    formula_text = sum_cell.formula
                else:
                    if sum_cell.value is not None and isinstance(sum_cell.value, str) and sum_cell.value.startswith("="):
                        formula_text = sum_cell.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {sum_cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {sum_cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains SUM function
                sum_pattern = r'\bSUM\s*\('
                if not re.search(sum_pattern, formula_upper):
                    logger.warning(f"Cell {sum_cell_coord} formula does not contain SUM function")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 2: Formula references the correct source range for this row
                # Expected: SUM(B{row_num}:D{row_num}) or similar
                expected_source_start = f"{source_start_col_letter}{row_num}"
                expected_source_end = f"{source_end_col_letter}{row_num}"
                expected_range_pattern = rf'{re.escape(expected_source_start)}\s*:\s*{re.escape(expected_source_end)}'
                
                if not re.search(expected_range_pattern, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {sum_cell_coord} formula does not reference correct range {expected_source_start}:{expected_source_end}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: Formula closes parentheses correctly
                open_count = formula_text.count('(')
                close_count = formula_text.count(')')
                if open_count != close_count:
                    logger.warning(f"Cell {sum_cell_coord} formula has mismatched parentheses")
                    all_passed = False
                    continue
                
                passed_count += 1
                logger.debug(f"✓ Cell {sum_cell_coord} has valid SUM formula")
                
            except Exception as e:
                logger.error(f"Error checking SUM cell {sum_cell_coord}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        # Require all specified cells to have correct formulas (no tolerance)
        if checked_count > 0:
            if all_passed and passed_count == checked_count:
                logger.info("=" * 60)
                logger.info(f"✓ All {checked_count} cells contain correct SUM formulas")
                logger.info("=" * 60)
                return 1.0
            else:
                logger.error("=" * 60)
                logger.error(f"✗ Verification failed: {passed_count}/{checked_count} cells passed")
                logger.error(f"  All specified cells must contain correct formulas")
                logger.error("=" * 60)
                return 0.0
        else:
            logger.error("=" * 60)
            logger.error("✗ No cells were checked")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_regexp_replace(result: str, expected: str = None, **options) -> float:
    """
    Verify if REGEX formulas exist in specified range with correct pattern and replacement.
    
    This function STRICTLY checks ALL cells in the specified range - no tolerance, no auto-detection.
    Every single cell in the specified range must contain the correct REGEX formula.
    
    This function checks:
    1. Whether ALL cells in the specified range (e.g., D1:D17) contain REGEX formulas
    2. Whether formulas reference the corresponding source column cell (D1->C1, D2->C2, etc.)
    3. Whether formulas contain the correct REGEX function
    4. Whether formulas contain the correct pattern (e.g., "(\\d+)(\\D+)")
    5. Whether formulas contain the correct replace pattern (e.g., "$2$1")
    
    IMPORTANT: This function checks ALL cells in the specified range, regardless of whether they
    appear to be empty. If any cell in the specified range is missing a formula, verification fails.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_range: Range containing REGEX formulas (e.g., "D1:D17") - ALL cells must have formulas
            - source_column: Source column letter (e.g., "C")
            - expected_function: Expected function name (default: "REGEX")
            - expected_pattern: Expected regex pattern (e.g., "(\\d+)(\\D+)")
            - expected_replace_pattern: Expected replace pattern (e.g., "$2$1")
    
    Returns:
        float: 1.0 if ALL cells in specified range contain correct REGEX formulas, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_range = options.get('check_range', 'D1:D17')
        source_column = options.get('source_column', 'C')
        expected_function = options.get('expected_function', 'REGEX')
        expected_pattern = options.get('expected_pattern', '(\\d+)(\\D+)')
        expected_replace_pattern = options.get('expected_replace_pattern', '$2$1')
        
        logger.info(f"Verifying REGEX formulas in file: {result}")
        logger.info(f"Check range: {check_range}")
        logger.info(f"Source column: {source_column}")
        logger.info(f"Expected function: {expected_function}")
        logger.info(f"Expected pattern: {expected_pattern}")
        logger.info(f"Expected replace pattern: {expected_replace_pattern}")
        
        # Parse check range - strictly use the specified range
        try:
            check_range_clean = check_range.replace('$', '')
            if ':' in check_range_clean:
                check_start_cell, check_end_cell = check_range_clean.split(':')
                check_start_col_letter = ''.join([c for c in check_start_cell if c.isalpha()])
                check_start_row = int(''.join([c for c in check_start_cell if c.isdigit()]))
                check_start_col = column_index_from_string(check_start_col_letter)
                check_end_col_letter = ''.join([c for c in check_end_cell if c.isalpha()])
                check_end_row = int(''.join([c for c in check_end_cell if c.isdigit()]))
                check_end_col = column_index_from_string(check_end_col_letter)
            else:
                logger.error(f"Invalid check range format: {check_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse check range {check_range}: {e}")
            return 0.0
        
        # Verify that range is a single column
        if check_start_col != check_end_col:
            logger.error(f"Check range must be a single column, got: {check_range}")
            return 0.0
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Strictly check ALL cells in the specified range - no auto-detection
        logger.info(f"Checking all cells in range {check_range} (rows {check_start_row} to {check_end_row})")
        
        # Check REGEX formulas - check ALL rows in the specified range
        all_passed = True
        checked_count = 0
        passed_count = 0
        
        for row_num in range(check_start_row, check_end_row + 1):
            cell_coord = f"{check_start_col_letter}{row_num}"
            expected_source_cell = f"{source_column}{row_num}"
            
            try:
                cell = ws[cell_coord]
                checked_count += 1
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.warning(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                else:
                    if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains REGEXP function
                regexp_pattern = rf'\b{re.escape(expected_function)}\s*\('
                if not re.search(regexp_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not contain {expected_function} function")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 2: Formula references the corresponding source column cell (C1, C2, etc.)
                source_cell_pattern = rf'\b{re.escape(expected_source_cell)}\b'
                if not re.search(source_cell_pattern, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {cell_coord} formula does not reference {expected_source_cell}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: Formula contains the expected pattern
                # The pattern might be escaped differently in the formula, so we check for key parts
                # Pattern: (\\d+)(\\D+)
                # We check for: (\\d+), (\\D+), and the overall structure
                pattern_escaped = re.escape(expected_pattern)
                # Allow for different escaping (single backslash vs double backslash)
                pattern_variations = [
                    expected_pattern,  # Original
                    expected_pattern.replace('\\', '\\\\'),  # Double escaped
                    expected_pattern.replace('\\\\', '\\'),  # Single escaped
                ]
                
                pattern_found = False
                for pattern_var in pattern_variations:
                    if pattern_var in formula_text:
                        pattern_found = True
                        break
                
                # Also check for key components: (\\d+) and (\\D+)
                if not pattern_found:
                    # Check for digit pattern and non-digit pattern
                    has_digit_pattern = re.search(r'\(\\?d\+\)|\(\\?\\?d\+\)', formula_text)
                    has_nondigit_pattern = re.search(r'\(\\?D\+\)|\(\\?\\?D\+\)', formula_text)
                    if has_digit_pattern and has_nondigit_pattern:
                        pattern_found = True
                
                if not pattern_found:
                    logger.warning(f"Cell {cell_coord} formula does not contain expected pattern '{expected_pattern}'")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: Formula contains the expected replace pattern
                # Replace pattern: $2$1 (REGEX uses $ for backreferences)
                # We check for variations: $2$1, "$2$1", etc.
                replace_pattern_variations = [
                    expected_replace_pattern,  # Original: $2$1
                    f'"{expected_replace_pattern}"',  # Quoted: "$2$1"
                    f"'{expected_replace_pattern}'",  # Single quoted: '$2$1'
                ]
                
                replace_pattern_found = False
                for replace_var in replace_pattern_variations:
                    if replace_var in formula_text:
                        replace_pattern_found = True
                        break
                
                # Also check for backreference patterns with $ symbol
                if not replace_pattern_found:
                    # Check for backreference pattern: $2 followed by $1
                    backref_pattern = re.search(r'\$2\$1', formula_text)
                    if backref_pattern:
                        replace_pattern_found = True
                
                if not replace_pattern_found:
                    logger.warning(f"Cell {cell_coord} formula does not contain expected replace pattern '{expected_replace_pattern}'")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 5: Formula closes parentheses correctly
                open_count = formula_text.count('(')
                close_count = formula_text.count(')')
                if open_count != close_count:
                    logger.warning(f"Cell {cell_coord} formula has mismatched parentheses")
                    all_passed = False
                    continue
                
                passed_count += 1
                logger.debug(f"✓ Cell {cell_coord} has valid REGEX formula")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
                # Require all specified cells to have correct formulas (no tolerance)
        if checked_count > 0:
            if all_passed and passed_count == checked_count:
                logger.info("=" * 60)
                logger.info(f"✓ All {checked_count} cells contain correct REGEX formulas")
                logger.info("=" * 60)
                return 1.0
            else:
                logger.error("=" * 60)
                logger.error(f"✗ Verification failed: {passed_count}/{checked_count} cells passed")
                logger.error(f"  All specified cells must contain correct REGEX formulas")
                logger.error("=" * 60)
                return 0.0
        else:
            logger.error("=" * 60)
            logger.error("✗ No cells were checked")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_regex_extract_brackets(result: str, expected: str = None, **options) -> float:
    """
    Verify if REGEX formulas exist in specified range to extract text from 《》 brackets.
    
    This function STRICTLY checks ALL cells in the specified range - no tolerance, no auto-detection.
    Every single cell in the specified range must contain the correct REGEX formula.
    
    This function checks:
    1. Whether ALL cells in the specified range (e.g., B1:B3) contain REGEX formulas
    2. Whether formulas reference the corresponding source column cell (B1->A1, B2->A2, etc.)
    3. Whether formulas contain the correct REGEX function
    4. Whether formulas contain the correct pattern (e.g., "[^《》]{5,}")
    
    IMPORTANT: This function checks ALL cells in the specified range, regardless of whether they
    appear to be empty. If any cell in the specified range is missing a formula, verification fails.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_range: Range containing REGEX formulas (e.g., "B1:B3") - ALL cells must have formulas
            - source_column: Source column letter (e.g., "A")
            - expected_function: Expected function name (default: "REGEX")
            - expected_pattern: Expected regex pattern (e.g., "[^《》]{5,}")
    
    Returns:
        float: 1.0 if ALL cells in specified range contain correct REGEX formulas, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_range = options.get('check_range', 'B1:B3')
        source_column = options.get('source_column', 'A')
        expected_function = options.get('expected_function', 'REGEX')
        expected_pattern = options.get('expected_pattern', '[^《》]{5,}')
        
        logger.info(f"Verifying REGEX formulas in file: {result}")
        logger.info(f"Check range: {check_range}")
        logger.info(f"Source column: {source_column}")
        logger.info(f"Expected function: {expected_function}")
        logger.info(f"Expected pattern: {expected_pattern}")
        
        # Parse check range - strictly use the specified range
        try:
            check_range_clean = check_range.replace('$', '')
            if ':' in check_range_clean:
                check_start_cell, check_end_cell = check_range_clean.split(':')
                check_start_col_letter = ''.join([c for c in check_start_cell if c.isalpha()])
                check_start_row = int(''.join([c for c in check_start_cell if c.isdigit()]))
                check_start_col = column_index_from_string(check_start_col_letter)
                check_end_col_letter = ''.join([c for c in check_end_cell if c.isalpha()])
                check_end_row = int(''.join([c for c in check_end_cell if c.isdigit()]))
                check_end_col = column_index_from_string(check_end_col_letter)
            else:
                logger.error(f"Invalid check range format: {check_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse check range {check_range}: {e}")
            return 0.0
        
        # Verify that range is a single column
        if check_start_col != check_end_col:
            logger.error(f"Check range must be a single column, got: {check_range}")
            return 0.0
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Strictly check ALL cells in the specified range - no auto-detection
        logger.info(f"Checking all cells in range {check_range} (rows {check_start_row} to {check_end_row})")
        
        # Check REGEX formulas - check ALL rows in the specified range
        all_passed = True
        checked_count = 0
        passed_count = 0
        
        for row_num in range(check_start_row, check_end_row + 1):
            cell_coord = f"{check_start_col_letter}{row_num}"
            expected_source_cell = f"{source_column}{row_num}"
            
            try:
                cell = ws[cell_coord]
                checked_count += 1
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.warning(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                else:
                    if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains REGEX function
                regexp_pattern = rf'\b{re.escape(expected_function)}\s*\('
                if not re.search(regexp_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not contain {expected_function} function")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 2: Formula references the corresponding source column cell (A1, A2, etc.)
                source_cell_pattern = rf'\b{re.escape(expected_source_cell)}\b'
                if not re.search(source_cell_pattern, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {cell_coord} formula does not reference {expected_source_cell}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: Formula contains the expected pattern
                # The pattern might be escaped differently in the formula, so we check for key parts
                # Pattern: [^《》]{5,}
                # We check for variations with different escaping
                pattern_variations = [
                    expected_pattern,  # Original: [^《》]{5,}
                    expected_pattern.replace('\\', '\\\\'),  # Double escaped
                    expected_pattern.replace('\\\\', '\\'),  # Single escaped
                    '[^《》]{5,}',  # Direct pattern
                    '\\[\\^《》\\]\\{5,\\}',  # Fully escaped
                ]
                
                pattern_found = False
                for pattern_var in pattern_variations:
                    if pattern_var in formula_text:
                        pattern_found = True
                        break
                
                # Also check for key components: [^《》] and {5,}
                if not pattern_found:
                    # Check for bracket pattern [^《》] and quantifier {5,}
                    has_bracket_pattern = re.search(r'\[\^《》\]|\[\\\^《》\\\]', formula_text)
                    has_quantifier = re.search(r'\{5,\}|\{5,', formula_text)
                    if has_bracket_pattern and has_quantifier:
                        pattern_found = True
                
                if not pattern_found:
                    logger.warning(f"Cell {cell_coord} formula does not contain expected pattern '{expected_pattern}'")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: Formula closes parentheses correctly
                open_count = formula_text.count('(')
                close_count = formula_text.count(')')
                if open_count != close_count:
                    logger.warning(f"Cell {cell_coord} formula has mismatched parentheses")
                    all_passed = False
                    continue
                
                passed_count += 1
                logger.debug(f"✓ Cell {cell_coord} has valid REGEX formula")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        # Require all specified cells to have correct formulas (no tolerance)
        if checked_count > 0:
            if all_passed and passed_count == checked_count:
                logger.info("=" * 60)
                logger.info(f"✓ All {checked_count} cells contain correct REGEX formulas")
                logger.info("=" * 60)
                return 1.0
            else:
                logger.error("=" * 60)
                logger.error(f"✗ Verification failed: {passed_count}/{checked_count} cells passed")
                logger.error(f"  All specified cells must contain correct REGEX formulas")
                logger.error("=" * 60)
                return 0.0
        else:
            logger.error("=" * 60)
            logger.error("✗ No cells were checked")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_contract_expiry_reminder(result: str, expected: str = None, **options) -> float:
    """
    Verify if nested IF formulas with TODAY function exist in specified range for contract expiry reminders.
    
    This function checks:
    1. Whether cells in specified range contain formulas
    2. Whether formulas contain IF and TODAY functions
    3. Whether formulas have nested IF structure
    4. Whether formulas contain date comparison conditions (>=30, <=0)
    5. Whether formulas contain expected text patterns (还有, 天到期, 已过期, 天后到期)
    6. Whether formulas reference the correct source column with relative references
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_range: Range to check (e.g., "C1:C3")
            - source_column: Source column letter for date reference (default: "B")
            - expected_functions: List of expected function names (default: ["IF", "TODAY"])
            - expected_conditions: List of expected conditions (default: [">=30", "<=0"])
            - expected_text_patterns: List of expected text patterns (default: ["还有", "天到期", "已过期", "天后到期"])
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_range = options.get('check_range', 'C1:C3')
        source_column = options.get('source_column', 'B')
        expected_functions = options.get('expected_functions', ['IF', 'TODAY'])
        expected_conditions = options.get('expected_conditions', ['>=30', '<=0'])
        expected_text_patterns = options.get('expected_text_patterns', ['还有', '天到期', '已过期', '天后到期'])
        
        logger.info(f"Verifying contract expiry reminder formulas in file: {result}")
        logger.info(f"Range to check: {check_range}")
        logger.info(f"Expected functions: {expected_functions}")
        
        # Parse the range
        try:
            range_clean = check_range.replace('$', '')
            if ':' in range_clean:
                start_cell, end_cell = range_clean.split(':')
                start_col_letter = ''.join([c for c in start_cell if c.isalpha()])
                start_row = int(''.join([c for c in start_cell if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                end_col_letter = ''.join([c for c in end_cell if c.isalpha()])
                end_row = int(''.join([c for c in end_cell if c.isdigit()]))
                end_col = column_index_from_string(end_col_letter)
            else:
                start_col_letter = ''.join([c for c in range_clean if c.isalpha()])
                start_row = int(''.join([c for c in range_clean if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                end_col_letter = start_col_letter
                end_row = start_row
                end_col = start_col
        except Exception as e:
            logger.error(f"Failed to parse range {check_range}: {e}")
            return 0.0
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each cell in the range
        all_passed = True
        checked_count = 0
        passed_count = 0
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{start_col_letter}{row_num}"
            expected_source_cell = f"{source_column}{row_num}"
            
            try:
                cell = ws[cell_coord]
                checked_count += 1
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.warning(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                else:
                    if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains IF function
                if_pattern = r'\bIF\s*\('
                if_count = len(re.findall(if_pattern, formula_upper))
                if if_count < 2:
                    logger.warning(f"Cell {cell_coord} formula does not contain nested IF functions (found {if_count})")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 2: Formula contains TODAY function
                today_pattern = r'\bTODAY\s*\('
                if not re.search(today_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not contain TODAY function")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: Formula references the correct source column cell (B1, B2, B3, etc.)
                # Allow for variations: B1, $B1, B$1, $B$1
                escaped_source_cell = re.escape(expected_source_cell)
                escaped_source_col = re.escape(source_column)
                source_cell_patterns = [
                    rf'\b{escaped_source_cell}\b',  # B1
                    rf'\${escaped_source_col}{row_num}\b',  # $B1
                    rf'\b{escaped_source_col}\${row_num}\b',  # B$1
                    rf'\${escaped_source_col}\${row_num}\b',  # $B$1
                ]
                
                source_cell_found = False
                for pattern in source_cell_patterns:
                    if re.search(pattern, formula_text, re.IGNORECASE):
                        source_cell_found = True
                        break
                
                if not source_cell_found:
                    logger.warning(f"Cell {cell_coord} formula does not reference source cell {expected_source_cell}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: Formula contains date comparison conditions
                # Check for >=30 pattern (allowing for spacing variations)
                escaped_source_col = re.escape(source_column)
                condition1_pattern = rf'{escaped_source_col}\d+\s*-\s*TODAY\s*\(\s*\)\s*>=\s*30'
                condition1_found = re.search(condition1_pattern, formula_upper)
                
                # Check for <=0 pattern
                condition2_pattern = rf'{escaped_source_col}\d+\s*-\s*TODAY\s*\(\s*\)\s*<=\s*0'
                condition2_found = re.search(condition2_pattern, formula_upper)
                
                if not condition1_found or not condition2_found:
                    logger.warning(f"Cell {cell_coord} formula does not contain expected date comparison conditions")
                    logger.warning(f"Formula: {formula_text}")
                    logger.warning(f"Expected: >=30 and <=0 conditions")
                    all_passed = False
                    continue
                
                # Check 5: Formula contains expected text patterns
                # Check for Chinese text patterns in the formula
                text_patterns_found = 0
                for pattern in expected_text_patterns:
                    if pattern in formula_text:
                        text_patterns_found += 1
                
                # Require at least 3 out of 4 text patterns to be present (for flexibility)
                if text_patterns_found < 3:
                    logger.warning(f"Cell {cell_coord} formula does not contain enough expected text patterns (found {text_patterns_found}/4)")
                    logger.warning(f"Formula: {formula_text}")
                    logger.warning(f"Expected patterns: {expected_text_patterns}")
                    all_passed = False
                    continue
                
                # Check 6: Formula contains string concatenation operator (&)
                if '&' not in formula_text:
                    logger.warning(f"Cell {cell_coord} formula does not contain string concatenation operator (&)")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 7: Formula has balanced parentheses
                open_count = formula_text.count('(')
                close_count = formula_text.count(')')
                if open_count != close_count:
                    logger.warning(f"Cell {cell_coord} formula has mismatched parentheses (open: {open_count}, close: {close_count})")
                    all_passed = False
                    continue
                
                passed_count += 1
                logger.debug(f"✓ Cell {cell_coord} has valid contract expiry reminder formula")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        # Require all specified cells to have correct formulas (no tolerance)
        if checked_count > 0:
            if all_passed and passed_count == checked_count:
                logger.info("=" * 60)
                logger.info(f"✓ All {checked_count} cells contain correct contract expiry reminder formulas")
                logger.info("=" * 60)
                return 1.0
            else:
                logger.error("=" * 60)
                logger.error(f"✗ Verification failed: {passed_count}/{checked_count} cells passed")
                logger.error(f"  All specified cells must contain correct formulas")
                logger.error("=" * 60)
                return 0.0
        else:
            logger.error("=" * 60)
            logger.error("✗ No cells were checked")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_if_sumif_pass_fail(result: str, expected: str = None, **options) -> float:
    """
    Verify if IF(SUMIF(...)) formulas exist in specified range for checking if scores meet threshold.
    
    This function STRICTLY checks ALL cells in the specified range - no tolerance, no auto-detection.
    Every single cell in the specified range must contain the correct formula.
    
    This function checks:
    1. Whether ALL cells in the specified range (e.g., F3:F5) contain formulas
    2. Whether formulas contain IF and SUMIF functions
    3. Whether SUMIF references the correct range (e.g., A:A)
    4. Whether SUMIF criteria references the correct column with relative row (e.g., E3, E4, E5)
    5. Whether SUMIF sum_range references the correct range (e.g., C:C)
    6. Whether IF condition checks threshold (>=280)
    7. Whether IF true value is "录取"
    8. Whether IF false value contains string concatenation with "相差" and "分"
    9. Whether formula structure is correct: IF(SUMIF(range, criteria, sum_range)>=threshold, "录取", "相差"&...&"分")
    
    IMPORTANT: This function checks ALL cells in the specified ranges, regardless of whether they
    appear to be empty. If any cell in the specified range is missing a formula, verification fails.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_range: Range to check (e.g., "F3:F5") - ALL cells must have formulas
            - expected_functions: List of expected function names (default: ["IF", "SUMIF"])
            - sumif_range: SUMIF range reference (default: "A:A")
            - sumif_criteria_col: Column letter for SUMIF criteria (default: "E")
            - sumif_sum_range: SUMIF sum_range reference (default: "C:C")
            - threshold: Threshold value for comparison (default: 280)
            - pass_text: Text to display when condition is met (default: "录取")
            - fail_text_pattern: Pattern for fail text (default: "相差.*分")
    
    Returns:
        float: 1.0 if ALL cells in specified range contain correct formulas, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_range = options.get('check_range', 'F3:F5')
        expected_functions = options.get('expected_functions', ['IF', 'SUMIF'])
        sumif_range = options.get('sumif_range', 'A:A')
        sumif_criteria_col = options.get('sumif_criteria_col', 'E')
        sumif_sum_range = options.get('sumif_sum_range', 'C:C')
        threshold = options.get('threshold', 280)
        pass_text = options.get('pass_text', '录取')
        fail_text_pattern = options.get('fail_text_pattern', '相差.*分')
        
        logger.info(f"Verifying IF(SUMIF) pass/fail formulas in file: {result}")
        logger.info(f"Range to check: {check_range}")
        logger.info(f"Expected functions: {expected_functions}")
        logger.info(f"Threshold: {threshold}")
        
        # Parse the range - strictly use the specified range
        try:
            range_clean = check_range.replace('$', '')
            if ':' in range_clean:
                start_cell, end_cell = range_clean.split(':')
                start_col_letter = ''.join([c for c in start_cell if c.isalpha()])
                start_row = int(''.join([c for c in start_cell if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                end_col_letter = ''.join([c for c in end_cell if c.isalpha()])
                end_row = int(''.join([c for c in end_cell if c.isdigit()]))
                end_col = column_index_from_string(end_col_letter)
            else:
                logger.error(f"Invalid range format: {check_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse range {check_range}: {e}")
            return 0.0
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Strictly check ALL cells in the specified range - no auto-detection
        logger.info(f"Checking all cells in range {check_range} (rows {start_row} to {end_row})")
        
        all_passed = True
        checked_count = 0
        passed_count = 0
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{start_col_letter}{row_num}"
            expected_criteria_cell = f"{sumif_criteria_col}{row_num}"
            
            try:
                cell = ws[cell_coord]
                checked_count += 1
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.warning(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                else:
                    if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains IF function
                if_pattern = r'\bIF\s*\('
                if not re.search(if_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not contain IF function")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 2: Formula contains SUMIF function
                sumif_pattern = r'\bSUMIF\s*\('
                if not re.search(sumif_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not contain SUMIF function")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: SUMIF references the correct range (A:A)
                # Allow variations: A:A, $A:$A
                sumif_range_patterns = [
                    rf'\b{re.escape(sumif_range)}\b',
                    rf'\${re.escape(sumif_range.replace(":", ":$"))}\b',
                ]
                sumif_range_found = False
                for pattern in sumif_range_patterns:
                    if re.search(pattern, formula_text, re.IGNORECASE):
                        sumif_range_found = True
                        break
                if not sumif_range_found:
                    logger.warning(f"Cell {cell_coord} formula does not reference SUMIF range {sumif_range}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: SUMIF criteria references the correct column with relative row (E3, E4, E5, etc.)
                # Allow variations: E3, $E3, E$3, $E$3
                escaped_criteria_cell = re.escape(expected_criteria_cell)
                escaped_criteria_col = re.escape(sumif_criteria_col)
                criteria_cell_patterns = [
                    rf'\b{escaped_criteria_cell}\b',  # E3
                    rf'\${escaped_criteria_col}{row_num}\b',  # $E3
                    rf'\b{escaped_criteria_col}\${row_num}\b',  # E$3
                    rf'\${escaped_criteria_col}\${row_num}\b',  # $E$3
                ]
                
                criteria_cell_found = False
                for pattern in criteria_cell_patterns:
                    if re.search(pattern, formula_text, re.IGNORECASE):
                        criteria_cell_found = True
                        break
                
                if not criteria_cell_found:
                    logger.warning(f"Cell {cell_coord} formula does not reference criteria cell {expected_criteria_cell}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 5: SUMIF sum_range references the correct range (C:C)
                # Allow variations: C:C, $C:$C
                sumif_sum_range_patterns = [
                    rf'\b{re.escape(sumif_sum_range)}\b',
                    rf'\${re.escape(sumif_sum_range.replace(":", ":$"))}\b',
                ]
                sumif_sum_range_found = False
                for pattern in sumif_sum_range_patterns:
                    if re.search(pattern, formula_text, re.IGNORECASE):
                        sumif_sum_range_found = True
                        break
                if not sumif_sum_range_found:
                    logger.warning(f"Cell {cell_coord} formula does not reference SUMIF sum_range {sumif_sum_range}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 6: IF condition checks threshold (>=280)
                threshold_pattern = rf'>=\s*{re.escape(str(threshold))}'
                if not re.search(threshold_pattern, formula_text):
                    logger.warning(f"Cell {cell_coord} formula does not contain threshold check >= {threshold}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 7: IF true value contains "录取"
                if pass_text not in formula_text:
                    logger.warning(f"Cell {cell_coord} formula does not contain pass text '{pass_text}'")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 8: IF false value contains string concatenation pattern
                if not re.search(fail_text_pattern, formula_text):
                    logger.warning(f"Cell {cell_coord} formula does not contain fail text pattern '{fail_text_pattern}'")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 9: Formula contains string concatenation operator (&)
                if '&' not in formula_text:
                    logger.warning(f"Cell {cell_coord} formula does not contain string concatenation operator (&)")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 10: Formula closes parentheses correctly
                open_count = formula_text.count('(')
                close_count = formula_text.count(')')
                if open_count != close_count:
                    logger.warning(f"Cell {cell_coord} formula has mismatched parentheses")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                passed_count += 1
                logger.debug(f"✓ Cell {cell_coord} has valid IF(SUMIF) formula")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        # Require ALL cells to pass (strict check)
        if checked_count > 0:
            if all_passed and passed_count == checked_count:
                logger.info("=" * 60)
                logger.info(f"✓ All cells in range {check_range} contain correct IF(SUMIF) formulas")
                logger.info(f"Passed: {passed_count}/{checked_count}")
                logger.info("=" * 60)
                return 1.0
            else:
                logger.error("=" * 60)
                logger.error(f"✗ Not all cells in range {check_range} contain correct formulas")
                logger.error(f"Passed: {passed_count}/{checked_count}")
                logger.error("=" * 60)
                return 0.0
        else:
            logger.error("=" * 60)
            logger.error("✗ No cells were checked")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0

def verify_if_countif_match_duplicate_names(result: str, expected: str = None, **options) -> float:
    """
    Verify if IF(COUNTIF(...), IF(ISERROR(MATCH(...)), ...)) formulas exist in ALL cells of specified range to extract duplicate names.
    
    This function checks:
    1. Whether ALL cells in the specified range (e.g., C2:C31) contain formulas
    2. Whether formulas contain IF, COUNTIF, ISERROR, and MATCH functions
    3. Whether COUNTIF references the correct range with mixed references (e.g., B$2:B2)
    4. Whether COUNTIF condition is > 1
    5. Whether MATCH references the correct range with mixed references (e.g., C$1:C1)
    6. Whether MATCH third parameter is 0
    7. Whether formula structure is correct: IF(COUNTIF(B$2:B2, B2) > 1, IF(ISERROR(MATCH(B2, C$1:C1, 0)), B2, ""), "")
    
    IMPORTANT: This function checks ALL cells in the specified range. If any cell is missing a formula, verification fails.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_range: Range to check (e.g., "C2:C31") - ALL cells must have formulas
            - source_column: Source column for COUNTIF (default: "B")
            - expected_functions: List of expected function names (default: ["IF", "COUNTIF", "ISERROR", "MATCH"])
    
    Returns:
        float: 1.0 if ALL cells in specified range contain correct formulas, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_range = options.get("check_range", "C2:C31")
        source_column = options.get("source_column", "B")
        expected_functions = options.get("expected_functions", ["IF", "COUNTIF", "ISERROR", "MATCH"])
        
        logger.info(f"Verifying IF(COUNTIF, IF(ISERROR(MATCH))) duplicate names formulas in file: {result}")
        logger.info(f"Range to check: {check_range}")
        logger.info(f"Source column: {source_column}")
        logger.info(f"Expected functions: {expected_functions}")
        
        # Parse the range
        try:
            range_clean = check_range.replace("$", "")
            if ":" in range_clean:
                start_cell, end_cell = range_clean.split(":")
                start_col_letter = "".join([c for c in start_cell if c.isalpha()])
                start_row = int("".join([c for c in start_cell if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                end_col_letter = "".join([c for c in end_cell if c.isalpha()])
                end_row = int("".join([c for c in end_cell if c.isdigit()]))
                end_col = column_index_from_string(end_col_letter)
            else:
                logger.error(f"Invalid range format: {check_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse range {check_range}: {e}")
            return 0.0
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check ALL cells in the specified range
        logger.info(f"Checking all cells in range {check_range} (rows {start_row} to {end_row})")
        
        all_passed = True
        checked_count = 0
        passed_count = 0
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{start_col_letter}{row_num}"
            expected_source_cell = f"{source_column}{row_num}"
            
            try:
                cell = ws[cell_coord]
                checked_count += 1
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.warning(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                elif cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula_text = cell.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains IF function (should have 2 IF functions)
                if_pattern = r"\bIF\s*\("
                if_matches = re.findall(if_pattern, formula_upper)
                if len(if_matches) < 2:
                    logger.warning(f"Cell {cell_coord} formula does not contain nested IF functions (found {len(if_matches)})")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 2: Formula contains COUNTIF function
                countif_pattern = r"\bCOUNTIF\s*\("
                if not re.search(countif_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not contain COUNTIF function")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: Formula contains ISERROR function
                iserror_pattern = r"\bISERROR\s*\("
                if not re.search(iserror_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not contain ISERROR function")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: Formula contains MATCH function
                match_pattern = r"\bMATCH\s*\("
                if not re.search(match_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not contain MATCH function")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 5: COUNTIF references the correct range with mixed references
                # Expected pattern: COUNTIF(B$2:B2, B2) or COUNTIF(B$2:B2,B2)
                # Allow variations in spacing
                countif_range_pattern = rf"COUNTIF\s*\(\s*{re.escape(source_column)}\$\d+\s*:\s*{re.escape(source_column)}\d+\s*,\s*{re.escape(source_column)}\d+\s*\)"
                if not re.search(countif_range_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not have correct COUNTIF range pattern")
                    logger.warning(f"Expected pattern: COUNTIF({source_column}$2:{source_column}2, {source_column}2)")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 6: COUNTIF condition is > 1
                countif_condition_pattern = rf"COUNTIF\s*\([^)]+\)\s*>\s*1"
                if not re.search(countif_condition_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not have COUNTIF condition > 1")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 7: MATCH references the correct range with mixed references
                # Expected pattern: MATCH(B2, C$1:C1, 0) or MATCH(B2,C$1:C1,0)
                # Allow variations in spacing
                match_pattern_full = rf"MATCH\s*\(\s*{re.escape(source_column)}\d+\s*,\s*{re.escape(start_col_letter)}\$\d+\s*:\s*{re.escape(start_col_letter)}\d+\s*,\s*0\s*\)"
                if not re.search(match_pattern_full, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not have correct MATCH pattern")
                    logger.warning(f"Expected pattern: MATCH({source_column}2, {start_col_letter}$1:{start_col_letter}1, 0)")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 8: Formula structure is IF(COUNTIF(...)>1, IF(ISERROR(MATCH(...)), B2, ""), "")
                # Check that outer IF wraps COUNTIF condition
                outer_if_pattern = rf"IF\s*\(\s*COUNTIF\s*\([^)]+\)\s*>\s*1\s*,"
                if not re.search(outer_if_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not have correct outer IF structure")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 9: Inner IF wraps ISERROR(MATCH(...))
                inner_if_pattern = rf"IF\s*\(\s*ISERROR\s*\(\s*MATCH\s*\([^)]+\)\s*\)\s*,"
                if not re.search(inner_if_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not have correct inner IF structure")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 10: Formula contains empty string literals ("")
                if '""' not in formula_text and '""' not in formula_text.replace(' ', ''):
                    # Check for variations like "" or ''
                    if not ('""' in formula_text or "''" in formula_text or '""' in formula_text.replace(' ', '')):
                        logger.warning(f"Cell {cell_coord} formula does not contain empty string literals")
                        logger.warning(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                
                # Check 11: Formula closes parentheses correctly
                open_count = formula_text.count("(")
                close_count = formula_text.count(")")
                if open_count != close_count:
                    logger.warning(f"Cell {cell_coord} formula has mismatched parentheses")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                passed_count += 1
                logger.debug(f"✓ Cell {cell_coord} has valid IF(COUNTIF, IF(ISERROR(MATCH))) formula")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        # Require ALL cells to pass (strict check)
        if checked_count > 0:
            if all_passed and passed_count == checked_count:
                logger.info("=" * 60)
                logger.info(f"✓ All cells in range {check_range} contain correct IF(COUNTIF, IF(ISERROR(MATCH))) formulas")
                logger.info(f"Passed: {passed_count}/{checked_count}")
                logger.info("=" * 60)
                return 1.0
            else:
                logger.error("=" * 60)
                logger.error(f"✗ Not all cells in range {check_range} contain correct formulas")
                logger.error(f"Passed: {passed_count}/{checked_count}")
                logger.error("=" * 60)
                return 0.0
        else:
            logger.error("=" * 60)
            logger.error("✗ No cells were checked")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0



def verify_department_merge(result: str, expected: str = None, **options) -> float:
    """
    Verify if departments in specified range are merged correctly and personnel data matches.
    
    This function checks:
    1. Whether departments in A2:A9 are merged correctly (each department merged into appropriate number of cells)
    2. Whether department names are correct (数据部, 市场部, 技术部, 人事部)
    3. Whether B column personnel data correctly corresponds to each department
    4. Department order can be arbitrary, personnel order within same department can be arbitrary
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_range: Range to check (e.g., "A2:A9")
            - personnel_column: Column letter for personnel data (default: "B")
            - expected_departments: Dict mapping department names to their config:
                {
                    "数据部": {"merge_count": 3, "personnel": ["张三", "李四", "王五"]},
                    "市场部": {"merge_count": 1, "personnel": ["吴十"]},
                    "技术部": {"merge_count": 2, "personnel": ["赵六", "钱七"]},
                    "人事部": {"merge_count": 2, "personnel": ["孙八", "周九"]}
                }
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        from openpyxl.utils import get_column_letter, column_index_from_string
        from openpyxl.cell.cell import MergedCell
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_range = options.get('check_range', 'A2:A9')
        personnel_column = options.get('personnel_column', 'B')
        expected_departments = options.get('expected_departments', {})
        
        logger.info(f"Verifying department merge in file: {result}")
        logger.info(f"Range to check: {check_range}")
        logger.info(f"Personnel column: {personnel_column}")
        logger.info(f"Expected departments: {list(expected_departments.keys())}")
        
        # Parse the range
        try:
            range_clean = check_range.replace('$', '')
            if ':' in range_clean:
                start_cell, end_cell = range_clean.split(':')
                start_col_letter = ''.join([c for c in start_cell if c.isalpha()])
                start_row = int(''.join([c for c in start_cell if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                end_col_letter = ''.join([c for c in end_cell if c.isalpha()])
                end_row = int(''.join([c for c in end_cell if c.isdigit()]))
                end_col = column_index_from_string(end_col_letter)
            else:
                logger.error(f"Invalid range format: {check_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse range {check_range}: {e}")
            return 0.0
        
        # Verify that range is a single column
        if start_col != end_col:
            logger.error(f"Check range must be a single column, got: {check_range}")
            return 0.0
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=True)  # data_only=True to get values
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Get all merged ranges in the worksheet
        merged_ranges = list(ws.merged_cells.ranges)
        
        # Track which rows are covered by merged cells
        merged_row_map = {}  # row -> (start_row, end_row, department_name)
        unmerged_rows = set(range(start_row, end_row + 1))
        
        # Process merged ranges that intersect with our check range
        for merged_range in merged_ranges:
            merged_start_col = merged_range.min_col
            merged_start_row = merged_range.min_row
            merged_end_col = merged_range.max_col
            merged_end_row = merged_range.max_row
            
            # Check if this merged range is in column A (our check column)
            if merged_start_col == start_col and merged_end_col == start_col:
                # Check if it intersects with our range
                if not (merged_end_row < start_row or merged_start_row > end_row):
                    # Get the department name from the top-left cell
                    top_left_cell = ws[f"{start_col_letter}{merged_start_row}"]
                    dept_name = str(top_left_cell.value).strip() if top_left_cell.value else ""
                    
                    # Mark all rows in this merged range
                    for row in range(merged_start_row, merged_end_row + 1):
                        if row in unmerged_rows:
                            unmerged_rows.remove(row)
                        merged_row_map[row] = (merged_start_row, merged_end_row, dept_name)
        
        # Process unmerged rows (single cell departments)
        for row in unmerged_rows:
            cell = ws[f"{start_col_letter}{row}"]
            dept_name = str(cell.value).strip() if cell.value else ""
            merged_row_map[row] = (row, row, dept_name)  # Single cell, start_row == end_row
        
        # Group rows by department
        department_groups = {}  # dept_name -> list of (start_row, end_row, row_count)
        for row in range(start_row, end_row + 1):
            if row in merged_row_map:
                start_r, end_r, dept_name = merged_row_map[row]
                if dept_name not in department_groups:
                    department_groups[dept_name] = []
                # Only add if this is the start row of a merged range (avoid duplicates)
                if row == start_r:
                    row_count = end_r - start_r + 1
                    department_groups[dept_name].append((start_r, end_r, row_count))
        
        logger.info(f"Found departments: {list(department_groups.keys())}")
        
        # Verify each expected department
        found_departments = set(department_groups.keys())
        expected_dept_names = set(expected_departments.keys())
        
        # Check if all expected departments are found
        if found_departments != expected_dept_names:
            logger.error(f"Department mismatch. Expected: {expected_dept_names}, Found: {found_departments}")
            return 0.0
        
        # Verify each department's merge count and personnel
        for dept_name, dept_config in expected_departments.items():
            expected_merge_count = dept_config.get('merge_count', 1)
            expected_personnel = set(dept_config.get('personnel', []))
            
            if dept_name not in department_groups:
                logger.error(f"Department '{dept_name}' not found")
                return 0.0
            
            dept_ranges = department_groups[dept_name]
            
            # Check merge count - should have exactly one merged range with correct count
            if len(dept_ranges) != 1:
                logger.error(f"Department '{dept_name}' should have exactly one merged range, found {len(dept_ranges)}")
                return 0.0
            
            start_r, end_r, actual_merge_count = dept_ranges[0]
            
            if actual_merge_count != expected_merge_count:
                logger.error(f"Department '{dept_name}' should merge {expected_merge_count} cells, but merged {actual_merge_count} cells")
                return 0.0
            
            # Verify personnel data in B column
            actual_personnel = []
            for row in range(start_r, end_r + 1):
                personnel_cell = ws[f"{personnel_column}{row}"]
                personnel_value = str(personnel_cell.value).strip() if personnel_cell.value else ""
                if personnel_value:
                    actual_personnel.append(personnel_value)
            
            actual_personnel_set = set(actual_personnel)
            
            if actual_personnel_set != expected_personnel:
                logger.error(f"Department '{dept_name}' personnel mismatch. Expected: {expected_personnel}, Found: {actual_personnel_set}")
                return 0.0
            
            logger.info(f"✓ Department '{dept_name}': merged {actual_merge_count} cells, personnel: {actual_personnel}")
        
        logger.info("=" * 60)
        logger.info("✓ All departments merged correctly with matching personnel data")
        logger.info("=" * 60)
        return 1.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_filter_non_letter_end(result: str, expected: str = None, **options) -> float:
    """
    Verify if formula cells in specified range and filter condition are correctly applied.
    
    This function STRICTLY checks ALL cells in the specified range - no tolerance, no auto-detection.
    Every single cell in the specified range must contain the correct formula.
    
    This function checks:
    1. Whether ALL cells in the specified formula range (e.g., B1:B10) contain formulas
    2. Whether formulas contain N, ISERROR, INDIRECT, and RIGHT functions
    3. Whether formulas reference the correct A column cell with relative row (e.g., $A2, $A3, etc.)
    4. Whether formulas have the correct structure: =N(ISERROR(N(INDIRECT(RIGHT($A2)&4^8))))
    5. Whether auto filter is enabled on the worksheet
    6. Whether filter is applied to the specified filter column (default: column B)
    7. Whether filter condition matches expected value (default: "1")
    
    The formula =N(ISERROR(N(INDIRECT(RIGHT($A2)&4^8)))) works as follows:
    - RIGHT($A2) gets the last character of A2
    - INDIRECT(RIGHT($A2)&4^8) tries to create a cell reference by concatenating the last character with "4^8" (65536)
    - If the last character is a letter, INDIRECT fails (invalid cell reference), ISERROR returns TRUE, N converts to 1
    - If the last character is a number, INDIRECT succeeds, ISERROR returns FALSE, N converts to 0
    - So the formula returns 1 for rows ending with letters (filter out) and 0 for rows ending with numbers (keep)
    
    IMPORTANT: This function checks ALL cells in the specified formula range. If any cell is missing a formula, verification fails.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formula_range: Range containing formulas (e.g., "B1:B10") - ALL cells must have formulas
            - source_column: Source column for RIGHT function (default: "A")
            - filter_column: Column to filter (default: "B")
            - filter_value: Expected filter value (default: "1")
            - expected_formula: Expected filter formula pattern (default: "=N(ISERROR(N(INDIRECT(RIGHT($A2)&4^8))))")
            - expected_functions: List of expected function names (default: ["N", "ISERROR", "INDIRECT", "RIGHT"])
    
    Returns:
        float: 1.0 if ALL cells in specified range contain correct formulas AND filter is correctly applied, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formula_range = options.get('formula_range', 'B1:B10')
        source_column = options.get('source_column', 'A')
        filter_column = options.get('filter_column', 'B')
        filter_value = options.get('filter_value', '1')
        expected_functions = options.get('expected_functions', ['N', 'ISERROR', 'INDIRECT', 'RIGHT'])
        
        logger.info(f"Verifying filter for non-letter ending rows in file: {result}")
        logger.info(f"Formula range: {formula_range}")
        logger.info(f"Source column: {source_column}")
        logger.info(f"Filter column: {filter_column}")
        logger.info(f"Filter value: {filter_value}")
        
        # Parse the formula range
        try:
            range_clean = formula_range.replace("$", "")
            if ":" in range_clean:
                start_cell, end_cell = range_clean.split(":")
                start_col_letter = "".join([c for c in start_cell if c.isalpha()])
                start_row = int("".join([c for c in start_cell if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                end_col_letter = "".join([c for c in end_cell if c.isalpha()])
                end_row = int("".join([c for c in end_cell if c.isdigit()]))
                end_col = column_index_from_string(end_col_letter)
            else:
                logger.error(f"Invalid range format: {formula_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse range {formula_range}: {e}")
            return 0.0
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=False)
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check 1: Verify ALL cells in formula range contain formulas
        logger.info(f"Checking all cells in range {formula_range} (rows {start_row} to {end_row})")
        
        all_passed = True
        checked_count = 0
        passed_count = 0
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{start_col_letter}{row_num}"
            expected_source_cell = f"${source_column}{row_num}"
            
            try:
                cell = ws[cell_coord]
                checked_count += 1
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.error(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                elif cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula_text = cell.value
                
                if formula_text is None:
                    logger.error(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains all expected functions
                for func_name in expected_functions:
                    func_pattern = rf'\b{re.escape(func_name.upper())}\s*\('
                    if not re.search(func_pattern, formula_upper):
                        logger.error(f"Cell {cell_coord} formula does not contain {func_name} function")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        break
                
                if not all_passed:
                    continue
                
                # Check 2: Formula contains N function
                n_pattern = r'\bN\s*\('
                if not re.search(n_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain N function")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: Formula contains ISERROR function
                iserror_pattern = r'\bISERROR\s*\('
                if not re.search(iserror_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain ISERROR function")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: Formula contains INDIRECT function
                indirect_pattern = r'\bINDIRECT\s*\('
                if not re.search(indirect_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain INDIRECT function")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 5: Formula contains RIGHT function
                right_pattern = r'\bRIGHT\s*\('
                if not re.search(right_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain RIGHT function")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 6: Formula references the correct source column with correct row
                source_cell_pattern = rf'\$\s*{re.escape(source_column.upper())}\s*{row_num}\b'
                if not re.search(source_cell_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not reference {expected_source_cell}")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 7: Formula contains the pattern "4^8" or "4^ 8" (with possible spaces)
                power_pattern = r'4\s*\^\s*8'
                if not re.search(power_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain '4^8' pattern")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 8: Formula structure is N(ISERROR(N(INDIRECT(RIGHT(...)&4^8))))
                # Check nested structure
                nested_pattern = r'N\s*\(\s*ISERROR\s*\(\s*N\s*\(\s*INDIRECT\s*\('
                if not re.search(nested_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not have correct nested structure N(ISERROR(N(INDIRECT(...))))")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                passed_count += 1
                logger.info(f"✓ Cell {cell_coord} has valid formula: {formula_text}")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                all_passed = False
        
        if not all_passed:
            logger.error(f"✗ Formula verification failed: {passed_count}/{checked_count} cells passed")
            return 0.0
        
        if checked_count == 0:
            logger.error(f"No cells found in range {formula_range}")
            return 0.0
        
        logger.info(f"✓ All {checked_count} cells in range {formula_range} contain correct formulas")
        
        # Check 2: Verify filter is applied (either AutoFilter or Standard Filter)
        # Standard Filter in LibreOffice Calc may not create AutoFilter, but hides rows instead
        filter_col_id = column_index_from_string(filter_column) - 1  # 0-based index
        filter_found = False
        filter_condition_met = False
        
        # Try to check AutoFilter first (for AutoFilter mode)
        if ws.auto_filter is not None and ws.auto_filter.ref is not None:
            logger.info(f"✓ AutoFilter is enabled, range: {ws.auto_filter.ref}")
            
            # Debug: Log all filter columns
            logger.info(f"Checking filter columns (total: {len(ws.auto_filter.filterColumn)})")
            for idx, flt_clm in enumerate(ws.auto_filter.filterColumn):
                logger.info(f"  Filter column {idx}: colId={flt_clm.colId}, hiddenButton={flt_clm.hiddenButton}, showButton={flt_clm.showButton}")
                if flt_clm.filters is not None:
                    logger.info(f"    filters.filter count: {len(flt_clm.filters.filter)}")
                    for flt in flt_clm.filters.filter:
                        # Handle both object with .val attribute and string values
                        if isinstance(flt, str):
                            logger.info(f"      Filter value: {flt} (type: str)")
                        elif hasattr(flt, 'val'):
                            logger.info(f"      Filter value: {flt.val} (type: {type(flt.val)})")
                        else:
                            logger.info(f"      Filter value: {flt} (type: {type(flt)})")
                if flt_clm.customFilters is not None:
                    logger.info(f"    customFilters count: {len(flt_clm.customFilters.customFilter)}")
                    for flt in flt_clm.customFilters.customFilter:
                        if isinstance(flt, str):
                            logger.info(f"      Custom filter: {flt} (type: str)")
                        elif hasattr(flt, 'operator') and hasattr(flt, 'val'):
                            logger.info(f"      Custom filter: operator={flt.operator}, val={flt.val} (type: {type(flt.val)})")
                        else:
                            logger.info(f"      Custom filter: {flt} (type: {type(flt)})")
            
            for flt_clm in ws.auto_filter.filterColumn:
                if flt_clm.colId == filter_col_id:
                    filter_found = True
                    logger.info(f"✓ Filter found on column {filter_column} (colId: {filter_col_id})")
                    
                    # Check if filters exist (standard filter)
                    if flt_clm.filters is not None:
                        logger.info(f"  filters object exists, filter count: {len(flt_clm.filters.filter) if hasattr(flt_clm.filters, 'filter') else 0}")
                        if hasattr(flt_clm.filters, 'filter') and len(flt_clm.filters.filter) > 0:
                            for flt in flt_clm.filters.filter:
                                # Handle both object with .val attribute and string values
                                if isinstance(flt, str):
                                    filter_val_str = flt
                                    logger.info(f"  Filter value (string): {filter_val_str}")
                                    if str(flt) == str(filter_value):
                                        filter_condition_met = True
                                        logger.info(f"✓ Filter condition matches: {filter_column} = {filter_value}")
                                elif hasattr(flt, 'val'):
                                    filter_val_str = str(flt.val)
                                    logger.info(f"  Filter value (object): {filter_val_str} (type: {type(flt.val)})")
                                    if str(flt.val) == str(filter_value) or flt.val == filter_value:
                                        filter_condition_met = True
                                        logger.info(f"✓ Filter condition matches: {filter_column} = {filter_value}")
                                else:
                                    filter_val_str = str(flt)
                                    logger.info(f"  Filter value (other): {filter_val_str} (type: {type(flt)})")
                                    if str(flt) == str(filter_value):
                                        filter_condition_met = True
                                        logger.info(f"✓ Filter condition matches: {filter_column} = {filter_value}")
                        else:
                            logger.warning(f"  filters.filter is empty or doesn't exist")
                    
                    # Check if custom filters exist
                    if flt_clm.customFilters is not None:
                        logger.info(f"✓ Custom filter exists on column {filter_column}")
                        for flt in flt_clm.customFilters.customFilter:
                            # Handle different filter object types
                            if isinstance(flt, str):
                                logger.info(f"  Custom filter (string): {flt}")
                                if str(flt) == str(filter_value):
                                    filter_condition_met = True
                                    logger.info(f"✓ Custom filter condition matches: {filter_column} = {filter_value}")
                            elif hasattr(flt, 'operator') and hasattr(flt, 'val'):
                                filter_val_str = str(flt.val)
                                logger.info(f"  Custom filter: operator={flt.operator}, val={filter_val_str}")
                                # Check for equal operator
                                operator_match = flt.operator in ['equal', '=', 'eq']
                                if operator_match:
                                    if str(flt.val) == str(filter_value) or flt.val == filter_value:
                                        filter_condition_met = True
                                        logger.info(f"✓ Custom filter condition matches: {filter_column} = {filter_value}")
                            else:
                                filter_val_str = str(flt)
                                logger.info(f"  Custom filter (other): {filter_val_str} (type: {type(flt)})")
                                if str(flt) == str(filter_value):
                                    filter_condition_met = True
                                    logger.info(f"✓ Custom filter condition matches: {filter_column} = {filter_value}")
                    
                    # Also check if the column has hiddenButton or showButton set (indicates filter is active)
                    if flt_clm.hiddenButton or (hasattr(flt_clm, 'showButton') and not flt_clm.showButton):
                        logger.info(f"  Filter button state indicates filter is active on column {filter_column}")
                        # If we found the filter column but couldn't match the value, still consider it if button state indicates filter
                        if not filter_condition_met:
                            logger.warning(f"  Filter column found but condition value not matched. Button state suggests filter is active.")
                            # For LibreOffice Calc, sometimes the filter value might not be directly accessible
                            # We'll be more lenient if the filter column exists and is active
                            filter_condition_met = True
                            logger.info(f"  Accepting filter based on button state (LibreOffice Calc compatibility)")
                    
                    break
        else:
            logger.info("AutoFilter is not enabled, checking for Standard Filter (row hiding)")
        
        # Check 3: If AutoFilter not found or condition not met, check row hiding (Standard Filter)
        # Standard Filter hides rows that don't match the condition
        # For filter condition B = 1, rows with B != 1 should be hidden, rows with B = 1 should be visible
        if not filter_condition_met:
            logger.info(f"Checking row hiding state for Standard Filter on column {filter_column} = {filter_value}")
            
            # Load workbook again with data_only=True to get calculated values instead of formulas
            try:
                wb_values = openpyxl.load_workbook(result, data_only=True)
                ws_values = wb_values.active
            except Exception as e:
                logger.warning(f"Failed to load workbook with data_only=True: {e}, using original workbook")
                ws_values = ws
            
            # Check rows in the formula range to see if filtering is applied correctly
            # We need to check if rows with B != filter_value are hidden, and rows with B == filter_value are visible
            visible_count = 0
            hidden_count = 0
            matching_visible = 0
            matching_hidden = 0
            non_matching_visible = 0
            non_matching_hidden = 0
            
            for row_num in range(start_row, end_row + 1):
                # Get the cell VALUE (calculated result) in the filter column, not the formula
                filter_cell = ws_values[f"{filter_column}{row_num}"]
                cell_value = filter_cell.value
                
                # Check if row is hidden
                row_dimension = ws.row_dimensions.get(row_num)
                is_hidden = row_dimension is not None and row_dimension.hidden if row_dimension else False
                
                # Convert cell value to string for comparison (use calculated value, not formula)
                # Handle different value types (int, float, str, etc.)
                if cell_value is None:
                    cell_value_str = ""
                elif isinstance(cell_value, (int, float)):
                    cell_value_str = str(int(cell_value)) if isinstance(cell_value, float) and cell_value.is_integer() else str(cell_value)
                else:
                    cell_value_str = str(cell_value)
                
                if is_hidden:
                    hidden_count += 1
                    if cell_value_str == str(filter_value):
                        matching_hidden += 1
                        logger.warning(f"  Row {row_num}: B={cell_value_str} matches filter but is HIDDEN (unexpected)")
                    else:
                        non_matching_hidden += 1
                        logger.debug(f"  Row {row_num}: B={cell_value_str} doesn't match filter and is HIDDEN (expected)")
                else:
                    visible_count += 1
                    if cell_value_str == str(filter_value):
                        matching_visible += 1
                        logger.debug(f"  Row {row_num}: B={cell_value_str} matches filter and is VISIBLE (expected)")
                    else:
                        non_matching_visible += 1
                        logger.warning(f"  Row {row_num}: B={cell_value_str} doesn't match filter but is VISIBLE (unexpected)")
            
            logger.info(f"  Row visibility summary:")
            logger.info(f"    Total rows: {end_row - start_row + 1}")
            logger.info(f"    Visible: {visible_count}, Hidden: {hidden_count}")
            logger.info(f"    Matching filter ({filter_column}={filter_value}): {matching_visible} visible, {matching_hidden} hidden")
            logger.info(f"    Non-matching: {non_matching_visible} visible, {non_matching_hidden} hidden")
            
            # Standard Filter should hide rows that don't match the condition
            # So rows with B != filter_value should be hidden, rows with B == filter_value should be visible
            if matching_visible > 0 and non_matching_visible == 0:
                # All matching rows are visible, all non-matching rows are hidden - perfect!
                filter_condition_met = True
                filter_found = True
                logger.info(f"✓ Standard Filter correctly applied: {matching_visible} matching rows visible, {non_matching_hidden} non-matching rows hidden")
            elif matching_visible > 0:
                # Some matching rows are visible - accept if most are correct
                if non_matching_visible == 0 or (matching_visible > non_matching_visible):
                    filter_condition_met = True
                    filter_found = True
                    logger.info(f"✓ Standard Filter applied: {matching_visible} matching rows visible")
                else:
                    logger.warning(f"  Standard Filter may not be correctly applied: {non_matching_visible} non-matching rows are visible")
            else:
                logger.warning(f"  No matching rows are visible, filter may not be correctly applied")
        
        if not filter_found:
            logger.error(f"Filter not found on column {filter_column} (colId: {filter_col_id})")
            if ws.auto_filter is not None and ws.auto_filter.ref is not None:
                logger.error(f"Available filter columns: {[flt_clm.colId for flt_clm in ws.auto_filter.filterColumn]}")
            else:
                logger.error("No AutoFilter found, and Standard Filter (row hiding) not detected")
            return 0.0
        
        if not filter_condition_met:
            logger.error(f"Filter condition not met: {filter_column} = {filter_value}")
            logger.error("Please check if the filter is correctly applied in LibreOffice Calc")
            return 0.0
        
        logger.info("=" * 60)
        logger.info("✓ All verification checks passed")
        logger.info(f"  - All {checked_count} cells in {formula_range} contain correct formulas")
        if ws.auto_filter is not None and ws.auto_filter.ref is not None:
            logger.info(f"  - AutoFilter is enabled")
        else:
            logger.info(f"  - Standard Filter detected (via row hiding)")
        logger.info(f"  - Filter applied to column {filter_column} with condition = {filter_value}")
        logger.info("=" * 60)
        return 1.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0



def verify_column_format_match(result: str, expected: str = None, **options) -> float:
    """
    Verify if two column ranges have identical formatting, including merged cells, borders, fonts, fills, alignment, etc.
    
    This function checks:
    1. Whether merged cells in source range match merged cells in target range (same positions and sizes)
    2. Whether border styles match for all cells
    3. Whether font properties match (size, color, bold, italic, underline, name)
    4. Whether fill/background colors match
    5. Whether alignment matches (horizontal, vertical)
    6. Whether number formats match
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - source_range: Source range to compare (e.g., "E6:E35")
            - target_range: Target range to compare (e.g., "G6:G35")
    
    Returns:
        float: 1.0 if all formatting matches, 0.0 otherwise
    """
    try:
        from openpyxl.utils import get_column_letter, column_index_from_string
        from openpyxl.cell.cell import MergedCell
        from openpyxl.styles import Border, Side
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        source_range = options.get('source_range', 'E6:E35')
        target_range = options.get('target_range', 'G6:G35')
        
        logger.info(f"Verifying column format match in file: {result}")
        logger.info(f"Source range: {source_range}")
        logger.info(f"Target range: {target_range}")
        
        # Parse source range
        try:
            source_clean = source_range.replace('$', '')
            if ':' in source_clean:
                source_start, source_end = source_clean.split(':')
                source_start_col_letter = ''.join([c for c in source_start if c.isalpha()])
                source_start_row = int(''.join([c for c in source_start if c.isdigit()]))
                source_start_col = column_index_from_string(source_start_col_letter)
                source_end_col_letter = ''.join([c for c in source_end if c.isalpha()])
                source_end_row = int(''.join([c for c in source_end if c.isdigit()]))
                source_end_col = column_index_from_string(source_end_col_letter)
            else:
                logger.error(f"Invalid source range format: {source_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse source range {source_range}: {e}")
            return 0.0
        
        # Parse target range
        try:
            target_clean = target_range.replace('$', '')
            if ':' in target_clean:
                target_start, target_end = target_clean.split(':')
                target_start_col_letter = ''.join([c for c in target_start if c.isalpha()])
                target_start_row = int(''.join([c for c in target_start if c.isdigit()]))
                target_start_col = column_index_from_string(target_start_col_letter)
                target_end_col_letter = ''.join([c for c in target_end if c.isalpha()])
                target_end_row = int(''.join([c for c in target_end if c.isdigit()]))
                target_end_col = column_index_from_string(target_end_col_letter)
            else:
                logger.error(f"Invalid target range format: {target_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse target range {target_range}: {e}")
            return 0.0
        
        # Verify ranges have same number of rows
        if (source_end_row - source_start_row) != (target_end_row - target_start_row):
            logger.error(f"Source and target ranges have different row counts: {source_range} vs {target_range}")
            return 0.0
        
        # Verify ranges are single columns
        if source_start_col != source_end_col:
            logger.error(f"Source range must be a single column: {source_range}")
            return 0.0
        if target_start_col != target_end_col:
            logger.error(f"Target range must be a single column: {target_range}")
            return 0.0
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=False)
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Get all merged ranges
        merged_ranges = list(ws.merged_cells.ranges)
        
        # Build merged cell maps for both columns
        source_merged_map = {}  # row -> (start_row, end_row)
        target_merged_map = {}  # row -> (start_row, end_row)
        
        for merged_range in merged_ranges:
            merged_start_col = merged_range.min_col
            merged_start_row = merged_range.min_row
            merged_end_col = merged_range.max_col
            merged_end_row = merged_range.max_row
            
            # Check if merged range is in source column
            if merged_start_col == source_start_col and merged_end_col == source_start_col:
                if not (merged_end_row < source_start_row or merged_start_row > source_end_row):
                    for row in range(merged_start_row, merged_end_row + 1):
                        if source_start_row <= row <= source_end_row:
                            source_merged_map[row] = (merged_start_row, merged_end_row)
            
            # Check if merged range is in target column
            if merged_start_col == target_start_col and merged_end_col == target_start_col:
                if not (merged_end_row < target_start_row or merged_start_row > target_end_row):
                    for row in range(merged_start_row, merged_end_row + 1):
                        if target_start_row <= row <= target_end_row:
                            target_merged_map[row] = (merged_start_row, merged_end_row)
        
        # Check 1: Merged cells match
        logger.info("Checking merged cells...")
        source_merged_groups = {}
        target_merged_groups = {}
        
        for row in range(source_start_row, source_end_row + 1):
            if row in source_merged_map:
                merge_key = source_merged_map[row]
                if merge_key not in source_merged_groups:
                    source_merged_groups[merge_key] = []
                source_merged_groups[merge_key].append(row)
        
        for row in range(target_start_row, target_end_row + 1):
            if row in target_merged_map:
                merge_key = target_merged_map[row]
                if merge_key not in target_merged_groups:
                    target_merged_groups[merge_key] = []
                target_merged_groups[merge_key].append(row)
        
        # Convert to relative positions for comparison
        source_relative_merges = {}
        for (start_row, end_row), rows in source_merged_groups.items():
            rel_start = start_row - source_start_row
            rel_end = end_row - source_start_row
            source_relative_merges[(rel_start, rel_end)] = rows
        
        target_relative_merges = {}
        for (start_row, end_row), rows in target_merged_groups.items():
            rel_start = start_row - target_start_row
            rel_end = end_row - target_start_row
            target_relative_merges[(rel_start, rel_end)] = rows
        
        if source_relative_merges != target_relative_merges:
            logger.error(f"Merged cells do not match: source={source_relative_merges}, target={target_relative_merges}")
            return 0.0
        
        logger.info("✓ Merged cells match")
        
        # Check 2-6: Format properties for each row
        logger.info("Checking format properties for each row...")
        all_passed = True
        checked_count = 0
        passed_count = 0
        
        def get_cell_border_info(cell):
            """Get border information as a comparable format"""
            if cell.border is None:
                return None
            border = cell.border
            return {
                'left': str(border.left.style) if border.left else None,
                'right': str(border.right.style) if border.right else None,
                'top': str(border.top.style) if border.top else None,
                'bottom': str(border.bottom.style) if border.bottom else None,
            }
        
        def get_cell_font_info(cell):
            """Get font information as a comparable format"""
            if cell.font is None:
                return None
            font = cell.font
            return {
                'name': font.name,
                'size': font.size,
                'bold': font.bold,
                'italic': font.italic,
                'underline': str(font.underline) if font.underline else None,
                'color': font.color.rgb if font.color and font.color.rgb else None,
            }
        
        def get_cell_fill_info(cell):
            """Get fill information as a comparable format"""
            if cell.fill is None:
                return None
            fill = cell.fill
            try:
                fg_color = fill.fgColor.rgb if fill.fgColor and fill.fgColor.rgb else None
            except:
                fg_color = None
            try:
                bg_color = fill.bgColor.rgb if fill.bgColor and fill.bgColor.rgb else None
            except:
                bg_color = None
            return {
                'fgColor': fg_color,
                'bgColor': bg_color,
                'fill_type': fill.fill_type if hasattr(fill, 'fill_type') else None,
            }
        
        def get_cell_alignment_info(cell):
            """Get alignment information as a comparable format"""
            if cell.alignment is None:
                return None
            alignment = cell.alignment
            return {
                'horizontal': str(alignment.horizontal) if alignment.horizontal else None,
                'vertical': str(alignment.vertical) if alignment.vertical else None,
            }
        
        for row_offset in range(source_end_row - source_start_row + 1):
            source_row = source_start_row + row_offset
            target_row = target_start_row + row_offset
            
            source_cell_coord = f"{source_start_col_letter}{source_row}"
            target_cell_coord = f"{target_start_col_letter}{target_row}"
            
            # Skip if this row is part of a merged cell (only check top-left cell)
            if source_row in source_merged_map:
                merge_start, merge_end = source_merged_map[source_row]
                if source_row != merge_start:
                    continue  # Skip non-top-left cells in merged range
            
            try:
                source_cell = ws[source_cell_coord]
                target_cell = ws[target_cell_coord]
                checked_count += 1
                
                # Check borders
                source_border = get_cell_border_info(source_cell)
                target_border = get_cell_border_info(target_cell)
                if source_border != target_border:
                    logger.warning(f"Row {source_row}: Border mismatch - source={source_border}, target={target_border}")
                    all_passed = False
                    continue
                
                # Check font
                source_font = get_cell_font_info(source_cell)
                target_font = get_cell_font_info(target_cell)
                if source_font != target_font:
                    logger.warning(f"Row {source_row}: Font mismatch - source={source_font}, target={target_font}")
                    all_passed = False
                    continue
                
                # Check fill
                source_fill = get_cell_fill_info(source_cell)
                target_fill = get_cell_fill_info(target_cell)
                if source_fill != target_fill:
                    logger.warning(f"Row {source_row}: Fill mismatch - source={source_fill}, target={target_fill}")
                    all_passed = False
                    continue
                
                # Check alignment
                source_alignment = get_cell_alignment_info(source_cell)
                target_alignment = get_cell_alignment_info(target_cell)
                if source_alignment != target_alignment:
                    logger.warning(f"Row {source_row}: Alignment mismatch - source={source_alignment}, target={target_alignment}")
                    all_passed = False
                    continue
                
                # Check number format
                source_num_format = source_cell.number_format
                target_num_format = target_cell.number_format
                if source_num_format != target_num_format:
                    logger.warning(f"Row {source_row}: Number format mismatch - source={source_num_format}, target={target_num_format}")
                    all_passed = False
                    continue
                
                passed_count += 1
                
            except Exception as e:
                logger.error(f"Error checking row {source_row}: {e}")
                all_passed = False
                continue
        
        if not all_passed:
            logger.error(f"Format verification failed: {passed_count}/{checked_count} cells passed")
            return 0.0
        
        logger.info("=" * 60)
        logger.info("✓ All format verification checks passed")
        logger.info(f"  - Merged cells match between {source_range} and {target_range}")
        logger.info(f"  - All {checked_count} cells have matching format properties:")
        logger.info(f"    * Borders")
        logger.info(f"    * Fonts (size, color, style)")
        logger.info(f"    * Fills (background colors)")
        logger.info(f"    * Alignment")
        logger.info(f"    * Number formats")
        logger.info("=" * 60)
        return 1.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_clean_remove_newlines(result: str, expected: str = None, **options) -> float:
    """
    Verify if CLEAN formulas exist in specified range to remove newlines from source cells.
    
    This function STRICTLY checks ALL cells in the specified range - no tolerance, no auto-detection.
    Every single cell in the specified range must contain the correct CLEAN formula.
    
    This function checks:
    1. Whether ALL cells in the specified range (e.g., B2:B4) contain CLEAN formulas
    2. Whether formulas reference the corresponding source column cell (B2->A2, B3->A3, etc.)
    3. Whether formulas contain the correct CLEAN function
    4. Whether formulas have the correct structure: =CLEAN(source_cell)
    
    IMPORTANT: This function checks ALL cells in the specified range, regardless of whether they
    appear to be empty. If any cell in the specified range is missing a formula, verification fails.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_range: Range containing CLEAN formulas (e.g., "B2:B4") - ALL cells must have formulas
            - source_column: Source column letter (e.g., "A")
            - expected_function: Expected function name (default: "CLEAN")
    
    Returns:
        float: 1.0 if ALL cells in specified range contain correct CLEAN formulas, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_range = options.get('check_range', 'B2:B4')
        source_column = options.get('source_column', 'A')
        expected_function = options.get('expected_function', 'CLEAN')
        
        logger.info(f"Verifying CLEAN formulas in file: {result}")
        logger.info(f"Check range: {check_range}")
        logger.info(f"Source column: {source_column}")
        logger.info(f"Expected function: {expected_function}")
        
        # Parse check range - strictly use the specified range
        try:
            check_range_clean = check_range.replace('$', '')
            if ':' in check_range_clean:
                check_start_cell, check_end_cell = check_range_clean.split(':')
                check_start_col_letter = ''.join([c for c in check_start_cell if c.isalpha()])
                check_start_row = int(''.join([c for c in check_start_cell if c.isdigit()]))
                check_start_col = column_index_from_string(check_start_col_letter)
                check_end_col_letter = ''.join([c for c in check_end_cell if c.isalpha()])
                check_end_row = int(''.join([c for c in check_end_cell if c.isdigit()]))
                check_end_col = column_index_from_string(check_end_col_letter)
            else:
                logger.error(f"Invalid check range format: {check_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse check range {check_range}: {e}")
            return 0.0
        
        # Verify that range is a single column
        if check_start_col != check_end_col:
            logger.error(f"Check range must be a single column, got: {check_range}")
            return 0.0
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Strictly check ALL cells in the specified range - no auto-detection
        logger.info(f"Checking all cells in range {check_range} (rows {check_start_row} to {check_end_row})")
        
        # Check CLEAN formulas - check ALL rows in the specified range
        all_passed = True
        checked_count = 0
        passed_count = 0
        
        for row_num in range(check_start_row, check_end_row + 1):
            cell_coord = f"{check_start_col_letter}{row_num}"
            expected_source_cell = f"{source_column}{row_num}"
            
            try:
                cell = ws[cell_coord]
                checked_count += 1
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.warning(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                else:
                    if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains CLEAN function
                clean_pattern = rf'\b{re.escape(expected_function)}\s*\('
                if not re.search(clean_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not contain {expected_function} function")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 2: Formula references the corresponding source column cell (A2, A3, etc.)
                source_cell_pattern = rf'\b{re.escape(expected_source_cell)}\b'
                if not re.search(source_cell_pattern, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {cell_coord} formula does not reference {expected_source_cell}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: Formula structure is CLEAN(source_cell) - allow for optional spaces
                clean_structure_pattern = rf'{re.escape(expected_function)}\s*\(\s*{re.escape(expected_source_cell)}\s*\)'
                if not re.search(clean_structure_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not have correct {expected_function}({expected_source_cell}) structure")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: Formula closes parentheses correctly
                open_count = formula_text.count('(')
                close_count = formula_text.count(')')
                if open_count != close_count:
                    logger.warning(f"Cell {cell_coord} formula has mismatched parentheses")
                    all_passed = False
                    continue
                
                passed_count += 1
                logger.debug(f"✓ Cell {cell_coord} has valid CLEAN formula")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        # Require all specified cells to have correct formulas (no tolerance)
        if checked_count > 0:
            if all_passed and passed_count == checked_count:
                logger.info("=" * 60)
                logger.info(f"✓ All {checked_count} cells contain correct CLEAN formulas")
                logger.info("=" * 60)
                return 1.0
            else:
                logger.error("=" * 60)
                logger.error(f"✗ Verification failed: {passed_count}/{checked_count} cells passed")
                logger.error(f"  All specified cells must contain correct CLEAN formulas")
                logger.error("=" * 60)
                return 0.0
        else:
            logger.error("=" * 60)
            logger.error("✗ No cells were checked")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_sumif_category_sum(result: str, expected: str = None, **options) -> float:
    """
    Verify if SUMIF formulas exist in specified range for calculating sum by category.
    
    This function checks:
    1. Whether ALL cells in the specified range (e.g., E3:E6) contain formulas
    2. Whether formulas contain SUMIF function
    3. Whether SUMIF references the correct range (e.g., $A$2:$A$13)
    4. Whether SUMIF criteria references the correct column with relative row (e.g., D3, D4, D5, D6)
    5. Whether SUMIF sum_range references the correct range (e.g., $B$2:$B$13)
    6. Whether formula structure is correct: SUMIF(range, criteria, sum_range)
    
    IMPORTANT: This function checks ALL cells in the specified range. If any cell is missing a formula, verification fails.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_range: Range to check (e.g., "E3:E6") - ALL cells must have formulas
            - expected_functions: List of expected function names (default: ["SUMIF"])
            - sumif_range: SUMIF range reference (default: "$A$2:$A$13")
            - sumif_criteria_col: Column letter for SUMIF criteria (default: "D")
            - sumif_sum_range: SUMIF sum_range reference (default: "$B$2:$B$13")
    
    Returns:
        float: 1.0 if ALL cells in specified range contain correct formulas, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_range = options.get('check_range', 'E3:E6')
        expected_functions = options.get('expected_functions', ['SUMIF'])
        sumif_range = options.get('sumif_range', '$A$2:$A$13')
        sumif_criteria_col = options.get('sumif_criteria_col', 'D')
        sumif_sum_range = options.get('sumif_sum_range', '$B$2:$B$13')
        
        logger.info(f"Verifying SUMIF category sum formulas in file: {result}")
        logger.info(f"Range to check: {check_range}")
        logger.info(f"Expected functions: {expected_functions}")
        logger.info(f"SUMIF range: {sumif_range}")
        logger.info(f"SUMIF criteria column: {sumif_criteria_col}")
        logger.info(f"SUMIF sum_range: {sumif_sum_range}")
        
        # Parse the range - strictly use the specified range
        try:
            range_clean = check_range.replace('$', '')
            if ':' in range_clean:
                start_cell, end_cell = range_clean.split(':')
                start_col_letter = ''.join([c for c in start_cell if c.isalpha()])
                start_row = int(''.join([c for c in start_cell if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                end_col_letter = ''.join([c for c in end_cell if c.isalpha()])
                end_row = int(''.join([c for c in end_cell if c.isdigit()]))
                end_col = column_index_from_string(end_col_letter)
            else:
                logger.error(f"Invalid range format: {check_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse range {check_range}: {e}")
            return 0.0
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Strictly check ALL cells in the specified range - no auto-detection
        logger.info(f"Checking all cells in range {check_range} (rows {start_row} to {end_row})")
        
        all_passed = True
        checked_count = 0
        passed_count = 0
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{start_col_letter}{row_num}"
            expected_criteria_cell = f"{sumif_criteria_col}{row_num}"
            
            try:
                cell = ws[cell_coord]
                checked_count += 1
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.warning(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                else:
                    if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains SUMIF function
                sumif_pattern = r'\bSUMIF\s*\('
                if not re.search(sumif_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not contain SUMIF function")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 2: SUMIF references the correct range (e.g., $A$2:$A$13)
                # Allow variations: $A$2:$A$13, A$2:A$13, $A2:$A13, A2:A13
                sumif_range_clean = sumif_range.replace('$', '')
                # Direct match without word boundaries - range references are typically separated by commas or parentheses
                sumif_range_patterns = [
                    re.escape(sumif_range),  # $A$2:$A$13
                    re.escape(sumif_range_clean),  # A2:A13
                ]
                # Also check for variations with different $ placements
                sumif_range_parts = sumif_range_clean.split(':')
                if len(sumif_range_parts) == 2:
                    sumif_range_patterns.extend([
                        rf'\${re.escape(sumif_range_parts[0])}\s*:\s*\${re.escape(sumif_range_parts[1])}',  # $A2:$A13
                        rf'{re.escape(sumif_range_parts[0])}\s*:\s*\${re.escape(sumif_range_parts[1])}',  # A2:$A13
                        rf'\${re.escape(sumif_range_parts[0])}\s*:\s*{re.escape(sumif_range_parts[1])}',  # $A2:A13
                    ])
                
                sumif_range_found = False
                for pattern in sumif_range_patterns:
                    if re.search(pattern, formula_text, re.IGNORECASE):
                        sumif_range_found = True
                        break
                if not sumif_range_found:
                    logger.warning(f"Cell {cell_coord} formula does not reference SUMIF range {sumif_range}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: SUMIF criteria references the correct column with relative row (e.g., D3, D4, D5, D6)
                # Allow variations: D3, $D3, D$3, $D$3
                escaped_criteria_cell = re.escape(expected_criteria_cell)
                escaped_criteria_col = re.escape(sumif_criteria_col)
                criteria_cell_patterns = [
                    rf'\b{escaped_criteria_cell}\b',  # D3
                    rf'\${escaped_criteria_col}{row_num}\b',  # $D3
                    rf'\b{escaped_criteria_col}\${row_num}\b',  # D$3
                    rf'\${escaped_criteria_col}\${row_num}\b',  # $D$3
                ]
                
                criteria_cell_found = False
                for pattern in criteria_cell_patterns:
                    if re.search(pattern, formula_text, re.IGNORECASE):
                        criteria_cell_found = True
                        break
                
                if not criteria_cell_found:
                    logger.warning(f"Cell {cell_coord} formula does not reference criteria cell {expected_criteria_cell}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: SUMIF sum_range references the correct range (e.g., $B$2:$B$13)
                # Allow variations: $B$2:$B$13, B$2:B$13, $B2:$B13, B2:B13
                sumif_sum_range_clean = sumif_sum_range.replace('$', '')
                # Direct match without word boundaries - range references are typically separated by commas or parentheses
                sumif_sum_range_patterns = [
                    re.escape(sumif_sum_range),  # $B$2:$B$13
                    re.escape(sumif_sum_range_clean),  # B2:B13
                ]
                # Also check for variations with different $ placements
                sumif_sum_range_parts = sumif_sum_range_clean.split(':')
                if len(sumif_sum_range_parts) == 2:
                    sumif_sum_range_patterns.extend([
                        rf'\${re.escape(sumif_sum_range_parts[0])}\s*:\s*\${re.escape(sumif_sum_range_parts[1])}',  # $B2:$B13
                        rf'{re.escape(sumif_sum_range_parts[0])}\s*:\s*\${re.escape(sumif_sum_range_parts[1])}',  # B2:$B13
                        rf'\${re.escape(sumif_sum_range_parts[0])}\s*:\s*{re.escape(sumif_sum_range_parts[1])}',  # $B2:B13
                    ])
                
                sumif_sum_range_found = False
                for pattern in sumif_sum_range_patterns:
                    if re.search(pattern, formula_text, re.IGNORECASE):
                        sumif_sum_range_found = True
                        break
                if not sumif_sum_range_found:
                    logger.warning(f"Cell {cell_coord} formula does not reference SUMIF sum_range {sumif_sum_range}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 5: Formula closes parentheses correctly
                open_count = formula_text.count('(')
                close_count = formula_text.count(')')
                if open_count != close_count:
                    logger.warning(f"Cell {cell_coord} formula has mismatched parentheses")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                passed_count += 1
                logger.debug(f"✓ Cell {cell_coord} has valid SUMIF formula")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        # Require ALL cells to pass (strict check)
        if checked_count > 0:
            if all_passed and passed_count == checked_count:
                logger.info("=" * 60)
                logger.info(f"✓ All cells in range {check_range} contain correct SUMIF formulas")
                logger.info(f"Passed: {passed_count}/{checked_count}")
                logger.info("=" * 60)
                return 1.0
            else:
                logger.error("=" * 60)
                logger.error(f"✗ Not all cells in range {check_range} contain correct formulas")
                logger.error(f"Passed: {passed_count}/{checked_count}")
                logger.error("=" * 60)
                return 0.0
        else:
            logger.error("=" * 60)
            logger.error("✗ No cells were checked")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_multi_condition_filter(result: str, expected: str = None, **options) -> float:
    """
    Verify if multi-condition filter formulas exist using either method:
    Method 1: IFERROR(INDEX(SMALL(IF(...)))) in specified range
    Method 2: FILTER function in specified cell
    
    This function checks BOTH methods and returns 1.0 if EITHER method passes.
    
    Method 1 checks:
    1. Whether ALL cells in the specified range (e.g., G2:K3) contain formulas
    2. Whether formulas contain IFERROR, INDEX, SMALL, and IF functions
    3. Whether IF conditions check three criteria with AND logic (multiplication)
    4. Whether conditions reference correct ranges and values
    5. Whether INDEX references correct column (e.g., $A:$A)
    6. Whether ROWS function is used correctly for row counting
    
    Method 2 checks:
    1. Whether specified cell (e.g., G2) contains FILTER formula
    2. Whether FILTER references correct data range
    3. Whether FILTER conditions check three criteria with AND logic (multiplication)
    4. Whether conditions reference correct ranges and values
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - method1_range: Range to check for method 1 (e.g., "G2:K3")
            - method1_expected_functions: List of expected functions (default: ["IFERROR", "INDEX", "SMALL", "IF"])
            - method1_condition_ranges: Dict with condition ranges and values
            - method1_index_range: INDEX range reference (default: "$A:$A")
            - method1_row_range: ROW range reference (default: "$C$2:$C$7")
            - method2_cell: Cell to check for method 2 (e.g., "G2")
            - method2_expected_functions: List of expected functions (default: ["FILTER"])
            - method2_data_range: FILTER data range (default: "A1:E7")
            - method2_condition_ranges: Dict with condition ranges and values
    
    Returns:
        float: 1.0 if EITHER method passes, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        # Get options
        method1_range = options.get('method1_range', 'G2:K3')
        method1_expected_functions = options.get('method1_expected_functions', ['IFERROR', 'INDEX', 'SMALL', 'IF'])
        method1_condition_ranges = options.get('method1_condition_ranges', {})
        method1_index_range = options.get('method1_index_range', '$A:$A')
        method1_row_range = options.get('method1_row_range', '$C$2:$C$7')
        
        method2_cell = options.get('method2_cell', 'G2')
        method2_expected_functions = options.get('method2_expected_functions', ['FILTER'])
        method2_data_range = options.get('method2_data_range', 'A1:E7')
        method2_condition_ranges = options.get('method2_condition_ranges', {})
        
        logger.info(f"Verifying multi-condition filter formulas in file: {result}")
        logger.info(f"Method 1 range: {method1_range}")
        logger.info(f"Method 2 cell: {method2_cell}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        method1_passed = False
        method2_passed = False
        
        # Check Method 1: IFERROR(INDEX(SMALL(IF(...))))
        logger.info("=" * 60)
        logger.info("Checking Method 1: IFERROR(INDEX(SMALL(IF(...))))")
        logger.info("=" * 60)
        
        try:
            # Parse method1_range
            range_clean = method1_range.replace('$', '')
            if ':' not in range_clean:
                logger.error(f"Invalid method1_range format: {method1_range}")
                method1_passed = False
            else:
                start_cell, end_cell = range_clean.split(':')
                start_col_letter = ''.join([c for c in start_cell if c.isalpha()])
                start_row = int(''.join([c for c in start_cell if c.isdigit()]))
                end_col_letter = ''.join([c for c in end_cell if c.isalpha()])
                end_row = int(''.join([c for c in end_cell if c.isdigit()]))
                
                all_passed = True
                checked_count = 0
                passed_count = 0
                
                # For method 1, formula is filled across G2:K3
                # INDEX range changes with column: G2 uses A:A, H2 uses B:B, I2 uses C:C, J2 uses D:D, K2 uses E:E
                # So we check all cells in the range
                for row_num in range(start_row, end_row + 1):
                    for col_num in range(column_index_from_string(start_col_letter), column_index_from_string(end_col_letter) + 1):
                        cell_coord = f"{get_column_letter(col_num)}{row_num}"
                        
                        # Calculate expected INDEX column based on cell position
                        # G column (7) -> A column (1), H column (8) -> B column (2), etc.
                        start_col_index = column_index_from_string(start_col_letter)
                        cell_col_index = col_num
                        expected_index_col_index = cell_col_index - start_col_index + 1  # G=7 -> 1 (A), H=8 -> 2 (B)
                        expected_index_col_letter = get_column_letter(expected_index_col_index)
                        expected_index_range = f"{expected_index_col_letter}:{expected_index_col_letter}"  # A:A, B:B, C:C, etc.
                        
                        try:
                            cell = ws[cell_coord]
                            checked_count += 1
                            
                            # Check if cell contains a formula
                            if cell.data_type != "f":
                                logger.warning(f"Cell {cell_coord} does not contain a formula")
                                all_passed = False
                                continue
                            
                            # Get formula text
                            formula_text = None
                            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                                formula_text = cell._value
                            elif hasattr(cell, "formula"):
                                formula_text = cell.formula
                            else:
                                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                                    formula_text = cell.value
                            
                            if formula_text is None:
                                logger.warning(f"Could not extract formula from cell {cell_coord}")
                                all_passed = False
                                continue
                            
                            formula_upper = formula_text.upper()
                            logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                            
                            # Check required functions
                            for func in method1_expected_functions:
                                func_pattern = rf'\b{func}\s*\('
                                if not re.search(func_pattern, formula_upper):
                                    logger.warning(f"Cell {cell_coord} formula does not contain {func} function")
                                    all_passed = False
                                    break
                            
                            if not all_passed:
                                continue
                            
                            # Check IFERROR structure
                            iferror_pattern = r'IFERROR\s*\('
                            if not re.search(iferror_pattern, formula_upper):
                                logger.warning(f"Cell {cell_coord} formula does not contain IFERROR function")
                                all_passed = False
                                continue
                            
                            # Check INDEX structure - column should match cell position
                            # G column -> A:A, H column -> B:B, I column -> C:C, J column -> D:D, K column -> E:E
                            index_pattern = rf'INDEX\s*\(\s*{re.escape(expected_index_range)}'
                            if not re.search(index_pattern, formula_upper):
                                logger.warning(f"Cell {cell_coord} formula does not reference INDEX range {expected_index_range} (expected for column {get_column_letter(col_num)})")
                                all_passed = False
                                continue
                            
                            # Check AGGREGATE function
                            aggregate_pattern = r'AGGREGATE\s*\('
                            if not re.search(aggregate_pattern, formula_upper):
                                logger.warning(f"Cell {cell_coord} formula does not contain AGGREGATE function")
                                all_passed = False
                                continue
                            
                            # Check AGGREGATE parameters: AGGREGATE(15, 6, ...)
                            # 15 = SMALL function, 6 = ignore errors
                            aggregate_params_pattern = r'AGGREGATE\s*\(\s*15\s*,\s*6\s*,'
                            if not re.search(aggregate_params_pattern, formula_upper):
                                logger.warning(f"Cell {cell_coord} formula does not have correct AGGREGATE parameters (15, 6)")
                                all_passed = False
                                continue
                            
                            # Check ROW function
                            row_pattern = r'ROW\s*\('
                            if not re.search(row_pattern, formula_upper):
                                logger.warning(f"Cell {cell_coord} formula does not contain ROW function")
                                all_passed = False
                                continue
                            
                            # Check ROW range reference
                            row_range_clean = method1_row_range.replace('$', '')
                            row_range_patterns = [
                                rf'ROW\s*\(\s*{re.escape(method1_row_range)}',  # ROW($C$2:$C$7)
                                rf'ROW\s*\(\s*{re.escape(row_range_clean)}',  # ROW(C2:C7)
                            ]
                            row_range_found = any(re.search(p, formula_text, re.IGNORECASE) for p in row_range_patterns)
                            if not row_range_found:
                                logger.warning(f"Cell {cell_coord} formula does not reference ROW range {method1_row_range}")
                                all_passed = False
                                continue
                            
                            # Check for division operator (/) after ROW - ROW(...)/
                            row_divide_pattern = r'ROW\s*\([^)]+\)\s*/'
                            if not re.search(row_divide_pattern, formula_text, re.IGNORECASE):
                                logger.warning(f"Cell {cell_coord} formula does not have ROW(...)/ pattern")
                                all_passed = False
                                continue
                            
                            # Check conditions (three conditions with multiplication)
                            gender_range_full = method1_condition_ranges.get('gender_range', '$C$2:$C$7')
                            gender_range_clean = gender_range_full.replace('$', '')
                            gender_value = method1_condition_ranges.get('gender_value', '女')
                            dept_range_full = method1_condition_ranges.get('dept_range', '$D$2:$D$7')
                            dept_range_clean = dept_range_full.replace('$', '')
                            dept_value = method1_condition_ranges.get('dept_value', '财务部')
                            edu_range_full = method1_condition_ranges.get('edu_range', '$E$2:$E$7')
                            edu_range_clean = edu_range_full.replace('$', '')
                            edu_value = method1_condition_ranges.get('edu_value', '本科')
                            
                            # Check for condition patterns (allow variations with/without $, different quote types)
                            # Pattern: range = "value" or range = 'value' or range = value
                            gender_patterns = [
                                rf'{re.escape(gender_range_full)}\s*=\s*["\']{re.escape(gender_value)}["\']',  # $C$2:$C$7="女"
                                rf'{re.escape(gender_range_clean)}\s*=\s*["\']{re.escape(gender_value)}["\']',  # C2:C7="女"
                                rf'{re.escape(gender_range_full)}\s*=\s*{re.escape(gender_value)}',  # $C$2:$C$7=女 (no quotes)
                                rf'{re.escape(gender_range_clean)}\s*=\s*{re.escape(gender_value)}',  # C2:C7=女 (no quotes)
                            ]
                            dept_patterns = [
                                rf'{re.escape(dept_range_full)}\s*=\s*["\']{re.escape(dept_value)}["\']',
                                rf'{re.escape(dept_range_clean)}\s*=\s*["\']{re.escape(dept_value)}["\']',
                                rf'{re.escape(dept_range_full)}\s*=\s*{re.escape(dept_value)}',
                                rf'{re.escape(dept_range_clean)}\s*=\s*{re.escape(dept_value)}',
                            ]
                            edu_patterns = [
                                rf'{re.escape(edu_range_full)}\s*=\s*["\']{re.escape(edu_value)}["\']',
                                rf'{re.escape(edu_range_clean)}\s*=\s*["\']{re.escape(edu_value)}["\']',
                                rf'{re.escape(edu_range_full)}\s*=\s*{re.escape(edu_value)}',
                                rf'{re.escape(edu_range_clean)}\s*=\s*{re.escape(edu_value)}',
                            ]
                            
                            gender_found = any(re.search(p, formula_text, re.IGNORECASE) for p in gender_patterns)
                            dept_found = any(re.search(p, formula_text, re.IGNORECASE) for p in dept_patterns)
                            edu_found = any(re.search(p, formula_text, re.IGNORECASE) for p in edu_patterns)
                            
                            if not (gender_found and dept_found and edu_found):
                                logger.warning(f"Cell {cell_coord} formula does not contain all three conditions")
                                logger.debug(f"  Gender found: {gender_found}, Dept found: {dept_found}, Edu found: {edu_found}")
                                logger.debug(f"  Formula: {formula_text}")
                                all_passed = False
                                continue
                            
                            # Check for multiplication operator (*) between conditions (AND logic)
                            if '*' not in formula_text:
                                logger.warning(f"Cell {cell_coord} formula does not use multiplication for AND logic")
                                all_passed = False
                                continue
                            
                            # Check ROWS function
                            rows_pattern = r'ROWS\s*\('
                            if not re.search(rows_pattern, formula_upper):
                                logger.warning(f"Cell {cell_coord} formula does not contain ROWS function")
                                all_passed = False
                                continue
                            
                            # Check parentheses balance
                            open_count = formula_text.count('(')
                            close_count = formula_text.count(')')
                            if open_count != close_count:
                                logger.warning(f"Cell {cell_coord} formula has mismatched parentheses")
                                all_passed = False
                                continue
                            
                            passed_count += 1
                            logger.debug(f"✓ Cell {cell_coord} has valid Method 1 formula")
                            
                        except Exception as e:
                            logger.error(f"Error checking cell {cell_coord}: {e}")
                            import traceback
                            logger.error(traceback.format_exc())
                            all_passed = False
                
                if checked_count > 0 and all_passed and passed_count == checked_count:
                    method1_passed = True
                    logger.info(f"✓ Method 1 passed: {passed_count}/{checked_count} cells")
                else:
                    logger.warning(f"✗ Method 1 failed: {passed_count}/{checked_count} cells passed")
                    
        except Exception as e:
            logger.warning(f"Method 1 check failed: {e}")
            import traceback
            logger.error(traceback.format_exc())
            method1_passed = False
        
        # Check Method 2: FILTER function
        logger.info("=" * 60)
        logger.info("Checking Method 2: FILTER function")
        logger.info("=" * 60)
        
        try:
            cell = ws[method2_cell]
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.warning(f"Cell {method2_cell} does not contain a formula")
                method2_passed = False
            else:
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                else:
                    if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {method2_cell}")
                    method2_passed = False
                else:
                    formula_upper = formula_text.upper()
                    logger.debug(f"Cell {method2_cell} formula: {formula_text}")
                    
                    # Check FILTER function
                    filter_pattern = r'\bFILTER\s*\('
                    if not re.search(filter_pattern, formula_upper):
                        logger.warning(f"Cell {method2_cell} formula does not contain FILTER function")
                        method2_passed = False
                    else:
                        # Check data range
                        data_range_clean = method2_data_range.replace('$', '')
                        data_range_pattern = re.escape(data_range_clean)
                        if not re.search(data_range_pattern, formula_text, re.IGNORECASE):
                            logger.warning(f"Cell {method2_cell} formula does not reference data range {method2_data_range}")
                            method2_passed = False
                        else:
                            # Check conditions
                            gender_range_full = method2_condition_ranges.get('gender_range', 'C1:C7')
                            gender_range_clean = gender_range_full.replace('$', '')
                            gender_value = method2_condition_ranges.get('gender_value', '女')
                            dept_range_full = method2_condition_ranges.get('dept_range', 'D1:D7')
                            dept_range_clean = dept_range_full.replace('$', '')
                            dept_value = method2_condition_ranges.get('dept_value', '财务部')
                            edu_range_full = method2_condition_ranges.get('edu_range', 'E1:E7')
                            edu_range_clean = edu_range_full.replace('$', '')
                            edu_value = method2_condition_ranges.get('edu_value', '本科')
                            
                            # Check for condition patterns (allow variations with/without $, different quote types)
                            gender_patterns = [
                                rf'{re.escape(gender_range_full)}\s*=\s*["\']{re.escape(gender_value)}["\']',
                                rf'{re.escape(gender_range_clean)}\s*=\s*["\']{re.escape(gender_value)}["\']',
                                rf'{re.escape(gender_range_full)}\s*=\s*{re.escape(gender_value)}',
                                rf'{re.escape(gender_range_clean)}\s*=\s*{re.escape(gender_value)}',
                            ]
                            dept_patterns = [
                                rf'{re.escape(dept_range_full)}\s*=\s*["\']{re.escape(dept_value)}["\']',
                                rf'{re.escape(dept_range_clean)}\s*=\s*["\']{re.escape(dept_value)}["\']',
                                rf'{re.escape(dept_range_full)}\s*=\s*{re.escape(dept_value)}',
                                rf'{re.escape(dept_range_clean)}\s*=\s*{re.escape(dept_value)}',
                            ]
                            edu_patterns = [
                                rf'{re.escape(edu_range_full)}\s*=\s*["\']{re.escape(edu_value)}["\']',
                                rf'{re.escape(edu_range_clean)}\s*=\s*["\']{re.escape(edu_value)}["\']',
                                rf'{re.escape(edu_range_full)}\s*=\s*{re.escape(edu_value)}',
                                rf'{re.escape(edu_range_clean)}\s*=\s*{re.escape(edu_value)}',
                            ]
                            
                            gender_found = any(re.search(p, formula_text, re.IGNORECASE) for p in gender_patterns)
                            dept_found = any(re.search(p, formula_text, re.IGNORECASE) for p in dept_patterns)
                            edu_found = any(re.search(p, formula_text, re.IGNORECASE) for p in edu_patterns)
                            
                            if not (gender_found and dept_found and edu_found):
                                logger.warning(f"Cell {method2_cell} formula does not contain all three conditions")
                                logger.debug(f"  Gender found: {gender_found}, Dept found: {dept_found}, Edu found: {edu_found}")
                                logger.debug(f"  Formula: {formula_text}")
                                method2_passed = False
                            else:
                                # Check for multiplication operator (*) between conditions
                                if '*' not in formula_text:
                                    logger.warning(f"Cell {method2_cell} formula does not use multiplication for AND logic")
                                    method2_passed = False
                                else:
                                    # Check parentheses balance
                                    open_count = formula_text.count('(')
                                    close_count = formula_text.count(')')
                                    if open_count != close_count:
                                        logger.warning(f"Cell {method2_cell} formula has mismatched parentheses")
                                        method2_passed = False
                                    else:
                                        method2_passed = True
                                        logger.info(f"✓ Method 2 passed: FILTER formula is correct")
                                        
        except Exception as e:
            logger.warning(f"Method 2 check failed: {e}")
            import traceback
            logger.error(traceback.format_exc())
            method2_passed = False
        
        # Return 1.0 if EITHER method passes
        logger.info("=" * 60)
        if method1_passed:
            logger.info("✓ Verification passed: Method 1 (IFERROR(INDEX(SMALL(IF(...))))) is correct")
            logger.info("=" * 60)
            return 1.0
        elif method2_passed:
            logger.info("✓ Verification passed: Method 2 (FILTER) is correct")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("✗ Verification failed: Neither method passed")
            logger.error(f"  Method 1 (IFERROR(INDEX(SMALL(IF(...))))): {'PASSED' if method1_passed else 'FAILED'}")
            logger.error(f"  Method 2 (FILTER): {'PASSED' if method2_passed else 'FAILED'}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_vlookup_groupby_scan(result: str, expected: str = None, **options) -> float:
    """
    Verify if VLOOKUP with GROUPBY, SCAN, RIGHT, CONCAT formula exists in specified cell.
    
    This function checks:
    1. Whether the specified cell contains a VLOOKUP formula
    2. Whether the formula contains GROUPBY, SCAN, RIGHT, CONCAT, and SUM functions
    3. Whether VLOOKUP references the correct lookup value (e.g., A7)
    4. Whether SCAN function references the correct range (e.g., B2:B4)
    5. Whether RIGHT function extracts correct number of characters (e.g., 3)
    6. Whether GROUPBY references the correct sum range (e.g., D2:D4)
    7. Whether VLOOKUP col_index is correct (e.g., 2)
    8. Whether the formula structure is correct: VLOOKUP(lookup_value, GROUPBY(RIGHT(SCAN(...), n), sum_range, SUM), col_index,)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_cell: Cell to check (e.g., "B7")
            - expected_functions: List of expected function names (default: ["VLOOKUP", "GROUPBY", "SCAN", "RIGHT", "CONCAT", "SUM"])
            - vlookup_lookup_value: VLOOKUP lookup value cell (e.g., "A7")
            - scan_range: SCAN range reference (e.g., "B2:B4")
            - right_num_chars: Number of characters for RIGHT function (default: 3)
            - groupby_sum_range: GROUPBY sum range reference (e.g., "D2:D4")
            - vlookup_col_index: VLOOKUP column index (default: 2)
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_cell = options.get('check_cell', 'B7')
        expected_functions = options.get('expected_functions', ['VLOOKUP', 'GROUPBY', 'SCAN', 'RIGHT', 'CONCAT', 'SUM'])
        vlookup_lookup_value = options.get('vlookup_lookup_value', 'A7')
        scan_range = options.get('scan_range', 'B2:B4')
        right_num_chars = options.get('right_num_chars', 3)
        groupby_sum_range = options.get('groupby_sum_range', 'D2:D4')
        vlookup_col_index = options.get('vlookup_col_index', 2)
        
        logger.info(f"Verifying VLOOKUP(GROUPBY(SCAN)) formula in file: {result}")
        logger.info(f"Cell to check: {check_cell}")
        logger.info(f"Expected functions: {expected_functions}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Get the cell to check
        try:
            cell = ws[check_cell]
        except Exception as e:
            logger.error(f"Failed to access cell {check_cell}: {e}")
            return 0.0
        
        # Check if cell contains a formula
        if cell.data_type != "f":
            logger.error(f"Cell {check_cell} does not contain a formula")
            return 0.0
        
        # Get formula text
        formula_text = None
        if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
            formula_text = cell._value
        elif hasattr(cell, "formula"):
            formula_text = cell.formula
        elif cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
            formula_text = cell.value
        
        if formula_text is None:
            logger.error(f"Could not extract formula from cell {check_cell}")
            return 0.0
        
        formula_upper = formula_text.upper()
        logger.info(f"Cell {check_cell} formula: {formula_text}")
        
        # Check 1: Formula contains all expected functions
        for func in expected_functions:
            func_pattern = rf'\b{func}\s*\('
            if not re.search(func_pattern, formula_upper):
                logger.error(f"Cell {check_cell} formula does not contain {func} function")
                logger.error(f"Formula: {formula_text}")
                return 0.0
        
        # Check 2: VLOOKUP structure - VLOOKUP(lookup_value, table_array, col_index, [range_lookup])
        vlookup_pattern = r'\bVLOOKUP\s*\('
        if not re.search(vlookup_pattern, formula_upper):
            logger.error(f"Cell {check_cell} formula does not contain VLOOKUP function")
            return 0.0
        
        # Check 3: VLOOKUP references the correct lookup value
        vlookup_lookup_clean = vlookup_lookup_value.replace('$', '')
        vlookup_lookup_patterns = [
            re.escape(vlookup_lookup_value),  # A7
            re.escape(vlookup_lookup_clean),  # A7 (if no $)
            rf'\${re.escape(vlookup_lookup_clean)}',  # $A7
            rf'{re.escape(vlookup_lookup_clean)}\$',  # A$7
            rf'\${re.escape(vlookup_lookup_clean)}\$',  # $A$7
        ]
        vlookup_lookup_found = False
        # Find VLOOKUP opening parenthesis and check first parameter
        vlookup_match = re.search(r'VLOOKUP\s*\(', formula_text, re.IGNORECASE)
        if vlookup_match:
            # Extract the first parameter after VLOOKUP(
            start_pos = vlookup_match.end()
            # Find the first comma or closing parenthesis
            end_pos = start_pos
            paren_count = 0
            while end_pos < len(formula_text):
                if formula_text[end_pos] == '(':
                    paren_count += 1
                elif formula_text[end_pos] == ')':
                    if paren_count == 0:
                        break
                    paren_count -= 1
                elif formula_text[end_pos] == ',' and paren_count == 0:
                    break
                end_pos += 1
            
            first_param = formula_text[start_pos:end_pos].strip()
            for pattern in vlookup_lookup_patterns:
                if re.search(pattern, first_param, re.IGNORECASE):
                    vlookup_lookup_found = True
                    break
        
        if not vlookup_lookup_found:
            logger.warning(f"Cell {check_cell} formula may not reference VLOOKUP lookup value {vlookup_lookup_value}")
            logger.warning(f"Formula: {formula_text}")
            # Don't fail here, as the lookup value might be in a different format
        
        # Check 4: SCAN function structure - SCAN(initial_value, array, function)
        scan_pattern = r'\bSCAN\s*\('
        if not re.search(scan_pattern, formula_upper):
            logger.error(f"Cell {check_cell} formula does not contain SCAN function")
            return 0.0
        
        # Check 5: SCAN references the correct range
        scan_range_clean = scan_range.replace('$', '')
        scan_range_patterns = [
            re.escape(scan_range),  # B2:B4
            re.escape(scan_range_clean),  # B2:B4 (if no $)
        ]
        # Also check for variations with different $ placements
        scan_range_parts = scan_range_clean.split(':')
        if len(scan_range_parts) == 2:
            scan_range_patterns.extend([
                rf'\${re.escape(scan_range_parts[0])}\s*:\s*\${re.escape(scan_range_parts[1])}',  # $B2:$B4
                rf'{re.escape(scan_range_parts[0])}\s*:\s*\${re.escape(scan_range_parts[1])}',  # B2:$B4
                rf'\${re.escape(scan_range_parts[0])}\s*:\s*{re.escape(scan_range_parts[1])}',  # $B2:B4
            ])
        
        scan_range_found = False
        for pattern in scan_range_patterns:
            if re.search(pattern, formula_text, re.IGNORECASE):
                scan_range_found = True
                break
        
        if not scan_range_found:
            logger.warning(f"Cell {check_cell} formula may not reference SCAN range {scan_range}")
            logger.warning(f"Formula: {formula_text}")
            # Don't fail here, as the range might be in a different format
        
        # Check 6: RIGHT function structure - RIGHT(text, num_chars)
        right_pattern = r'\bRIGHT\s*\('
        if not re.search(right_pattern, formula_upper):
            logger.error(f"Cell {check_cell} formula does not contain RIGHT function")
            return 0.0
        
        # Check 7: RIGHT extracts correct number of characters
        # Look for RIGHT(..., 3) or RIGHT(...,3) pattern
        right_num_patterns = [
            rf'RIGHT\s*\([^,)]+,\s*{right_num_chars}\s*\)',  # RIGHT(..., 3)
            rf'RIGHT\s*\([^,)]+,{right_num_chars}\s*\)',  # RIGHT(...,3)
        ]
        right_num_found = False
        for pattern in right_num_patterns:
            if re.search(pattern, formula_upper):
                right_num_found = True
                break
        
        if not right_num_found:
            logger.warning(f"Cell {check_cell} formula may not use RIGHT with {right_num_chars} characters")
            logger.warning(f"Formula: {formula_text}")
            # Don't fail here, as the number might be in a different format
        
        # Check 8: CONCAT function in SCAN
        concat_pattern = r'\bCONCAT\s*\('
        if not re.search(concat_pattern, formula_upper):
            logger.error(f"Cell {check_cell} formula does not contain CONCAT function")
            return 0.0
        
        # Check 9: GROUPBY function structure - GROUPBY(rows, values, function)
        groupby_pattern = r'\bGROUPBY\s*\('
        if not re.search(groupby_pattern, formula_upper):
            logger.error(f"Cell {check_cell} formula does not contain GROUPBY function")
            return 0.0
        
        # Check 10: GROUPBY references the correct sum range
        groupby_sum_range_clean = groupby_sum_range.replace('$', '')
        groupby_sum_range_patterns = [
            re.escape(groupby_sum_range),  # D2:D4
            re.escape(groupby_sum_range_clean),  # D2:D4 (if no $)
        ]
        # Also check for variations with different $ placements
        groupby_sum_range_parts = groupby_sum_range_clean.split(':')
        if len(groupby_sum_range_parts) == 2:
            groupby_sum_range_patterns.extend([
                rf'\${re.escape(groupby_sum_range_parts[0])}\s*:\s*\${re.escape(groupby_sum_range_parts[1])}',  # $D2:$D4
                rf'{re.escape(groupby_sum_range_parts[0])}\s*:\s*\${re.escape(groupby_sum_range_parts[1])}',  # D2:$D4
                rf'\${re.escape(groupby_sum_range_parts[0])}\s*:\s*{re.escape(groupby_sum_range_parts[1])}',  # $D2:D4
            ])
        
        groupby_sum_range_found = False
        for pattern in groupby_sum_range_patterns:
            if re.search(pattern, formula_text, re.IGNORECASE):
                groupby_sum_range_found = True
                break
        
        if not groupby_sum_range_found:
            logger.warning(f"Cell {check_cell} formula may not reference GROUPBY sum range {groupby_sum_range}")
            logger.warning(f"Formula: {formula_text}")
            # Don't fail here, as the range might be in a different format
        
        # Check 11: SUM function in GROUPBY
        sum_pattern = r'\bSUM\s*\('
        if not re.search(sum_pattern, formula_upper):
            logger.error(f"Cell {check_cell} formula does not contain SUM function")
            return 0.0
        
        # Check 12: VLOOKUP col_index is correct
        # Look for VLOOKUP(..., ..., 2, ...) pattern
        # This is tricky because GROUPBY is the second parameter, so we need to find the col_index after GROUPBY closes
        # For simplicity, we'll check if the number 2 appears in the context of VLOOKUP
        vlookup_col_index_patterns = [
            rf'VLOOKUP\s*\([^,)]+,\s*[^,)]+,\s*{vlookup_col_index}\s*,',  # VLOOKUP(..., ..., 2,)
            rf'VLOOKUP\s*\([^,)]+,\s*[^,)]+,\s*{vlookup_col_index}\s*\)',  # VLOOKUP(..., ..., 2)
        ]
        vlookup_col_index_found = False
        for pattern in vlookup_col_index_patterns:
            if re.search(pattern, formula_upper):
                vlookup_col_index_found = True
                break
        
        if not vlookup_col_index_found:
            logger.warning(f"Cell {check_cell} formula may not use VLOOKUP col_index {vlookup_col_index}")
            logger.warning(f"Formula: {formula_text}")
            # Don't fail here, as the col_index might be in a different format
        
        # Check 13: Formula structure - VLOOKUP should contain GROUPBY which contains RIGHT(SCAN(...))
        # Check that GROUPBY is inside VLOOKUP
        vlookup_groupby_pattern = r'VLOOKUP\s*\([^,)]+,\s*GROUPBY\s*\('
        if not re.search(vlookup_groupby_pattern, formula_upper):
            logger.warning(f"Cell {check_cell} formula may not have correct VLOOKUP(GROUPBY(...)) structure")
            logger.warning(f"Formula: {formula_text}")
            # Don't fail here, as the structure might be correct but formatted differently
        
        # Check 14: RIGHT should contain SCAN
        right_scan_pattern = r'RIGHT\s*\(\s*SCAN\s*\('
        if not re.search(right_scan_pattern, formula_upper):
            logger.warning(f"Cell {check_cell} formula may not have correct RIGHT(SCAN(...)) structure")
            logger.warning(f"Formula: {formula_text}")
            # Don't fail here, as the structure might be correct but formatted differently
        
        # Check 15: Formula closes parentheses correctly
        open_count = formula_text.count('(')
        close_count = formula_text.count(')')
        if open_count != close_count:
            logger.error(f"Cell {check_cell} formula has mismatched parentheses")
            logger.error(f"Formula: {formula_text}")
            return 0.0
        
        logger.info("=" * 60)
        logger.info(f"✓ VLOOKUP(GROUPBY(SCAN)) formula verification passed")
        logger.info(f"Cell {check_cell} contains correct formula structure")
        logger.info("=" * 60)
        return 1.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_sum_vlookup_index(result: str, expected: str = None, **options) -> float:
    """
    Verify if SUM with VLOOKUP and INDEX formula exists in specified cell.
    
    This function checks:
    1. Whether the specified cell contains a SUM formula
    2. Whether the formula contains VLOOKUP and INDEX functions
    3. Whether VLOOKUP references the correct lookup value (e.g., "客户1")
    4. Whether VLOOKUP references the correct table array (e.g., B2:D3)
    5. Whether VLOOKUP col_index is correct (e.g., 3)
    6. Whether VLOOKUP range_lookup is correct (e.g., 0 for exact match)
    7. Whether INDEX references the correct array (e.g., D2:D3)
    8. Whether INDEX row_num is correct (e.g., 2)
    9. Whether the formula structure is correct: SUM(VLOOKUP(...), INDEX(...))
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_cell: Cell to check (e.g., "B7")
            - expected_functions: List of expected function names (default: ["SUM", "VLOOKUP", "INDEX"])
            - vlookup_lookup_value: VLOOKUP lookup value (e.g., "\"客户1\"")
            - vlookup_table_array: VLOOKUP table array (e.g., "B2:D3")
            - vlookup_col_index: VLOOKUP column index (default: 3)
            - vlookup_range_lookup: VLOOKUP range lookup (default: 0 for exact match)
            - index_array: INDEX array reference (e.g., "D2:D3")
            - index_row_num: INDEX row number (default: 2)
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_cell = options.get('check_cell', 'B7')
        expected_functions = options.get('expected_functions', ['SUM', 'VLOOKUP', 'INDEX'])
        vlookup_lookup_value = options.get('vlookup_lookup_value', '"客户1"')
        vlookup_table_array = options.get('vlookup_table_array', 'B2:D3')
        vlookup_col_index = options.get('vlookup_col_index', 3)
        vlookup_range_lookup = options.get('vlookup_range_lookup', 0)
        index_array = options.get('index_array', 'D2:D3')
        index_row_num = options.get('index_row_num', 2)
        
        logger.info(f"Verifying SUM(VLOOKUP, INDEX) formula in file: {result}")
        logger.info(f"Cell to check: {check_cell}")
        logger.info(f"Expected functions: {expected_functions}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Get the cell to check
        try:
            cell = ws[check_cell]
        except Exception as e:
            logger.error(f"Failed to access cell {check_cell}: {e}")
            return 0.0
        
        # Check if cell contains a formula
        if cell.data_type != "f":
            logger.error(f"Cell {check_cell} does not contain a formula")
            return 0.0
        
        # Get formula text
        formula_text = None
        if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
            formula_text = cell._value
        elif hasattr(cell, "formula"):
            formula_text = cell.formula
        elif cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
            formula_text = cell.value
        
        if formula_text is None:
            logger.error(f"Could not extract formula from cell {check_cell}")
            return 0.0
        
        formula_upper = formula_text.upper()
        logger.info(f"Cell {check_cell} formula: {formula_text}")
        
        # Check 1: Formula contains all expected functions
        for func in expected_functions:
            func_pattern = rf'\b{func}\s*\('
            if not re.search(func_pattern, formula_upper):
                logger.error(f"Cell {check_cell} formula does not contain {func} function")
                logger.error(f"Formula: {formula_text}")
                return 0.0
        
        # Check 2: SUM structure - SUM(value1, value2)
        sum_pattern = r'\bSUM\s*\('
        if not re.search(sum_pattern, formula_upper):
            logger.error(f"Cell {check_cell} formula does not contain SUM function")
            return 0.0
        
        # Check 3: VLOOKUP structure - VLOOKUP(lookup_value, table_array, col_index, range_lookup)
        vlookup_pattern = r'\bVLOOKUP\s*\('
        if not re.search(vlookup_pattern, formula_upper):
            logger.error(f"Cell {check_cell} formula does not contain VLOOKUP function")
            return 0.0
        
        # Check 4: VLOOKUP references the correct lookup value
        # Remove quotes from lookup value for pattern matching
        vlookup_lookup_clean = vlookup_lookup_value.strip('"').strip("'")
        vlookup_lookup_patterns = [
            re.escape(vlookup_lookup_value),  # "客户1"
            rf'["\']{re.escape(vlookup_lookup_clean)}["\']',  # "客户1" or '客户1'
            re.escape(vlookup_lookup_clean),  # 客户1 (without quotes)
        ]
        vlookup_lookup_found = False
        for pattern in vlookup_lookup_patterns:
            if re.search(pattern, formula_text, re.IGNORECASE):
                vlookup_lookup_found = True
                break
        
        if not vlookup_lookup_found:
            logger.warning(f"Cell {check_cell} formula may not reference VLOOKUP lookup value {vlookup_lookup_value}")
            logger.warning(f"Formula: {formula_text}")
            # Don't fail here, as the lookup value might be in a different format
        
        # Check 5: VLOOKUP references the correct table array
        vlookup_table_array_clean = vlookup_table_array.replace('$', '')
        vlookup_table_array_patterns = [
            re.escape(vlookup_table_array),  # B2:D3
            re.escape(vlookup_table_array_clean),  # B2:D3 (if no $)
        ]
        # Also check for variations with different $ placements
        vlookup_table_array_parts = vlookup_table_array_clean.split(':')
        if len(vlookup_table_array_parts) == 2:
            vlookup_table_array_patterns.extend([
                rf'\${re.escape(vlookup_table_array_parts[0])}\s*:\s*\${re.escape(vlookup_table_array_parts[1])}',  # $B2:$D3
                rf'{re.escape(vlookup_table_array_parts[0])}\s*:\s*\${re.escape(vlookup_table_array_parts[1])}',  # B2:$D3
                rf'\${re.escape(vlookup_table_array_parts[0])}\s*:\s*{re.escape(vlookup_table_array_parts[1])}',  # $B2:D3
            ])
        
        vlookup_table_array_found = False
        for pattern in vlookup_table_array_patterns:
            if re.search(pattern, formula_text, re.IGNORECASE):
                vlookup_table_array_found = True
                break
        
        if not vlookup_table_array_found:
            logger.warning(f"Cell {check_cell} formula may not reference VLOOKUP table array {vlookup_table_array}")
            logger.warning(f"Formula: {formula_text}")
            # Don't fail here, as the range might be in a different format
        
        # Check 6: VLOOKUP col_index is correct
        # Look for VLOOKUP(..., ..., 3, ...) pattern
        vlookup_col_index_patterns = [
            rf'VLOOKUP\s*\([^,)]+,\s*[^,)]+,\s*{vlookup_col_index}\s*,',  # VLOOKUP(..., ..., 3,)
            rf'VLOOKUP\s*\([^,)]+,\s*[^,)]+,\s*{vlookup_col_index}\s*\)',  # VLOOKUP(..., ..., 3)
        ]
        vlookup_col_index_found = False
        for pattern in vlookup_col_index_patterns:
            if re.search(pattern, formula_upper):
                vlookup_col_index_found = True
                break
        
        if not vlookup_col_index_found:
            logger.warning(f"Cell {check_cell} formula may not use VLOOKUP col_index {vlookup_col_index}")
            logger.warning(f"Formula: {formula_text}")
            # Don't fail here, as the col_index might be in a different format
        
        # Check 7: VLOOKUP range_lookup is correct (0 for exact match)
        vlookup_range_lookup_patterns = [
            rf'VLOOKUP\s*\([^,)]+,\s*[^,)]+,\s*[^,)]+,\s*{vlookup_range_lookup}\s*\)',  # VLOOKUP(..., ..., ..., 0)
            rf'VLOOKUP\s*\([^,)]+,\s*[^,)]+,\s*[^,)]+,\s*{vlookup_range_lookup}\s*,',  # VLOOKUP(..., ..., ..., 0,)
            rf'VLOOKUP\s*\([^,)]+,\s*[^,)]+,\s*[^,)]+,\s*FALSE\s*\)',  # VLOOKUP(..., ..., ..., FALSE)
        ]
        vlookup_range_lookup_found = False
        for pattern in vlookup_range_lookup_patterns:
            if re.search(pattern, formula_upper):
                vlookup_range_lookup_found = True
                break
        
        if not vlookup_range_lookup_found:
            logger.warning(f"Cell {check_cell} formula may not use VLOOKUP range_lookup {vlookup_range_lookup}")
            logger.warning(f"Formula: {formula_text}")
            # Don't fail here, as the range_lookup might be in a different format
        
        # Check 8: INDEX structure - INDEX(array, row_num, [column_num])
        index_pattern = r'\bINDEX\s*\('
        if not re.search(index_pattern, formula_upper):
            logger.error(f"Cell {check_cell} formula does not contain INDEX function")
            return 0.0
        
        # Check 9: INDEX references the correct array
        index_array_clean = index_array.replace('$', '')
        index_array_patterns = [
            re.escape(index_array),  # D2:D3
            re.escape(index_array_clean),  # D2:D3 (if no $)
        ]
        # Also check for variations with different $ placements
        index_array_parts = index_array_clean.split(':')
        if len(index_array_parts) == 2:
            index_array_patterns.extend([
                rf'\${re.escape(index_array_parts[0])}\s*:\s*\${re.escape(index_array_parts[1])}',  # $D2:$D3
                rf'{re.escape(index_array_parts[0])}\s*:\s*\${re.escape(index_array_parts[1])}',  # D2:$D3
                rf'\${re.escape(index_array_parts[0])}\s*:\s*{re.escape(index_array_parts[1])}',  # $D2:D3
            ])
        
        index_array_found = False
        for pattern in index_array_patterns:
            if re.search(pattern, formula_text, re.IGNORECASE):
                index_array_found = True
                break
        
        if not index_array_found:
            logger.warning(f"Cell {check_cell} formula may not reference INDEX array {index_array}")
            logger.warning(f"Formula: {formula_text}")
            # Don't fail here, as the range might be in a different format
        
        # Check 10: INDEX row_num is correct
        # Look for INDEX(..., 2) or INDEX(..., 2, ...) pattern
        index_row_num_patterns = [
            rf'INDEX\s*\([^,)]+,\s*{index_row_num}\s*\)',  # INDEX(..., 2)
            rf'INDEX\s*\([^,)]+,\s*{index_row_num}\s*,',  # INDEX(..., 2,)
        ]
        index_row_num_found = False
        for pattern in index_row_num_patterns:
            if re.search(pattern, formula_upper):
                index_row_num_found = True
                break
        
        if not index_row_num_found:
            logger.warning(f"Cell {check_cell} formula may not use INDEX row_num {index_row_num}")
            logger.warning(f"Formula: {formula_text}")
            # Don't fail here, as the row_num might be in a different format
        
        # Check 11: Formula structure - SUM should contain VLOOKUP and INDEX
        # Check that VLOOKUP is inside SUM
        sum_vlookup_pattern = r'SUM\s*\(\s*VLOOKUP\s*\('
        if not re.search(sum_vlookup_pattern, formula_upper):
            logger.warning(f"Cell {check_cell} formula may not have correct SUM(VLOOKUP(...)) structure")
            logger.warning(f"Formula: {formula_text}")
            # Don't fail here, as the structure might be correct but formatted differently
        
        # Check 12: INDEX should be inside SUM
        sum_index_pattern = r'SUM\s*\([^,)]+,\s*INDEX\s*\('
        if not re.search(sum_index_pattern, formula_upper):
            logger.warning(f"Cell {check_cell} formula may not have correct SUM(..., INDEX(...)) structure")
            logger.warning(f"Formula: {formula_text}")
            # Don't fail here, as the structure might be correct but formatted differently
        
        # Check 13: Formula closes parentheses correctly
        open_count = formula_text.count('(')
        close_count = formula_text.count(')')
        if open_count != close_count:
            logger.error(f"Cell {check_cell} formula has mismatched parentheses")
            logger.error(f"Formula: {formula_text}")
            return 0.0
        
        logger.info("=" * 60)
        logger.info(f"✓ SUM(VLOOKUP, INDEX) formula verification passed")
        logger.info(f"Cell {check_cell} contains correct formula structure")
        logger.info("=" * 60)
        return 1.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_concatenate_cells(result: str, expected: str = None, **options) -> float:
    """
    Verify if at least one cell in the worksheet contains a formula that concatenates A1 and B1.
    
    This function checks:
    1. Whether at least one cell in the worksheet contains a formula
    2. Whether the formula uses & operator to concatenate A1 and B1 (e.g., =A1&B1)
    3. OR whether the formula uses CONCATENATE function to merge A1 and B1 (e.g., =CONCATENATE(A1,B1))
    4. Whether the formula references the correct source cells (A1 and B1)
    
    The function searches through all cells in the worksheet to find at least one matching formula.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - source_cell1: First source cell to concatenate (default: "A1")
            - source_cell2: Second source cell to concatenate (default: "B1")
    
    Returns:
        float: 1.0 if at least one cell contains correct concatenation formula, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        source_cell1 = options.get('source_cell1', 'A1')
        source_cell2 = options.get('source_cell2', 'B1')
        
        logger.info(f"Verifying concatenate formulas in file: {result}")
        logger.info(f"Looking for formulas that concatenate {source_cell1} and {source_cell2}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Search through all cells in the worksheet
        found_formula = False
        found_cell = None
        found_formula_text = None
        
        # Get the maximum row and column with data
        max_row = ws.max_row
        max_col = ws.max_column
        
        logger.info(f"Searching through worksheet (max_row={max_row}, max_col={max_col})")
        
        # Search all cells
        for row in range(1, max_row + 1):
            for col in range(1, max_col + 1):
                cell = ws.cell(row=row, column=col)
                cell_coord = f"{get_column_letter(col)}{row}"
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                else:
                    if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                
                if formula_text is None:
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Checking cell {cell_coord} formula: {formula_text}")
                
                # Check for two patterns:
                # Pattern 1: =A1&B1 (using & operator)
                # Pattern 2: =CONCATENATE(A1,B1) (using CONCATENATE function)
                
                # Pattern 1: Check for & operator concatenation
                # Match patterns like: =A1&B1, =$A$1&$B$1, =A1 & B1, etc.
                # Remove $ signs for matching
                source_cell1_clean = source_cell1.replace('$', '')
                source_cell2_clean = source_cell2.replace('$', '')
                formula_clean = formula_text.replace('$', '')
                
                # Pattern 1: & operator
                # Match: A1&B1 or A1 & B1 (with optional spaces)
                ampersand_pattern = rf'\b{re.escape(source_cell1_clean)}\s*&\s*{re.escape(source_cell2_clean)}\b'
                if re.search(ampersand_pattern, formula_clean, re.IGNORECASE):
                    found_formula = True
                    found_cell = cell_coord
                    found_formula_text = formula_text
                    logger.info(f"Found & operator concatenation in cell {cell_coord}: {formula_text}")
                    break
                
                # Pattern 2: CONCATENATE function
                # Match: =CONCATENATE(A1,B1) or =CONCATENATE(A1, B1) (with optional spaces)
                concatenate_pattern = rf'\bCONCATENATE\s*\(\s*{re.escape(source_cell1_clean)}\s*,\s*{re.escape(source_cell2_clean)}\s*\)'
                if re.search(concatenate_pattern, formula_clean, re.IGNORECASE):
                    found_formula = True
                    found_cell = cell_coord
                    found_formula_text = formula_text
                    logger.info(f"Found CONCATENATE function in cell {cell_coord}: {formula_text}")
                    break
            
            if found_formula:
                break
        
        if found_formula:
            logger.info("=" * 60)
            logger.info(f"✓ Concatenate formula verification passed")
            logger.info(f"Found formula in cell {found_cell}: {found_formula_text}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error("✗ Verification failed: No cell found with concatenation formula")
            logger.error(f"Expected formula: ={source_cell1}&{source_cell2} or =CONCATENATE({source_cell1},{source_cell2})")
            logger.error("=" * 60)
            return 0.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_lookup_date_match(result: str, expected: str = None, **options) -> float:
    """
    Verify if LOOKUP formulas exist in specified range with correct structure.
    
    This function checks:
    1. Whether cells in specified range contain formulas
    2. Whether formulas contain LOOKUP function
    3. Whether LOOKUP lookup_value references the correct column and row (e.g., $I3, $I4)
    4. Whether LOOKUP lookup_array is correct (e.g., $A:$A)
    5. Whether LOOKUP result_vector references the correct column based on mapping (K->C, L->D, M->E, N->F, O->G)
    6. Whether formula structure is correct: LOOKUP(lookup_value, lookup_array, result_vector)
    
    The function automatically detects the number of data rows by checking for non-empty cells
    in the specified range. It stops checking after finding 3 consecutive empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_range: Range to check (e.g., "K3:O217")
            - lookup_value_col: Column letter for LOOKUP lookup value (default: "I")
            - lookup_array: LOOKUP lookup array range (default: "$A:$A")
            - result_col_mapping: Dictionary mapping result columns to source columns (e.g., {"K": "C", "L": "D"})
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_range = options.get('check_range', 'K3:O217')
        lookup_value_col = options.get('lookup_value_col', 'I')
        lookup_array = options.get('lookup_array', '$A:$A')
        result_col_mapping = options.get('result_col_mapping', {
            'K': 'C',
            'L': 'D',
            'M': 'E',
            'N': 'F',
            'O': 'G'
        })
        
        logger.info(f"Verifying LOOKUP formulas in file: {result}")
        logger.info(f"Range to check: {check_range}")
        logger.info(f"Lookup value column: {lookup_value_col}")
        logger.info(f"Lookup array: {lookup_array}")
        logger.info(f"Result column mapping: {result_col_mapping}")
        
        # Parse the range manually
        try:
            # Remove $ signs and split by :
            range_clean = check_range.replace('$', '')
            if ':' in range_clean:
                start_cell, end_cell = range_clean.split(':')
                # Parse start cell
                start_col_letter = ''.join([c for c in start_cell if c.isalpha()])
                start_row = int(''.join([c for c in start_cell if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                # Parse end cell
                end_col_letter = ''.join([c for c in end_cell if c.isalpha()])
                end_row = int(''.join([c for c in end_cell if c.isdigit()]))
                end_col = column_index_from_string(end_col_letter)
            else:
                # Single cell
                start_col_letter = ''.join([c for c in range_clean if c.isalpha()])
                start_row = int(''.join([c for c in range_clean if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                end_col_letter = start_col_letter
                end_row = start_row
                end_col = start_col
        except Exception as e:
            logger.error(f"Failed to parse range {check_range}: {e}")
            return 0.0
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end row by checking for consecutive empty rows
        logger.info(f"Auto-detecting end row in range {check_range}...")
        detected_end_row = start_row
        empty_count = 0
        
        for row_num in range(start_row, end_row + 1):
            has_data = False
            for col_num in range(start_col, end_col + 1):
                col_letter = get_column_letter(col_num)
                cell = ws[f"{col_letter}{row_num}"]
                if cell.value is not None or (cell.data_type == "f"):
                    has_data = True
                    break
            
            if has_data:
                empty_count = 0
                detected_end_row = row_num
            else:
                empty_count += 1
                if empty_count >= 3:
                    break
        
        logger.info(f"Auto-detected end row: {detected_end_row}")
        actual_end_row = min(detected_end_row, end_row)
        
        # Check each cell in the range
        all_passed = True
        checked_count = 0
        passed_count = 0
        
        for row_num in range(start_row, actual_end_row + 1):
            for col_num in range(start_col, end_col + 1):
                col_letter = get_column_letter(col_num)
                cell_coord = f"{col_letter}{row_num}"
                
                try:
                    cell = ws[cell_coord]
                    checked_count += 1
                    
                    # Check if cell contains a formula
                    if cell.data_type != "f":
                        logger.warning(f"Cell {cell_coord} does not contain a formula")
                        all_passed = False
                        continue
                    
                    # Get formula text
                    formula_text = None
                    if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                        formula_text = cell._value
                    elif hasattr(cell, "formula"):
                        formula_text = cell.formula
                    else:
                        if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                            formula_text = cell.value
                    
                    if formula_text is None:
                        logger.warning(f"Could not extract formula from cell {cell_coord}")
                        all_passed = False
                        continue
                    
                    formula_upper = formula_text.upper()
                    logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                    
                    # Check 1: Formula contains LOOKUP function
                    lookup_pattern = r'\bLOOKUP\s*\('
                    if not re.search(lookup_pattern, formula_upper):
                        logger.warning(f"Cell {cell_coord} formula does not contain LOOKUP function")
                        logger.warning(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 2: LOOKUP lookup_value references the correct column and row
                    # Should be $I{row_num} or I{row_num} (with optional $)
                    lookup_value_patterns = [
                        rf'\${re.escape(lookup_value_col)}{row_num}\b',  # $I3
                        rf'{re.escape(lookup_value_col)}{row_num}\b',   # I3
                        rf'\${re.escape(lookup_value_col)}\${row_num}\b',  # $I$3
                    ]
                    lookup_value_found = False
                    for pattern in lookup_value_patterns:
                        if re.search(pattern, formula_text, re.IGNORECASE):
                            lookup_value_found = True
                            break
                    
                    if not lookup_value_found:
                        logger.warning(f"Cell {cell_coord} formula LOOKUP lookup_value does not reference {lookup_value_col}{row_num}")
                        logger.warning(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 3: LOOKUP lookup_array is correct (e.g., $A:$A)
                    lookup_array_pattern = re.escape(lookup_array).replace('\\$', '\\$?')
                    if not re.search(lookup_array_pattern, formula_text, re.IGNORECASE):
                        logger.warning(f"Cell {cell_coord} formula LOOKUP lookup_array does not reference {lookup_array}")
                        logger.warning(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 4: LOOKUP result_vector references the correct column based on mapping
                    # Get expected result column from mapping
                    if col_letter.upper() not in result_col_mapping:
                        logger.warning(f"Cell {cell_coord} column {col_letter} not in result_col_mapping")
                        all_passed = False
                        continue
                    
                    expected_result_col = result_col_mapping[col_letter.upper()]
                    # Should be {expected_result_col}:{expected_result_col} (e.g., C:C, D:D)
                    result_vector_patterns = [
                        rf'\b{re.escape(expected_result_col)}:{re.escape(expected_result_col)}\b',  # C:C
                        rf'\${re.escape(expected_result_col)}:\${re.escape(expected_result_col)}\b',  # $C:$C
                    ]
                    result_vector_found = False
                    for pattern in result_vector_patterns:
                        if re.search(pattern, formula_text, re.IGNORECASE):
                            result_vector_found = True
                            break
                    
                    if not result_vector_found:
                        logger.warning(f"Cell {cell_coord} formula LOOKUP result_vector does not reference {expected_result_col}:{expected_result_col}")
                        logger.warning(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 5: Formula structure is LOOKUP(lookup_value, lookup_array, result_vector)
                    # Extract LOOKUP parameters
                    lookup_match = re.search(r'LOOKUP\s*\(', formula_text, re.IGNORECASE)
                    if lookup_match:
                        # Find the parameters
                        start_pos = lookup_match.end()
                        # Count parentheses to find the end of LOOKUP function
                        paren_count = 1
                        pos = start_pos
                        while pos < len(formula_text) and paren_count > 0:
                            if formula_text[pos] == '(':
                                paren_count += 1
                            elif formula_text[pos] == ')':
                                paren_count -= 1
                            pos += 1
                        
                        if paren_count != 0:
                            logger.warning(f"Cell {cell_coord} formula LOOKUP has mismatched parentheses")
                            all_passed = False
                            continue
                    
                    # All checks passed for this cell
                    passed_count += 1
                    logger.debug(f"✓ Cell {cell_coord} passed verification")
                    
                except Exception as e:
                    logger.warning(f"Error checking cell {cell_coord}: {e}")
                    all_passed = False
                    continue
        
        # Calculate pass rate
        if checked_count == 0:
            logger.error("No cells were checked")
            return 0.0
        
        pass_rate = passed_count / checked_count
        logger.info(f"Checked {checked_count} cells, {passed_count} passed (pass rate: {pass_rate:.2%})")
        
        # Require at least 90% pass rate
        if pass_rate >= 0.9:
            logger.info("=" * 60)
            logger.info(f"✓ LOOKUP formula verification passed")
            logger.info(f"Pass rate: {pass_rate:.2%}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ LOOKUP formula verification failed")
            logger.error(f"Pass rate: {pass_rate:.2%} (required: >= 90%)")
            logger.error("=" * 60)
            return 0.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_index_column_row_transform(result: str, expected: str = None, **options) -> float:
    """
    Verify if INDEX formula with COLUMN and ROW functions exists in specified range to transform single column data into two columns.
    
    This function STRICTLY checks ALL cells in the specified range - no tolerance, no auto-detection.
    Every single cell in the specified range must contain the correct formula.
    
    This function checks:
    1. Whether ALL cells in the specified formula range (e.g., F2:G25) contain formulas
    2. Whether formulas contain INDEX, COLUMN, and ROW functions
    3. Whether INDEX references the correct source column (e.g., $A:$A)
    4. Whether formulas have the correct structure: =INDEX($A:$A,COLUMN(A1)+ROW(A1)*2-1)&""
    5. Whether COLUMN and ROW functions use relative references (A1 pattern)
    6. Whether formula includes &"" concatenation
    
    The formula =INDEX($A:$A,COLUMN(A1)+ROW(A1)*2-1)&"" works as follows:
    - INDEX($A:$A, ...) extracts data from column A
    - COLUMN(A1) returns 1 (column A is column 1), but when copied to G column, it becomes COLUMN(B1)=2
    - ROW(A1) returns the row number of the current cell (F2: ROW(A1)=1, F3: ROW(A2)=2)
    - COLUMN(A1)+ROW(A1)*2-1 calculates the index: F2=1+1*2-1=2 (A2), G2=2+1*2-1=3 (A3), F3=1+2*2-1=4 (A4)
    - &"" ensures the result is text format
    - This transforms A column data into F and G columns, with every two A rows corresponding to one F-G row
    
    IMPORTANT: This function checks ALL cells in the specified formula range. If any cell is missing a formula, verification fails.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formula_range: Range containing formulas (e.g., "F2:G25") - ALL cells must have formulas
            - source_column: Source column for INDEX function (default: "A")
            - expected_formula_pattern: Expected formula pattern (default: "=INDEX($A:$A,COLUMN(A1)+ROW(A1)*2-1)&\"\"")
            - expected_functions: List of expected function names (default: ["INDEX", "COLUMN", "ROW"])
    
    Returns:
        float: 1.0 if ALL cells in specified range contain correct formulas, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formula_range = options.get('formula_range', 'F2:G25')
        source_column = options.get('source_column', 'A')
        expected_functions = options.get('expected_functions', ['INDEX', 'COLUMN', 'ROW'])
        
        logger.info(f"Verifying INDEX(COLUMN+ROW) transform formula in file: {result}")
        logger.info(f"Formula range: {formula_range}")
        logger.info(f"Source column: {source_column}")
        
        # Parse the formula range
        try:
            range_clean = formula_range.replace("$", "")
            if ":" in range_clean:
                start_cell, end_cell = range_clean.split(":")
                start_col_letter = "".join([c for c in start_cell if c.isalpha()])
                start_row = int("".join([c for c in start_cell if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                end_col_letter = "".join([c for c in end_cell if c.isalpha()])
                end_row = int("".join([c for c in end_cell if c.isdigit()]))
                end_col = column_index_from_string(end_col_letter)
            else:
                logger.error(f"Invalid range format: {formula_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse range {formula_range}: {e}")
            return 0.0
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=False)
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check 1: Verify ALL cells in formula range contain formulas
        logger.info(f"Checking all cells in range {formula_range} (rows {start_row} to {end_row}, columns {start_col} to {end_col})")
        
        all_passed = True
        checked_count = 0
        passed_count = 0
        
        for row_num in range(start_row, end_row + 1):
            for col_num in range(start_col, end_col + 1):
                col_letter = get_column_letter(col_num)
                cell_coord = f"{col_letter}{row_num}"
                
                try:
                    cell = ws[cell_coord]
                    checked_count += 1
                    
                    # Check if cell contains a formula
                    if cell.data_type != "f":
                        logger.error(f"Cell {cell_coord} does not contain a formula")
                        all_passed = False
                        continue
                    
                    # Get formula text
                    formula_text = None
                    if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                        formula_text = cell._value
                    elif hasattr(cell, "formula"):
                        formula_text = cell.formula
                    elif cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                    
                    if formula_text is None:
                        logger.error(f"Could not extract formula from cell {cell_coord}")
                        all_passed = False
                        continue
                    
                    formula_upper = formula_text.upper()
                    logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                    
                    # Check 1: Formula contains all expected functions
                    for func_name in expected_functions:
                        func_pattern = rf'\b{re.escape(func_name.upper())}\s*\('
                        if not re.search(func_pattern, formula_upper):
                            logger.error(f"Cell {cell_coord} formula does not contain {func_name} function")
                            logger.error(f"Formula: {formula_text}")
                            all_passed = False
                            break
                    
                    if not all_passed:
                        continue
                    
                    # Check 2: Formula contains INDEX function
                    index_pattern = r'\bINDEX\s*\('
                    if not re.search(index_pattern, formula_upper):
                        logger.error(f"Cell {cell_coord} formula does not contain INDEX function")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 3: INDEX references the correct source column (e.g., $A:$A)
                    source_col_patterns = [
                        rf'\$\s*{re.escape(source_column.upper())}\s*:\s*\$\s*{re.escape(source_column.upper())}',
                        rf'\$\s*{re.escape(source_column.upper())}\s*:\s*{re.escape(source_column.upper())}',
                        rf'{re.escape(source_column.upper())}\s*:\s*\$\s*{re.escape(source_column.upper())}',
                        rf'{re.escape(source_column.upper())}\s*:\s*{re.escape(source_column.upper())}',
                    ]
                    source_col_found = False
                    for pattern in source_col_patterns:
                        if re.search(pattern, formula_upper):
                            source_col_found = True
                            break
                    
                    if not source_col_found:
                        logger.error(f"Cell {cell_coord} formula INDEX does not reference ${source_column}:${source_column}")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 4: Formula contains COLUMN function
                    column_pattern = r'\bCOLUMN\s*\('
                    if not re.search(column_pattern, formula_upper):
                        logger.error(f"Cell {cell_coord} formula does not contain COLUMN function")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 5: COLUMN function uses relative reference (A1 pattern, not $A$1)
                    # Look for COLUMN(A1), COLUMN(B1), etc. (relative reference)
                    column_ref_pattern = r'COLUMN\s*\(\s*[A-Z]+\d+\s*\)'
                    if not re.search(column_ref_pattern, formula_upper):
                        logger.error(f"Cell {cell_coord} formula COLUMN does not use relative reference (A1 pattern)")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 6: Formula contains ROW function
                    row_pattern = r'\bROW\s*\('
                    if not re.search(row_pattern, formula_upper):
                        logger.error(f"Cell {cell_coord} formula does not contain ROW function")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 7: ROW function uses relative reference (A1 pattern, not $A$1)
                    row_ref_pattern = r'ROW\s*\(\s*[A-Z]+\d+\s*\)'
                    if not re.search(row_ref_pattern, formula_upper):
                        logger.error(f"Cell {cell_coord} formula ROW does not use relative reference (A1 pattern)")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 8: Formula contains the pattern COLUMN(...)+ROW(...)*2-1
                    # This pattern calculates the index: COLUMN(A1)+ROW(A1)*2-1
                    index_calc_pattern = r'COLUMN\s*\([^)]+\)\s*\+\s*ROW\s*\([^)]+\)\s*\*\s*2\s*-\s*1'
                    if not re.search(index_calc_pattern, formula_upper):
                        logger.error(f"Cell {cell_coord} formula does not contain COLUMN(...)+ROW(...)*2-1 pattern")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 9: Formula contains &"" concatenation (optional but common)
                    # This is flexible - some formulas might not have it
                    concat_pattern = r'&\s*""'
                    has_concat = re.search(concat_pattern, formula_upper)
                    if not has_concat:
                        logger.debug(f"Cell {cell_coord} formula does not contain &\"\" concatenation (optional)")
                    
                    # Check 10: Formula structure is INDEX($A:$A,COLUMN(A1)+ROW(A1)*2-1)&""
                    # Verify the overall structure
                    # INDEX should be followed by source column, then the calculation
                    index_structure_pattern = r'INDEX\s*\(\s*\$\s*[A-Z]+\s*:\s*\$\s*[A-Z]+\s*,\s*COLUMN\s*\([^)]+\)\s*\+\s*ROW\s*\([^)]+\)\s*\*\s*2\s*-\s*1'
                    if not re.search(index_structure_pattern, formula_upper):
                        logger.error(f"Cell {cell_coord} formula does not have correct INDEX structure")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    passed_count += 1
                    logger.debug(f"✓ Cell {cell_coord} has valid formula: {formula_text}")
                    
                except Exception as e:
                    logger.error(f"Error checking cell {cell_coord}: {e}")
                    all_passed = False
        
        if not all_passed:
            logger.error("=" * 60)
            logger.error(f"✗ INDEX(COLUMN+ROW) transform formula verification failed")
            logger.error(f"Some cells in range {formula_range} are missing formulas or have incorrect formulas")
            logger.error("=" * 60)
            return 0.0
        
        # Calculate pass rate
        if checked_count == 0:
            logger.error("No cells were checked")
            return 0.0
        
        pass_rate = passed_count / checked_count
        logger.info(f"Checked {checked_count} cells, {passed_count} passed (pass rate: {pass_rate:.2%})")
        
        # Require 100% pass rate (all cells must have correct formulas)
        if pass_rate == 1.0:
            logger.info("=" * 60)
            logger.info(f"✓ INDEX(COLUMN+ROW) transform formula verification passed")
            logger.info(f"All {checked_count} cells in range {formula_range} contain correct formulas")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ INDEX(COLUMN+ROW) transform formula verification failed")
            logger.error(f"Pass rate: {pass_rate:.2%} (required: 100%)")
            logger.error("=" * 60)
            return 0.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_count_find_conditional_formatting(result: str, expected: str = None, **options) -> float:
    """
    Verify if conditional formatting with COUNT(FIND(...)) formulas exists in specified range with font colors.
    
    This function checks:
    1. Whether the specified range (e.g., D1:D44) has conditional formatting
    2. Whether there are two conditional formatting rules:
       - Condition 1: COUNT(FIND("罗江",D1)) with red font color
       - Condition 2: COUNT(FIND("中江",D1)) with blue font color
    3. Whether both conditions apply to the specified range
    4. Whether the font colors match the expected colors (red and blue)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_range: Range to check (e.g., "D1:D44")
            - condition1_formula_pattern: Expected formula pattern for condition 1 (default: 'COUNT(FIND("罗江",D1))')
            - condition1_font_color: Expected font color for condition 1 (default: "red")
            - condition2_formula_pattern: Expected formula pattern for condition 2 (default: 'COUNT(FIND("中江",D1))')
            - condition2_font_color: Expected font color for condition 2 (default: "blue")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        from openpyxl.worksheet.cell_range import CellRange
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_range = options.get('check_range', 'D1:D44')
        condition1_formula_pattern = options.get('condition1_formula_pattern', 'COUNT(FIND("罗江",D1))')
        condition1_font_color = options.get('condition1_font_color', 'red')
        condition2_formula_pattern = options.get('condition2_formula_pattern', 'COUNT(FIND("中江",D1))')
        condition2_font_color = options.get('condition2_font_color', 'blue')
        
        logger.info(f"Verifying conditional formatting in file: {result}")
        logger.info(f"Range to check: {check_range}")
        logger.info(f"Condition 1: {condition1_formula_pattern} -> {condition1_font_color}")
        logger.info(f"Condition 2: {condition2_formula_pattern} -> {condition2_font_color}")
        
        # Parse the range
        try:
            range_clean = check_range.replace('$', '')
            if ':' in range_clean:
                start_cell, end_cell = range_clean.split(':')
                # Parse start cell
                start_col_letter = ''.join([c for c in start_cell if c.isalpha()])
                start_row = int(''.join([c for c in start_cell if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                # Parse end cell
                end_col_letter = ''.join([c for c in end_cell if c.isalpha()])
                end_row = int(''.join([c for c in end_cell if c.isdigit()]))
                end_col = column_index_from_string(end_col_letter)
            else:
                logger.error(f"Invalid range format: {check_range}. Expected format like 'D1:D44'")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse range {check_range}: {e}")
            return 0.0
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=False)
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check conditional formatting
        conditional_formattings = ws.conditional_formatting
        
        if not conditional_formattings:
            logger.error("No conditional formatting found in worksheet")
            return 0.0
        
        found_condition1 = False
        found_condition2 = False
        condition1_range_cells = None
        condition2_range_cells = None
        
        # Helper function to check if color matches
        def check_font_color(font_color_obj, expected_color_name):
            """Check if font color matches expected color name"""
            if font_color_obj is None or not hasattr(font_color_obj, 'rgb'):
                logger.debug(f"Font color object is None or has no rgb attribute")
                return False
            
            color_rgb = font_color_obj.rgb
            if color_rgb is None:
                logger.debug(f"Font color RGB is None")
                return False
            
            color_str = str(color_rgb).upper()
            logger.debug(f"Checking color: {color_str} against {expected_color_name}")
            
            # Convert color name to RGB values
            if expected_color_name.lower() == 'red':
                # Red: high red, low green, low blue
                if len(color_str) >= 6:
                    if len(color_str) == 8:
                        r_val = int(color_str[2:4], 16)
                        g_val = int(color_str[4:6], 16)
                        b_val = int(color_str[6:8], 16)
                    elif len(color_str) == 6:
                        r_val = int(color_str[0:2], 16)
                        g_val = int(color_str[2:4], 16)
                        b_val = int(color_str[4:6], 16)
                    else:
                        logger.debug(f"Unexpected color string length: {len(color_str)}")
                        return False
                    # Red: R > 200, G < 100, B < 100
                    is_red = r_val > 200 and g_val < 100 and b_val < 100
                    logger.debug(f"Red check: RGB({r_val}, {g_val}, {b_val}) -> {is_red}")
                    return is_red
            elif expected_color_name.lower() == 'blue':
                # Blue: low red, low green, high blue
                if len(color_str) >= 6:
                    if len(color_str) == 8:
                        r_val = int(color_str[2:4], 16)
                        g_val = int(color_str[4:6], 16)
                        b_val = int(color_str[6:8], 16)
                    elif len(color_str) == 6:
                        r_val = int(color_str[0:2], 16)
                        g_val = int(color_str[2:4], 16)
                        b_val = int(color_str[4:6], 16)
                    else:
                        logger.debug(f"Unexpected color string length: {len(color_str)}")
                        return False
                    # Blue: R < 100, G < 100, B > 200 (relaxed: allow some tolerance)
                    is_blue = r_val < 150 and g_val < 150 and b_val > 150
                    logger.debug(f"Blue check: RGB({r_val}, {g_val}, {b_val}) -> {is_blue}")
                    return is_blue
            
            logger.debug(f"Color name {expected_color_name} not recognized")
            return False
        
        # Check each conditional formatting rule
        for fmt in conditional_formattings:
            # Check if this formatting applies to any cell in our target range
            fmt_applies_to_range = False
            for rge in fmt.cells:
                # Check if this range overlaps with our target range
                cf_start_col = rge.min_col
                cf_start_row = rge.min_row
                cf_end_col = rge.max_col
                cf_end_row = rge.max_row
                
                # Check if ranges overlap
                if not (cf_end_col < start_col or cf_start_col > end_col or 
                        cf_end_row < start_row or cf_start_row > end_row):
                    fmt_applies_to_range = True
                    break
            
            if not fmt_applies_to_range:
                continue
            
            # Check each rule in this formatting
            for r in fmt.rules:
                # Check formula
                if not r.formula:
                    continue
                
                formula_text = r.formula[0] if isinstance(r.formula, list) else str(r.formula)
                formula_upper = formula_text.upper()
                
                logger.debug(f"Found conditional formatting formula: {formula_text}")
                
                # Check if formula contains COUNT and FIND
                count_pattern = r'\bCOUNT\s*\('
                find_pattern = r'\bFIND\s*\('
                
                if not re.search(count_pattern, formula_upper) or not re.search(find_pattern, formula_upper):
                    logger.debug(f"Formula does not contain COUNT(FIND(...)): {formula_text}")
                    continue
                
                # Check font color
                font_color = None
                if r.dxf and r.dxf.font:
                    try:
                        if r.dxf.font.color:
                            font_color = r.dxf.font.color
                    except:
                        pass
                
                if font_color is None:
                    logger.debug(f"Conditional formatting rule has no font color")
                    continue
                
                # Get font color RGB for debugging
                font_color_rgb = None
                if font_color and hasattr(font_color, 'rgb'):
                    font_color_rgb = font_color.rgb
                logger.debug(f"Font color RGB: {font_color_rgb}")
                
                # Check condition 1: COUNT(FIND("罗江",D1))
                # Pattern: COUNT(FIND("罗江",D1)) or COUNT(FIND("罗江",D$1)) etc.
                # Use original formula_text (not uppercase) for Chinese character matching
                condition1_match = re.search(r'COUNT\s*\(\s*FIND\s*\(\s*["\'""]罗江["\'""]\s*,\s*D\$?\d+\s*\)\s*\)', formula_text, re.IGNORECASE)
                
                if condition1_match:
                    color_match = check_font_color(font_color, condition1_font_color)
                    logger.debug(f"Condition 1 match: formula={condition1_match is not None}, color={color_match}")
                    if color_match:
                        found_condition1 = True
                        condition1_range_cells = rge
                        logger.info(f"✓ Found condition 1: {formula_text} -> {condition1_font_color}")
                        # Don't continue here, check condition 2 as well
                
                # Check condition 2: COUNT(FIND("中江",D1))
                # Use original formula_text (not uppercase) for Chinese character matching
                condition2_match = re.search(r'COUNT\s*\(\s*FIND\s*\(\s*["\'""]中江["\'""]\s*,\s*D\$?\d+\s*\)\s*\)', formula_text, re.IGNORECASE)
                
                if condition2_match:
                    color_match = check_font_color(font_color, condition2_font_color)
                    logger.debug(f"Condition 2 match: formula={condition2_match is not None}, color={color_match}")
                    if color_match:
                        found_condition2 = True
                        condition2_range_cells = rge
                        logger.info(f"✓ Found condition 2: {formula_text} -> {condition2_font_color}")
                        # Don't continue here, both conditions might be in separate rules
        
        # Verify both conditions are found
        if not found_condition1:
            logger.error("=" * 60)
            logger.error("✗ Condition 1 not found")
            logger.error(f"  Expected: {condition1_formula_pattern} -> {condition1_font_color}")
            logger.error("=" * 60)
            return 0.0
        
        if not found_condition2:
            logger.error("=" * 60)
            logger.error("✗ Condition 2 not found")
            logger.error(f"  Expected: {condition2_formula_pattern} -> {condition2_font_color}")
            logger.error("=" * 60)
            return 0.0
        
        # Verify that both conditions apply to the target range
        if condition1_range_cells:
            cf_start_col = condition1_range_cells.min_col
            cf_start_row = condition1_range_cells.min_row
            cf_end_col = condition1_range_cells.max_col
            cf_end_row = condition1_range_cells.max_row
            
            if cf_start_col > start_col or cf_end_col < end_col or \
               cf_start_row > start_row or cf_end_row < end_row:
                logger.error("=" * 60)
                logger.error("✗ Condition 1 range does not fully cover target range")
                logger.error(f"  Target range: {check_range} (cols {start_col}-{end_col}, rows {start_row}-{end_row})")
                logger.error(f"  CF range: cols {cf_start_col}-{cf_end_col}, rows {cf_start_row}-{cf_end_row}")
                logger.error("=" * 60)
                return 0.0
        
        if condition2_range_cells:
            cf_start_col = condition2_range_cells.min_col
            cf_start_row = condition2_range_cells.min_row
            cf_end_col = condition2_range_cells.max_col
            cf_end_row = condition2_range_cells.max_row
            
            if cf_start_col > start_col or cf_end_col < end_col or \
               cf_start_row > start_row or cf_end_row < end_row:
                logger.error("=" * 60)
                logger.error("✗ Condition 2 range does not fully cover target range")
                logger.error(f"  Target range: {check_range} (cols {start_col}-{end_col}, rows {start_row}-{end_row})")
                logger.error(f"  CF range: cols {cf_start_col}-{cf_end_col}, rows {cf_start_row}-{cf_end_row}")
                logger.error("=" * 60)
                return 0.0
        
        logger.info("=" * 60)
        logger.info(f"✓ Conditional formatting verification passed")
        logger.info(f"  - Condition 1: {condition1_formula_pattern} -> {condition1_font_color} ✓")
        logger.info(f"  - Condition 2: {condition2_formula_pattern} -> {condition2_font_color} ✓")
        logger.info(f"  - Range: {check_range}")
        logger.info("=" * 60)
        return 1.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_sumpRODUCT_multi_condition_sum(result: str, expected: str = None, **options) -> float:
    """
    Verify if SUMPRODUCT formulas with multiple conditions exist in specified range for multi-condition summing.
    
    This function STRICTLY checks ALL cells in the specified range - no tolerance, no auto-detection.
    Every single cell in the specified range must contain the correct formula.
    
    This function checks:
    1. Whether ALL cells in the specified range (e.g., H3:H4) contain formulas
    2. Whether formulas contain SUMPRODUCT, ISNUMBER, SEARCH, TRIM, LOOKUP, and ROW functions
    3. Whether SEARCH function references the correct column with relative row (e.g., F3, F4)
    4. Whether LOOKUP function references the correct range (e.g., A$2:A$9)
    5. Whether TRIM function is used for both search and match conditions
    6. Whether match condition references the correct columns (B$2:B$9 and G3, G4)
    7. Whether sum range references the correct range (e.g., C$2:C$9)
    8. Whether formula structure is correct: SUMPRODUCT(ISNUMBER(SEARCH(...))*(TRIM(...)=TRIM(...))*...)
    
    IMPORTANT: This function checks ALL cells in the specified ranges, regardless of whether they
    appear to be empty. If any cell in the specified range is missing a formula, verification fails.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_range: Range to check (e.g., "H3:H4") - ALL cells must have formulas
            - expected_functions: List of expected function names (default: ["SUMPRODUCT", "ISNUMBER", "SEARCH", "TRIM", "LOOKUP", "ROW"])
            - lookup_range: LOOKUP range reference (default: "A$2:A$9")
            - search_col: Column letter for SEARCH criteria (default: "F")
            - match_col: Column letter for match condition (default: "B")
            - match_col_ref: Column letter for match reference (default: "G")
            - sum_range: Sum range reference (default: "C$2:C$9")
    
    Returns:
        float: 1.0 if ALL cells in specified range contain correct formulas, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_range = options.get('check_range', 'H3:H4')
        expected_functions = options.get('expected_functions', ['SUMPRODUCT', 'ISNUMBER', 'SEARCH', 'TRIM', 'LOOKUP', 'ROW'])
        lookup_range = options.get('lookup_range', 'A$2:A$9')
        search_col = options.get('search_col', 'F')
        match_col = options.get('match_col', 'B')
        match_col_ref = options.get('match_col_ref', 'G')
        sum_range = options.get('sum_range', 'C$2:C$9')
        
        logger.info(f"Verifying SUMPRODUCT multi-condition sum formulas in file: {result}")
        logger.info(f"Range to check: {check_range}")
        logger.info(f"Expected functions: {expected_functions}")
        
        # Parse the range - strictly use the specified range
        try:
            range_clean = check_range.replace('$', '')
            if ':' in range_clean:
                start_cell, end_cell = range_clean.split(':')
                start_col_letter = ''.join([c for c in start_cell if c.isalpha()])
                start_row = int(''.join([c for c in start_cell if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                end_col_letter = ''.join([c for c in end_cell if c.isalpha()])
                end_row = int(''.join([c for c in end_cell if c.isdigit()]))
                end_col = column_index_from_string(end_col_letter)
            else:
                logger.error(f"Invalid range format: {check_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse range {check_range}: {e}")
            return 0.0
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Strictly check ALL cells in the specified range - no auto-detection
        logger.info(f"Checking all cells in range {check_range} (rows {start_row} to {end_row})")
        
        all_passed = True
        checked_count = 0
        passed_count = 0
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{start_col_letter}{row_num}"
            expected_search_cell = f"{search_col}{row_num}"
            expected_match_cell = f"{match_col_ref}{row_num}"
            
            try:
                cell = ws[cell_coord]
                checked_count += 1
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.warning(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                else:
                    if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains all expected functions
                for func in expected_functions:
                    func_pattern = rf'\b{func}\s*\('
                    if not re.search(func_pattern, formula_upper):
                        logger.warning(f"Cell {cell_coord} formula does not contain {func} function")
                        logger.warning(f"Formula: {formula_text}")
                        all_passed = False
                        break
                
                if not all_passed:
                    continue
                
                # Check 2: Formula contains SUMPRODUCT function
                sumproduct_pattern = r'\bSUMPRODUCT\s*\('
                if not re.search(sumproduct_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not contain SUMPRODUCT function")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: Formula contains ISNUMBER(SEARCH(...)) structure
                isnumber_search_pattern = r'\bISNUMBER\s*\(\s*SEARCH\s*\('
                if not re.search(isnumber_search_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not contain ISNUMBER(SEARCH(...)) structure")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: SEARCH function references the correct column with relative row (F3, F4, etc.)
                # Allow variations: F3, $F3, F$3, $F$3
                escaped_search_cell = re.escape(expected_search_cell)
                escaped_search_col = re.escape(search_col)
                search_cell_patterns = [
                    rf'\b{escaped_search_cell}\b',  # F3
                    rf'\${escaped_search_col}{row_num}\b',  # $F3
                    rf'\b{escaped_search_col}\${row_num}\b',  # F$3
                    rf'\${escaped_search_col}\${row_num}\b',  # $F$3
                ]
                
                search_cell_found = False
                for pattern in search_cell_patterns:
                    if re.search(pattern, formula_text, re.IGNORECASE):
                        search_cell_found = True
                        break
                
                if not search_cell_found:
                    logger.warning(f"Cell {cell_coord} formula does not reference search cell {expected_search_cell}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 5: LOOKUP function references the correct range (A$2:A$9)
                # Allow variations: A$2:A$9, $A$2:$A$9, A2:A9, $A2:$A9, A$2:$A$9, $A$2:A$9
                # Extract column and row info from lookup_range (e.g., "A$2:A$9" -> "A", "2", "9")
                lookup_parts = re.match(r'([A-Z]+)\$?(\d+):([A-Z]+)\$?(\d+)', lookup_range, re.IGNORECASE)
                if lookup_parts:
                    lookup_col = lookup_parts.group(1)
                    lookup_start_row = lookup_parts.group(2)
                    lookup_end_row = lookup_parts.group(4)
                    # Match any combination of $ placement
                    lookup_range_patterns = [
                        rf'\$?{re.escape(lookup_col)}\$?{lookup_start_row}\s*:\s*\$?{re.escape(lookup_col)}\$?{lookup_end_row}',
                    ]
                else:
                    # Fallback to exact match
                    lookup_range_patterns = [
                        rf'\b{re.escape(lookup_range)}\b',
                    ]
                
                lookup_range_found = False
                for pattern in lookup_range_patterns:
                    if re.search(pattern, formula_text, re.IGNORECASE):
                        lookup_range_found = True
                        break
                
                if not lookup_range_found:
                    logger.warning(f"Cell {cell_coord} formula does not reference LOOKUP range {lookup_range}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 6: Formula contains TRIM function for both search and match
                trim_pattern = r'\bTRIM\s*\('
                trim_matches = len(re.findall(trim_pattern, formula_upper))
                if trim_matches < 2:
                    logger.warning(f"Cell {cell_coord} formula should contain at least 2 TRIM functions")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 7: Match condition references the correct columns (B$2:B$9 and G3, G4, etc.)
                # Check for B$2:B$9 or similar patterns
                # Allow various combinations: B$2:B$9, $B$2:$B$9, B2:B9, $B2:$B9, B$2:$B$9, $B$2:B$9
                match_range_patterns = [
                    rf'\$?{re.escape(match_col)}\$?\d+\s*:\s*\$?{re.escape(match_col)}\$?\d+',
                ]
                
                match_range_found = False
                for pattern in match_range_patterns:
                    if re.search(pattern, formula_text, re.IGNORECASE):
                        match_range_found = True
                        break
                
                if not match_range_found:
                    logger.warning(f"Cell {cell_coord} formula does not reference match range with column {match_col}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check for G3, G4, etc. in match condition
                escaped_match_cell = re.escape(expected_match_cell)
                escaped_match_col_ref = re.escape(match_col_ref)
                match_cell_patterns = [
                    rf'\b{escaped_match_cell}\b',  # G3
                    rf'\${escaped_match_col_ref}{row_num}\b',  # $G3
                    rf'\b{escaped_match_col_ref}\${row_num}\b',  # G$3
                    rf'\${escaped_match_col_ref}\${row_num}\b',  # $G$3
                ]
                
                match_cell_found = False
                for pattern in match_cell_patterns:
                    if re.search(pattern, formula_text, re.IGNORECASE):
                        match_cell_found = True
                        break
                
                if not match_cell_found:
                    logger.warning(f"Cell {cell_coord} formula does not reference match cell {expected_match_cell}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 8: Sum range references the correct range (C$2:C$9)
                # Allow variations: C$2:C$9, $C$2:$C$9, C2:C9, $C2:$C9, C$2:$C$9, $C$2:C$9
                # Extract column and row info from sum_range (e.g., "C$2:C$9" -> "C", "2", "9")
                sum_parts = re.match(r'([A-Z]+)\$?(\d+):([A-Z]+)\$?(\d+)', sum_range, re.IGNORECASE)
                if sum_parts:
                    sum_col = sum_parts.group(1)
                    sum_start_row = sum_parts.group(2)
                    sum_end_row = sum_parts.group(4)
                    # Match any combination of $ placement
                    sum_range_patterns = [
                        rf'\$?{re.escape(sum_col)}\$?{sum_start_row}\s*:\s*\$?{re.escape(sum_col)}\$?{sum_end_row}',
                    ]
                else:
                    # Fallback to exact match
                    sum_range_patterns = [
                        rf'\b{re.escape(sum_range)}\b',
                    ]
                
                sum_range_found = False
                for pattern in sum_range_patterns:
                    if re.search(pattern, formula_text, re.IGNORECASE):
                        sum_range_found = True
                        break
                
                if not sum_range_found:
                    logger.warning(f"Cell {cell_coord} formula does not reference sum range {sum_range}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 9: Formula structure contains multiplication operators (*) for conditions
                # Should have at least 2 multiplication operators for the conditions
                mult_count = formula_text.count('*')
                if mult_count < 2:
                    logger.warning(f"Cell {cell_coord} formula should contain multiplication operators for conditions")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 10: Formula closes parentheses correctly
                open_count = formula_text.count('(')
                close_count = formula_text.count(')')
                if open_count != close_count:
                    logger.warning(f"Cell {cell_coord} formula has mismatched parentheses")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                passed_count += 1
                logger.info(f"✓ Cell {cell_coord} formula verification passed")
                
            except Exception as e:
                logger.warning(f"Error checking cell {cell_coord}: {e}")
                all_passed = False
                continue
        
        if not all_passed or checked_count == 0:
            logger.error("=" * 60)
            logger.error(f"✗ SUMPRODUCT multi-condition sum verification failed")
            logger.error(f"  Checked: {checked_count} cells")
            logger.error(f"  Passed: {passed_count} cells")
            logger.error(f"  Range: {check_range}")
            logger.error("=" * 60)
            return 0.0
        
        if passed_count != checked_count:
            logger.error("=" * 60)
            logger.error(f"✗ Not all cells passed verification")
            logger.error(f"  Checked: {checked_count} cells")
            logger.error(f"  Passed: {passed_count} cells")
            logger.error(f"  Range: {check_range}")
            logger.error("=" * 60)
            return 0.0
        
        logger.info("=" * 60)
        logger.info(f"✓ SUMPRODUCT multi-condition sum verification passed")
        logger.info(f"  - Checked: {checked_count} cells")
        logger.info(f"  - Passed: {passed_count} cells")
        logger.info(f"  - Range: {check_range}")
        logger.info("=" * 60)
        return 1.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_sumpRODUCT_mmult_find_hours_sum(result: str, expected: str = None, **options) -> float:
    """
    Verify if SUMPRODUCT(MMULT(1-ISERR(FIND(...)))) formulas exist in specified range for summing hours when multiple names exist in cells.
    
    This function STRICTLY checks ALL cells in the specified range - no tolerance, no auto-detection.
    Every single cell in the specified range must contain the correct formula.
    
    This function checks:
    1. Whether ALL cells in the specified range (e.g., C18:C22) contain formulas
    2. Whether formulas contain SUMPRODUCT, MMULT, ISERR, FIND, and ROW functions
    3. Whether FIND function references the correct column with relative row (e.g., B18, B19, B20, etc.)
    4. Whether FIND function references the correct search range (e.g., B$2:J$11)
    5. Whether MMULT function contains 1-ISERR(FIND(...)) structure
    6. Whether MMULT function contains ROW($1:$9)^0 structure
    7. Whether SUMPRODUCT function references the correct sum range (e.g., M$1:M$10)
    8. Whether formula structure is correct: SUMPRODUCT(MMULT(1-ISERR(FIND(B18,B$2:J$11)),ROW($1:$9)^0),M$1:M$10)
    
    IMPORTANT: This function checks ALL cells in the specified ranges, regardless of whether they
    appear to be empty. If any cell in the specified range is missing a formula, verification fails.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_range: Range to check (e.g., "C18:C22") - ALL cells must have formulas
            - expected_functions: List of expected function names (default: ["SUMPRODUCT", "MMULT", "ISERR", "FIND", "ROW"])
            - find_criteria_col: Column letter for FIND criteria (default: "B")
            - find_search_range: FIND search range reference (default: "B$2:J$11")
            - row_range: ROW range reference (default: "$1:$9")
            - sum_range: Sum range reference (default: "M$1:M$10")
    
    Returns:
        float: 1.0 if ALL cells in specified range contain correct formulas, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_range = options.get('check_range', 'C18:C22')
        expected_functions = options.get('expected_functions', ['SUMPRODUCT', 'MMULT', 'ISERR', 'FIND', 'ROW'])
        find_criteria_col = options.get('find_criteria_col', 'B')
        find_search_range = options.get('find_search_range', 'B$2:J$11')
        row_range = options.get('row_range', '$1:$9')
        sum_range = options.get('sum_range', 'M$1:M$10')
        
        logger.info(f"Verifying SUMPRODUCT(MMULT(FIND)) hours sum formulas in file: {result}")
        logger.info(f"Range to check: {check_range}")
        logger.info(f"Expected functions: {expected_functions}")
        
        # Parse the range - strictly use the specified range
        try:
            range_clean = check_range.replace('$', '')
            if ':' in range_clean:
                start_cell, end_cell = range_clean.split(':')
                start_col_letter = ''.join([c for c in start_cell if c.isalpha()])
                start_row = int(''.join([c for c in start_cell if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                end_col_letter = ''.join([c for c in end_cell if c.isalpha()])
                end_row = int(''.join([c for c in end_cell if c.isdigit()]))
                end_col = column_index_from_string(end_col_letter)
            else:
                logger.error(f"Invalid range format: {check_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse range {check_range}: {e}")
            return 0.0
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Strictly check ALL cells in the specified range - no auto-detection
        logger.info(f"Checking all cells in range {check_range} (rows {start_row} to {end_row})")
        
        all_passed = True
        checked_count = 0
        passed_count = 0
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{start_col_letter}{row_num}"
            expected_find_cell = f"{find_criteria_col}{row_num}"
            
            try:
                cell = ws[cell_coord]
                checked_count += 1
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.warning(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                else:
                    if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains all expected functions
                for func in expected_functions:
                    func_pattern = rf'\b{func}\s*\('
                    if not re.search(func_pattern, formula_upper):
                        logger.warning(f"Cell {cell_coord} formula does not contain {func} function")
                        logger.warning(f"Formula: {formula_text}")
                        all_passed = False
                        break
                
                if not all_passed:
                    continue
                
                # Check 2: Formula contains SUMPRODUCT function
                sumproduct_pattern = r'\bSUMPRODUCT\s*\('
                if not re.search(sumproduct_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not contain SUMPRODUCT function")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: Formula contains MMULT function
                mmult_pattern = r'\bMMULT\s*\('
                if not re.search(mmult_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not contain MMULT function")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: Formula contains 1-ISERR(FIND(...)) structure
                iserr_find_pattern = r'1\s*-\s*ISERR\s*\(\s*FIND\s*\('
                if not re.search(iserr_find_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not contain 1-ISERR(FIND(...)) structure")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 5: FIND function references the correct cell with relative row (B18, B19, B20, etc.)
                # Allow variations: B18, $B18, B$18, $B$18
                escaped_find_cell = re.escape(expected_find_cell)
                escaped_find_col = re.escape(find_criteria_col)
                find_cell_patterns = [
                    rf'\b{escaped_find_cell}\b',  # B18
                    rf'\${escaped_find_col}{row_num}\b',  # $B18
                    rf'\b{escaped_find_col}\${row_num}\b',  # B$18
                    rf'\${escaped_find_col}\${row_num}\b',  # $B$18
                ]
                
                find_cell_found = False
                for pattern in find_cell_patterns:
                    if re.search(pattern, formula_text, re.IGNORECASE):
                        find_cell_found = True
                        break
                
                if not find_cell_found:
                    logger.warning(f"Cell {cell_coord} formula does not reference FIND criteria cell {expected_find_cell}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 6: FIND function references the correct search range (B$2:J$11)
                # Allow variations: B$2:J$11, $B$2:$J$11, B2:J11, $B2:$J11, etc.
                find_parts = re.match(r'([A-Z]+)\$?(\d+):([A-Z]+)\$?(\d+)', find_search_range, re.IGNORECASE)
                if find_parts:
                    find_start_col = find_parts.group(1)
                    find_start_row = find_parts.group(2)
                    find_end_col = find_parts.group(3)
                    find_end_row = find_parts.group(4)
                    # Match any combination of $ placement
                    find_range_patterns = [
                        rf'\$?{re.escape(find_start_col)}\$?{find_start_row}\s*:\s*\$?{re.escape(find_end_col)}\$?{find_end_row}',
                    ]
                else:
                    # Fallback to exact match
                    find_range_patterns = [
                        rf'\b{re.escape(find_search_range)}\b',
                    ]
                
                find_range_found = False
                for pattern in find_range_patterns:
                    if re.search(pattern, formula_text, re.IGNORECASE):
                        find_range_found = True
                        break
                
                if not find_range_found:
                    logger.warning(f"Cell {cell_coord} formula does not reference FIND search range {find_search_range}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 7: Formula contains ROW($1:$9)^0 structure
                # Allow variations: ROW($1:$9)^0, ROW($1:$9)^ 0, ROW($1:$9) ^0, etc.
                row_parts = re.match(r'\$?(\d+):\$?(\d+)', row_range, re.IGNORECASE)
                if row_parts:
                    row_start = row_parts.group(1)
                    row_end = row_parts.group(2)
                    row_patterns = [
                        rf'ROW\s*\(\s*\$?{row_start}\s*:\s*\$?{row_end}\s*\)\s*\^\s*0',
                    ]
                else:
                    row_patterns = [
                        rf'ROW\s*\(\s*{re.escape(row_range)}\s*\)\s*\^\s*0',
                    ]
                
                row_pattern_found = False
                for pattern in row_patterns:
                    if re.search(pattern, formula_text, re.IGNORECASE):
                        row_pattern_found = True
                        break
                
                if not row_pattern_found:
                    logger.warning(f"Cell {cell_coord} formula does not contain ROW({row_range})^0 structure")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 8: SUMPRODUCT function references the correct sum range (M$1:M$10)
                # Allow variations: M$1:M$10, $M$1:$M$10, M1:M10, $M1:$M10, etc.
                sum_parts = re.match(r'([A-Z]+)\$?(\d+):([A-Z]+)\$?(\d+)', sum_range, re.IGNORECASE)
                if sum_parts:
                    sum_start_col = sum_parts.group(1)
                    sum_start_row = sum_parts.group(2)
                    sum_end_col = sum_parts.group(3)
                    sum_end_row = sum_parts.group(4)
                    # Match any combination of $ placement
                    sum_range_patterns = [
                        rf'\$?{re.escape(sum_start_col)}\$?{sum_start_row}\s*:\s*\$?{re.escape(sum_end_col)}\$?{sum_end_row}',
                    ]
                else:
                    # Fallback to exact match
                    sum_range_patterns = [
                        rf'\b{re.escape(sum_range)}\b',
                    ]
                
                sum_range_found = False
                for pattern in sum_range_patterns:
                    if re.search(pattern, formula_text, re.IGNORECASE):
                        sum_range_found = True
                        break
                
                if not sum_range_found:
                    logger.warning(f"Cell {cell_coord} formula does not reference sum range {sum_range}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 9: Formula structure is SUMPRODUCT(MMULT(...), ...)
                sumproduct_mmult_pattern = r'SUMPRODUCT\s*\(\s*MMULT\s*\('
                if not re.search(sumproduct_mmult_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not have correct SUMPRODUCT(MMULT(...)) structure")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 10: Formula closes parentheses correctly
                open_count = formula_text.count('(')
                close_count = formula_text.count(')')
                if open_count != close_count:
                    logger.warning(f"Cell {cell_coord} formula has mismatched parentheses")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                passed_count += 1
                logger.info(f"✓ Cell {cell_coord} formula verification passed")
                
            except Exception as e:
                logger.warning(f"Error checking cell {cell_coord}: {e}")
                all_passed = False
                continue
        
        if not all_passed or checked_count == 0:
            logger.error("=" * 60)
            logger.error(f"✗ SUMPRODUCT(MMULT(FIND)) hours sum verification failed")
            logger.error(f"  Checked: {checked_count} cells")
            logger.error(f"  Passed: {passed_count} cells")
            logger.error(f"  Range: {check_range}")
            logger.error("=" * 60)
            return 0.0
        
        if passed_count != checked_count:
            logger.error("=" * 60)
            logger.error(f"✗ Not all cells passed verification")
            logger.error(f"  Checked: {checked_count} cells")
            logger.error(f"  Passed: {passed_count} cells")
            logger.error(f"  Range: {check_range}")
            logger.error("=" * 60)
            return 0.0
        
        logger.info("=" * 60)
        logger.info(f"✓ SUMPRODUCT(MMULT(FIND)) hours sum verification passed")
        logger.info(f"  - Checked: {checked_count} cells")
        logger.info(f"  - Passed: {passed_count} cells")
        logger.info(f"  - Range: {check_range}")
        logger.info("=" * 60)
        return 1.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0

def verify_sumpRODUCT_price_extract(result: str, expected: str = None, **options) -> float:
    """
    Verify if SUMPRODUCT formulas exist in specified range for extracting prices by level from price table.
    
    This function STRICTLY checks ALL cells in the specified range - no tolerance, no auto-detection.
    Every single cell in the specified range must contain the correct formula.
    
    This function checks:
    1. Whether ALL cells in the specified range (e.g., C2:C10) contain formulas
    2. Whether formulas contain SUMPRODUCT function
    3. Whether formulas contain first condition: ($F$2:$F$7=$A{row}) with absolute reference F$2:$F$7 and relative reference A column
    4. Whether formulas contain second condition: ($G$1:$J$1=$B{row}) with absolute reference G$1:$J$1 and relative reference B column
    5. Whether formulas contain sum range: $G$2:$J$7 with absolute reference
    6. Whether formula structure is correct: SUMPRODUCT(($F$2:$F$7=$A2)*($G$1:$J$1=$B2)*$G$2:$J$7)
    
    IMPORTANT: This function checks ALL cells in the specified ranges, regardless of whether they
    appear to be empty. If any cell in the specified range is missing a formula, verification fails.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_range: Range to check (e.g., "C2:C10") - ALL cells must have formulas
            - expected_functions: List of expected function names (default: ["SUMPRODUCT"])
            - condition1_range: First condition range (default: "$F$2:$F$7")
            - condition1_col: First condition column reference (default: "A")
            - condition2_range: Second condition range (default: "$G$1:$J$1")
            - condition2_col: Second condition column reference (default: "B")
            - sum_range: Sum range reference (default: "$G$2:$J$7")
    
    Returns:
        float: 1.0 if ALL cells in specified range contain correct formulas, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_range = options.get('check_range', 'C2:C10')
        expected_functions = options.get('expected_functions', ['SUMPRODUCT'])
        condition1_range = options.get('condition1_range', '$F$2:$F$7')
        condition1_col = options.get('condition1_col', 'A')
        condition2_range = options.get('condition2_range', '$G$1:$J$1')
        condition2_col = options.get('condition2_col', 'B')
        sum_range = options.get('sum_range', '$G$2:$J$7')
        
        logger.info(f"Verifying SUMPRODUCT price extract formulas in file: {result}")
        logger.info(f"Range to check: {check_range}")
        logger.info(f"Expected functions: {expected_functions}")
        
        # Parse the range - strictly use the specified range
        try:
            range_clean = check_range.replace('$', '')
            if ':' in range_clean:
                start_cell, end_cell = range_clean.split(':')
                start_col_letter = ''.join([c for c in start_cell if c.isalpha()])
                start_row = int(''.join([c for c in start_cell if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                end_col_letter = ''.join([c for c in end_cell if c.isalpha()])
                end_row = int(''.join([c for c in end_cell if c.isdigit()]))
                end_col = column_index_from_string(end_col_letter)
            else:
                logger.error(f"Invalid range format: {check_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse range {check_range}: {e}")
            return 0.0
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Strictly check ALL cells in the specified range - no auto-detection
        logger.info(f"Checking all cells in range {check_range} (rows {start_row} to {end_row})")
        
        all_passed = True
        checked_count = 0
        passed_count = 0
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{start_col_letter}{row_num}"
            expected_condition1_cell = f"{condition1_col}{row_num}"
            expected_condition2_cell = f"{condition2_col}{row_num}"
            
            try:
                cell = ws[cell_coord]
                checked_count += 1
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.warning(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                else:
                    if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains all expected functions
                for func in expected_functions:
                    func_pattern = rf'\b{func}\s*\('
                    if not re.search(func_pattern, formula_upper):
                        logger.warning(f"Cell {cell_coord} formula does not contain {func} function")
                        logger.warning(f"Formula: {formula_text}")
                        all_passed = False
                        break
                
                if not all_passed:
                    continue
                
                # Check 2: Formula contains SUMPRODUCT function
                sumproduct_pattern = r'\bSUMPRODUCT\s*\('
                if not re.search(sumproduct_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not contain SUMPRODUCT function")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: Formula contains first condition: ($F$2:$F$7=$A{row})
                # Allow flexible spacing, case, and optional $ signs
                # Pattern: ($F$2:$F$7=$A2) or (F$2:F$7=$A2) or ($F2:$F7=$A2) etc.
                condition1_range_clean = condition1_range.replace("$", "")
                condition1_patterns = [
                    rf'\(\s*\$?F\$?2\s*:\s*\$?F\$?7\s*=\s*\$?{condition1_col}{row_num}\s*\)',  # Flexible $ placement
                    rf'\(\s*{re.escape(condition1_range)}\s*=\s*\$?{condition1_col}{row_num}\s*\)',  # Exact match with $
                    rf'\(\s*{re.escape(condition1_range_clean)}\s*=\s*\$?{condition1_col}{row_num}\s*\)',  # Without $
                ]
                condition1_matched = any(re.search(pattern, formula_text, re.IGNORECASE) for pattern in condition1_patterns)
                if not condition1_matched:
                    logger.warning(f"Cell {cell_coord} formula does not contain first condition ({condition1_range}={expected_condition1_cell})")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: Formula contains second condition: ($G$1:$J$1=$B{row})
                condition2_range_clean = condition2_range.replace("$", "")
                condition2_patterns = [
                    rf'\(\s*\$?G\$?1\s*:\s*\$?J\$?1\s*=\s*\$?{condition2_col}{row_num}\s*\)',  # Flexible $ placement
                    rf'\(\s*{re.escape(condition2_range)}\s*=\s*\$?{condition2_col}{row_num}\s*\)',  # Exact match with $
                    rf'\(\s*{re.escape(condition2_range_clean)}\s*=\s*\$?{condition2_col}{row_num}\s*\)',  # Without $
                ]
                condition2_matched = any(re.search(pattern, formula_text, re.IGNORECASE) for pattern in condition2_patterns)
                if not condition2_matched:
                    logger.warning(f"Cell {cell_coord} formula does not contain second condition ({condition2_range}={expected_condition2_cell})")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 5: Formula contains sum range: $G$2:$J$7
                sum_range_clean = sum_range.replace("$", "")
                sum_range_patterns = [
                    rf'\b\$?G\$?2\s*:\s*\$?J\$?7\b',  # Flexible $ placement
                    rf'\b{re.escape(sum_range)}\b',  # Exact match with $
                    rf'\b{re.escape(sum_range_clean)}\b',  # Without $
                ]
                sum_range_matched = any(re.search(pattern, formula_text, re.IGNORECASE) for pattern in sum_range_patterns)
                if not sum_range_matched:
                    logger.warning(f"Cell {cell_coord} formula does not contain sum range {sum_range}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 6: Formula structure contains multiplication operators (*) between conditions
                # Look for pattern: condition1*condition2*sum_range
                if '*' not in formula_text:
                    logger.warning(f"Cell {cell_coord} formula does not contain multiplication operators (*)")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 7: Formula closes parentheses correctly
                open_count = formula_text.count('(')
                close_count = formula_text.count(')')
                if open_count != close_count:
                    logger.warning(f"Cell {cell_coord} formula has mismatched parentheses")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                passed_count += 1
                logger.debug(f"✓ Cell {cell_coord} has valid SUMPRODUCT price extract formula")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        # Require all specified cells to have correct formulas (no tolerance)
        if checked_count > 0:
            if all_passed and passed_count == checked_count:
                logger.info("=" * 60)
                logger.info(f"✓ SUMPRODUCT price extract verification passed")
                logger.info(f"  - Checked: {checked_count} cells")
                logger.info(f"  - Passed: {passed_count} cells")
                logger.info(f"  - Range: {check_range}")
                logger.info("=" * 60)
                return 1.0
            else:
                logger.error("=" * 60)
                logger.error(f"✗ SUMPRODUCT price extract verification failed")
                logger.error(f"  - Checked: {checked_count} cells")
                logger.error(f"  - Passed: {passed_count} cells")
                logger.error(f"  - Range: {check_range}")
                logger.error(f"  All specified cells must contain correct formulas")
                logger.error("=" * 60)
                return 0.0
        else:
            logger.error("=" * 60)
            logger.error("✗ No cells were checked")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0
    """
    Verify if store and staff pivot formulas are correctly applied to display multiple staff members per store in one row.
    
    This function checks:
    1. Whether ALL cells in C2:C34 contain COUNTIF formulas: =COUNTIF($A$2:A2,A2)
    2. Whether G2 contains UNIQUE formula: =UNIQUE(A2:A34)
    3. Whether ALL cells in H2:H31 contain INDEX+MATCH+IFERROR formulas: =IFERROR(INDEX($B$2:$B$34,MATCH($G2&1,$A$2:$A$34&$C$2:$C$34,0)),"")
    4. Whether ALL cells in I2:I31 contain INDEX+MATCH+IFERROR formulas: =IFERROR(INDEX($B$2:$B$34,MATCH($G2&2,$A$2:$A$34&$C$2:$C$34,0)),"")
    5. Whether ALL cells in J2:J31 contain INDEX+MATCH+IFERROR formulas: =IFERROR(INDEX($B$2:$B$34,MATCH($G2&3,$A$2:$A$34&$C$2:$C$34,0)),"")
    6. Whether headers in G1, H1, I1, J1 are: 门店, 店员1, 店员2, 店员3
    
    IMPORTANT: This function checks ALL cells in the specified ranges. If any cell is missing a formula, verification fails.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - countif_range: Range for COUNTIF formulas (default: "C2:C34")
            - unique_cell: Cell for UNIQUE formula (default: "G2")
            - unique_range: Range for UNIQUE function (default: "A2:A34")
            - staff_range_h: Range for first staff column (default: "H2:H31")
            - staff_range_i: Range for second staff column (default: "I2:I31")
            - staff_range_j: Range for third staff column (default: "J2:J31")
            - headers: Dict mapping column letters to expected header text (default: {"G": "门店", "H": "店员1", "I": "店员2", "J": "店员3"})
            - source_data_range: Source data range for INDEX (default: "$B$2:$B$34")
            - match_range_a: First part of MATCH range (default: "$A$2:$A$34")
            - match_range_c: Second part of MATCH range (default: "$C$2:$C$34")
    
    Returns:
        float: 1.0 if ALL cells in specified ranges contain correct formulas and headers are correct, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import column_index_from_string, get_column_letter
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        countif_range = options.get("countif_range", "C2:C34")
        unique_cell = options.get("unique_cell", "G2")
        unique_range = options.get("unique_range", "A2:A34")
        staff_range_h = options.get("staff_range_h", "H2:H31")
        staff_range_i = options.get("staff_range_i", "I2:I31")
        staff_range_j = options.get("staff_range_j", "J2:J31")
        headers = options.get("headers", {"G": "门店", "H": "店员1", "I": "店员2", "J": "店员3"})
        source_data_range = options.get("source_data_range", "$B$2:$B$34")
        match_range_a = options.get("match_range_a", "$A$2:$A$34")
        match_range_c = options.get("match_range_c", "$C$2:$C$34")
        
        logger.info(f"Verifying store and staff pivot formulas in file: {result}")
        logger.info(f"COUNTIF range: {countif_range}")
        logger.info(f"UNIQUE cell: {unique_cell}")
        logger.info(f"Staff ranges: {staff_range_h}, {staff_range_i}, {staff_range_j}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        all_passed = True
        
        # Helper function to parse range
        def parse_range(range_str):
            range_clean = range_str.replace("$", "")
            if ":" in range_clean:
                start_cell, end_cell = range_clean.split(":")
                start_col_letter = "".join([c for c in start_cell if c.isalpha()])
                start_row = int("".join([c for c in start_cell if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                end_col_letter = "".join([c for c in end_cell if c.isalpha()])
                end_row = int("".join([c for c in end_cell if c.isdigit()]))
                end_col = column_index_from_string(end_col_letter)
                return start_col, start_row, end_col, end_row
            else:
                # Single cell
                col_letter = "".join([c for c in range_clean if c.isalpha()])
                row = int("".join([c for c in range_clean if c.isdigit()]))
                col = column_index_from_string(col_letter)
                return col, row, col, row
        
        # Helper function to get formula from cell
        def get_formula(cell):
            if cell.data_type != "f":
                return None
            formula_text = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula_text = cell._value
            elif hasattr(cell, "formula"):
                formula_text = cell.formula
            elif cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                formula_text = cell.value
            return formula_text
        
        # Check 1: COUNTIF formulas in C2:C34
        logger.info("Checking COUNTIF formulas...")
        start_col, start_row, end_col, end_row = parse_range(countif_range)
        for row in range(start_row, end_row + 1):
            cell_coord = f"{get_column_letter(start_col)}{row}"
            cell = ws[cell_coord]
            formula_text = get_formula(cell)
            
            if formula_text is None:
                logger.warning(f"Cell {cell_coord} does not contain a formula")
                all_passed = False
                continue
            
            formula_upper = formula_text.upper()
            
            # Check for COUNTIF function
            if not re.search(r'\bCOUNTIF\s*\(', formula_upper):
                logger.warning(f"Cell {cell_coord} formula does not contain COUNTIF function")
                logger.warning(f"Formula: {formula_text}")
                all_passed = False
                continue
            
            # Check for pattern: COUNTIF($A$2:A2, A2)
            # Allow variations in spacing and $ placement
            countif_pattern = r'COUNTIF\s*\(\s*\$?A\$?2\s*:\s*\$?A\d+\s*,\s*\$?A\d+\s*\)'
            if not re.search(countif_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula does not match COUNTIF pattern")
                logger.warning(f"Formula: {formula_text}")
                all_passed = False
                continue
            
            logger.debug(f"✓ Cell {cell_coord} has valid COUNTIF formula")
        
        # Check 2: UNIQUE formula in G2
        logger.info("Checking UNIQUE formula...")
        unique_col, unique_row, _, _ = parse_range(unique_cell)
        unique_cell_coord = f"{get_column_letter(unique_col)}{unique_row}"
        unique_cell_obj = ws[unique_cell_coord]
        unique_formula = get_formula(unique_cell_obj)
        
        if unique_formula is None:
            logger.warning(f"Cell {unique_cell_coord} does not contain a formula")
            all_passed = False
        else:
            unique_formula_upper = unique_formula.upper()
            
            # Check for UNIQUE function
            if not re.search(r'\bUNIQUE\s*\(', unique_formula_upper):
                logger.warning(f"Cell {unique_cell_coord} formula does not contain UNIQUE function")
                logger.warning(f"Formula: {unique_formula}")
                all_passed = False
            else:
                # Check for pattern: UNIQUE(A2:A34)
                unique_range_clean = unique_range.replace("$", "")
                unique_pattern = rf'UNIQUE\s*\(\s*\$?A\$?2\s*:\s*\$?A\$?34\s*\)'
                if not re.search(unique_pattern, unique_formula_upper):
                    logger.warning(f"Cell {unique_cell_coord} formula does not match UNIQUE pattern")
                    logger.warning(f"Formula: {unique_formula}")
                    all_passed = False
                else:
                    logger.debug(f"✓ Cell {unique_cell_coord} has valid UNIQUE formula")
        
        # Check 3-5: INDEX+MATCH+IFERROR formulas in H, I, J columns
        staff_ranges = [
            (staff_range_h, 1, "H"),
            (staff_range_i, 2, "I"),
            (staff_range_j, 3, "J")
        ]
        
        for staff_range, staff_num, col_letter in staff_ranges:
            logger.info(f"Checking INDEX+MATCH+IFERROR formulas in {staff_range} (staff {staff_num})...")
            start_col, start_row, end_col, end_row = parse_range(staff_range)
            
            for row in range(start_row, end_row + 1):
                cell_coord = f"{get_column_letter(start_col)}{row}"
                cell = ws[cell_coord]
                formula_text = get_formula(cell)
                
                if formula_text is None:
                    logger.warning(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                
                # Check for IFERROR function
                if not re.search(r'\bIFERROR\s*\(', formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not contain IFERROR function")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check for INDEX function
                if not re.search(r'\bINDEX\s*\(', formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not contain INDEX function")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check for MATCH function
                if not re.search(r'\bMATCH\s*\(', formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not contain MATCH function")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check for pattern: INDEX($B$2:$B$34, MATCH($G{row}&{staff_num}, $A$2:$A$34&$C$2:$C$34, 0))
                # Check INDEX range
                source_data_range_clean = source_data_range.replace("$", "")
                index_pattern = rf'INDEX\s*\(\s*\$?B\$?2\s*:\s*\$?B\$?34\s*,'
                if not re.search(index_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not contain correct INDEX range")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check MATCH pattern: MATCH($G{row}&{staff_num}, $A$2:$A$34&$C$2:$C$34, 0)
                # Allow variations in spacing
                g_cell_pattern = rf'\$?G{row}'
                match_pattern = rf'MATCH\s*\(\s*{re.escape(g_cell_pattern)}\s*&\s*{staff_num}\s*,'
                if not re.search(match_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not contain correct MATCH lookup value pattern (G{row}&{staff_num})")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check MATCH range: $A$2:$A$34&$C$2:$C$34
                match_range_a_clean = match_range_a.replace("$", "")
                match_range_c_clean = match_range_c.replace("$", "")
                match_range_pattern = rf'{re.escape(match_range_a_clean)}\s*&\s*{re.escape(match_range_c_clean)}'
                if not re.search(match_range_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not contain correct MATCH range pattern")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check MATCH third parameter is 0
                match_third_param_pattern = r'MATCH\s*\([^,]+,\s*[^,]+,\s*0\s*\)'
                if not re.search(match_third_param_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula MATCH function does not have 0 as third parameter")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check IFERROR error value is ""
                iferror_error_pattern = r'IFERROR\s*\([^,]+,\s*""\s*\)'
                if not re.search(iferror_error_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula IFERROR function does not have \"\" as error value")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                logger.debug(f"✓ Cell {cell_coord} has valid INDEX+MATCH+IFERROR formula")
        
        # Check 6: Headers
        logger.info("Checking headers...")
        for col_letter, expected_header in headers.items():
            header_cell_coord = f"{col_letter}1"
            header_cell = ws[header_cell_coord]
            header_value = str(header_cell.value).strip() if header_cell.value else ""
            
            if header_value != expected_header:
                logger.warning(f"Cell {header_cell_coord} header is '{header_value}', expected '{expected_header}'")
                all_passed = False
            else:
                logger.debug(f"✓ Cell {header_cell_coord} has correct header: {expected_header}")
        
        if all_passed:
            logger.info("=" * 60)
            logger.info("✓ Store and staff pivot verification passed")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error("✗ Store and staff pivot verification failed")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0




def verify_name_count_summary(result: str, expected: str = None, **options) -> float:
    """
    Verify if name count summary is correctly displayed with names and their occurrence counts.
    
    This function checks:
    1. Whether there exists a range (excluding columns A, C, B, D) with 5 consecutive cells containing the 5 names: 冯文荣、王伟荣、单瓞绵、董水军、张无忌
    2. Whether each name's right adjacent cell contains the correct count: 52, 77, 51, 51, 25 respectively
    
    IMPORTANT: This function searches for the names in any columns except A, C, B, D, and verifies the counts.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - expected_names: List of expected names (default: ["冯文荣", "王伟荣", "单瓞绵", "董水军", "张无忌"])
            - expected_counts: List of expected counts corresponding to names (default: [52, 77, 51, 51, 25])
            - exclude_columns: List of column letters to exclude from search (default: ["A", "C", "B", "D"])
            - search_start_row: Starting row for search (default: 1)
            - search_end_row: Ending row for search (default: 1000)
    
    Returns:
        float: 1.0 if names and counts are found correctly, 0.0 otherwise
    """
    try:
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        expected_names = options.get("expected_names", ["冯文荣", "王伟荣", "单瓞绵", "董水军", "张无忌"])
        expected_counts = options.get("expected_counts", [52, 77, 51, 51, 25])
        exclude_columns = options.get("exclude_columns", ["A", "C", "B", "D"])
        search_start_row = options.get("search_start_row", 1)
        search_end_row = options.get("search_end_row", 1000)
        
        logger.info(f"Verifying name count summary in file: {result}")
        logger.info(f"Expected names: {expected_names}")
        logger.info(f"Expected counts: {expected_counts}")
        logger.info(f"Exclude columns: {exclude_columns}")
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=True)  # data_only=True to get values
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Convert exclude columns to column indices
        exclude_col_indices = set()
        for col_letter in exclude_columns:
            exclude_col_indices.add(column_index_from_string(col_letter))
        
        # Search for the 5 consecutive cells containing the names
        found = False
        found_location = None
        
        # Search through all columns except excluded ones
        for col_idx in range(1, ws.max_column + 1):
            if col_idx in exclude_col_indices:
                continue
            
            col_letter = get_column_letter(col_idx)
            
            # Search through rows
            for row in range(search_start_row, min(search_end_row + 1, ws.max_row + 1)):
                # Check if we can find 5 consecutive cells starting from this row
                if row + 4 > ws.max_row:
                    continue
                
                # Check if these 5 cells contain all expected names
                found_names = []
                found_counts = []
                all_match = True
                
                for i in range(5):
                    name_cell = ws[f"{col_letter}{row + i}"]
                    count_cell = ws[f"{get_column_letter(col_idx + 1)}{row + i}"]
                    
                    name_value = str(name_cell.value).strip() if name_cell.value else ""
                    count_value = count_cell.value
                    
                    # Check if this name is in expected names
                    if name_value in expected_names:
                        found_names.append(name_value)
                        # Try to convert count to int
                        try:
                            count_int = int(float(count_value)) if count_value is not None else None
                            found_counts.append(count_int)
                        except (ValueError, TypeError):
                            found_counts.append(None)
                    else:
                        all_match = False
                        break
                
                # Check if we found all 5 names
                if all_match and len(found_names) == 5:
                    # Check if all expected names are present
                    if set(found_names) == set(expected_names):
                        # Verify counts match
                        name_count_map = dict(zip(expected_names, expected_counts))
                        counts_match = True
                        for name, count in zip(found_names, found_counts):
                            if count != name_count_map.get(name):
                                counts_match = False
                                break
                        
                        if counts_match:
                            found = True
                            found_location = (col_letter, row)
                            logger.info(f"Found names and counts at {col_letter}{row}:{get_column_letter(col_idx + 1)}{row + 4}")
                            break
                
                if found:
                    break
            
            if found:
                break
        
        if found:
            logger.info("=" * 60)
            logger.info("✓ Name count summary verification passed")
            logger.info(f"  - Location: {found_location[0]}{found_location[1]}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error("✗ Name count summary verification failed")
            logger.error("  - Could not find 5 consecutive cells with expected names and counts")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_sort_choose_person_contract(result: str, expected: str = None, **options) -> float:
    """
    Verify if M10:O25 range contains correctly sorted data matching the source data after sorting.
    
    This function checks:
    1. Reads source data from F11:F25 (names), G11:G25 (contract amounts), I11:I25 (contract locations)
    2. Sorts the data: first by name (descending), then by contract amount (descending) within same name
    3. Compares M10:O25 range cell by cell with the sorted data
    4. Ensures every cell matches exactly, no deviation allowed
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - result_range: Result range to check (default: "M10:O25")
            - source_name_range: Source name range (default: "F11:F25")
            - source_amount_range: Source amount range (default: "G11:G25")
            - source_location_range: Source location range (default: "I11:I25")
    
    Returns:
        float: 1.0 if all cells match exactly, 0.0 otherwise
    """
    try:
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        result_range = options.get('result_range', 'M10:O25')
        source_name_range = options.get('source_name_range', 'F11:F25')
        source_amount_range = options.get('source_amount_range', 'G11:G25')
        source_location_range = options.get('source_location_range', 'I11:I25')
        
        logger.info(f"Verifying sorted data in file: {result}")
        logger.info(f"Result range: {result_range}")
        logger.info(f"Source ranges: {source_name_range}, {source_amount_range}, {source_location_range}")
        
        # Load workbook to get values
        try:
            wb = openpyxl.load_workbook(result, data_only=True)  # data_only=True to get values
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Helper function to parse range and get cell values
        def parse_range_get_values(range_str):
            range_clean = range_str.replace("$", "")
            if ":" in range_clean:
                start_cell, end_cell = range_clean.split(":")
                start_col_letter = "".join([c for c in start_cell if c.isalpha()])
                start_row = int("".join([c for c in start_cell if c.isdigit()]))
                end_col_letter = "".join([c for c in end_cell if c.isalpha()])
                end_row = int("".join([c for c in end_cell if c.isdigit()]))
                
                values = []
                for row in range(start_row, end_row + 1):
                    row_values = []
                    start_col_idx = column_index_from_string(start_col_letter)
                    end_col_idx = column_index_from_string(end_col_letter)
                    for col_idx in range(start_col_idx, end_col_idx + 1):
                        col_letter = get_column_letter(col_idx)
                        cell = ws[f"{col_letter}{row}"]
                        # Get cell value, convert None to empty string, numbers to float for comparison
                        cell_value = cell.value
                        if cell_value is None:
                            cell_value = ""
                        elif isinstance(cell_value, (int, float)):
                            # Keep as number for comparison
                            cell_value = float(cell_value) if isinstance(cell_value, float) else int(cell_value)
                        else:
                            cell_value = str(cell_value).strip()
                        row_values.append(cell_value)
                    values.append(row_values)
                return values
            else:
                logger.error(f"Invalid range format: {range_str}")
                return None
        
        # Read source data
        source_names = parse_range_get_values(source_name_range)
        source_amounts = parse_range_get_values(source_amount_range)
        source_locations = parse_range_get_values(source_location_range)
        
        if source_names is None or source_amounts is None or source_locations is None:
            logger.error("Failed to read source data")
            return 0.0
        
        # Combine source data into list of tuples (name, amount, location)
        source_data = []
        for i in range(len(source_names)):
            name = source_names[i][0] if source_names[i] else ""
            amount = source_amounts[i][0] if source_amounts[i] else ""
            location = source_locations[i][0] if source_locations[i] else ""
            source_data.append((name, amount, location))
        
        logger.info(f"Source data rows: {len(source_data)}")
        
        # Sort source data: first by name (descending), then by amount (descending)
        # For descending sort, we use reverse=True
        # For name comparison, handle empty strings and None
        def sort_key(item):
            name, amount, location = item
            # Convert name to string for comparison, empty string sorts last in descending
            name_str = str(name) if name is not None and name != "" else ""
            # Convert amount to float for comparison, None/empty sorts last in descending
            try:
                amount_num = float(amount) if amount is not None and amount != "" else float('-inf')
            except (ValueError, TypeError):
                amount_num = float('-inf')
            # Return tuple for multi-level sort: (name, amount)
            # For descending: we'll use reverse=True, so we want higher values first
            # In descending order, we want names in reverse alphabetical order
            return (name_str, amount_num)
        
        sorted_source_data = sorted(source_data, key=sort_key, reverse=True)
        
        logger.info(f"Sorted source data rows: {len(sorted_source_data)}")
        
        # Read result data
        result_data = parse_range_get_values(result_range)
        if result_data is None:
            logger.error("Failed to read result data")
            return 0.0
        
        logger.info(f"Result data rows: {len(result_data)}, cols: {len(result_data[0]) if result_data else 0}")
        
        # Check if dimensions match
        # Result range M10:O25 is 16 rows x 3 columns
        # Source data is 15 rows, but result includes header row (M10)
        # So we need to check: result_data[1:] (skip header) should match sorted_source_data
        
        if len(result_data) < len(sorted_source_data):
            logger.error(f"Result data has fewer rows ({len(result_data)}) than sorted source data ({len(sorted_source_data)})")
            return 0.0
        
        # Compare data cell by cell
        # If M10 is header, compare from M11:O25 (result_data[1:]) with sorted_source_data
        # If M10 is data, compare from M10:O25 (result_data) with sorted_source_data
        # We'll try both approaches, but typically M10 might be header
        
        # Try comparing from row 1 (assuming M10 is header)
        start_row_idx = 1
        if len(result_data) - start_row_idx == len(sorted_source_data):
            # M10 is likely header, compare from M11
            comparison_data = result_data[start_row_idx:]
        elif len(result_data) == len(sorted_source_data):
            # M10 is data, compare from M10
            start_row_idx = 0
            comparison_data = result_data
        else:
            logger.error(f"Row count mismatch: result has {len(result_data)} rows, sorted source has {len(sorted_source_data)} rows")
            return 0.0
        
        # Check column count
        if len(comparison_data[0]) != 3:
            logger.error(f"Result data should have 3 columns, but has {len(comparison_data[0])}")
            return 0.0
        
        # Compare cell by cell
        all_match = True
        mismatch_count = 0
        
        for i in range(len(sorted_source_data)):
            expected_name, expected_amount, expected_location = sorted_source_data[i]
            actual_row = comparison_data[i]
            actual_name = actual_row[0] if len(actual_row) > 0 else None
            actual_amount = actual_row[1] if len(actual_row) > 1 else None
            actual_location = actual_row[2] if len(actual_row) > 2 else None
            
            # Normalize values for comparison
            def normalize_value(val):
                if val is None:
                    return ""
                if isinstance(val, (int, float)):
                    return float(val)
                return str(val).strip()
            
            expected_name_norm = normalize_value(expected_name)
            expected_amount_norm = normalize_value(expected_amount)
            expected_location_norm = normalize_value(expected_location)
            
            actual_name_norm = normalize_value(actual_name)
            actual_amount_norm = normalize_value(actual_amount)
            actual_location_norm = normalize_value(actual_location)
            
            # Compare name
            if expected_name_norm != actual_name_norm:
                logger.error(f"Row {i+start_row_idx+10} (M{10+i+start_row_idx}): Name mismatch - Expected: '{expected_name_norm}', Actual: '{actual_name_norm}'")
                all_match = False
                mismatch_count += 1
                continue
            
            # Compare amount (handle numeric comparison)
            if isinstance(expected_amount_norm, (int, float)) and isinstance(actual_amount_norm, (int, float)):
                if abs(expected_amount_norm - actual_amount_norm) > 0.001:  # Allow small floating point differences
                    logger.error(f"Row {i+start_row_idx+10} (N{10+i+start_row_idx}): Amount mismatch - Expected: {expected_amount_norm}, Actual: {actual_amount_norm}")
                    all_match = False
                    mismatch_count += 1
                    continue
            elif expected_amount_norm != actual_amount_norm:
                logger.error(f"Row {i+start_row_idx+10} (N{10+i+start_row_idx}): Amount mismatch - Expected: '{expected_amount_norm}', Actual: '{actual_amount_norm}'")
                all_match = False
                mismatch_count += 1
                continue
            
            # Compare location
            if expected_location_norm != actual_location_norm:
                logger.error(f"Row {i+start_row_idx+10} (O{10+i+start_row_idx}): Location mismatch - Expected: '{expected_location_norm}', Actual: '{actual_location_norm}'")
                all_match = False
                mismatch_count += 1
                continue
        
        if all_match:
            logger.info("=" * 60)
            logger.info(f"✓ Sorted data verification passed")
            logger.info(f"  - Result range: {result_range}")
            logger.info(f"  - Compared {len(sorted_source_data)} rows")
            logger.info(f"  - All cells match exactly")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ Sorted data verification failed")
            logger.error(f"  - Result range: {result_range}")
            logger.error(f"  - Mismatches: {mismatch_count} out of {len(sorted_source_data)} rows")
            logger.error(f"  - All cells must match exactly, no deviation allowed")
            logger.error("=" * 60)
            return 0.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_right_match_left_extract(result: str, expected: str = None, **options) -> float:
    """
    Verify if RIGHT(MATCH(LEFT(...))) formulas exist in ALL cells of specified range to extract text after last asterisk.
    
    This function STRICTLY checks ALL cells in the specified range - no tolerance, no auto-detection.
    Every single cell in the specified range must contain the correct formula.
    
    This function checks:
    1. Whether ALL cells in the specified formula range (e.g., B2:B33) contain formulas
    2. Whether formulas contain RIGHT, MATCH, and LEFT functions
    3. Whether formulas reference the correct source column cell with relative row (e.g., A2, A3, etc.)
    4. Whether formulas contain ROW($1:$99) or similar array reference
    5. Whether formulas contain the pattern matching logic for asterisk "*"
    6. Whether formulas have the correct structure: =RIGHT(A2,MATCH(,0/(LEFT(RIGHT(A2,ROW($1:$99)))="*"),)-1)
    
    The formula =RIGHT(A2,MATCH(,0/(LEFT(RIGHT(A2,ROW($1:$99)))="*"),)-1) works as follows:
    - RIGHT(A2, ...) extracts characters from the right side of A2
    - MATCH(,0/(LEFT(RIGHT(A2,ROW($1:$99)))="*"),) finds the position of the last "*"
      * LEFT(RIGHT(A2,ROW($1:$99))) checks characters from right to left (ROW($1:$99) generates array 1 to 99)
      * 0/(LEFT(RIGHT(A2,ROW($1:$99)))="*") converts matching "*" to 0, non-matching to error
      * MATCH finds the first 0 position, which is the last "*" position
    - -1 adjusts the position to get the number of characters after "*"
    
    IMPORTANT: This function checks ALL cells in the specified formula range. If any cell is missing a formula, verification fails.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formula_range: Range containing formulas (e.g., "B2:B33") - ALL cells must have formulas
            - source_column: Source column for formula (default: "A")
            - expected_functions: List of expected function names (default: ["RIGHT", "MATCH", "LEFT"])
            - expected_pattern: Expected pattern character (default: "*")
            - row_array_pattern: Expected ROW array pattern (default: "ROW($1:$99)")
    
    Returns:
        float: 1.0 if ALL cells in specified range contain correct formulas, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formula_range = options.get('formula_range', 'B2:B33')
        source_column = options.get('source_column', 'A')
        expected_functions = options.get('expected_functions', ['RIGHT', 'MATCH', 'LEFT'])
        expected_pattern = options.get('expected_pattern', '*')
        row_array_pattern = options.get('row_array_pattern', 'ROW($1:$99)')
        
        logger.info(f"Verifying RIGHT(MATCH(LEFT)) extract formulas in file: {result}")
        logger.info(f"Formula range: {formula_range}")
        logger.info(f"Source column: {source_column}")
        logger.info(f"Expected functions: {expected_functions}")
        logger.info(f"Expected pattern: {expected_pattern}")
        
        # Parse the formula range
        try:
            range_clean = formula_range.replace("$", "")
            if ":" in range_clean:
                start_cell, end_cell = range_clean.split(":")
                start_col_letter = "".join([c for c in start_cell if c.isalpha()])
                start_row = int("".join([c for c in start_cell if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                end_col_letter = "".join([c for c in end_cell if c.isalpha()])
                end_row = int("".join([c for c in end_cell if c.isdigit()]))
                end_col = column_index_from_string(end_col_letter)
            else:
                logger.error(f"Invalid range format: {formula_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse range {formula_range}: {e}")
            return 0.0
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check ALL cells in formula range
        logger.info(f"Checking all cells in range {formula_range} (rows {start_row} to {end_row})")
        
        all_passed = True
        checked_count = 0
        passed_count = 0
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{start_col_letter}{row_num}"
            expected_source_cell = f"{source_column}{row_num}"
            
            try:
                cell = ws[cell_coord]
                checked_count += 1
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.error(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                elif cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula_text = cell.value
                
                if formula_text is None:
                    logger.error(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains all expected functions
                for func_name in expected_functions:
                    func_pattern = rf'\b{re.escape(func_name.upper())}\s*\('
                    if not re.search(func_pattern, formula_upper):
                        logger.error(f"Cell {cell_coord} formula does not contain {func_name} function")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        break
                
                if not all_passed:
                    continue
                
                # Check 2: Formula contains RIGHT function
                right_pattern = r'\bRIGHT\s*\('
                if not re.search(right_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain RIGHT function")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: Formula contains MATCH function
                match_pattern = r'\bMATCH\s*\('
                if not re.search(match_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain MATCH function")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: Formula contains LEFT function
                left_pattern = r'\bLEFT\s*\('
                if not re.search(left_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain LEFT function")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 5: Formula references the correct source column with correct row
                # Allow both relative (A2) and absolute ($A2) references, but prefer relative
                source_cell_patterns = [
                    rf'\b{re.escape(source_column.upper())}\s*{row_num}\b',  # A2 (relative)
                    rf'\$\s*{re.escape(source_column.upper())}\s*{row_num}\b',  # $A2 (mixed)
                ]
                source_cell_found = False
                for pattern in source_cell_patterns:
                    if re.search(pattern, formula_upper):
                        source_cell_found = True
                        break
                
                if not source_cell_found:
                    logger.error(f"Cell {cell_coord} formula does not reference {expected_source_cell}")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 6: Formula contains ROW array pattern (e.g., ROW($1:$99))
                row_array_pattern_upper = row_array_pattern.upper()
                # Escape special characters but allow flexibility in spacing
                row_array_escaped = re.escape(row_array_pattern_upper).replace(r'\$', r'\$?').replace(r'\ ', r'\s*')
                if not re.search(row_array_escaped, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain ROW array pattern {row_array_pattern}")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 7: Formula contains pattern matching logic (0/(...)=...)
                # This checks for the structure: 0/(LEFT(RIGHT(...))="*")
                pattern_match_logic = r'0\s*/\s*\(\s*LEFT\s*\('
                if not re.search(pattern_match_logic, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain pattern matching logic (0/(LEFT(...)))")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 8: Formula contains the expected pattern character (e.g., "*")
                # Escape the pattern character for regex
                pattern_escaped = re.escape(expected_pattern)
                pattern_check = rf'=\s*["\']?\s*{pattern_escaped}\s*["\']?'
                if not re.search(pattern_check, formula_text):
                    logger.error(f"Cell {cell_coord} formula does not contain pattern matching for '{expected_pattern}'")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 9: Formula structure should be RIGHT(source, MATCH(,0/(LEFT(RIGHT(...))="*"),)-1)
                # Check that MATCH is inside RIGHT
                right_match_pattern = r'RIGHT\s*\([^,)]+,\s*MATCH\s*\('
                if not re.search(right_match_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not have correct RIGHT(MATCH(...)) structure")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 10: Formula should contain -1 at the end (adjustment for position)
                minus_one_pattern = r'-\s*1\s*\)'
                if not re.search(minus_one_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain -1 adjustment")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 11: Formula closes parentheses correctly
                open_count = formula_text.count('(')
                close_count = formula_text.count(')')
                if open_count != close_count:
                    logger.error(f"Cell {cell_coord} formula has mismatched parentheses")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                passed_count += 1
                logger.info(f"✓ Cell {cell_coord} has valid formula: {formula_text}")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                all_passed = False
        
        if not all_passed:
            logger.error(f"✗ Formula verification failed: {passed_count}/{checked_count} cells passed")
            return 0.0
        
        if checked_count == 0:
            logger.error(f"No cells found in range {formula_range}")
            return 0.0
        
        logger.info("=" * 60)
        logger.info(f"✓ All {checked_count} cells in range {formula_range} contain correct RIGHT(MATCH(LEFT)) formulas")
        logger.info(f"  - All cells passed verification")
        logger.info(f"  - Formula structure: RIGHT(source, MATCH(,0/(LEFT(RIGHT(...))=\"*\"),)-1)")
        logger.info("=" * 60)
        return 1.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_if_mod_date_calculate(result: str, expected: str = None, **options) -> float:
    """
    Verify if IF(MOD(...), DATE(...), DATE(...)) formulas exist in ALL cells of specified range to calculate dates.
    
    This function STRICTLY checks ALL cells in the specified range - no tolerance, no auto-detection.
    Every single cell in the specified range must contain the correct formula.
    
    This function checks:
    1. Whether ALL cells in the specified formula range (e.g., D2:D43) contain formulas
    2. Whether formulas contain IF, MOD, DATE, YEAR, INT, RIGHT, LEN, FIND, and MONTH functions
    3. Whether formulas reference the correct source column cells with relative row (e.g., A2, B2, etc.)
    4. Whether formulas have the correct structure: IF(MOD(B2,1), DATE(YEAR(A2),INT(B2),RIGHT(B2,LEN(B2)-FIND(".",B2))), DATE(YEAR(A2),MONTH(A2),B2))
    
    The formula =IF(MOD(B2,1),DATE(YEAR(A2),INT(B2),RIGHT(B2,LEN(B2)-FIND(".",B2))),DATE(YEAR(A2),MONTH(A2),B2)) works as follows:
    - IF(MOD(B2,1), ...) checks if B2 has a decimal part
      * MOD(B2,1) returns the remainder of B2 divided by 1, non-zero if decimal exists (truthy), 0 if integer (falsy)
    - If B2 has decimal part (MOD(B2,1) is truthy):
      * DATE(YEAR(A2),INT(B2),RIGHT(B2,LEN(B2)-FIND(".",B2)))
      * YEAR(A2) gets the year from A2
      * INT(B2) gets the integer part of B2 as month
      * RIGHT(B2,LEN(B2)-FIND(".",B2)) extracts the decimal part as day
    - If B2 is integer (MOD(B2,1) is falsy):
      * DATE(YEAR(A2),MONTH(A2),B2)
      * YEAR(A2) gets the year from A2
      * MONTH(A2) gets the month from A2
      * B2 is used as day
    
    IMPORTANT: This function checks ALL cells in the specified formula range. If any cell is missing a formula, verification fails.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formula_range: Range containing formulas (e.g., "D2:D43") - ALL cells must have formulas
            - source_column_a: Source column A for formula (default: "A")
            - source_column_b: Source column B for formula (default: "B")
            - expected_functions: List of expected function names (default: ["IF", "MOD", "DATE", "YEAR", "INT", "RIGHT", "LEN", "FIND", "MONTH"])
    
    Returns:
        float: 1.0 if ALL cells in specified range contain correct formulas, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formula_range = options.get('formula_range', 'D2:D43')
        source_column_a = options.get('source_column_a', 'A')
        source_column_b = options.get('source_column_b', 'B')
        expected_functions = options.get('expected_functions', ['IF', 'MOD', 'DATE', 'YEAR', 'INT', 'RIGHT', 'LEN', 'FIND', 'MONTH'])
        
        logger.info(f"Verifying IF(MOD(DATE)) calculation formulas in file: {result}")
        logger.info(f"Formula range: {formula_range}")
        logger.info(f"Source column A: {source_column_a}")
        logger.info(f"Source column B: {source_column_b}")
        logger.info(f"Expected functions: {expected_functions}")
        
        # Parse the formula range
        try:
            range_clean = formula_range.replace("$", "")
            if ":" in range_clean:
                start_cell, end_cell = range_clean.split(":")
                start_col_letter = "".join([c for c in start_cell if c.isalpha()])
                start_row = int("".join([c for c in start_cell if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                end_col_letter = "".join([c for c in end_cell if c.isalpha()])
                end_row = int("".join([c for c in end_cell if c.isdigit()]))
                end_col = column_index_from_string(end_col_letter)
            else:
                logger.error(f"Invalid range format: {formula_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse range {formula_range}: {e}")
            return 0.0
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check ALL cells in formula range
        logger.info(f"Checking all cells in range {formula_range} (rows {start_row} to {end_row})")
        
        all_passed = True
        checked_count = 0
        passed_count = 0
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{start_col_letter}{row_num}"
            expected_source_cell_a = f"{source_column_a}{row_num}"
            expected_source_cell_b = f"{source_column_b}{row_num}"
            
            try:
                cell = ws[cell_coord]
                checked_count += 1
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.error(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                elif cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula_text = cell.value
                
                if formula_text is None:
                    logger.error(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains all expected functions
                for func_name in expected_functions:
                    func_pattern = rf'\b{re.escape(func_name.upper())}\s*\('
                    if not re.search(func_pattern, formula_upper):
                        logger.error(f"Cell {cell_coord} formula does not contain {func_name} function")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        break
                
                if not all_passed:
                    continue
                
                # Check 2: Formula contains IF function
                if_pattern = r'\bIF\s*\('
                if not re.search(if_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain IF function")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: Formula contains MOD function
                mod_pattern = r'\bMOD\s*\('
                if not re.search(mod_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain MOD function")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: Formula contains DATE function (should appear twice)
                date_pattern = r'\bDATE\s*\('
                date_matches = re.findall(date_pattern, formula_upper)
                if len(date_matches) < 2:
                    logger.error(f"Cell {cell_coord} formula does not contain two DATE functions (found {len(date_matches)})")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 5: Formula contains YEAR function (should appear twice)
                year_pattern = r'\bYEAR\s*\('
                year_matches = re.findall(year_pattern, formula_upper)
                if len(year_matches) < 2:
                    logger.error(f"Cell {cell_coord} formula does not contain two YEAR functions (found {len(year_matches)})")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 6: Formula contains INT function
                int_pattern = r'\bINT\s*\('
                if not re.search(int_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain INT function")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 7: Formula contains RIGHT function
                right_pattern = r'\bRIGHT\s*\('
                if not re.search(right_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain RIGHT function")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 8: Formula contains LEN function
                len_pattern = r'\bLEN\s*\('
                if not re.search(len_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain LEN function")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 9: Formula contains FIND function
                find_pattern = r'\bFIND\s*\('
                if not re.search(find_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain FIND function")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 10: Formula contains MONTH function
                month_pattern = r'\bMONTH\s*\('
                if not re.search(month_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain MONTH function")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 11: Formula references the correct source column A with correct row
                source_cell_a_patterns = [
                    rf'\b{re.escape(source_column_a.upper())}\s*{row_num}\b',  # A2 (relative)
                    rf'\$\s*{re.escape(source_column_a.upper())}\s*{row_num}\b',  # $A2 (mixed)
                ]
                source_cell_a_found = False
                for pattern in source_cell_a_patterns:
                    if re.search(pattern, formula_upper):
                        source_cell_a_found = True
                        break
                
                if not source_cell_a_found:
                    logger.error(f"Cell {cell_coord} formula does not reference {expected_source_cell_a}")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 12: Formula references the correct source column B with correct row
                source_cell_b_patterns = [
                    rf'\b{re.escape(source_column_b.upper())}\s*{row_num}\b',  # B2 (relative)
                    rf'\$\s*{re.escape(source_column_b.upper())}\s*{row_num}\b',  # $B2 (mixed)
                ]
                source_cell_b_found = False
                for pattern in source_cell_b_patterns:
                    if re.search(pattern, formula_upper):
                        source_cell_b_found = True
                        break
                
                if not source_cell_b_found:
                    logger.error(f"Cell {cell_coord} formula does not reference {expected_source_cell_b}")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 13: Formula structure should be IF(MOD(B2,1), DATE(...), DATE(...))
                # Check that MOD is inside IF
                if_mod_pattern = r'IF\s*\(\s*MOD\s*\('
                if not re.search(if_mod_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not have correct IF(MOD(...)) structure")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 14: Formula contains RIGHT(LEN(FIND pattern for decimal extraction
                right_len_find_pattern = r'RIGHT\s*\([^,)]+,\s*LEN\s*\([^,)]+\)\s*-\s*FIND\s*\('
                if not re.search(right_len_find_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not have correct RIGHT(LEN(...)-FIND(...)) structure")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 15: Formula contains FIND with dot pattern (for decimal point)
                find_dot_pattern = r'FIND\s*\(\s*["\']?\s*\.\s*["\']?\s*,'
                if not re.search(find_dot_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain FIND with dot pattern for decimal point")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 16: Formula closes parentheses correctly
                open_count = formula_text.count('(')
                close_count = formula_text.count(')')
                if open_count != close_count:
                    logger.error(f"Cell {cell_coord} formula has mismatched parentheses")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                passed_count += 1
                logger.info(f"✓ Cell {cell_coord} has valid formula: {formula_text}")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                all_passed = False
        
        if not all_passed:
            logger.error(f"✗ Formula verification failed: {passed_count}/{checked_count} cells passed")
            return 0.0
        
        if checked_count == 0:
            logger.error(f"No cells found in range {formula_range}")
            return 0.0
        
        logger.info("=" * 60)
        logger.info(f"✓ All {checked_count} cells in range {formula_range} contain correct IF(MOD(DATE)) formulas")
        logger.info(f"  - All cells passed verification")
        logger.info(f"  - Formula structure: IF(MOD(B2,1), DATE(YEAR(A2),INT(B2),RIGHT(B2,LEN(B2)-FIND(\".\",B2))), DATE(YEAR(A2),MONTH(A2),B2))")
        logger.info("=" * 60)
        return 1.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_financial_month_convert(result: str, expected: str = None, **options) -> float:
    """
    Verify if financial month conversion formulas exist in ALL cells of specified range.
    
    This function STRICTLY checks ALL cells in the specified range - no tolerance, no auto-detection.
    Every single cell in the specified range must contain the correct formula.
    
    This function checks:
    1. Whether ALL cells in the specified formula range (e.g., B1:B58) contain formulas
    2. Whether formulas contain YEAR, DAY, MONTH, and IF functions
    3. Whether formulas reference the correct source column cells with relative row (e.g., A1, A2, etc.)
    4. Whether formulas have the correct structure: (YEAR(A1)+(DAY(A1)>25))&"/"&IF(((DAY(A1)>25)+MONTH(A1))>12,--(DAY(A1)>25),((DAY(A1)>25)+MONTH(A1)))
    5. Whether formulas contain string concatenation operator &
    6. Whether formulas contain logical expression (DAY(...)>25)
    
    The formula =(YEAR(A1)+(DAY(A1)>25))&"/"&IF(((DAY(A1)>25)+MONTH(A1))>12,--(DAY(A1)>25),((DAY(A1)>25)+MONTH(A1))) works as follows:
    - YEAR(A1)+(DAY(A1)>25) calculates the financial year
      * YEAR(A1) gets the year from A1
      * DAY(A1)>25 returns TRUE(1) if day > 25, FALSE(0) otherwise
      * If day > 25, year is incremented by 1 (cross-year case)
    - (DAY(A1)>25)+MONTH(A1) calculates the financial month
      * DAY(A1)>25 returns 1 if day > 25, 0 otherwise
      * MONTH(A1) gets the month from A1
      * If day > 25, month is incremented by 1
    - IF(((DAY(A1)>25)+MONTH(A1))>12,--(DAY(A1)>25),((DAY(A1)>25)+MONTH(A1))) handles cross-year case
      * If month > 12, returns 1 (January)
      * --(DAY(A1)>25) converts logical value to numeric (1 if day > 25, 0 otherwise)
      * Otherwise returns the calculated month
    - &"/"& concatenates year and month into "year/month" format
    
    IMPORTANT: This function checks ALL cells in the specified formula range. If any cell is missing a formula, verification fails.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formula_range: Range containing formulas (e.g., "B1:B58") - ALL cells must have formulas
            - source_column: Source column for formula (default: "A")
            - expected_functions: List of expected function names (default: ["YEAR", "DAY", "MONTH", "IF"])
    
    Returns:
        float: 1.0 if ALL cells in specified range contain correct formulas, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formula_range = options.get('formula_range', 'B1:B58')
        source_column = options.get('source_column', 'A')
        expected_functions = options.get('expected_functions', ['YEAR', 'DAY', 'MONTH', 'IF'])
        
        logger.info(f"Verifying financial month conversion formulas in file: {result}")
        logger.info(f"Formula range: {formula_range}")
        logger.info(f"Source column: {source_column}")
        logger.info(f"Expected functions: {expected_functions}")
        
        # Parse the formula range
        try:
            range_clean = formula_range.replace("$", "")
            if ":" in range_clean:
                start_cell, end_cell = range_clean.split(":")
                start_col_letter = "".join([c for c in start_cell if c.isalpha()])
                start_row = int("".join([c for c in start_cell if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                end_col_letter = "".join([c for c in end_cell if c.isalpha()])
                end_row = int("".join([c for c in end_cell if c.isdigit()]))
                end_col = column_index_from_string(end_col_letter)
            else:
                logger.error(f"Invalid range format: {formula_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse range {formula_range}: {e}")
            return 0.0
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check ALL cells in formula range
        logger.info(f"Checking all cells in range {formula_range} (rows {start_row} to {end_row})")
        
        all_passed = True
        checked_count = 0
        passed_count = 0
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{start_col_letter}{row_num}"
            expected_source_cell = f"{source_column}{row_num}"
            
            try:
                cell = ws[cell_coord]
                checked_count += 1
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.error(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                elif cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula_text = cell.value
                
                if formula_text is None:
                    logger.error(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains all expected functions
                for func_name in expected_functions:
                    func_pattern = rf'\b{re.escape(func_name.upper())}\s*\('
                    if not re.search(func_pattern, formula_upper):
                        logger.error(f"Cell {cell_coord} formula does not contain {func_name} function")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        break
                
                if not all_passed:
                    continue
                
                # Check 2: Formula contains YEAR function
                year_pattern = r'\bYEAR\s*\('
                if not re.search(year_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain YEAR function")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: Formula contains DAY function
                day_pattern = r'\bDAY\s*\('
                if not re.search(day_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain DAY function")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: Formula contains MONTH function
                month_pattern = r'\bMONTH\s*\('
                if not re.search(month_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain MONTH function")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 5: Formula contains IF function
                if_pattern = r'\bIF\s*\('
                if not re.search(if_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain IF function")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 6: Formula contains string concatenation operator &
                if '&' not in formula_text:
                    logger.error(f"Cell {cell_coord} formula does not contain string concatenation operator &")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 7: Formula contains logical expression DAY(...)>25
                day_gt_25_pattern = r'DAY\s*\([^)]+\)\s*>\s*25'
                if not re.search(day_gt_25_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain logical expression DAY(...)>25")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 8: Formula references the correct source column cell with relative row
                # Allow for variations: A1, $A1, A$1, $A$1
                escaped_source_cell = re.escape(expected_source_cell)
                escaped_source_col = re.escape(source_column)
                source_cell_patterns = [
                    rf'\b{escaped_source_cell}\b',  # A1
                    rf'\${escaped_source_col}{row_num}\b',  # $A1
                    rf'\b{escaped_source_col}\${row_num}\b',  # A$1
                    rf'\${escaped_source_col}\${row_num}\b',  # $A$1
                ]
                
                source_cell_found = False
                for pattern in source_cell_patterns:
                    if re.search(pattern, formula_text, re.IGNORECASE):
                        source_cell_found = True
                        break
                
                if not source_cell_found:
                    logger.error(f"Cell {cell_coord} formula does not reference source cell {expected_source_cell}")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 9: Formula contains YEAR(...)+(DAY(...)>25) pattern
                year_plus_day_pattern = r'YEAR\s*\([^)]+\)\s*\+\s*\(\s*DAY\s*\([^)]+\)\s*>\s*25\s*\)'
                if not re.search(year_plus_day_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not have correct YEAR(...)+(DAY(...)>25) structure")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 10: Formula contains (DAY(...)>25)+MONTH(...) pattern
                day_plus_month_pattern = r'\(\s*DAY\s*\([^)]+\)\s*>\s*25\s*\)\s*\+\s*MONTH\s*\('
                if not re.search(day_plus_month_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not have correct (DAY(...)>25)+MONTH(...) structure")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 11: Formula contains IF with month > 12 condition
                if_month_gt_12_pattern = r'IF\s*\(\s*\(\s*\(\s*DAY\s*\([^)]+\)\s*>\s*25\s*\)\s*\+\s*MONTH\s*\([^)]+\)\s*\)\s*>\s*12'
                if not re.search(if_month_gt_12_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not have correct IF(((DAY(...)>25)+MONTH(...))>12,...) structure")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 12: Formula contains string "/" for concatenation
                if '"/"' not in formula_text and "'/" not in formula_text and '"/' not in formula_text:
                    logger.error(f"Cell {cell_coord} formula does not contain string \"/\" for concatenation")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 13: Formula closes parentheses correctly
                open_count = formula_text.count('(')
                close_count = formula_text.count(')')
                if open_count != close_count:
                    logger.error(f"Cell {cell_coord} formula has mismatched parentheses")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                passed_count += 1
                logger.info(f"✓ Cell {cell_coord} has valid formula: {formula_text}")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                all_passed = False
        
        if not all_passed:
            logger.error(f"✗ Formula verification failed: {passed_count}/{checked_count} cells passed")
            return 0.0
        
        if checked_count == 0:
            logger.error(f"No cells found in range {formula_range}")
            return 0.0
        
        logger.info("=" * 60)
        logger.info(f"✓ All {checked_count} cells in range {formula_range} contain correct financial month conversion formulas")
        logger.info(f"  - All cells passed verification")
        logger.info(f"  - Formula structure: (YEAR(A1)+(DAY(A1)>25))&\"/\"&IF(((DAY(A1)>25)+MONTH(A1))>12,--(DAY(A1)>25),((DAY(A1)>25)+MONTH(A1)))")
        logger.info("=" * 60)
        return 1.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_sortby_letter_number_sort(result: str, expected: str = None, **options) -> float:
    """
    Verify if SORTBY formula exists in specified cell to sort data by letter first, then by number.
    
    This function STRICTLY checks ALL cells in the specified range - no tolerance, no auto-detection.
    Every single cell in the specified range must contain the correct formula or correct result.
    
    This function checks:
    1. Whether the formula cell (e.g., B2) contains a SORTBY formula
    2. Whether the formula contains SORTBY, RIGHT, LEFT, and LEN functions
    3. Whether the formula references the correct source range (e.g., A2:A78)
    4. Whether the formula has the correct structure: =SORTBY(A2:A78,RIGHT(A2:A78),,--LEFT(A2:A78,LEN(A2:A78)-1),)
    5. Whether all cells in the result range (B2:B78) contain formulas or correct sorted results
    
    The formula =SORTBY(A2:A78,RIGHT(A2:A78),,--LEFT(A2:A78,LEN(A2:A78)-1),) works as follows:
    - SORTBY sorts the array A2:A78 based on sort keys
    - First sort key: RIGHT(A2:A78) extracts the last character (letter) from each cell
    - Second sort key: --LEFT(A2:A78,LEN(A2:A78)-1) extracts all characters except the last (number part)
      * LEN(A2:A78)-1 calculates the number of characters to extract (total length minus 1)
      * LEFT extracts the number part
      * -- (double negative) converts text to number for proper numeric sorting
    - Sorting order: first by letter (abcd...), then by number (ascending) within same letter
    
    IMPORTANT: This function checks ALL cells in the specified formula range. If any cell is missing a formula or has incorrect result, verification fails.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formula_cell: Cell containing the formula (e.g., "B2")
            - formula_range: Range containing formulas/results (e.g., "B2:B78") - ALL cells must have formulas or correct results
            - source_range: Source range for SORTBY function (e.g., "A2:A78")
            - expected_functions: List of expected function names (default: ["SORTBY", "RIGHT", "LEFT", "LEN"])
    
    Returns:
        float: 1.0 if ALL cells in specified range contain correct formulas or results, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formula_cell = options.get('formula_cell', 'B2')
        formula_range = options.get('formula_range', 'B2:B78')
        source_range = options.get('source_range', 'A2:A78')
        expected_functions = options.get('expected_functions', ['SORTBY', 'RIGHT', 'LEFT', 'LEN'])
        
        logger.info(f"Verifying SORTBY letter-number sort in file: {result}")
        logger.info(f"Formula cell: {formula_cell}")
        logger.info(f"Formula range: {formula_range}")
        logger.info(f"Source range: {source_range}")
        
        # Parse the formula range
        try:
            range_clean = formula_range.replace("$", "")
            if ":" in range_clean:
                start_cell, end_cell = range_clean.split(":")
                start_col_letter = "".join([c for c in start_cell if c.isalpha()])
                start_row = int("".join([c for c in start_cell if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                end_col_letter = "".join([c for c in end_cell if c.isalpha()])
                end_row = int("".join([c for c in end_cell if c.isdigit()]))
                end_col = column_index_from_string(end_col_letter)
            else:
                logger.error(f"Invalid range format: {formula_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse range {formula_range}: {e}")
            return 0.0
        
        # Parse source range
        try:
            source_range_clean = source_range.replace("$", "")
            if ":" in source_range_clean:
                source_start, source_end = source_range_clean.split(":")
                source_start_col = "".join([c for c in source_start if c.isalpha()])
                source_start_row = int("".join([c for c in source_start if c.isdigit()]))
                source_end_col = "".join([c for c in source_end if c.isalpha()])
                source_end_row = int("".join([c for c in source_end if c.isdigit()]))
            else:
                logger.error(f"Invalid source range format: {source_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse source range {source_range}: {e}")
            return 0.0
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=False)
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check 1: Verify the formula cell contains SORTBY formula
        logger.info(f"Checking formula cell {formula_cell}")
        
        try:
            formula_cell_obj = ws[formula_cell]
            
            # Check if cell contains a formula (including array formulas)
            # Array formulas may have data_type "f" or may be stored differently
            is_formula = False
            if formula_cell_obj.data_type == "f":
                is_formula = True
            # Also check if it's an array formula by checking array_formulas attribute
            elif hasattr(ws, "array_formulas"):
                for array_range, array_formula in ws.array_formulas.items():
                    if formula_cell in array_range:
                        is_formula = True
                        break
            
            if not is_formula:
                logger.error(f"Cell {formula_cell} does not contain a formula")
                return 0.0
            
            # Get formula text - try multiple methods for array formulas
            formula_text = None
            
            # Method 1: Check if value is ArrayFormula object (most direct for array formulas)
            if formula_cell_obj.value is not None:
                # Check if it's an ArrayFormula object
                from openpyxl.worksheet.formula import ArrayFormula
                if isinstance(formula_cell_obj.value, ArrayFormula):
                    # ArrayFormula object has a 'text' attribute that contains the formula
                    if hasattr(formula_cell_obj.value, "text"):
                        formula_text = formula_cell_obj.value.text
                    elif hasattr(formula_cell_obj.value, "formula"):
                        formula_text = formula_cell_obj.value.formula
                    elif hasattr(formula_cell_obj.value, "__str__"):
                        # Try string representation
                        formula_str = str(formula_cell_obj.value)
                        if "SORTBY" in formula_str.upper() or formula_str.startswith("="):
                            formula_text = formula_str
            
            # Method 2: Check _value attribute (might also be ArrayFormula)
            if formula_text is None and hasattr(formula_cell_obj, "_value"):
                from openpyxl.worksheet.formula import ArrayFormula
                if isinstance(formula_cell_obj._value, ArrayFormula):
                    if hasattr(formula_cell_obj._value, "text"):
                        formula_text = formula_cell_obj._value.text
                    elif hasattr(formula_cell_obj._value, "formula"):
                        formula_text = formula_cell_obj._value.formula
                    elif hasattr(formula_cell_obj._value, "__str__"):
                        formula_str = str(formula_cell_obj._value)
                        if "SORTBY" in formula_str.upper() or formula_str.startswith("="):
                            formula_text = formula_str
                elif isinstance(formula_cell_obj._value, str):
                    if formula_cell_obj._value.startswith("="):
                        formula_text = formula_cell_obj._value
                    elif "SORTBY" in formula_cell_obj._value.upper():
                        formula_text = "=" + formula_cell_obj._value if not formula_cell_obj._value.startswith("=") else formula_cell_obj._value
            
            # Method 3: Check array_formulas attribute (for array formulas)
            if formula_text is None and hasattr(ws, "array_formulas"):
                try:
                    # array_formulas is a dict where keys are ranges and values are formula strings
                    for array_range_str, array_formula in ws.array_formulas.items():
                        # Check if formula_cell is within the array range
                        cell_in_range = False
                        if ":" in array_range_str:
                            start_cell_str, end_cell_str = array_range_str.split(":")
                            # Parse range to check if formula_cell is in it
                            try:
                                # Get column and row from formula_cell
                                cell_col_letter = "".join([c for c in formula_cell if c.isalpha()])
                                cell_row = int("".join([c for c in formula_cell if c.isdigit()]))
                                cell_col = column_index_from_string(cell_col_letter)
                                
                                # Get column and row from start and end cells
                                start_col_letter = "".join([c for c in start_cell_str if c.isalpha()])
                                start_row = int("".join([c for c in start_cell_str if c.isdigit()]))
                                start_col = column_index_from_string(start_col_letter)
                                
                                end_col_letter = "".join([c for c in end_cell_str if c.isalpha()])
                                end_row = int("".join([c for c in end_cell_str if c.isdigit()]))
                                end_col = column_index_from_string(end_col_letter)
                                
                                # Check if cell is within range
                                if start_col <= cell_col <= end_col and start_row <= cell_row <= end_row:
                                    cell_in_range = True
                            except Exception as e:
                                # Fallback: simple string check
                                if formula_cell in array_range_str or array_range_str.startswith(formula_cell):
                                    cell_in_range = True
                        elif formula_cell == array_range_str:
                            # Exact match
                            cell_in_range = True
                        
                        if cell_in_range:
                            # Extract formula text
                            if isinstance(array_formula, str):
                                formula_text = array_formula
                            elif isinstance(array_formula, tuple) and len(array_formula) > 0:
                                formula_text = array_formula[0]
                            elif hasattr(array_formula, "text"):
                                formula_text = array_formula.text
                            break
                except Exception as e:
                    logger.debug(f"Error checking array_formulas: {e}")
            
            # Method 4: Check formula attribute
            if formula_text is None and hasattr(formula_cell_obj, "formula"):
                formula_text = formula_cell_obj.formula
            
            # Method 5: Check value attribute (for regular formulas)
            if formula_text is None and formula_cell_obj.value is not None:
                if isinstance(formula_cell_obj.value, str):
                    if formula_cell_obj.value.startswith("="):
                        formula_text = formula_cell_obj.value
                    elif "SORTBY" in formula_cell_obj.value.upper():
                        formula_text = "=" + formula_cell_obj.value if not formula_cell_obj.value.startswith("=") else formula_cell_obj.value
            
            # Method 5: Check array_value attribute (if exists)
            if formula_text is None and hasattr(formula_cell_obj, "array_value"):
                if isinstance(formula_cell_obj.array_value, str):
                    if formula_cell_obj.array_value.startswith("="):
                        formula_text = formula_cell_obj.array_value
                    elif "SORTBY" in formula_cell_obj.array_value.upper():
                        formula_text = "=" + formula_cell_obj.array_value if not formula_cell_obj.array_value.startswith("=") else formula_cell_obj.array_value
            
            # Method 6: Try to get from internal formula representation
            if formula_text is None:
                # Try accessing internal attributes
                if hasattr(formula_cell_obj, "formula") and formula_cell_obj.formula:
                    formula_text = formula_cell_obj.formula
                elif hasattr(formula_cell_obj, "_value") and isinstance(formula_cell_obj._value, str):
                    # Even if it doesn't start with "=", it might be a formula
                    if "SORTBY" in formula_cell_obj._value.upper() or "RIGHT" in formula_cell_obj._value.upper():
                        formula_text = "=" + formula_cell_obj._value if not formula_cell_obj._value.startswith("=") else formula_cell_obj._value
            
            if formula_text is None:
                logger.error(f"Could not extract formula from cell {formula_cell}")
                logger.error(f"Cell data_type: {formula_cell_obj.data_type}")
                logger.error(f"Cell value: {formula_cell_obj.value}")
                logger.error(f"Cell value type: {type(formula_cell_obj.value)}")
                if hasattr(formula_cell_obj.value, "__dict__"):
                    logger.error(f"Cell value attributes: {dir(formula_cell_obj.value)}")
                logger.error(f"Cell has _value: {hasattr(formula_cell_obj, '_value')}")
                if hasattr(formula_cell_obj, "_value"):
                    logger.error(f"Cell _value: {formula_cell_obj._value}")
                    logger.error(f"Cell _value type: {type(formula_cell_obj._value)}")
                    if hasattr(formula_cell_obj._value, "__dict__"):
                        logger.error(f"Cell _value attributes: {dir(formula_cell_obj._value)}")
                if hasattr(ws, "array_formulas"):
                    logger.error(f"Array formulas in sheet: {list(ws.array_formulas.keys())}")
                return 0.0
            
            # Ensure formula starts with "="
            if not formula_text.startswith("="):
                formula_text = "=" + formula_text
            
            formula_upper = formula_text.upper()
            logger.debug(f"Cell {formula_cell} formula: {formula_text}")
            
            # Check 1: Formula contains SORTBY function
            sortby_pattern = r'\bSORTBY\s*\('
            if not re.search(sortby_pattern, formula_upper):
                logger.error(f"Cell {formula_cell} formula does not contain SORTBY function")
                logger.error(f"Formula: {formula_text}")
                return 0.0
            
            # Check 2: Formula contains all expected functions
            for func_name in expected_functions:
                func_pattern = rf'\b{re.escape(func_name.upper())}\s*\('
                if not re.search(func_pattern, formula_upper):
                    logger.error(f"Cell {formula_cell} formula does not contain {func_name} function")
                    logger.error(f"Formula: {formula_text}")
                    return 0.0
            
            # Check 3: Formula contains RIGHT function
            right_pattern = r'\bRIGHT\s*\('
            if not re.search(right_pattern, formula_upper):
                logger.error(f"Cell {formula_cell} formula does not contain RIGHT function")
                logger.error(f"Formula: {formula_text}")
                return 0.0
            
            # Check 4: Formula contains LEFT function
            left_pattern = r'\bLEFT\s*\('
            if not re.search(left_pattern, formula_upper):
                logger.error(f"Cell {formula_cell} formula does not contain LEFT function")
                logger.error(f"Formula: {formula_text}")
                return 0.0
            
            # Check 5: Formula contains LEN function
            len_pattern = r'\bLEN\s*\('
            if not re.search(len_pattern, formula_upper):
                logger.error(f"Cell {formula_cell} formula does not contain LEN function")
                logger.error(f"Formula: {formula_text}")
                return 0.0
            
            # Check 6: Formula references the correct source range
            # Allow flexible matching for range references (with or without $)
            source_range_patterns = [
                re.escape(source_range),
                re.escape(source_range.replace("$", "")),
                re.escape(source_range.replace("A", "A").replace("$", "")),
            ]
            source_range_found = False
            for pattern in source_range_patterns:
                if re.search(pattern, formula_text, re.IGNORECASE):
                    source_range_found = True
                    break
            
            # Also check for partial match (e.g., A2:A78 without $)
            source_partial_pattern = rf'{re.escape(source_start_col)}\s*\d+\s*:\s*{re.escape(source_end_col)}\s*\d+'
            if not source_range_found and not re.search(source_partial_pattern, formula_text, re.IGNORECASE):
                logger.error(f"Cell {formula_cell} formula does not reference source range {source_range}")
                logger.error(f"Formula: {formula_text}")
                return 0.0
            
            # Check 7: Formula structure contains RIGHT and LEFT with LEN
            # Check for RIGHT(...) pattern
            right_match = re.search(r'RIGHT\s*\([^)]+\)', formula_upper)
            if not right_match:
                logger.error(f"Cell {formula_cell} formula does not have valid RIGHT function call")
                logger.error(f"Formula: {formula_text}")
                return 0.0
            
            # Check for LEFT(...LEN(...)-1) pattern
            left_len_pattern = r'LEFT\s*\([^,]+,\s*LEN\s*\([^)]+\)\s*-\s*1\s*\)'
            if not re.search(left_len_pattern, formula_upper):
                logger.error(f"Cell {formula_cell} formula does not have correct LEFT(LEN(...)-1) structure")
                logger.error(f"Formula: {formula_text}")
                return 0.0
            
            # Check 8: Formula contains double negative (--) for number conversion
            double_negative_pattern = r'--\s*LEFT'
            if not re.search(double_negative_pattern, formula_upper):
                logger.error(f"Cell {formula_cell} formula does not contain -- (double negative) for number conversion")
                logger.error(f"Formula: {formula_text}")
                return 0.0
            
            logger.info(f"✓ Cell {formula_cell} has valid SORTBY formula: {formula_text}")
            
        except Exception as e:
            logger.error(f"Error checking formula cell {formula_cell}: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return 0.0
        
        # Check 2: Verify ALL cells in formula range contain formulas or correct results
        logger.info(f"Checking all cells in range {formula_range} (rows {start_row} to {end_row})")
        
        all_passed = True
        checked_count = 0
        passed_count = 0
        
        # For SORTBY array formula, we need to check if all cells have formulas or if they have correct sorted results
        # Since SORTBY is an array formula, it might be entered only in B2, but results should appear in all cells
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{start_col_letter}{row_num}"
            
            try:
                cell = ws[cell_coord]
                checked_count += 1
                
                # For SORTBY array formulas, cells might contain:
                # 1. The formula itself (in B2)
                # 2. Array formula results (in other cells)
                # 3. Or the formula might be copied to all cells
                
                # Check if cell contains a formula
                if cell.data_type == "f":
                    # Cell has a formula - verify it's correct
                    cell_formula = None
                    
                    # Method 1: Check if value is ArrayFormula object (for array formulas)
                    if cell.value is not None:
                        from openpyxl.worksheet.formula import ArrayFormula
                        if isinstance(cell.value, ArrayFormula):
                            if hasattr(cell.value, "text"):
                                cell_formula = cell.value.text
                            elif hasattr(cell.value, "formula"):
                                cell_formula = cell.value.formula
                            elif hasattr(cell.value, "__str__"):
                                formula_str = str(cell.value)
                                if "SORTBY" in formula_str.upper() or formula_str.startswith("="):
                                    cell_formula = formula_str
                    
                    # Method 2: Check _value attribute (might also be ArrayFormula)
                    if cell_formula is None and hasattr(cell, "_value"):
                        from openpyxl.worksheet.formula import ArrayFormula
                        if isinstance(cell._value, ArrayFormula):
                            if hasattr(cell._value, "text"):
                                cell_formula = cell._value.text
                            elif hasattr(cell._value, "formula"):
                                cell_formula = cell._value.formula
                            elif hasattr(cell._value, "__str__"):
                                formula_str = str(cell._value)
                                if "SORTBY" in formula_str.upper() or formula_str.startswith("="):
                                    cell_formula = formula_str
                        elif isinstance(cell._value, str) and cell._value.startswith("="):
                            cell_formula = cell._value
                    
                    # Method 3: Check formula attribute
                    if cell_formula is None and hasattr(cell, "formula"):
                        cell_formula = cell.formula
                    
                    # Method 4: Check value attribute (for regular formulas)
                    if cell_formula is None and cell.value is not None:
                        if isinstance(cell.value, str) and cell.value.startswith("="):
                            cell_formula = cell.value
                    
                    # Ensure formula starts with "="
                    if cell_formula and not cell_formula.startswith("="):
                        cell_formula = "=" + cell_formula
                    
                    if cell_formula:
                        cell_formula_upper = cell_formula.upper()
                        # Check if it contains SORTBY (might be the same formula or array formula result)
                        if not re.search(r'\bSORTBY\s*\(', cell_formula_upper):
                            # If it's not the main formula cell and doesn't have SORTBY, it might be an array formula result
                            # In LibreOffice, array formulas might show as individual formulas in each cell
                            # We'll accept this as long as the main formula cell is correct
                            if cell_coord == formula_cell:
                                logger.error(f"Cell {cell_coord} should contain SORTBY formula but doesn't")
                                logger.error(f"Extracted formula: {cell_formula}")
                                all_passed = False
                                continue
                        passed_count += 1
                        logger.debug(f"✓ Cell {cell_coord} has formula: {cell_formula[:50]}...")
                    else:
                        # Cell marked as formula but we can't extract it
                        if cell_coord == formula_cell:
                            logger.error(f"Could not extract formula from cell {cell_coord}")
                            logger.error(f"Cell data_type: {cell.data_type}")
                            logger.error(f"Cell value type: {type(cell.value)}")
                            all_passed = False
                            continue
                        # For other cells, might be array formula results
                        passed_count += 1
                else:
                    # Cell doesn't have a formula - might be array formula result
                    # For SORTBY array formulas, results are calculated values
                    # We'll accept non-formula cells as long as they have values (array formula results)
                    if cell.value is not None:
                        passed_count += 1
                        logger.debug(f"✓ Cell {cell_coord} has value (array formula result): {cell.value}")
                    else:
                        logger.error(f"Cell {cell_coord} has no formula and no value")
                        all_passed = False
                        continue
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                all_passed = False
        
        if not all_passed:
            logger.error(f"✗ Formula verification failed: {passed_count}/{checked_count} cells passed")
            return 0.0
        
        if checked_count == 0:
            logger.error(f"No cells found in range {formula_range}")
            return 0.0
        
        logger.info("=" * 60)
        logger.info(f"✓ All {checked_count} cells in range {formula_range} contain correct SORTBY formulas or results")
        logger.info(f"  - Formula cell {formula_cell} contains correct SORTBY formula")
        logger.info(f"  - Formula structure: SORTBY(A2:A78,RIGHT(A2:A78),,--LEFT(A2:A78,LEN(A2:A78)-1),)")
        logger.info(f"  - All cells passed verification")
        logger.info("=" * 60)
        return 1.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_irr_profit_calculation(result: str, expected: str = None, **options) -> float:
    """
    Verify if IRR and profit calculation formulas exist in specified ranges for calculating financial product IRR.
    
    This function STRICTLY checks ALL cells in the specified ranges - no tolerance, no auto-detection.
    Every single cell in the specified ranges must contain the correct formula.
    
    This function checks:
    1. Whether ALL cells in the profit range (e.g., G2:G20) contain formulas =E2-D2, =E3-D3, etc.
    2. Whether the IRR cell (e.g., F2) contains formula =IRR(G2:G20)
    3. Whether profit formulas reference the correct E and D column cells with relative row
    4. Whether IRR formula references the correct profit range (G2:G20)
    5. Whether formulas use relative references correctly (each row references its own data)
    
    IMPORTANT: This function checks ALL cells in the specified ranges, regardless of whether they
    appear to be empty. If any cell in the specified range is missing a formula, verification fails.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - profit_range: Range containing profit formulas (e.g., "G2:G20") - ALL cells must have formulas
            - irr_cell: Cell containing IRR formula (e.g., "F2") - must have formula
            - source_col_e: Source column E for profit calculation (default: "E")
            - source_col_d: Source column D for profit calculation (default: "D")
    
    Returns:
        float: 1.0 if ALL cells in specified ranges contain correct formulas, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        profit_range = options.get('profit_range', 'G2:G20')
        irr_cell = options.get('irr_cell', 'F2')
        source_col_e = options.get('source_col_e', 'E')
        source_col_d = options.get('source_col_d', 'D')
        
        logger.info(f"Verifying IRR and profit calculation formulas in file: {result}")
        logger.info(f"Profit range: {profit_range}, IRR cell: {irr_cell}")
        
        # Parse profit range - strictly use the specified range
        try:
            profit_range_clean = profit_range.replace('$', '')
            if ':' in profit_range_clean:
                profit_start_cell, profit_end_cell = profit_range_clean.split(':')
                profit_start_col_letter = ''.join([c for c in profit_start_cell if c.isalpha()])
                profit_start_row = int(''.join([c for c in profit_start_cell if c.isdigit()]))
                profit_start_col = column_index_from_string(profit_start_col_letter)
                profit_end_col_letter = ''.join([c for c in profit_end_cell if c.isalpha()])
                profit_end_row = int(''.join([c for c in profit_end_cell if c.isdigit()]))
                profit_end_col = column_index_from_string(profit_end_col_letter)
            else:
                logger.error(f"Invalid profit range format: {profit_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse profit range {profit_range}: {e}")
            return 0.0
        
        # Verify that profit range is a single column
        if profit_start_col != profit_end_col:
            logger.error(f"Profit range must be a single column, got: {profit_range}")
            return 0.0
        
        # Parse IRR cell
        try:
            irr_cell_clean = irr_cell.replace('$', '')
            irr_col_letter = ''.join([c for c in irr_cell_clean if c.isalpha()])
            irr_row = int(''.join([c for c in irr_cell_clean if c.isdigit()]))
            irr_col = column_index_from_string(irr_col_letter)
        except Exception as e:
            logger.error(f"Failed to parse IRR cell {irr_cell}: {e}")
            return 0.0
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Strictly check ALL cells in the specified ranges - no auto-detection
        logger.info(f"Checking all cells in profit range {profit_range} (rows {profit_start_row} to {profit_end_row})")
        logger.info(f"Checking IRR cell {irr_cell}")
        
        # Check profit formulas - check ALL rows in the specified range
        all_passed = True
        checked_count = 0
        passed_count = 0
        
        for row_num in range(profit_start_row, profit_end_row + 1):
            profit_cell_coord = f"{profit_start_col_letter}{row_num}"
            
            try:
                profit_cell = ws[profit_cell_coord]
                checked_count += 1
                
                # Check if cell contains a formula
                if profit_cell.data_type != "f":
                    logger.warning(f"Cell {profit_cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(profit_cell, "_value") and isinstance(profit_cell._value, str) and profit_cell._value.startswith("="):
                    formula_text = profit_cell._value
                elif hasattr(profit_cell, "formula"):
                    formula_text = profit_cell.formula
                else:
                    if profit_cell.value is not None and isinstance(profit_cell.value, str) and profit_cell.value.startswith("="):
                        formula_text = profit_cell.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {profit_cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {profit_cell_coord} formula: {formula_text}")
                
                # Check 1: Formula structure should be =E{row_num}-D{row_num} or similar
                # Expected pattern: =E{row_num}-D{row_num} (with possible $ for absolute references)
                expected_e_cell = f"{source_col_e}{row_num}"
                expected_d_cell = f"{source_col_d}{row_num}"
                
                # Pattern to match E{row}-D{row} (allowing for $ absolute references)
                e_pattern = rf'{re.escape(source_col_e)}\$?{row_num}'
                d_pattern = rf'{re.escape(source_col_d)}\$?{row_num}'
                
                # Check if formula contains both E and D column references for this row
                e_match = re.search(e_pattern, formula_text, re.IGNORECASE)
                d_match = re.search(d_pattern, formula_text, re.IGNORECASE)
                
                if not e_match or not d_match:
                    logger.warning(f"Cell {profit_cell_coord} formula does not reference correct cells {expected_e_cell} and {expected_d_cell}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 2: Formula should be subtraction (E - D)
                # Pattern: =E{row}-D{row} or =E{row} - D{row} (with spaces)
                subtraction_pattern = rf'{re.escape(source_col_e)}\$?{row_num}\s*-\s*{re.escape(source_col_d)}\$?{row_num}'
                if not re.search(subtraction_pattern, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {profit_cell_coord} formula does not have correct subtraction structure (E-D)")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: Formula should start with =
                if not formula_text.strip().startswith('='):
                    logger.warning(f"Cell {profit_cell_coord} formula does not start with =")
                    all_passed = False
                    continue
                
                # Check 4: Formula closes parentheses correctly (if any)
                open_count = formula_text.count('(')
                close_count = formula_text.count(')')
                if open_count != close_count:
                    logger.warning(f"Cell {profit_cell_coord} formula has mismatched parentheses")
                    all_passed = False
                    continue
                
                passed_count += 1
                logger.debug(f"✓ Cell {profit_cell_coord} has valid profit formula")
                
            except Exception as e:
                logger.error(f"Error checking profit cell {profit_cell_coord}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        # Check IRR formula in F2
        try:
            irr_cell_obj = ws[irr_cell]
            checked_count += 1
            
            # Check if cell contains a formula
            if irr_cell_obj.data_type != "f":
                logger.warning(f"Cell {irr_cell} does not contain a formula")
                all_passed = False
            else:
                # Get formula text
                formula_text = None
                if hasattr(irr_cell_obj, "_value") and isinstance(irr_cell_obj._value, str) and irr_cell_obj._value.startswith("="):
                    formula_text = irr_cell_obj._value
                elif hasattr(irr_cell_obj, "formula"):
                    formula_text = irr_cell_obj.formula
                else:
                    if irr_cell_obj.value is not None and isinstance(irr_cell_obj.value, str) and irr_cell_obj.value.startswith("="):
                        formula_text = irr_cell_obj.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {irr_cell}")
                    all_passed = False
                else:
                    formula_upper = formula_text.upper()
                    logger.debug(f"Cell {irr_cell} formula: {formula_text}")
                    
                    # Check 1: Formula contains IRR function
                    irr_pattern = r'\bIRR\s*\('
                    if not re.search(irr_pattern, formula_upper):
                        logger.warning(f"Cell {irr_cell} formula does not contain IRR function")
                        logger.warning(f"Formula: {formula_text}")
                        all_passed = False
                    else:
                        # Check 2: Formula references the correct profit range (G2:G20)
                        expected_range = f"{profit_start_col_letter}{profit_start_row}:{profit_end_col_letter}{profit_end_row}"
                        # Pattern to match G2:G20 (allowing for $ absolute references)
                        range_pattern = rf'{re.escape(profit_start_col_letter)}\$?{profit_start_row}\s*:\s*{re.escape(profit_end_col_letter)}\$?{profit_end_row}'
                        
                        if not re.search(range_pattern, formula_text, re.IGNORECASE):
                            logger.warning(f"Cell {irr_cell} formula does not reference correct range {expected_range}")
                            logger.warning(f"Formula: {formula_text}")
                            all_passed = False
                        else:
                            # Check 3: Formula structure is =IRR(G2:G20)
                            irr_range_pattern = rf'IRR\s*\(\s*{re.escape(profit_start_col_letter)}\$?{profit_start_row}\s*:\s*{re.escape(profit_end_col_letter)}\$?{profit_end_row}\s*\)'
                            if not re.search(irr_range_pattern, formula_upper):
                                logger.warning(f"Cell {irr_cell} formula does not have correct IRR(range) structure")
                                logger.warning(f"Formula: {formula_text}")
                                all_passed = False
                            else:
                                # Check 4: Formula closes parentheses correctly
                                open_count = formula_text.count('(')
                                close_count = formula_text.count(')')
                                if open_count != close_count:
                                    logger.warning(f"Cell {irr_cell} formula has mismatched parentheses")
                                    all_passed = False
                                else:
                                    passed_count += 1
                                    logger.debug(f"✓ Cell {irr_cell} has valid IRR formula")
        except Exception as e:
            logger.error(f"Error checking IRR cell {irr_cell}: {e}")
            import traceback
            logger.error(traceback.format_exc())
            all_passed = False
        
        if not all_passed:
            logger.error(f"✗ Formula verification failed: {passed_count}/{checked_count} cells passed")
            return 0.0
        
        if checked_count == 0:
            logger.error(f"No cells found in specified ranges")
            return 0.0
        
        logger.info("=" * 60)
        logger.info(f"✓ All {checked_count} cells contain correct formulas")
        logger.info(f"  - Profit range {profit_range}: {profit_end_row - profit_start_row + 1} cells with =E-D formulas")
        logger.info(f"  - IRR cell {irr_cell}: =IRR({profit_range}) formula")
        logger.info(f"  - All cells passed verification")
        logger.info("=" * 60)
        return 1.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_remove_empty_rows(result: str, expected: str = None, **options) -> float:
    """
    Verify if all empty rows have been removed from the Excel file.
    
    This function checks:
    1. Whether every row in the worksheet contains at least one non-empty cell
    2. A row is considered empty if all cells in that row are None, empty strings, or only whitespace
    3. The verification scans all rows from row 1 to max_row
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - start_row: Starting row to check (default: 1)
            - end_row: Ending row to check (default: None, checks all rows)
            - ignore_header: Whether to ignore the first row (default: False)
    
    Returns:
        float: 1.0 if all rows contain content (no empty rows), 0.0 otherwise
    """
    try:
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        start_row = options.get('start_row', 1)
        end_row = options.get('end_row', None)
        ignore_header = options.get('ignore_header', False)
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=False)
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Determine the range to check
        max_row = ws.max_row
        if end_row is None:
            end_row = max_row
        
        logger.info(f"Checking rows {start_row} to {end_row} for empty rows...")
        logger.info(f"Total rows in worksheet: {max_row}")
        
        # Adjust start_row if ignoring header
        check_start_row = start_row + 1 if ignore_header else start_row
        
        # Check each row
        empty_rows_found = []
        for row_num in range(check_start_row, end_row + 1):
            row = ws[row_num]
            
            # Check if row is empty
            is_empty = True
            for cell in row:
                cell_value = cell.value
                # Check if cell has content
                if cell_value is not None:
                    # Check if it's not an empty string or only whitespace
                    if isinstance(cell_value, str):
                        if cell_value.strip() != "":
                            is_empty = False
                            break
                    else:
                        # Non-string value (number, date, etc.) is considered content
                        is_empty = False
                        break
            
            if is_empty:
                empty_rows_found.append(row_num)
                logger.warning(f"Empty row found at row {row_num}")
        
        # Verification result
        if len(empty_rows_found) > 0:
            logger.error(f"Found {len(empty_rows_found)} empty row(s): {empty_rows_found}")
            logger.error("Verification failed: Empty rows still exist in the worksheet")
            return 0.0
        
        logger.info("=" * 60)
        logger.info(f"✓ All rows contain content (checked rows {check_start_row} to {end_row})")
        logger.info(f"✓ No empty rows found")
        logger.info("=" * 60)
        return 1.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_and_not_conditional_formatting(result: str, expected: str = None, **options) -> float:
    """
    Verify if conditional formatting with AND and NOT formulas exists in specified range with fill colors.
    
    This function checks:
    1. Whether the specified range (e.g., E13:J47) has conditional formatting
    2. Whether there are two conditional formatting rules:
       - Condition 1: AND($B13 + $D13 <= E13, E13 <= $B13 + $C13) with green fill color
       - Condition 2: NOT(AND($B13 + $D13 <= E13, E13 <= $B13 + $C13)) with red fill color
    3. Whether both conditions apply to the specified range
    4. Whether the fill colors match the expected colors (green and red)
    5. Whether each cell in the range has the correct conditional formatting
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_range: Range to check (e.g., "E13:J47")
            - condition1_formula_pattern: Expected formula pattern for condition 1 (default: 'AND($B13 + $D13 <= E13, E13 <= $B13 + $C13)')
            - condition1_fill_color: Expected fill color for condition 1 (default: "green")
            - condition2_formula_pattern: Expected formula pattern for condition 2 (default: 'NOT(AND($B13 + $D13 <= E13, E13 <= $B13 + $C13))')
            - condition2_fill_color: Expected fill color for condition 2 (default: "red")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        from openpyxl.worksheet.cell_range import CellRange
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_range = options.get('check_range', 'E13:J47')
        condition1_formula_pattern = options.get('condition1_formula_pattern', 'AND($B13 + $D13 <= E13, E13 <= $B13 + $C13)')
        condition1_fill_color = options.get('condition1_fill_color', 'green')
        condition2_formula_pattern = options.get('condition2_formula_pattern', 'NOT(AND($B13 + $D13 <= E13, E13 <= $B13 + $C13))')
        condition2_fill_color = options.get('condition2_fill_color', 'red')
        
        logger.info(f"Verifying conditional formatting in file: {result}")
        logger.info(f"Range to check: {check_range}")
        logger.info(f"Condition 1: {condition1_formula_pattern} -> {condition1_fill_color}")
        logger.info(f"Condition 2: {condition2_formula_pattern} -> {condition2_fill_color}")
        
        # Parse the range
        try:
            range_clean = check_range.replace('$', '')
            if ':' in range_clean:
                start_cell, end_cell = range_clean.split(':')
                # Parse start cell
                start_col_letter = ''.join([c for c in start_cell if c.isalpha()])
                start_row = int(''.join([c for c in start_cell if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                # Parse end cell
                end_col_letter = ''.join([c for c in end_cell if c.isalpha()])
                end_row = int(''.join([c for c in end_cell if c.isdigit()]))
                end_col = column_index_from_string(end_col_letter)
            else:
                logger.error(f"Invalid range format: {check_range}. Expected format like 'E13:J47'")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse range {check_range}: {e}")
            return 0.0
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=False)
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check conditional formatting
        conditional_formattings = ws.conditional_formatting
        
        if not conditional_formattings:
            logger.error("No conditional formatting found in worksheet")
            return 0.0
        
        # Debug: Print all conditional formatting rules
        logger.info("=" * 60)
        logger.info("DEBUG: All conditional formatting rules found:")
        for idx, fmt in enumerate(conditional_formattings):
            logger.info(f"  CF Rule {idx + 1}:")
            for rge in fmt.cells:
                logger.info(f"    Range: {rge}")
            for rule_idx, r in enumerate(fmt.rules):
                logger.info(f"    Rule {rule_idx + 1}:")
                if r.formula:
                    formula_text = r.formula[0] if isinstance(r.formula, list) else str(r.formula)
                    logger.info(f"      Formula: {formula_text}")
                else:
                    logger.info(f"      Formula: None")
                if r.dxf:
                    if r.dxf.fill:
                        try:
                            if r.dxf.fill.bgColor:
                                logger.info(f"      Fill bgColor: {r.dxf.fill.bgColor.rgb}")
                            if r.dxf.fill.fgColor:
                                logger.info(f"      Fill fgColor: {r.dxf.fill.fgColor.rgb}")
                        except Exception as e:
                            logger.info(f"      Fill color error: {e}")
                    if r.dxf.font:
                        try:
                            if r.dxf.font.color:
                                logger.info(f"      Font color: {r.dxf.font.color.rgb}")
                        except Exception as e:
                            logger.info(f"      Font color error: {e}")
        logger.info("=" * 60)
        
        found_condition1 = False
        found_condition2 = False
        condition1_range_cells = None
        condition2_range_cells = None
        
        # Helper function to check if fill color matches
        def check_fill_color(fill_color_obj, expected_color_name):
            """Check if fill color matches expected color name"""
            if fill_color_obj is None:
                logger.debug(f"Fill color object is None")
                return False
            
            color_rgb = None
            if hasattr(fill_color_obj, 'rgb'):
                color_rgb = fill_color_obj.rgb
            elif hasattr(fill_color_obj, 'bgColor') and fill_color_obj.bgColor:
                color_rgb = fill_color_obj.bgColor.rgb
            elif hasattr(fill_color_obj, 'fgColor') and fill_color_obj.fgColor:
                color_rgb = fill_color_obj.fgColor.rgb
            
            if color_rgb is None:
                logger.debug(f"Fill color RGB is None")
                return False
            
            color_str = str(color_rgb).upper()
            logger.debug(f"Checking color: {color_str} against {expected_color_name}")
            
            # Convert color name to RGB values
            if expected_color_name.lower() == 'green':
                # Check for known green color values (LibreOffice may use different shades)
                known_greens = ['FF00A933', '00A933', '00FF00', 'FF00FF00', '008000', 'FF008000', '90EE90', 'FF90EE90']
                if color_str in known_greens or color_str.endswith('00A933') or color_str.endswith('00FF00') or color_str.endswith('008000'):
                    logger.debug(f"Green check: Known green color value {color_str}")
                    return True
                
                # Green: low red, high green, low blue (relaxed criteria for LibreOffice)
                if len(color_str) >= 6:
                    if len(color_str) == 8:
                        r_val = int(color_str[2:4], 16)
                        g_val = int(color_str[4:6], 16)
                        b_val = int(color_str[6:8], 16)
                    elif len(color_str) == 6:
                        r_val = int(color_str[0:2], 16)
                        g_val = int(color_str[2:4], 16)
                        b_val = int(color_str[4:6], 16)
                    else:
                        logger.debug(f"Unexpected color string length: {len(color_str)}")
                        return False
                    # Green: R < 150, G > 100, B < 150 (relaxed for LibreOffice)
                    is_green = r_val < 150 and g_val > 100 and b_val < 150 and g_val > r_val and g_val > b_val
                    logger.debug(f"Green check: RGB({r_val}, {g_val}, {b_val}) -> {is_green}")
                    return is_green
            elif expected_color_name.lower() == 'red':
                # Check for known red color values (LibreOffice may use different shades)
                known_reds = ['FFFF0000', 'FF0000', 'FF00', 'FFFF00', 'DC143C', 'FFDC143C', 'CD5C5C', 'FFCD5C5C']
                if color_str in known_reds or color_str.endswith('FF0000') or color_str.endswith('FF00'):
                    logger.debug(f"Red check: Known red color value {color_str}")
                    return True
                
                # Red: high red, low green, low blue (relaxed criteria for LibreOffice)
                if len(color_str) >= 6:
                    if len(color_str) == 8:
                        r_val = int(color_str[2:4], 16)
                        g_val = int(color_str[4:6], 16)
                        b_val = int(color_str[6:8], 16)
                    elif len(color_str) == 6:
                        r_val = int(color_str[0:2], 16)
                        g_val = int(color_str[2:4], 16)
                        b_val = int(color_str[4:6], 16)
                    else:
                        logger.debug(f"Unexpected color string length: {len(color_str)}")
                        return False
                    # Red: R > 150, G < 150, B < 150, R > G, R > B (relaxed for LibreOffice)
                    is_red = r_val > 150 and g_val < 150 and b_val < 150 and r_val > g_val and r_val > b_val
                    logger.debug(f"Red check: RGB({r_val}, {g_val}, {b_val}) -> {is_red}")
                    return is_red
            
            logger.debug(f"Color name {expected_color_name} not recognized")
            return False
        
        # Check each conditional formatting rule
        for fmt in conditional_formattings:
            # Check if this formatting applies to any cell in our target range
            fmt_applies_to_range = False
            for rge in fmt.cells:
                # Check if this range overlaps with our target range
                cf_start_col = rge.min_col
                cf_start_row = rge.min_row
                cf_end_col = rge.max_col
                cf_end_row = rge.max_row
                
                # Check if ranges overlap
                if not (cf_end_col < start_col or cf_start_col > end_col or 
                        cf_end_row < start_row or cf_start_row > end_row):
                    fmt_applies_to_range = True
                    break
            
            if not fmt_applies_to_range:
                continue
            
            # Check each rule in this formatting
            for r in fmt.rules:
                # Check formula
                if not r.formula:
                    continue
                
                formula_text = r.formula[0] if isinstance(r.formula, list) else str(r.formula)
                formula_upper = formula_text.upper()
                
                logger.info(f"Checking conditional formatting formula: {formula_text}")
                
                # Check if formula contains AND
                and_pattern = r'\bAND\s*\('
                if not re.search(and_pattern, formula_upper):
                    logger.debug(f"Formula does not contain AND: {formula_text}")
                    continue
                
                logger.info(f"  Formula contains AND, checking pattern...")
                
                # Check fill color and font color (LibreOffice may use font color instead of fill color)
                fill_color = None
                font_color = None
                if r.dxf:
                    if r.dxf.fill:
                        try:
                            if r.dxf.fill.bgColor:
                                fill_color = r.dxf.fill.bgColor
                            elif r.dxf.fill.fgColor:
                                fill_color = r.dxf.fill.fgColor
                        except:
                            pass
                    if r.dxf.font:
                        try:
                            if r.dxf.font.color:
                                font_color = r.dxf.font.color
                        except:
                            pass
                
                # Use font color if fill color is not available (LibreOffice Calc behavior)
                color_to_check = fill_color if fill_color is not None else font_color
                
                if color_to_check is None:
                    logger.debug(f"Conditional formatting rule has no fill or font color")
                    continue
                
                # Check condition 1: AND($B13 + $D13 <= E13, E13 <= $B13 + $C13)
                # Pattern: AND($B$?13 + $D$?13 <= E$?13, E$?13 <= $B$?13 + $C$?13)
                # Allow variations in absolute/relative references
                # Also try to match with different row references (E13, E$13, $E13, $E$13)
                condition1_patterns = [
                    r'AND\s*\(\s*\$?B\$?\d+\s*\+\s*\$?D\$?\d+\s*<=\s*E\$?\d+\s*,\s*E\$?\d+\s*<=\s*\$?B\$?\d+\s*\+\s*\$?C\$?\d+\s*\)',
                    r'AND\s*\(\s*\$B\$?\d+\s*\+\s*\$D\$?\d+\s*<=\s*\$?E\$?\d+\s*,\s*\$?E\$?\d+\s*<=\s*\$B\$?\d+\s*\+\s*\$C\$?\d+\s*\)',
                ]
                condition1_match = None
                for pattern in condition1_patterns:
                    condition1_match = re.search(pattern, formula_upper)
                    if condition1_match:
                        logger.info(f"  Condition 1 pattern matched: {pattern}")
                        break
                
                if condition1_match:
                    color_match = check_fill_color(color_to_check, condition1_fill_color)
                    color_type = "fill" if fill_color is not None else "font"
                    logger.info(f"  Condition 1: formula match={condition1_match is not None}, {color_type} color match={color_match}")
                    if color_match:
                        found_condition1 = True
                        if condition1_range_cells is None:
                            condition1_range_cells = rge
                        else:
                            # Merge ranges if multiple ranges found
                            from openpyxl.worksheet.cell_range import CellRange
                            try:
                                combined = CellRange(condition1_range_cells.coord + ":" + rge.coord)
                                condition1_range_cells = combined
                            except:
                                condition1_range_cells = rge
                        logger.info(f"✓ Found condition 1: {formula_text} -> {condition1_fill_color} ({color_type} color)")
                    else:
                        logger.warning(f"  Condition 1 formula matched but color did not match (color: {color_to_check.rgb if hasattr(color_to_check, 'rgb') else 'unknown'})")
                else:
                    logger.debug(f"  Condition 1 pattern did not match: {formula_text}")
                
                # Check condition 2: NOT(AND($B13 + $D13 <= E13, E13 <= $B13 + $C13))
                # Pattern: NOT(AND($B$?13 + $D$?13 <= E$?13, E$?13 <= $B$?13 + $C$?13))
                condition2_patterns = [
                    r'NOT\s*\(\s*AND\s*\(\s*\$?B\$?\d+\s*\+\s*\$?D\$?\d+\s*<=\s*E\$?\d+\s*,\s*E\$?\d+\s*<=\s*\$?B\$?\d+\s*\+\s*\$?C\$?\d+\s*\)\s*\)',
                    r'NOT\s*\(\s*AND\s*\(\s*\$B\$?\d+\s*\+\s*\$D\$?\d+\s*<=\s*\$?E\$?\d+\s*,\s*\$?E\$?\d+\s*<=\s*\$B\$?\d+\s*\+\s*\$C\$?\d+\s*\)\s*\)',
                ]
                condition2_match = None
                for pattern in condition2_patterns:
                    condition2_match = re.search(pattern, formula_upper)
                    if condition2_match:
                        logger.info(f"  Condition 2 pattern matched: {pattern}")
                        break
                
                if condition2_match:
                    color_match = check_fill_color(color_to_check, condition2_fill_color)
                    color_type = "fill" if fill_color is not None else "font"
                    logger.info(f"  Condition 2: formula match={condition2_match is not None}, {color_type} color match={color_match}")
                    if color_match:
                        found_condition2 = True
                        if condition2_range_cells is None:
                            condition2_range_cells = rge
                        else:
                            # Merge ranges if multiple ranges found
                            from openpyxl.worksheet.cell_range import CellRange
                            try:
                                combined = CellRange(condition2_range_cells.coord + ":" + rge.coord)
                                condition2_range_cells = combined
                            except:
                                condition2_range_cells = rge
                        logger.info(f"✓ Found condition 2: {formula_text} -> {condition2_fill_color} ({color_type} color)")
                    else:
                        logger.warning(f"  Condition 2 formula matched but color did not match (color: {color_to_check.rgb if hasattr(color_to_check, 'rgb') else 'unknown'})")
                else:
                    logger.debug(f"  Condition 2 pattern did not match: {formula_text}")
        
        # Verify both conditions are found
        if not found_condition1:
            logger.error("=" * 60)
            logger.error("✗ Condition 1 not found")
            logger.error(f"  Expected: {condition1_formula_pattern} -> {condition1_fill_color}")
            logger.error("=" * 60)
            return 0.0
        
        if not found_condition2:
            logger.error("=" * 60)
            logger.error("✗ Condition 2 not found")
            logger.error(f"  Expected: {condition2_formula_pattern} -> {condition2_fill_color}")
            logger.error("=" * 60)
            return 0.0
        
        # Verify that both conditions apply to the target range
        # Note: If CF is applied to first row only (e.g., E13:J13) with relative references,
        # LibreOffice will automatically apply it to all rows, so we check if:
        # 1. CF range covers the first row of target range, OR
        # 2. CF range fully covers the target range
        
        # Check if formulas use relative references (will auto-apply to other rows)
        uses_relative_refs = False
        for fmt in conditional_formattings:
            for r in fmt.rules:
                if r.formula:
                    formula_text = r.formula[0] if isinstance(r.formula, list) else str(r.formula)
                    # Check if formula uses relative references (E13 instead of $E$13)
                    # Pattern: E13, E$13, $E13 (but not $E$13)
                    if re.search(r'[^$]E\$?\d+', formula_text, re.IGNORECASE):
                        uses_relative_refs = True
                        break
            if uses_relative_refs:
                break
        
        if condition1_range_cells:
            cf_start_col = condition1_range_cells.min_col
            cf_start_row = condition1_range_cells.min_row
            cf_end_col = condition1_range_cells.max_col
            cf_end_row = condition1_range_cells.max_row
            
            # Check column coverage
            col_ok = cf_start_col <= start_col and cf_end_col >= end_col
            # Check row coverage: either fully covers OR covers first row with relative refs
            row_ok = (cf_start_row <= start_row and cf_end_row >= end_row) or \
                     (uses_relative_refs and cf_start_row == start_row and cf_end_row >= start_row and cf_start_col <= start_col and cf_end_col >= end_col)
            
            if not (col_ok and row_ok):
                logger.error("=" * 60)
                logger.error("✗ Condition 1 range does not cover target range")
                logger.error(f"  Target range: {check_range} (cols {start_col}-{end_col}, rows {start_row}-{end_row})")
                logger.error(f"  CF range: cols {cf_start_col}-{cf_end_col}, rows {cf_start_row}-{cf_end_row}")
                logger.error(f"  Uses relative refs: {uses_relative_refs}")
                logger.error("=" * 60)
                return 0.0
            else:
                logger.info(f"✓ Condition 1 range covers target range (CF: {cf_start_col}-{cf_end_col}, {cf_start_row}-{cf_end_row})")
        
        if condition2_range_cells:
            cf_start_col = condition2_range_cells.min_col
            cf_start_row = condition2_range_cells.min_row
            cf_end_col = condition2_range_cells.max_col
            cf_end_row = condition2_range_cells.max_row
            
            # Check column coverage
            col_ok = cf_start_col <= start_col and cf_end_col >= end_col
            # Check row coverage: either fully covers OR covers first row with relative refs
            row_ok = (cf_start_row <= start_row and cf_end_row >= end_row) or \
                     (uses_relative_refs and cf_start_row == start_row and cf_end_row >= start_row and cf_start_col <= start_col and cf_end_col >= end_col)
            
            if not (col_ok and row_ok):
                logger.error("=" * 60)
                logger.error("✗ Condition 2 range does not cover target range")
                logger.error(f"  Target range: {check_range} (cols {start_col}-{end_col}, rows {start_row}-{end_row})")
                logger.error(f"  CF range: cols {cf_start_col}-{cf_end_col}, rows {cf_start_row}-{cf_end_row}")
                logger.error(f"  Uses relative refs: {uses_relative_refs}")
                logger.error("=" * 60)
                return 0.0
            else:
                logger.info(f"✓ Condition 2 range covers target range (CF: {cf_start_col}-{cf_end_col}, {cf_start_row}-{cf_end_row})")
        
        # Verify that ALL cells in the target range have conditional formatting
        # We need to check each cell individually to ensure it's covered
        total_target_cells = (end_row - start_row + 1) * (end_col - start_col + 1)
        cells_with_cf = set()
        
        # Collect all cells covered by the matching conditional formatting
        for fmt in conditional_formattings:
            for rge in fmt.cells:
                # Check if this range overlaps with our target range
                if not (rge.max_col < start_col or rge.min_col > end_col or 
                        rge.max_row < start_row or rge.min_row > end_row):
                    # This range overlaps, check if it has the matching rules
                    for r in fmt.rules:
                        if not r.formula:
                            continue
                        formula_text = r.formula[0] if isinstance(r.formula, list) else str(r.formula)
                        formula_upper = formula_text.upper()
                        
                        # Check if this is a matching rule
                        and_pattern = r'\bAND\s*\('
                        if not re.search(and_pattern, formula_upper):
                            continue
                        
                        # Check fill color and font color
                        fill_color = None
                        font_color = None
                        if r.dxf:
                            if r.dxf.fill:
                                try:
                                    if r.dxf.fill.bgColor:
                                        fill_color = r.dxf.fill.bgColor
                                    elif r.dxf.fill.fgColor:
                                        fill_color = r.dxf.fill.fgColor
                                except:
                                    pass
                            if r.dxf.font:
                                try:
                                    if r.dxf.font.color:
                                        font_color = r.dxf.font.color
                                except:
                                    pass
                        
                        color_to_check = fill_color if fill_color is not None else font_color
                        if color_to_check is None:
                            continue
                        
                        # Check if this is condition 1 or condition 2
                        condition1_match = re.search(
                            r'AND\s*\(\s*\$?B\$?\d+\s*\+\s*\$?D\$?\d+\s*<=\s*E\$?\d+\s*,\s*E\$?\d+\s*<=\s*\$?B\$?\d+\s*\+\s*\$?C\$?\d+\s*\)',
                            formula_upper
                        )
                        condition2_match = re.search(
                            r'NOT\s*\(\s*AND\s*\(\s*\$?B\$?\d+\s*\+\s*\$?D\$?\d+\s*<=\s*E\$?\d+\s*,\s*E\$?\d+\s*<=\s*\$?B\$?\d+\s*\+\s*\$?C\$?\d+\s*\)\s*\)',
                            formula_upper
                        )
                        
                        is_condition1 = condition1_match and check_fill_color(color_to_check, condition1_fill_color)
                        is_condition2 = condition2_match and check_fill_color(color_to_check, condition2_fill_color)
                        
                        if not (is_condition1 or is_condition2):
                            continue
                        
                        # This is a matching rule, add all cells in the range to the set
                        # If using relative refs and CF is only on first row, assume it applies to all rows
                        if uses_relative_refs and rge.min_row == start_row and rge.max_row == start_row:
                            # CF applied to first row only, but with relative refs, it applies to all rows
                            for row in range(start_row, end_row + 1):
                                for col in range(max(start_col, rge.min_col), min(end_col, rge.max_col) + 1):
                                    cells_with_cf.add((row, col))
                        else:
                            # CF applied to specific range
                            for row in range(max(start_row, rge.min_row), min(end_row, rge.max_row) + 1):
                                for col in range(max(start_col, rge.min_col), min(end_col, rge.max_col) + 1):
                                    cells_with_cf.add((row, col))
        
        # Check if all target cells are covered
        missing_cells = []
        for row in range(start_row, end_row + 1):
            for col in range(start_col, end_col + 1):
                if (row, col) not in cells_with_cf:
                    col_letter = get_column_letter(col)
                    missing_cells.append(f"{col_letter}{row}")
        
        if missing_cells:
            logger.error("=" * 60)
            logger.error(f"✗ {len(missing_cells)} cells in target range do not have conditional formatting")
            logger.error(f"  Missing cells (first 20): {', '.join(missing_cells[:20])}")
            if len(missing_cells) > 20:
                logger.error(f"  ... and {len(missing_cells) - 20} more cells")
            logger.error(f"  Total target cells: {total_target_cells}")
            logger.error(f"  Cells with CF: {len(cells_with_cf)}")
            logger.error("=" * 60)
            return 0.0
        
        if len(cells_with_cf) < total_target_cells:
            logger.error("=" * 60)
            logger.error(f"✗ Not all target cells have conditional formatting")
            logger.error(f"  Expected: {total_target_cells} cells")
            logger.error(f"  Found: {len(cells_with_cf)} cells")
            logger.error("=" * 60)
            return 0.0
        
        logger.info("=" * 60)
        logger.info(f"✓ Conditional formatting verification passed")
        logger.info(f"  - Condition 1: {condition1_formula_pattern} -> {condition1_fill_color} ✓")
        logger.info(f"  - Condition 2: {condition2_formula_pattern} -> {condition2_fill_color} ✓")
        logger.info(f"  - Range: {check_range} (all {total_target_cells} cells verified)")
        logger.info("=" * 60)
        return 1.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_text_sumpRODUCT_mmult_match_win_lose(result: str, expected: str = None, **options) -> float:
    """
    Verify if TEXT(SUMPRODUCT(MMULT(MATCH(...)))) formulas exist in ALL cells of specified range to calculate win/lose/draw results.
    
    This function STRICTLY checks ALL cells in the specified range - no tolerance, no auto-detection.
    Every single cell in the specified range must contain the correct formula.
    
    The formula =TEXT(SUMPRODUCT(MMULT(N(MOD(MATCH(OFFSET(A$2,,MATCH(H11,B$1:E$1,),20),H$2:L$2,),5)+1=MATCH(B$2:E$21,H$2:L$2,)),{1;1;1;1})-MMULT(N(MOD(MATCH(OFFSET(A$2,,MATCH(H11,B$1:E$1,),20),H$2:L$2,)+4,5)=MOD(MATCH(B$2:E$21,H$2:L$2,),5)),{1;1;1;1})),"贏0;輸0;平") 
    calculates win/lose/draw results based on five-element cycle (金木水火土) game logic.
    
    This function checks:
    1. Whether ALL cells in the specified range (e.g., I12:I15) contain formulas
    2. Whether formulas contain TEXT, SUMPRODUCT, MMULT, MATCH, OFFSET, MOD, and N functions
    3. Whether formulas contain the correct structure with two MMULT operations
    4. Whether formulas contain OFFSET with MATCH(H11,B$1:E$1,) reference
    5. Whether formulas contain MATCH(B$2:E$21,H$2:L$2,) reference
    6. Whether formulas contain MOD operations with 5 (for five-element cycle)
    7. Whether formulas contain TEXT format string "贏0;輸0;平" or similar
    8. Whether formulas contain array constant {1;1;1;1}
    
    IMPORTANT: This function checks ALL cells in the specified range. If any cell is missing a formula, verification fails.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_range: Range to check (e.g., "I12:I15") - ALL cells must have formulas
            - expected_functions: List of expected function names (default: ["TEXT", "SUMPRODUCT", "MMULT", "MATCH", "OFFSET", "MOD", "N"])
            - offset_match_ref: OFFSET MATCH reference (default: "MATCH(H11,B$1:E$1,)")
            - match_range: MATCH range reference (default: "B$2:E$21")
            - match_lookup: MATCH lookup array (default: "H$2:L$2")
            - text_format: TEXT format string (default: "贏0;輸0;平")
            - array_constant: Array constant pattern (default: "{1;1;1;1}")
    
    Returns:
        float: 1.0 if ALL cells in specified range contain correct formulas, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_range = options.get('check_range', 'I12:I15')
        expected_functions = options.get('expected_functions', ['TEXT', 'SUMPRODUCT', 'MMULT', 'MATCH', 'OFFSET', 'MOD', 'N'])
        offset_match_ref = options.get('offset_match_ref', 'MATCH(H11,B$1:E$1,)')
        match_range = options.get('match_range', 'B$2:E$21')
        match_lookup = options.get('match_lookup', 'H$2:L$2')
        text_format = options.get('text_format', '贏0;輸0;平')
        array_constant = options.get('array_constant', '{1;1;1;1}')
        
        logger.info(f"Verifying TEXT(SUMPRODUCT(MMULT(MATCH))) win/lose formulas in file: {result}")
        logger.info(f"Range to check: {check_range}")
        logger.info(f"Expected functions: {expected_functions}")
        
        # Parse the range
        try:
            range_clean = check_range.replace('$', '')
            if ':' in range_clean:
                start_cell, end_cell = range_clean.split(':')
                start_col_letter = ''.join([c for c in start_cell if c.isalpha()])
                start_row = int(''.join([c for c in start_cell if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                end_col_letter = ''.join([c for c in end_cell if c.isalpha()])
                end_row = int(''.join([c for c in end_cell if c.isdigit()]))
                end_col = column_index_from_string(end_col_letter)
            else:
                logger.error(f"Invalid range format: {check_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse range {check_range}: {e}")
            return 0.0
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Strictly check ALL cells in the specified range
        logger.info(f"Checking all cells in range {check_range} (rows {start_row} to {end_row})")
        
        all_passed = True
        checked_count = 0
        passed_count = 0
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{start_col_letter}{row_num}"
            
            try:
                cell = ws[cell_coord]
                checked_count += 1
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.error(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                elif cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula_text = cell.value
                
                if formula_text is None:
                    logger.error(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains all expected functions
                for func in expected_functions:
                    func_pattern = rf'\b{re.escape(func.upper())}\s*\('
                    if not re.search(func_pattern, formula_upper):
                        logger.error(f"Cell {cell_coord} formula does not contain {func} function")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        break
                
                if not all_passed:
                    continue
                
                # Check 2: Formula contains TEXT function
                text_pattern = r'\bTEXT\s*\('
                if not re.search(text_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain TEXT function")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: Formula contains SUMPRODUCT function
                sumproduct_pattern = r'\bSUMPRODUCT\s*\('
                if not re.search(sumproduct_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain SUMPRODUCT function")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: Formula contains MMULT function (should appear twice)
                mmult_pattern = r'\bMMULT\s*\('
                mmult_matches = len(re.findall(mmult_pattern, formula_upper))
                if mmult_matches < 2:
                    logger.error(f"Cell {cell_coord} formula does not contain at least 2 MMULT functions (found {mmult_matches})")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 5: Formula contains OFFSET function
                offset_pattern = r'\bOFFSET\s*\('
                if not re.search(offset_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain OFFSET function")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 6: Formula contains MATCH function (should appear multiple times)
                match_pattern = r'\bMATCH\s*\('
                match_matches = len(re.findall(match_pattern, formula_upper))
                if match_matches < 3:
                    logger.error(f"Cell {cell_coord} formula does not contain at least 3 MATCH functions (found {match_matches})")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 7: Formula contains MOD function with 5 (for five-element cycle)
                mod_pattern = r'\bMOD\s*\([^,]+,\s*5\s*\)'
                if not re.search(mod_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain MOD(...,5) pattern")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 8: Formula contains N function
                n_pattern = r'\bN\s*\('
                if not re.search(n_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain N function")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 9: Formula contains OFFSET with MATCH reference pattern
                # Allow flexibility in spacing and reference format
                offset_match_pattern = r'OFFSET\s*\([^,]+,\s*,\s*MATCH\s*\(\s*H\d+\s*,\s*B\$?\d+\s*:\s*E\$?\d+\s*,\s*\)'
                if not re.search(offset_match_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain OFFSET(...,MATCH(H...,B$1:E$1,)) pattern")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 10: Formula contains MATCH(B$2:E$21,H$2:L$2,) pattern
                match_range_pattern = r'MATCH\s*\(\s*B\$?\d+\s*:\s*E\$?\d+\s*,\s*H\$?\d+\s*:\s*L\$?\d+\s*,\s*\)'
                if not re.search(match_range_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain MATCH(B$2:E$21,H$2:L$2,) pattern")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 11: Formula contains array constant {1;1;1;1} or similar
                array_pattern = r'\{[^}]*1[^}]*;[^}]*1[^}]*;[^}]*1[^}]*;[^}]*1[^}]*\}'
                if not re.search(array_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain array constant pattern like {{1;1;1;1}}")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 12: Formula contains TEXT format string (allow variations)
                # Escape special characters in text_format
                text_format_escaped = re.escape(text_format)
                # Allow flexibility in quotes and spacing
                text_format_pattern = rf'["\']?\s*{text_format_escaped}\s*["\']?'
                if not re.search(text_format_pattern, formula_text):
                    logger.error(f"Cell {cell_coord} formula does not contain TEXT format string '{text_format}'")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 13: Formula structure - TEXT(SUMPRODUCT(...))
                text_sumpRODUCT_pattern = r'TEXT\s*\(\s*SUMPRODUCT\s*\('
                if not re.search(text_sumpRODUCT_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not have correct TEXT(SUMPRODUCT(...)) structure")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 14: Formula contains subtraction between two MMULT operations
                # Look for pattern: MMULT(...) - MMULT(...)
                mmult_subtract_pattern = r'MMULT\s*\([^)]+\)\s*-\s*MMULT\s*\('
                if not re.search(mmult_subtract_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain MMULT(...) - MMULT(...) subtraction pattern")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 15: Formula closes parentheses correctly
                open_count = formula_text.count('(')
                close_count = formula_text.count(')')
                if open_count != close_count:
                    logger.error(f"Cell {cell_coord} formula has mismatched parentheses (open: {open_count}, close: {close_count})")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                passed_count += 1
                logger.debug(f"✓ Cell {cell_coord} passed all checks")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                all_passed = False
                continue
        
        if not all_passed:
            logger.error("=" * 60)
            logger.error(f"✗ Formula verification failed")
            logger.error(f"  Checked: {checked_count} cells")
            logger.error(f"  Passed: {passed_count} cells")
            logger.error(f"  Range: {check_range}")
            logger.error("=" * 60)
            return 0.0
        
        if checked_count == 0:
            logger.error("=" * 60)
            logger.error(f"✗ No cells were checked in range {check_range}")
            logger.error("=" * 60)
            return 0.0
        
        logger.info("=" * 60)
        logger.info(f"✓ TEXT(SUMPRODUCT(MMULT(MATCH))) formula verification passed")
        logger.info(f"  - Checked: {checked_count} cells")
        logger.info(f"  - Passed: {passed_count} cells")
        logger.info(f"  - Range: {check_range}")
        logger.info("=" * 60)
        return 1.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0

def verify_iferror_index_small_position_mapping(result: str, expected: str = None, **options) -> float:
    """
    Verify if IFERROR(INDEX(SMALL(IF(...)))) formulas exist to map positions between two tables.
    
    This function checks:
    1. Whether specified cells contain IFERROR formulas
    2. Whether formulas contain INDEX, SMALL, IF, ROW, and COLUMN functions
    3. Whether formulas have correct condition check ($A$1:$D$4=0)
    4. Whether formulas use position encoding (ROW*10+COLUMN) for mapping
    5. Whether formulas reference correct source and target ranges
    
    Expected formula pattern:
    =IFERROR(INDEX($G$1:$J$4,INT((SMALL(IF($A$1:$D$4=0,ROW($A$1:$D$4)*10+COLUMN($A$1:$D$4),""),(ROW()-1)*2+COLUMN()-11)-1)/10),MOD(SMALL(IF($A$1:$D$4=0,ROW($A$1:$D$4)*10+COLUMN($A$1:$D$4),""),(ROW()-1)*2+COLUMN()-11)-1,10)+1),"")
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_range: Range to check (e.g., "L1:M4")
            - source_range: Source range for condition check (e.g., "$A$1:$D$4")
            - target_range: Target range for INDEX (e.g., "$G$1:$J$4")
            - expected_functions: List of expected function names (default: ["IFERROR", "INDEX", "SMALL", "IF", "ROW", "COLUMN"])
            - condition_value: Value to check in condition (default: 0)
            - position_encoding_multiplier: Multiplier for position encoding (default: 10)
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_range = options.get('check_range', 'L1:M4')
        source_range = options.get('source_range', '$A$1:$D$4')
        target_range = options.get('target_range', '$G$1:$J$4')
        expected_functions = options.get('expected_functions', ['IFERROR', 'INDEX', 'SMALL', 'IF', 'ROW', 'COLUMN'])
        condition_value = options.get('condition_value', 0)
        position_encoding_multiplier = options.get('position_encoding_multiplier', 10)
        
        logger.info(f"Verifying IFERROR(INDEX(SMALL(IF))) position mapping formulas in file: {result}")
        logger.info(f"Check range: {check_range}")
        logger.info(f"Source range: {source_range}")
        logger.info(f"Target range: {target_range}")
        logger.info(f"Expected functions: {expected_functions}")
        
        # Parse the check range
        try:
            range_clean = check_range.replace("$", "")
            if ":" in range_clean:
                start_cell, end_cell = range_clean.split(":")
                start_col_letter = "".join([c for c in start_cell if c.isalpha()])
                start_row = int("".join([c for c in start_cell if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                end_col_letter = "".join([c for c in end_cell if c.isalpha()])
                end_row = int("".join([c for c in end_cell if c.isdigit()]))
                end_col = column_index_from_string(end_col_letter)
            else:
                logger.error(f"Invalid range format: {check_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse range {check_range}: {e}")
            return 0.0
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=False)
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each cell in the check range
        all_passed = True
        checked_count = 0
        passed_count = 0
        
        logger.info(f"Checking cells in range {check_range} (rows {start_row} to {end_row}, columns {start_col} to {end_col})")
        
        for row_num in range(start_row, end_row + 1):
            for col_num in range(start_col, end_col + 1):
                col_letter = get_column_letter(col_num)
                cell_coord = f"{col_letter}{row_num}"
                
                try:
                    cell = ws[cell_coord]
                    checked_count += 1
                    
                    # Check if cell contains a formula
                    if cell.data_type != "f":
                        logger.warning(f"Cell {cell_coord} does not contain a formula (data_type: {cell.data_type})")
                        logger.warning(f"  Cell value: {cell.value}, Cell type: {type(cell.value)}")
                        all_passed = False
                        continue
                    
                    # Get formula text - try multiple methods for LibreOffice compatibility
                    # Note: Array formulas are entered with Ctrl+Shift+Enter and displayed as {=formula}
                    # In openpyxl, array formulas are stored as ArrayFormula objects
                    formula_text = None
                    
                    # Method 1: Handle ArrayFormula object (for array formulas)
                    if hasattr(cell, "_value") and cell._value is not None:
                        from openpyxl.worksheet.formula import ArrayFormula
                        if isinstance(cell._value, ArrayFormula):
                            # ArrayFormula object has 'text' attribute containing the formula
                            try:
                                formula_text = cell._value.text
                                if formula_text:
                                    logger.debug(f"Cell {cell_coord} array formula extracted from ArrayFormula.text")
                                else:
                                    # If text is None or empty, try to get from ref or convert to string
                                    formula_text = str(cell._value)
                                    logger.debug(f"Cell {cell_coord} array formula extracted from ArrayFormula (converted to string)")
                            except (AttributeError, TypeError) as e:
                                # Fallback: convert to string
                                formula_text = str(cell._value)
                                logger.debug(f"Cell {cell_coord} array formula extracted from ArrayFormula (fallback to string): {e}")
                        elif isinstance(cell._value, str):
                            raw_value = cell._value
                            # Handle array formula format {=formula}
                            if raw_value.startswith("{") and raw_value.endswith("}"):
                                # Remove curly braces for array formula
                                formula_text = raw_value[1:-1]  # Remove { and }
                                logger.debug(f"Cell {cell_coord} array formula extracted from _value (removed braces)")
                            elif raw_value.startswith("="):
                                formula_text = raw_value
                                logger.debug(f"Cell {cell_coord} formula extracted from _value")
                            # Check if it looks like a formula without = prefix
                            elif any(func in raw_value.upper() for func in ['IFERROR', 'INDEX', 'SMALL', 'IF', 'ROW', 'COLUMN']):
                                # Handle array formula without = prefix
                                if raw_value.startswith("{") and raw_value.endswith("}"):
                                    formula_text = f"={raw_value[1:-1]}"  # Remove braces and add =
                                else:
                                    formula_text = f"={raw_value}"  # Add = prefix
                                logger.debug(f"Cell {cell_coord} formula extracted from _value (added = prefix)")
                    # Method 2: Try formula attribute
                    elif hasattr(cell, "formula") and cell.formula:
                        raw_formula = cell.formula
                        # Handle array formula format
                        if raw_formula.startswith("{") and raw_formula.endswith("}"):
                            formula_text = raw_formula[1:-1]  # Remove braces
                            logger.debug(f"Cell {cell_coord} array formula extracted from formula attribute")
                        else:
                            formula_text = raw_formula
                            logger.debug(f"Cell {cell_coord} formula extracted from formula attribute")
                    # Method 3: Try value attribute (for some LibreOffice saved files)
                    elif cell.value is not None:
                        from openpyxl.worksheet.formula import ArrayFormula
                        if isinstance(cell.value, ArrayFormula):
                            # ArrayFormula object has 'text' attribute
                            try:
                                formula_text = cell.value.text
                                if formula_text:
                                    logger.debug(f"Cell {cell_coord} array formula extracted from value ArrayFormula.text")
                                else:
                                    formula_text = str(cell.value)
                                    logger.debug(f"Cell {cell_coord} array formula extracted from value ArrayFormula (converted to string)")
                            except (AttributeError, TypeError) as e:
                                formula_text = str(cell.value)
                                logger.debug(f"Cell {cell_coord} array formula extracted from value ArrayFormula (fallback to string): {e}")
                        elif isinstance(cell.value, str):
                            raw_value = cell.value
                            # Handle array formula format
                            if raw_value.startswith("{") and raw_value.endswith("}"):
                                formula_text = raw_value[1:-1]  # Remove braces
                                logger.debug(f"Cell {cell_coord} array formula extracted from value")
                            elif raw_value.startswith("="):
                                formula_text = raw_value
                                logger.debug(f"Cell {cell_coord} formula extracted from value")
                    
                    # Additional debugging if still None
                    if formula_text is None:
                        logger.warning(f"Could not extract formula from cell {cell_coord}")
                        logger.warning(f"  data_type: {cell.data_type}")
                        logger.warning(f"  has _value: {hasattr(cell, '_value')}, _value: {getattr(cell, '_value', 'N/A')}")
                        logger.warning(f"  has formula: {hasattr(cell, 'formula')}, formula: {getattr(cell, 'formula', 'N/A')}")
                        logger.warning(f"  value: {cell.value}, value type: {type(cell.value)}")
                        all_passed = False
                        continue
                    
                    # Ensure formula starts with = (for consistency)
                    if not formula_text.startswith("="):
                        formula_text = f"={formula_text}"
                    
                    formula_upper = formula_text.upper()
                    logger.debug(f"Cell {cell_coord} formula: {formula_text[:200]}...")
                    
                    # Check 1: Formula contains IFERROR function
                    iferror_pattern = r'\bIFERROR\s*\('
                    if not re.search(iferror_pattern, formula_upper):
                        logger.warning(f"Cell {cell_coord} formula does not contain IFERROR function")
                        logger.warning(f"  Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 2: Formula contains INDEX function
                    index_pattern = r'\bINDEX\s*\('
                    if not re.search(index_pattern, formula_upper):
                        logger.warning(f"Cell {cell_coord} formula does not contain INDEX function")
                        logger.warning(f"  Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 3: Formula contains SMALL function
                    small_pattern = r'\bSMALL\s*\('
                    if not re.search(small_pattern, formula_upper):
                        logger.warning(f"Cell {cell_coord} formula does not contain SMALL function")
                        logger.warning(f"  Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 4: Formula contains IF function
                    if_pattern = r'\bIF\s*\('
                    if not re.search(if_pattern, formula_upper):
                        logger.warning(f"Cell {cell_coord} formula does not contain IF function")
                        logger.warning(f"  Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 5: Formula contains ROW function
                    row_pattern = r'\bROW\s*\('
                    if not re.search(row_pattern, formula_upper):
                        logger.warning(f"Cell {cell_coord} formula does not contain ROW function")
                        logger.warning(f"  Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 6: Formula contains COLUMN function
                    column_pattern = r'\bCOLUMN\s*\('
                    if not re.search(column_pattern, formula_upper):
                        logger.warning(f"Cell {cell_coord} formula does not contain COLUMN function")
                        logger.warning(f"  Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 7: Formula contains condition check (source_range=condition_value)
                    # Formula may contain $A$1:$D$4=0 or A1:D4=0, so check both patterns
                    source_range_with_dollar = re.escape(source_range)  # Keep $ signs: \$A\$1:\$D\$4
                    source_range_no_dollar = re.escape(source_range.replace("$", ""))  # Without $: A1:D4
                    # Try pattern with dollar signs first (more common in formulas)
                    condition_pattern1 = rf'{source_range_with_dollar}\s*=\s*{condition_value}'
                    condition_pattern2 = rf'{source_range_no_dollar}\s*=\s*{condition_value}'
                    if not re.search(condition_pattern1, formula_text, re.IGNORECASE) and not re.search(condition_pattern2, formula_text, re.IGNORECASE):
                        logger.warning(f"Cell {cell_coord} formula does not contain condition check {source_range}={condition_value}")
                        logger.warning(f"  Formula: {formula_text}")
                        logger.warning(f"  Tried patterns: {condition_pattern1} and {condition_pattern2}")
                        all_passed = False
                        continue
                    
                    # Check 8: Formula contains position encoding (ROW*multiplier+COLUMN)
                    # Look for pattern like ROW(...)*10+COLUMN(...) or similar
                    encoding_pattern = rf'ROW\s*\([^)]+\)\s*\*\s*{position_encoding_multiplier}\s*\+\s*COLUMN\s*\('
                    if not re.search(encoding_pattern, formula_upper):
                        # Also check for COLUMN*multiplier+ROW pattern (less common but possible)
                        encoding_pattern2 = rf'COLUMN\s*\([^)]+\)\s*\*\s*{position_encoding_multiplier}\s*\+\s*ROW\s*\('
                        if not re.search(encoding_pattern2, formula_upper):
                            logger.warning(f"Cell {cell_coord} formula does not contain position encoding (ROW*{position_encoding_multiplier}+COLUMN)")
                            logger.warning(f"  Formula: {formula_text}")
                            all_passed = False
                            continue
                    
                    # Check 9: Formula references target range for INDEX
                    # Formula may contain $G$1:$J$4 or G1:J4, so check both patterns
                    target_range_with_dollar = re.escape(target_range)  # Keep $ signs: \$G\$1:\$J\$4
                    target_range_no_dollar = re.escape(target_range.replace("$", ""))  # Without $: G1:J4
                    # Try pattern with dollar signs first (more common in formulas)
                    target_pattern1 = rf'{target_range_with_dollar}'
                    target_pattern2 = rf'{target_range_no_dollar}'
                    if not re.search(target_pattern1, formula_text, re.IGNORECASE) and not re.search(target_pattern2, formula_text, re.IGNORECASE):
                        logger.warning(f"Cell {cell_coord} formula does not reference target range {target_range}")
                        logger.warning(f"  Formula: {formula_text}")
                        logger.warning(f"  Tried patterns: {target_pattern1} and {target_pattern2}")
                        all_passed = False
                        continue
                    
                    # Check 10: Formula structure contains SMALL inside IF
                    # Check that SMALL is used with IF condition
                    if_small_pattern = r'IF\s*\([^)]*SMALL'
                    if not re.search(if_small_pattern, formula_upper):
                        # Also check reverse pattern
                        small_if_pattern = r'SMALL\s*\(\s*IF\s*\('
                        if not re.search(small_if_pattern, formula_upper):
                            logger.warning(f"Cell {cell_coord} formula does not have SMALL(IF(...)) structure")
                            logger.warning(f"  Formula: {formula_text}")
                            all_passed = False
                            continue
                    
                    # Check 11: Formula contains INT and MOD functions for position decoding
                    int_pattern = r'\bINT\s*\('
                    mod_pattern = r'\bMOD\s*\('
                    if not re.search(int_pattern, formula_upper) or not re.search(mod_pattern, formula_upper):
                        logger.warning(f"Cell {cell_coord} formula does not contain INT and MOD functions for position decoding")
                        logger.warning(f"  Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    logger.info(f"✓ Cell {cell_coord} has valid IFERROR(INDEX(SMALL(IF))) formula")
                    passed_count += 1
                    
                except Exception as e:
                    logger.error(f"Error checking cell {cell_coord}: {e}")
                    import traceback
                    logger.error(traceback.format_exc())
                    all_passed = False
        
        if all_passed and checked_count > 0:
            logger.info("=" * 60)
            logger.info(f"✓ All cells in range {check_range} contain correct IFERROR(INDEX(SMALL(IF))) formulas")
            logger.info(f"  - Checked: {checked_count} cells")
            logger.info(f"  - Passed: {passed_count} cells")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ IFERROR(INDEX(SMALL(IF))) formula verification failed")
            logger.error(f"  - Checked: {checked_count} cells")
            logger.error(f"  - Passed: {passed_count} cells")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_value_sort_column(result: str, expected: str = None, **options) -> float:
    """
    Verify if VALUE formulas exist in specified column to convert text to numbers, and verify sorting.
    
    This function checks:
    1. Whether specified cells contain VALUE formulas
    2. Whether formulas reference the correct source column cells
    3. Whether the data is sorted correctly (ascending or descending order is acceptable)
    4. Whether formula structure is correct: VALUE(source_cell)
    
    Expected formula pattern:
    - D2: =VALUE(B2) (convert text in B2 to number)
    - D3: =VALUE(B3) (and so on for other rows)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_column: Column to check for formulas (e.g., "D")
            - start_row: Starting row number (e.g., 2)
            - source_column: Column containing source text values (e.g., "B")
            - expected_functions: List of expected function names (default: ["VALUE"])
            - data_column: Column to use for auto-detecting end row (e.g., "B")
            - sort_column: Column to check for sorting (e.g., "D")
            - allow_ascending: Whether ascending sort is acceptable (default: True)
            - allow_descending: Whether descending sort is acceptable (default: True)
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_column = options.get('check_column', 'D')
        start_row = options.get('start_row', 2)
        source_column = options.get('source_column', 'B')
        expected_functions = options.get('expected_functions', ['VALUE'])
        data_column = options.get('data_column', 'B')
        sort_column = options.get('sort_column', 'D')
        allow_ascending = options.get('allow_ascending', True)
        allow_descending = options.get('allow_descending', True)
        
        logger.info(f"Verifying VALUE formulas and sorting in file: {result}")
        logger.info(f"Check column: {check_column}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Source column: {source_column}")
        logger.info(f"Sort column: {sort_column}")
        logger.info(f"Expected functions: {expected_functions}")
        logger.info(f"Allow ascending: {allow_ascending}, Allow descending: {allow_descending}")
        
        # Load workbook to get formulas and values
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row  # Start from start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Check 1: Verify VALUE formulas in check_column
        all_passed = True
        logger.info(f"Checking column {check_column} for VALUE formulas (rows {start_row} to {end_row})")
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{check_column}{row_num}"
            try:
                cell = ws[cell_coord]
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.warning(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                elif cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula_text = cell.value
                # Handle ArrayFormula object
                elif hasattr(cell, "_value") and cell._value is not None:
                    from openpyxl.worksheet.formula import ArrayFormula
                    if isinstance(cell._value, ArrayFormula):
                        try:
                            formula_text = cell._value.text
                            if formula_text and not formula_text.startswith("="):
                                formula_text = f"={formula_text}"
                        except (AttributeError, TypeError):
                            formula_text = str(cell._value)
                            if not formula_text.startswith("="):
                                formula_text = f"={formula_text}"
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                # Ensure formula starts with =
                if not formula_text.startswith("="):
                    formula_text = f"={formula_text}"
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains VALUE function
                value_pattern = r'\bVALUE\s*\('
                if not re.search(value_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not contain VALUE function")
                    logger.warning(f"  Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 2: Formula references the source column cell (e.g., B2, B3, etc.)
                expected_source_cell = f"{source_column}{row_num}"
                source_cell_pattern = rf'{source_column}{row_num}\b'
                if not re.search(source_cell_pattern, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {cell_coord} formula does not reference source column cell {expected_source_cell}")
                    logger.warning(f"  Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: Formula structure is VALUE(source_cell)
                value_cell_pattern = rf'VALUE\s*\(\s*{source_column}{row_num}\s*\)'
                if not re.search(value_cell_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not have correct VALUE({source_column}{row_num}) structure")
                    logger.warning(f"  Formula: {formula_text}")
                    all_passed = False
                    continue
                
                logger.info(f"✓ Cell {cell_coord} has valid VALUE formula: {formula_text}")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        if not all_passed:
            logger.error("=" * 60)
            logger.error(f"✗ VALUE formula verification failed")
            logger.error("=" * 60)
            return 0.0
        
        # Check 2: Verify sorting
        logger.info(f"Checking if column {sort_column} is sorted correctly (rows {start_row} to {end_row})")
        
        # Collect values from sort_column
        sort_values = []
        for row_num in range(start_row, end_row + 1):
            cell = ws[f"{sort_column}{row_num}"]
            # Get calculated value (data_only=True for values)
            try:
                # Try to get numeric value
                if cell.data_type == "n":
                    sort_values.append((row_num, float(cell.value)))
                elif cell.data_type == "f":
                    # For formula cells, we need to get the calculated value
                    # Load with data_only=True to get calculated values
                    wb_values = openpyxl.load_workbook(result, data_only=True)
                    ws_values = wb_values.active
                    value_cell = ws_values[f"{sort_column}{row_num}"]
                    if value_cell.value is not None:
                        try:
                            sort_values.append((row_num, float(value_cell.value)))
                        except (ValueError, TypeError):
                            logger.warning(f"Cell {sort_column}{row_num} has non-numeric value: {value_cell.value}")
                    else:
                        logger.warning(f"Cell {sort_column}{row_num} has no value")
                else:
                    # Try to convert to float
                    if cell.value is not None:
                        try:
                            sort_values.append((row_num, float(cell.value)))
                        except (ValueError, TypeError):
                            logger.warning(f"Cell {sort_column}{row_num} has non-numeric value: {cell.value}")
            except Exception as e:
                logger.warning(f"Error reading cell {sort_column}{row_num}: {e}")
        
        if len(sort_values) < 2:
            logger.warning(f"Not enough values to verify sorting: only {len(sort_values)} values")
            # If there's only one value, sorting is trivially correct
            if len(sort_values) == 1:
                logger.info("Only one value, sorting is trivially correct")
                logger.info("=" * 60)
                logger.info(f"✓ VALUE formula verification passed")
                logger.info("=" * 60)
                return 1.0
            else:
                logger.error("No values found in sort column")
                return 0.0
        
        # Check if values are sorted
        values_only = [v for _, v in sort_values]
        is_ascending = all(values_only[i] <= values_only[i+1] for i in range(len(values_only)-1))
        is_descending = all(values_only[i] >= values_only[i+1] for i in range(len(values_only)-1))
        
        logger.info(f"Sort values: {values_only}")
        logger.info(f"Is ascending: {is_ascending}")
        logger.info(f"Is descending: {is_descending}")
        
        if is_ascending and allow_ascending:
            logger.info(f"✓ Column {sort_column} is sorted in ascending order")
            sort_passed = True
        elif is_descending and allow_descending:
            logger.info(f"✓ Column {sort_column} is sorted in descending order")
            sort_passed = True
        elif is_ascending and not allow_ascending:
            logger.warning(f"Column {sort_column} is sorted in ascending order, but ascending is not allowed")
            sort_passed = False
        elif is_descending and not allow_descending:
            logger.warning(f"Column {sort_column} is sorted in descending order, but descending is not allowed")
            sort_passed = False
        else:
            logger.warning(f"Column {sort_column} is not sorted (neither ascending nor descending)")
            logger.warning(f"  Values: {values_only}")
            sort_passed = False
        
        if sort_passed:
            logger.info("=" * 60)
            logger.info(f"✓ VALUE formula and sorting verification passed")
            logger.info(f"  - Checked: {end_row - start_row + 1} cells")
            logger.info(f"  - Sort order: {'ascending' if is_ascending else 'descending'}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ Sorting verification failed")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_mid_date_format(result: str, expected: str = None, **options) -> float:
    """
    Verify if MID formulas with concatenation exist to format date from numeric string.
    
    This function checks:
    1. Whether specified cells contain MID formulas
    2. Whether formulas use concatenation operator (&)
    3. Whether formulas extract year (first 4 characters) and month (characters 5-6)
    4. Whether formulas reference the correct source column cells
    5. Whether formula structure is correct: MID(source_cell,start1,length1)&separator&MID(source_cell,start2,length2)
    
    Expected formula pattern:
    - B1: =(MID(A1,1,4)&"-"&MID(A1,5,2)) (extract year and month, format as YYYY-MM)
    - B2: =(MID(A2,1,4)&"-"&MID(A2,5,2)) (and so on for other rows)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_column: Column to check (e.g., "B")
            - start_row: Starting row number (e.g., 1)
            - source_column: Column containing source numeric strings (e.g., "A")
            - expected_functions: List of expected function names (default: ["MID"])
            - data_column: Column to use for auto-detecting end row (e.g., "A")
            - year_start: Start position for year extraction (default: 1)
            - year_length: Length of year (default: 4)
            - month_start: Start position for month extraction (default: 5)
            - month_length: Length of month (default: 2)
            - separator: Separator character (default: "-")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_column = options.get('check_column', 'B')
        start_row = options.get('start_row', 1)
        source_column = options.get('source_column', 'A')
        expected_functions = options.get('expected_functions', ['MID'])
        data_column = options.get('data_column', 'A')
        year_start = options.get('year_start', 1)
        year_length = options.get('year_length', 4)
        month_start = options.get('month_start', 5)
        month_length = options.get('month_length', 2)
        separator = options.get('separator', '-')
        
        logger.info(f"Verifying MID date format formulas in file: {result}")
        logger.info(f"Check column: {check_column}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Source column: {source_column}")
        logger.info(f"Expected functions: {expected_functions}")
        logger.info(f"Year: start={year_start}, length={year_length}")
        logger.info(f"Month: start={month_start}, length={month_length}")
        logger.info(f"Separator: {separator}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row  # Start from start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Check each row in the specified column
        all_passed = True
        logger.info(f"Checking column {check_column} (rows {start_row} to {end_row})")
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{check_column}{row_num}"
            try:
                cell = ws[cell_coord]
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.warning(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                elif cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula_text = cell.value
                # Handle ArrayFormula object
                elif hasattr(cell, "_value") and cell._value is not None:
                    from openpyxl.worksheet.formula import ArrayFormula
                    if isinstance(cell._value, ArrayFormula):
                        try:
                            formula_text = cell._value.text
                            if formula_text and not formula_text.startswith("="):
                                formula_text = f"={formula_text}"
                        except (AttributeError, TypeError):
                            formula_text = str(cell._value)
                            if not formula_text.startswith("="):
                                formula_text = f"={formula_text}"
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                # Remove leading = if present for pattern matching (formula may start with = or not)
                formula_clean = formula_text.lstrip("=")
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains MID function (at least twice)
                mid_pattern = r'\bMID\s*\('
                mid_matches = len(re.findall(mid_pattern, formula_upper))
                if mid_matches < 2:
                    logger.warning(f"Cell {cell_coord} formula does not contain at least 2 MID functions")
                    logger.warning(f"  Formula: {formula_text}")
                    logger.warning(f"  Found {mid_matches} MID function(s)")
                    all_passed = False
                    continue
                
                # Check 2: Formula contains concatenation operator &
                if '&' not in formula_text:
                    logger.warning(f"Cell {cell_coord} formula does not contain concatenation operator &")
                    logger.warning(f"  Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: Formula references the source column cell (e.g., A1, A2, etc.)
                expected_source_cell = f"{source_column}{row_num}"
                source_cell_pattern = rf'{source_column}{row_num}\b'
                if not re.search(source_cell_pattern, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {cell_coord} formula does not reference source column cell {expected_source_cell}")
                    logger.warning(f"  Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: First MID function extracts year (start=year_start, length=year_length)
                # Pattern: MID(source_cell, year_start, year_length)
                year_mid_pattern = rf'MID\s*\(\s*{source_column}{row_num}\s*,\s*{year_start}\s*,\s*{year_length}\s*\)'
                if not re.search(year_mid_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not have MID({source_column}{row_num},{year_start},{year_length}) for year extraction")
                    logger.warning(f"  Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 5: Second MID function extracts month (start=month_start, length=month_length)
                # Pattern: MID(source_cell, month_start, month_length)
                month_mid_pattern = rf'MID\s*\(\s*{source_column}{row_num}\s*,\s*{month_start}\s*,\s*{month_length}\s*\)'
                if not re.search(month_mid_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not have MID({source_column}{row_num},{month_start},{month_length}) for month extraction")
                    logger.warning(f"  Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 6: Formula contains separator (with quotes or as string)
                # Separator might be in quotes: "-" or '-' or just -
                separator_pattern1 = rf'["\']{re.escape(separator)}["\']'  # "-" or '-'
                separator_pattern2 = re.escape(separator)  # Just the separator
                if not re.search(separator_pattern1, formula_text) and separator not in formula_text:
                    logger.warning(f"Cell {cell_coord} formula does not contain separator '{separator}'")
                    logger.warning(f"  Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 7: Formula structure: MID(...)&separator&MID(...)
                # Check that there's a MID, then &, then separator, then &, then another MID
                structure_pattern = rf'MID\s*\([^)]+\)\s*&\s*["\']?{re.escape(separator)}["\']?\s*&\s*MID\s*\('
                if not re.search(structure_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not have correct structure: MID(...)&separator&MID(...)")
                    logger.warning(f"  Formula: {formula_text}")
                    all_passed = False
                    continue
                
                logger.info(f"✓ Cell {cell_coord} has valid MID date format formula: {formula_text}")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        if all_passed:
            logger.info("=" * 60)
            logger.info(f"✓ All cells in column {check_column} contain correct MID date format formulas")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MID date format formula verification failed")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_iferror_text_vlookup_index_small_countif(result: str, expected: str = None, **options) -> float:
    """
    Verify if IFERROR(TEXT(VLOOKUP(INDEX(SMALL(IF(COUNTIF(...))))))) formulas exist for cross-sheet lookup.
    
    This function checks:
    1. Whether specified cells contain IFERROR, TEXT, VLOOKUP, INDEX, SMALL, IF, COUNTIF, and ROW functions
    2. Whether formulas reference correct cross-sheet ranges
    3. Whether formulas have correct condition check (COUNTIF(...)>0)
    4. Whether formulas use correct structure for date formatting
    
    Expected formula pattern:
    B2=IFERROR(TEXT(VLOOKUP(INDEX(整机SN关联表.$B$3:$B$31,SMALL(IF(COUNTIF(整机SN关联表.$C$3:$G$31,"*"&$A$2&"*")>0,ROW($1:$29),1E+099),ROW(A1))),整机出货年月.$B$2:$C$30,2,0),"YYYY-MM-DD"),"")
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_columns: List of columns to check (e.g., ["B", "D", "F", "H", "J"])
            - start_row: Starting row number (e.g., 2)
            - source_columns: List of source columns for each check column (e.g., ["A", "C", "E", "G", "I"])
            - expected_functions: List of expected function names (default: ["IFERROR", "TEXT", "VLOOKUP", "INDEX", "SMALL", "IF", "COUNTIF", "ROW"])
            - data_column: Column to use for auto-detecting end row (e.g., "A")
            - sn_table: Sheet name for SN association table (e.g., "整机SN关联表")
            - date_table: Sheet name for date table (e.g., "整机出货年月")
            - sn_range: Range for SN lookup in sn_table (e.g., "$B$3:$B$31")
            - search_range: Range to search in sn_table (e.g., "$C$3:$G$31")
            - lookup_range: Range for VLOOKUP in date_table (e.g., "$B$2:$C$30")
            - date_format: Date format string (e.g., "YYYY-MM-DD")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_columns = options.get('check_columns', ['B', 'D', 'F', 'H', 'J'])
        start_row = options.get('start_row', 2)
        source_columns = options.get('source_columns', ['A', 'C', 'E', 'G', 'I'])
        expected_functions = options.get('expected_functions', ['IFERROR', 'TEXT', 'VLOOKUP', 'INDEX', 'SMALL', 'IF', 'COUNTIF', 'ROW'])
        data_column = options.get('data_column', 'A')
        sn_table = options.get('sn_table', '整机SN关联表')
        date_table = options.get('date_table', '整机出货年月')
        sn_range = options.get('sn_range', '$B$3:$B$31')
        search_range = options.get('search_range', '$C$3:$G$31')
        lookup_range = options.get('lookup_range', '$B$2:$C$30')
        date_format = options.get('date_format', 'YYYY-MM-DD')
        
        # Ensure check_columns and source_columns have same length
        if len(check_columns) != len(source_columns):
            logger.error(f"Mismatch: {len(check_columns)} check columns but {len(source_columns)} source columns")
            return 0.0
        
        logger.info(f"Verifying IFERROR(TEXT(VLOOKUP(INDEX(SMALL(IF(COUNTIF))))) formulas in file: {result}")
        logger.info(f"Check columns: {check_columns}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Source columns: {source_columns}")
        logger.info(f"Expected functions: {expected_functions}")
        logger.info(f"SN table: {sn_table}, Date table: {date_table}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row
        
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:
                    break
            else:
                empty_count = 0
                end_row = row_num
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Check each column and row
        all_passed = True
        checked_count = 0
        passed_count = 0
        
        for col_idx, check_column in enumerate(check_columns):
            source_column = source_columns[col_idx] if col_idx < len(source_columns) else check_column
            logger.info(f"Checking column {check_column} with source column {source_column} (rows {start_row} to {end_row})")
            
            for row_num in range(start_row, end_row + 1):
                cell_coord = f"{check_column}{row_num}"
                checked_count += 1
                
                try:
                    cell = ws[cell_coord]
                    
                    # Check if cell contains a formula
                    if cell.data_type != "f":
                        logger.warning(f"Cell {cell_coord} does not contain a formula")
                        all_passed = False
                        continue
                    
                    # Get formula text
                    formula_text = None
                    if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                        formula_text = cell._value
                    elif hasattr(cell, "formula"):
                        formula_text = cell.formula
                    elif cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                    # Handle ArrayFormula object
                    elif hasattr(cell, "_value") and cell._value is not None:
                        from openpyxl.worksheet.formula import ArrayFormula
                        if isinstance(cell._value, ArrayFormula):
                            try:
                                formula_text = cell._value.text
                                if formula_text and not formula_text.startswith("="):
                                    formula_text = f"={formula_text}"
                            except (AttributeError, TypeError):
                                formula_text = str(cell._value)
                                if not formula_text.startswith("="):
                                    formula_text = f"={formula_text}"
                    
                    if formula_text is None:
                        logger.warning(f"Could not extract formula from cell {cell_coord}")
                        all_passed = False
                        continue
                    
                    if not formula_text.startswith("="):
                        formula_text = f"={formula_text}"
                    
                    formula_upper = formula_text.upper()
                    logger.debug(f"Cell {cell_coord} formula: {formula_text[:200]}...")
                    
                    # Check 1: Formula contains all expected functions
                    for func_name in expected_functions:
                        func_pattern = rf'\b{func_name}\s*\('
                        if not re.search(func_pattern, formula_upper):
                            logger.warning(f"Cell {cell_coord} formula does not contain {func_name} function")
                            logger.warning(f"  Formula: {formula_text[:200]}...")
                            all_passed = False
                            break
                    else:
                        # All functions found, continue with other checks
                        pass
                    
                    if not all_passed:
                        continue
                    
                    # Check 2: Formula contains IFERROR
                    iferror_pattern = r'\bIFERROR\s*\('
                    if not re.search(iferror_pattern, formula_upper):
                        logger.warning(f"Cell {cell_coord} formula does not contain IFERROR function")
                        all_passed = False
                        continue
                    
                    # Check 3: Formula contains TEXT with date format
                    # TEXT function may have nested functions as first parameter, so we check separately
                    text_func_pattern = r'\bTEXT\s*\('
                    if not re.search(text_func_pattern, formula_upper):
                        logger.warning(f"Cell {cell_coord} formula does not contain TEXT function")
                        logger.warning(f"  Formula: {formula_text[:200]}...")
                        all_passed = False
                        continue
                    
                    # Check if date format string exists in formula (may be in quotes)
                    date_format_escaped = re.escape(date_format)
                    format_pattern1 = rf'["\']{date_format_escaped}["\']'  # "YYYY-MM-DD" or 'YYYY-MM-DD'
                    format_pattern2 = date_format_escaped  # Just YYYY-MM-DD
                    if not (re.search(format_pattern1, formula_text) or date_format in formula_text):
                        logger.warning(f"Cell {cell_coord} formula does not contain date format {date_format}")
                        logger.warning(f"  Formula: {formula_text[:200]}...")
                        all_passed = False
                        continue
                    
                    # Check 4: Formula contains VLOOKUP
                    vlookup_pattern = r'\bVLOOKUP\s*\('
                    if not re.search(vlookup_pattern, formula_upper):
                        logger.warning(f"Cell {cell_coord} formula does not contain VLOOKUP function")
                        all_passed = False
                        continue
                    
                    # Check 5: Formula contains INDEX
                    index_pattern = r'\bINDEX\s*\('
                    if not re.search(index_pattern, formula_upper):
                        logger.warning(f"Cell {cell_coord} formula does not contain INDEX function")
                        all_passed = False
                        continue
                    
                    # Check 6: Formula contains SMALL
                    small_pattern = r'\bSMALL\s*\('
                    if not re.search(small_pattern, formula_upper):
                        logger.warning(f"Cell {cell_coord} formula does not contain SMALL function")
                        all_passed = False
                        continue
                    
                    # Check 7: Formula contains IF
                    if_pattern = r'\bIF\s*\('
                    if not re.search(if_pattern, formula_upper):
                        logger.warning(f"Cell {cell_coord} formula does not contain IF function")
                        all_passed = False
                        continue
                    
                    # Check 8: Formula contains COUNTIF
                    countif_pattern = r'\bCOUNTIF\s*\('
                    if not re.search(countif_pattern, formula_upper):
                        logger.warning(f"Cell {cell_coord} formula does not contain COUNTIF function")
                        all_passed = False
                        continue
                    
                    # Check 9: Formula contains ROW
                    row_pattern = r'\bROW\s*\('
                    if not re.search(row_pattern, formula_upper):
                        logger.warning(f"Cell {cell_coord} formula does not contain ROW function")
                        all_passed = False
                        continue
                    
                    # Check 10: Formula references SN table
                    sn_table_escaped = re.escape(sn_table)
                    if not re.search(sn_table_escaped, formula_text, re.IGNORECASE):
                        logger.warning(f"Cell {cell_coord} formula does not reference SN table {sn_table}")
                        logger.warning(f"  Formula: {formula_text[:200]}...")
                        all_passed = False
                        continue
                    
                    # Check 11: Formula references date table
                    date_table_escaped = re.escape(date_table)
                    if not re.search(date_table_escaped, formula_text, re.IGNORECASE):
                        logger.warning(f"Cell {cell_coord} formula does not reference date table {date_table}")
                        logger.warning(f"  Formula: {formula_text[:200]}...")
                        all_passed = False
                        continue
                    
                    # Check 12: Formula contains COUNTIF condition check (>0)
                    countif_condition_pattern = r'COUNTIF\s*\([^)]+\)\s*>\s*0'
                    if not re.search(countif_condition_pattern, formula_upper):
                        logger.warning(f"Cell {cell_coord} formula does not contain COUNTIF(...)>0 condition")
                        logger.warning(f"  Formula: {formula_text[:200]}...")
                        all_passed = False
                        continue
                    
                    # Check 13: Formula references source column (with $ for absolute reference in first row)
                    # For row 2, should reference $A$2, $C$2, etc. (absolute column, absolute row)
                    # For other rows, may use relative or absolute references
                    # Use string concatenation to avoid regex group reference errors
                    source_ref_pattern1 = r'\$' + source_column + r'\$' + str(start_row) + r'\b'  # $A$2 format
                    source_ref_pattern2 = r'["\']\*\s*["\']\s*&\s*\$' + source_column + r'\$' + str(start_row) + r'\s*&\s*["\']\*\s*["\']'  # "*"&$A$2&"*" format
                    source_ref_pattern3 = r'["\']\*\s*["\']\s*&\s*' + source_column + str(start_row) + r'\s*&\s*["\']\*\s*["\']'  # "*"&A2&"*" format (relative)
                    if not (re.search(source_ref_pattern1, formula_text, re.IGNORECASE) or 
                            re.search(source_ref_pattern2, formula_text, re.IGNORECASE) or
                            re.search(source_ref_pattern3, formula_text, re.IGNORECASE)):
                        # Also check if it references the corresponding row (for copied formulas)
                        source_cell_pattern = source_column + str(row_num) + r'\b'
                        if not re.search(source_cell_pattern, formula_text, re.IGNORECASE):
                            logger.warning(f"Cell {cell_coord} formula does not reference source column {source_column} (expected {source_column}{start_row} or {source_column}{row_num})")
                            logger.warning(f"  Formula: {formula_text[:200]}...")
                            all_passed = False
                            continue
                    
                    # Check 14: Formula structure contains wildcard pattern "*"&cell&"*"
                    # Allow for quoted wildcards: "*"&cell&"*" or '*"&cell&"*'
                    wildcard_start_pattern = r'["\']\*\s*["\']\s*&'
                    wildcard_end_pattern = r'&\s*["\']\*\s*["\']'
                    has_wildcard_start = re.search(wildcard_start_pattern, formula_text)
                    has_wildcard_end = re.search(wildcard_end_pattern, formula_text)
                    if not (has_wildcard_start and has_wildcard_end):
                        logger.warning(f"Cell {cell_coord} formula does not contain wildcard pattern \"*\"&cell&\"*\"")
                        logger.warning(f"  Formula: {formula_text[:200]}...")
                        all_passed = False
                        continue
                    
                    # Check 15: Formula contains 1E+099 or similar large number (for IF false value)
                    large_number_pattern = r'1E\s*\+\s*099|1E\+099|999999|9\.9E\+|1E\+9'
                    if not re.search(large_number_pattern, formula_upper):
                        logger.warning(f"Cell {cell_coord} formula does not contain large number (1E+099) for IF false value")
                        logger.warning(f"  Formula: {formula_text[:200]}...")
                        all_passed = False
                        continue
                    
                    logger.info(f"✓ Cell {cell_coord} has valid IFERROR(TEXT(VLOOKUP(INDEX(SMALL(IF(COUNTIF))))) formula")
                    passed_count += 1
                    
                except Exception as e:
                    logger.error(f"Error checking cell {cell_coord}: {e}")
                    import traceback
                    logger.error(traceback.format_exc())
                    all_passed = False
        
        if all_passed and checked_count > 0:
            logger.info("=" * 60)
            logger.info(f"✓ All cells contain correct IFERROR(TEXT(VLOOKUP(INDEX(SMALL(IF(COUNTIF))))) formulas")
            logger.info(f"  - Checked: {checked_count} cells")
            logger.info(f"  - Passed: {passed_count} cells")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ IFERROR(TEXT(VLOOKUP(INDEX(SMALL(IF(COUNTIF))))) formula verification failed")
            logger.error(f"  - Checked: {checked_count} cells")
            logger.error(f"  - Passed: {passed_count} cells")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0

def verify_text_sort_filter_date(result: str, expected: str = None, **options) -> float:
    """
    Verify if TEXT(SORT(FILTER(...))) formula exists to sort and format dates.
    
    This function checks:
    1. Whether specified cell contains TEXT, SORT, and FILTER functions
    2. Whether FILTER condition is correct (B:B<>"")
    3. Whether SORT parameters are correct (1, 1 for ascending)
    4. Whether TEXT format is correct ("yyyy-m-dd")
    5. Whether formula structure matches expected pattern
    
    Expected formula pattern:
    B2=TEXT(SORT(FILTER(B:B; B:B<>""); 1; 1); "yyyy-m-dd")
    Note: LibreOffice Calc uses semicolons (;) as parameter separators
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_column: Column to check for formula (e.g., "B")
            - start_row: Starting row number (e.g., 2)
            - source_column: Column containing source dates (e.g., "B")
            - expected_functions: List of expected function names (default: ["TEXT", "SORT", "FILTER"])
            - data_column: Column to use for auto-detecting end row (e.g., "B")
            - date_format: Expected date format string (e.g., "yyyy-m-dd")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.worksheet.formula import ArrayFormula
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_column = options.get('check_column', 'B')
        start_row = options.get('start_row', 2)
        source_column = options.get('source_column', 'B')
        expected_functions = options.get('expected_functions', ['TEXT', 'SORT', 'FILTER'])
        data_column = options.get('data_column', 'B')
        date_format = options.get('date_format', 'yyyy-m-dd')
        
        logger.info(f"Verifying TEXT(SORT(FILTER(...))) formula in file: {result}")
        logger.info(f"Check column: {check_column}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Source column: {source_column}")
        logger.info(f"Expected functions: {expected_functions}")
        logger.info(f"Date format: {date_format}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check the first cell (start_row) for the formula
        # For array formulas, the formula might be in the first cell, and results spill to other cells
        # Try to find the formula in nearby cells if not found in the exact cell
        cell_coord = f"{check_column}{start_row}"
        checked_count = 0
        passed_count = 0
        
        # Try multiple cells: the target cell and nearby cells (for array formula spill)
        # Also try alternative columns (B and C) in case formula was entered in different column
        cells_to_check = [
            f"{check_column}{start_row}",  # Primary cell
        ]
        if start_row > 1:
            cells_to_check.append(f"{check_column}{start_row - 1}")  # Row above
        cells_to_check.append(f"{check_column}{start_row + 1}")  # Row below
        
        # Also try alternative columns (B or C) if check_column is one of them
        if check_column == "C":
            cells_to_check.extend([
                f"B{start_row}",
                f"B{start_row - 1}" if start_row > 1 else None,
                f"B{start_row + 1}",
            ])
        elif check_column == "B":
            cells_to_check.extend([
                f"C{start_row}",
                f"C{start_row - 1}" if start_row > 1 else None,
                f"C{start_row + 1}",
            ])
        
        # Remove None values and duplicates, keep order
        cells_to_check = [c for c in cells_to_check if c is not None]
        cells_to_check = list(dict.fromkeys(cells_to_check))
        
        formula_found = False
        cell_with_formula = None
        formula_text = None
        
        for cell_coord_to_try in cells_to_check:
            try:
                cell = ws[cell_coord_to_try]
                checked_count += 1
                
                # Check if cell contains a formula
                if cell.data_type == "f":
                    cell_with_formula = cell
                    formula_found = True
                    cell_coord = cell_coord_to_try
                    break
            except:
                continue
        
        if not formula_found:
            # If no formula found, check the primary cell anyway for detailed error message
            try:
                cell = ws[f"{check_column}{start_row}"]
                logger.warning(f"Cell {check_column}{start_row} does not contain a formula (data_type: {cell.data_type})")
                logger.warning(f"  Cell value: {cell.value}, Cell type: {type(cell.value)}")
            except:
                pass
            
            # Also check if there are formulas in nearby cells
            logger.warning(f"Checking nearby cells for formula...")
            for row_offset in [-1, 0, 1, 2]:
                try:
                    check_row = start_row + row_offset
                    if check_row < 1:
                        continue
                    nearby_cell = ws[f"{check_column}{check_row}"]
                    logger.warning(f"  {check_column}{check_row}: data_type={nearby_cell.data_type}, value={nearby_cell.value}")
                except:
                    pass
            
            logger.error("=" * 60)
            logger.error(f"✗ TEXT(SORT(FILTER(...))) formula verification failed")
            logger.error(f"  - Checked: {checked_count} cells")
            logger.error(f"  - Passed: {passed_count} cells")
            logger.error("=" * 60)
            return 0.0
        
        try:
            cell = cell_with_formula
            
            # Get formula text - try multiple methods for LibreOffice compatibility
            # Note: Array formulas are entered with Ctrl+Shift+Enter and displayed as {=formula}
            # In openpyxl, array formulas are stored as ArrayFormula objects
            formula_text = None
            
            # Method 1: Handle ArrayFormula object (for array formulas)
            if hasattr(cell, "_value") and cell._value is not None:
                from openpyxl.worksheet.formula import ArrayFormula
                if isinstance(cell._value, ArrayFormula):
                    # ArrayFormula object has 'text' attribute containing the formula
                    try:
                        formula_text = cell._value.text
                        if formula_text:
                            logger.debug(f"Cell {cell_coord} array formula extracted from ArrayFormula.text")
                        else:
                            # If text is None or empty, try to get from ref or convert to string
                            formula_text = str(cell._value)
                            logger.debug(f"Cell {cell_coord} array formula extracted from ArrayFormula (converted to string)")
                    except (AttributeError, TypeError) as e:
                        # Fallback: convert to string
                        formula_text = str(cell._value)
                        logger.debug(f"Cell {cell_coord} array formula extracted from ArrayFormula (fallback to string): {e}")
                elif isinstance(cell._value, str):
                    raw_value = cell._value
                    # Handle array formula format {=formula}
                    if raw_value.startswith("{") and raw_value.endswith("}"):
                        # Remove curly braces for array formula
                        formula_text = raw_value[1:-1]  # Remove { and }
                        logger.debug(f"Cell {cell_coord} array formula extracted from _value (removed braces)")
                    elif raw_value.startswith("="):
                        formula_text = raw_value
                        logger.debug(f"Cell {cell_coord} formula extracted from _value")
                    # Check if it looks like a formula without = prefix
                    elif any(func in raw_value.upper() for func in ['TEXT', 'SORT', 'FILTER']):
                        # Handle array formula without = prefix
                        if raw_value.startswith("{") and raw_value.endswith("}"):
                            formula_text = f"={raw_value[1:-1]}"  # Remove braces and add =
                        else:
                            formula_text = f"={raw_value}"  # Add = prefix
                        logger.debug(f"Cell {cell_coord} formula extracted from _value (added = prefix)")
            # Method 2: Try formula attribute
            elif hasattr(cell, "formula") and cell.formula:
                raw_formula = cell.formula
                # Handle array formula format
                if raw_formula.startswith("{") and raw_formula.endswith("}"):
                    formula_text = raw_formula[1:-1]  # Remove braces
                    logger.debug(f"Cell {cell_coord} array formula extracted from formula attribute")
                else:
                    formula_text = raw_formula
                    logger.debug(f"Cell {cell_coord} formula extracted from formula attribute")
            # Method 3: Try value attribute (for some LibreOffice saved files)
            elif cell.value is not None:
                from openpyxl.worksheet.formula import ArrayFormula
                if isinstance(cell.value, ArrayFormula):
                    # ArrayFormula object has 'text' attribute
                    try:
                        formula_text = cell.value.text
                        if formula_text:
                            logger.debug(f"Cell {cell_coord} array formula extracted from value ArrayFormula.text")
                        else:
                            formula_text = str(cell.value)
                            logger.debug(f"Cell {cell_coord} array formula extracted from value ArrayFormula (converted to string)")
                    except (AttributeError, TypeError) as e:
                        formula_text = str(cell.value)
                        logger.debug(f"Cell {cell_coord} array formula extracted from value ArrayFormula (fallback to string): {e}")
                elif isinstance(cell.value, str):
                    raw_value = cell.value
                    # Handle array formula format
                    if raw_value.startswith("{") and raw_value.endswith("}"):
                        formula_text = raw_value[1:-1]  # Remove braces
                        logger.debug(f"Cell {cell_coord} array formula extracted from value")
                    elif raw_value.startswith("="):
                        formula_text = raw_value
                        logger.debug(f"Cell {cell_coord} formula extracted from value")
            
            if not formula_text:
                logger.warning(f"Cell {cell_coord} does not contain a formula")
                logger.warning(f"  data_type: {cell.data_type}, value: {cell.value}, type: {type(cell.value)}")
                logger.warning(f"  _value: {getattr(cell, '_value', 'N/A')}, type: {type(getattr(cell, '_value', None))}")
                logger.error("=" * 60)
                logger.error(f"✗ TEXT(SORT(FILTER(...))) formula verification failed")
                logger.error(f"  - Checked: {checked_count} cells")
                logger.error(f"  - Passed: {passed_count} cells")
                logger.error("=" * 60)
                return 0.0
            
            # Ensure formula starts with =
            if not formula_text.startswith("="):
                formula_text = "=" + formula_text
            
            # Remove leading = and normalize
            if formula_text.startswith("="):
                formula_text = formula_text[1:]
            if formula_text.startswith("{"):
                formula_text = formula_text[1:]
            if formula_text.endswith("}"):
                formula_text = formula_text[:-1]
            
            formula_upper = formula_text.upper()
            logger.info(f"Cell {cell_coord} formula: {formula_text[:200]}...")
            
            all_passed = True
            
            # Check 1: Formula contains TEXT function
            text_pattern = r'\bTEXT\s*\('
            if not re.search(text_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula does not contain TEXT function")
                all_passed = False
            
            # Check 2: Formula contains SORT function
            # Support Excel internal prefixes like _xlfn._xlws.SORT
            sort_pattern = r'(_XLFN\._XLWS\.)?SORT\s*\('
            if not re.search(sort_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula does not contain SORT function")
                all_passed = False
            
            # Check 3: Formula contains FILTER function
            # Support Excel internal prefixes like _xlfn._xlws.FILTER
            filter_pattern = r'(_XLFN\._XLWS\.)?FILTER\s*\('
            if not re.search(filter_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula does not contain FILTER function")
                all_passed = False
            
            # Check 4: FILTER condition check (B:B<>"" or B:B<>'')
            # Allow both semicolon and comma as separators (LibreOffice vs Excel)
            filter_condition_pattern1 = rf'{source_column}\s*:\s*{source_column}\s*[<>=]+\s*["\']\s*["\']'  # B:B<>""
            filter_condition_pattern2 = rf'{source_column}\s*:\s*{source_column}\s*[<>=]+\s*["\']\s*["\']'  # B:B<>''
            # Try simpler pattern
            simple_pattern = rf'{source_column}\s*:\s*{source_column}\s*[<>=]+'
            if not re.search(simple_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula does not contain FILTER condition {source_column}:{source_column}<>\"\"")
                all_passed = False
            
            # Check 5: SORT parameters (1, 1 or 1; 1 for ascending)
            # Allow both comma and semicolon separators
            # Support Excel internal prefixes like _xlfn._xlws.SORT
            # Use more flexible pattern to handle nested parentheses
            sort_params_pattern1 = r'(_XLFN\._XLWS\.)?SORT\s*\([^,;)]+,\s*1\s*,\s*1\s*\)'  # SORT(..., 1, 1)
            sort_params_pattern2 = r'(_XLFN\._XLWS\.)?SORT\s*\([^,;)]+;\s*1\s*;\s*1\s*\)'  # SORT(...; 1; 1)
            # Also check for just the parameters pattern (more flexible)
            sort_params_pattern3 = r',\s*1\s*,\s*1\s*\)'  # ..., 1, 1)
            sort_params_pattern4 = r';\s*1\s*;\s*1\s*\)'  # ...; 1; 1)
            # Check if SORT exists and parameters follow
            has_sort = bool(re.search(r'(_XLFN\._XLWS\.)?SORT\s*\(', formula_upper))
            has_params = bool(re.search(sort_params_pattern3, formula_upper) or 
                             re.search(sort_params_pattern4, formula_upper))
            if not (re.search(sort_params_pattern1, formula_upper) or 
                    re.search(sort_params_pattern2, formula_upper) or
                    (has_sort and has_params)):
                logger.warning(f"Cell {cell_coord} formula does not contain SORT with ascending parameters (1, 1 or 1; 1)")
                logger.warning(f"  Formula excerpt: {formula_text[:150]}...")
                all_passed = False
            
            # Check 6: TEXT format string ("yyyy-m-dd" or 'yyyy-m-dd')
            date_format_escaped = re.escape(date_format)
            format_pattern1 = rf'["\']{date_format_escaped}["\']'  # "yyyy-m-dd" or 'yyyy-m-dd'
            if not (re.search(format_pattern1, formula_text) or date_format in formula_text):
                logger.warning(f"Cell {cell_coord} formula does not contain date format {date_format}")
                all_passed = False
            
            if all_passed:
                passed_count += 1
                logger.info(f"✓ Cell {cell_coord} passed all checks")
            else:
                logger.warning(f"✗ Cell {cell_coord} failed some checks")
        
        except Exception as e:
            logger.error(f"Error checking cell {cell_coord}: {e}")
            import traceback
            logger.error(traceback.format_exc())
            all_passed = False
        
        if passed_count == checked_count and checked_count > 0:
            logger.info("=" * 60)
            logger.info(f"✓ TEXT(SORT(FILTER(...))) formula verification passed")
            logger.info(f"  - Checked: {checked_count} cells")
            logger.info(f"  - Passed: {passed_count} cells")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ TEXT(SORT(FILTER(...))) formula verification failed")
            logger.error(f"  - Checked: {checked_count} cells")
            logger.error(f"  - Passed: {passed_count} cells")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_unique_sumif_material_summary(result: str, expected: str = None, **options) -> float:
    """
    Verify if UNIQUE and SUMIF formulas exist to summarize quantities by material code.
    
    This function checks:
    1. Whether H2 contains UNIQUE function referencing source column (G2:INDEX(G:G, COUNTA(G:G)))
    2. Whether I column starting from I2 contains SUMIF formulas
    3. Whether SUMIF formulas reference correct ranges ($G:$G, $F:$F)
    4. Whether SUMIF criteria reference corresponding H column cells (H2, H3, etc.)
    5. Whether formula structure matches expected pattern
    
    Expected formula pattern:
    H2=UNIQUE(G2:INDEX(G:G, COUNTA(G:G)))
    I2=SUMIF($G:$G,H2,$F:$F)
    I3=SUMIF($G:$G,H3,$F:$F)
    ...
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - unique_cell: Cell containing UNIQUE formula (e.g., "H2")
            - unique_source_column: Source column for UNIQUE (e.g., "G")
            - sumif_column: Column containing SUMIF formulas (e.g., "I")
            - sumif_start_row: Starting row for SUMIF formulas (e.g., 2)
            - criteria_range: Range for SUMIF criteria (e.g., "$G:$G")
            - sum_range: Range for SUMIF sum (e.g., "$F:$F")
            - criteria_column: Column containing criteria cells (e.g., "H")
            - data_column: Column to use for auto-detecting end row (e.g., "G")
            - expected_functions: List of expected function names (default: ["UNIQUE", "INDEX", "COUNTA", "SUMIF"])
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.worksheet.formula import ArrayFormula
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        unique_cell = options.get('unique_cell', 'H2')
        unique_source_column = options.get('unique_source_column', 'G')
        unique_start_row = options.get('unique_start_row', 2)
        sumif_column = options.get('sumif_column', 'I')
        sumif_start_row = options.get('sumif_start_row', 2)
        criteria_range = options.get('criteria_range', '$G:$G')
        sum_range = options.get('sum_range', '$F:$F')
        criteria_column = options.get('criteria_column', 'H')
        data_column = options.get('data_column', 'G')
        expected_functions = options.get('expected_functions', ['UNIQUE', 'INDEX', 'COUNTA', 'SUMIF'])
        
        logger.info(f"Verifying UNIQUE and SUMIF formulas in file: {result}")
        logger.info(f"UNIQUE cell: {unique_cell}")
        logger.info(f"UNIQUE source column: {unique_source_column}")
        logger.info(f"SUMIF column: {sumif_column}")
        logger.info(f"SUMIF start row: {sumif_start_row}")
        logger.info(f"Criteria range: {criteria_range}")
        logger.info(f"Sum range: {sum_range}")
        logger.info(f"Expected functions: {expected_functions}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        all_passed = True
        checked_count = 0
        passed_count = 0
        
        # Check 1: UNIQUE formula in H2 with INDEX and COUNTA
        try:
            unique_cell_obj = ws[unique_cell]
            checked_count += 1
            
            # Extract formula text
            formula_text = None
            if hasattr(unique_cell_obj, "_value") and isinstance(unique_cell_obj._value, ArrayFormula):
                formula_text = unique_cell_obj._value.text
            elif hasattr(unique_cell_obj, "value") and isinstance(unique_cell_obj.value, ArrayFormula):
                formula_text = unique_cell_obj.value.text
            elif hasattr(unique_cell_obj, "_value") and isinstance(unique_cell_obj._value, str):
                raw_value = unique_cell_obj._value
                if raw_value.startswith("="):
                    formula_text = raw_value
                elif raw_value.startswith("{") and raw_value.endswith("}"):
                    formula_text = raw_value[1:-1]
            elif hasattr(unique_cell_obj, "formula") and unique_cell_obj.formula:
                formula_text = unique_cell_obj.formula
            elif unique_cell_obj.data_type == "f" and unique_cell_obj.value and isinstance(unique_cell_obj.value, str):
                formula_text = unique_cell_obj.value
            
            if not formula_text:
                logger.warning(f"Cell {unique_cell} does not contain a formula")
                all_passed = False
            else:
                # Ensure formula starts with =
                if not formula_text.startswith("="):
                    formula_text = "=" + formula_text
                
                formula_upper = formula_text.upper()
                logger.info(f"Cell {unique_cell} formula: {formula_text[:200]}...")
                
                # Check UNIQUE function
                unique_pattern = r'(_XLFN\._XLWS\.)?UNIQUE\s*\('
                if not re.search(unique_pattern, formula_upper):
                    logger.warning(f"Cell {unique_cell} formula does not contain UNIQUE function")
                    all_passed = False
                
                # Check INDEX function
                index_pattern = r'(_XLFN\._XLWS\.)?INDEX\s*\('
                if not re.search(index_pattern, formula_upper):
                    logger.warning(f"Cell {unique_cell} formula does not contain INDEX function")
                    all_passed = False
                
                # Check COUNTA function
                counta_pattern = r'(_XLFN\._XLWS\.)?COUNTA\s*\('
                if not re.search(counta_pattern, formula_upper):
                    logger.warning(f"Cell {unique_cell} formula does not contain COUNTA function")
                    all_passed = False
                
                # Check UNIQUE parameter structure: G2:INDEX(G:G, COUNTA(G:G))
                unique_start_escaped = re.escape(str(unique_start_row))
                unique_source_escaped = re.escape(unique_source_column)
                # Check for G2:INDEX pattern
                unique_param_pattern1 = unique_source_escaped + unique_start_escaped + r'\s*:\s*INDEX'
                # Check for INDEX(G:G, COUNTA(G:G)) pattern
                index_param_pattern = r'INDEX\s*\(\s*' + unique_source_escaped + r'\s*:\s*' + unique_source_escaped + r'\s*,\s*COUNTA'
                if not (re.search(unique_param_pattern1, formula_upper) and re.search(index_param_pattern, formula_upper)):
                    logger.warning(f"Cell {unique_cell} formula does not contain expected UNIQUE parameter structure G{unique_start_row}:INDEX({unique_source_column}:{unique_source_column}, COUNTA(...))")
                    all_passed = False
                
                if all_passed:
                    passed_count += 1
                    logger.info(f"✓ Cell {unique_cell} passed UNIQUE check")
        except Exception as e:
            logger.error(f"Error checking cell {unique_cell}: {e}")
            import traceback
            logger.error(traceback.format_exc())
            all_passed = False
        
        # Check 2: SUMIF formulas in I column starting from I2
        # First, determine which rows have UNIQUE values in criteria_column (H column)
        # Only check SUMIF formulas for rows where criteria_column has values
        logger.info(f"Determining rows with UNIQUE values in column {criteria_column}...")
        max_row = ws.max_row
        rows_with_unique_values = []
        
        # Find all rows in criteria_column (H) that have values (from UNIQUE result)
        empty_count = 0
        for row_num in range(sumif_start_row, max_row + 1):
            criteria_cell = ws[f"{criteria_column}{row_num}"]
            if criteria_cell.value is not None and not (isinstance(criteria_cell.value, str) and criteria_cell.value.strip() == ""):
                rows_with_unique_values.append(row_num)
                empty_count = 0
            else:
                empty_count += 1
                # If we find 3 consecutive empty cells, assume we've reached the end
                if empty_count >= 3:
                    break
        
        logger.info(f"Found {len(rows_with_unique_values)} rows with UNIQUE values (rows: {rows_with_unique_values[:10]}{'...' if len(rows_with_unique_values) > 10 else ''})")
        logger.info(f"Checking column {sumif_column} for SUMIF formulas in these {len(rows_with_unique_values)} rows")
        
        if len(rows_with_unique_values) == 0:
            logger.warning(f"No UNIQUE values found in column {criteria_column}")
            all_passed = False
        
        sumif_passed = 0
        sumif_checked = 0
        
        for row_num in rows_with_unique_values:
            cell_coord = f"{sumif_column}{row_num}"
            try:
                cell = ws[cell_coord]
                sumif_checked += 1
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.warning(f"Cell {cell_coord} does not contain a formula (data_type: {cell.data_type})")
                    all_passed = False
                    continue
                
                # Extract formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, ArrayFormula):
                    formula_text = cell._value.text
                elif hasattr(cell, "value") and isinstance(cell.value, ArrayFormula):
                    formula_text = cell.value.text
                elif hasattr(cell, "_value") and isinstance(cell._value, str):
                    raw_value = cell._value
                    if raw_value.startswith("="):
                        formula_text = raw_value
                    elif raw_value.startswith("{") and raw_value.endswith("}"):
                        formula_text = raw_value[1:-1]
                elif hasattr(cell, "formula") and cell.formula:
                    formula_text = cell.formula
                elif cell.value and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula_text = cell.value
                
                if not formula_text:
                    logger.warning(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Ensure formula starts with =
                if not formula_text.startswith("="):
                    formula_text = "=" + formula_text
                
                formula_upper = formula_text.upper()
                
                cell_passed = True
                
                # Check SUMIF function
                sumif_pattern = r'(_XLFN\._XLWS\.)?SUMIF\s*\('
                if not re.search(sumif_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not contain SUMIF function")
                    cell_passed = False
                    all_passed = False
                
                # Check criteria range ($G:$G or G:G)
                criteria_range_clean = criteria_range.replace("$", "")
                # Use re.escape to properly escape range references
                if ':' in criteria_range_clean:
                    criteria_parts = criteria_range_clean.split(':')
                    criteria_part1_escaped = re.escape(criteria_parts[0])
                    criteria_part2_escaped = re.escape(criteria_parts[1])
                    criteria_pattern1 = r'\$' + criteria_part1_escaped + r'\s*:\s*\$' + criteria_part2_escaped
                    criteria_pattern2 = criteria_part1_escaped + r'\s*:\s*' + criteria_part2_escaped
                else:
                    criteria_range_escaped = re.escape(criteria_range_clean)
                    criteria_pattern1 = r'\$' + criteria_range_escaped
                    criteria_pattern2 = criteria_range_escaped
                if not (re.search(criteria_pattern1, formula_upper) or 
                        re.search(criteria_pattern2, formula_upper)):
                    logger.warning(f"Cell {cell_coord} formula does not reference criteria range {criteria_range}")
                    cell_passed = False
                    all_passed = False
                
                # Check sum range ($F:$F or F:F)
                sum_range_clean = sum_range.replace("$", "")
                # Use re.escape to properly escape range references
                if ':' in sum_range_clean:
                    sum_parts = sum_range_clean.split(':')
                    sum_part1_escaped = re.escape(sum_parts[0])
                    sum_part2_escaped = re.escape(sum_parts[1])
                    sum_pattern1 = r'\$' + sum_part1_escaped + r'\s*:\s*\$' + sum_part2_escaped
                    sum_pattern2 = sum_part1_escaped + r'\s*:\s*' + sum_part2_escaped
                else:
                    sum_range_escaped = re.escape(sum_range_clean)
                    sum_pattern1 = r'\$' + sum_range_escaped
                    sum_pattern2 = sum_range_escaped
                if not (re.search(sum_pattern1, formula_upper) or 
                        re.search(sum_pattern2, formula_upper)):
                    logger.warning(f"Cell {cell_coord} formula does not reference sum range {sum_range}")
                    cell_passed = False
                    all_passed = False
                
                # Check criteria cell reference (H2, H3, etc.)
                criteria_cell_pattern = rf'{criteria_column}{row_num}\b'
                if not re.search(criteria_cell_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not reference criteria cell {criteria_column}{row_num}")
                    cell_passed = False
                    all_passed = False
                
                if cell_passed:
                    sumif_passed += 1
                    if sumif_checked <= 3:  # Only log first few
                        logger.info(f"✓ Cell {cell_coord} passed SUMIF check")
            
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                all_passed = False
        
        checked_count += sumif_checked
        passed_count += sumif_passed
        
        # Verification passes if:
        # 1. UNIQUE check passed
        # 2. At least one SUMIF formula exists
        # 3. All rows with UNIQUE values have corresponding SUMIF formulas
        unique_check_passed = (passed_count > sumif_passed) or (sumif_checked == 0 and sumif_passed == 0)
        verification_passed = unique_check_passed and sumif_passed > 0 and sumif_passed == sumif_checked
        
        if verification_passed:
            logger.info("=" * 60)
            logger.info(f"✓ UNIQUE and SUMIF formula verification passed")
            logger.info(f"  - UNIQUE cell checked: 1, passed: {1 if unique_check_passed else 0}")
            logger.info(f"  - SUMIF cells checked: {sumif_checked}, passed: {sumif_passed}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ UNIQUE and SUMIF formula verification failed")
            logger.error(f"  - UNIQUE cell checked: 1, passed: {1 if unique_check_passed else 0}")
            logger.error(f"  - SUMIF cells checked: {sumif_checked}, passed: {sumif_passed}")
            logger.error(f"  - Expected {len(rows_with_unique_values)} SUMIF formulas, found {sumif_passed}")
            logger.error("=" * 60)
            return 0.0
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0

def verify_multi_column_formulas(result: str, expected: str = None, **options) -> float:
    """
    Verify if multiple column formulas exist in Excel file.
    
    This function checks:
    1. Whether B column contains IF, COUNTIF, LOOKUP, ROW functions
    2. Whether D column contains UNIQUE function
    3. Whether E column contains TEXTJOIN and IF functions
    4. Whether F column contains FILTER and TEXTSPLIT functions
    
    Expected formula patterns:
    B column: IF(COUNTIF(...),ROW()-LOOKUP(...),0)
    D column: UNIQUE(...)
    E column: TEXTJOIN(";",1,IF(...))
    F column: FILTER(--TEXTSPLIT(...),--TEXTSPLIT(...)>0)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formula_columns: List of columns to check (e.g., ["B", "D", "E", "F"])
            - expected_functions: List of expected function names
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.worksheet.formula import ArrayFormula
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formula_columns = options.get('formula_columns', ['B', 'D', 'E', 'F'])
        expected_functions = options.get('expected_functions', ['IF', 'COUNTIF', 'LOOKUP', 'ROW', 'UNIQUE', 'TEXTJOIN', 'FILTER', 'TEXTSPLIT'])
        
        logger.info(f"Verifying multi-column formulas in file: {result}")
        logger.info(f"Formula columns: {formula_columns}")
        logger.info(f"Expected functions: {expected_functions}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        all_passed = True
        column_checks = {}
        
        # Check each column for formulas
        for col_letter in formula_columns:
            logger.info(f"Checking column {col_letter} for formulas...")
            col_passed = False
            formulas_found = []
            
            # Scan the column for formulas (check first 100 rows or until we find formulas)
            max_row = min(ws.max_row, 1000)  # Limit scan to first 1000 rows
            for row_num in range(1, max_row + 1):
                cell_coord = f"{col_letter}{row_num}"
                try:
                    cell = ws[cell_coord]
                    
                    # Extract formula text
                    formula_text = None
                    if hasattr(cell, "_value") and isinstance(cell._value, ArrayFormula):
                        formula_text = cell._value.text
                    elif hasattr(cell, "value") and isinstance(cell.value, ArrayFormula):
                        formula_text = cell.value.text
                    elif hasattr(cell, "_value") and isinstance(cell._value, str):
                        raw_value = cell._value
                        if raw_value.startswith("="):
                            formula_text = raw_value
                        elif raw_value.startswith("{") and raw_value.endswith("}"):
                            formula_text = raw_value[1:-1]
                    elif hasattr(cell, "formula") and cell.formula:
                        formula_text = cell.formula
                    elif cell.data_type == "f" and cell.value and isinstance(cell.value, str):
                        formula_text = cell.value
                    
                    if formula_text:
                        # Ensure formula starts with =
                        if not formula_text.startswith("="):
                            formula_text = "=" + formula_text
                        
                        formulas_found.append((cell_coord, formula_text))
                        formula_upper = formula_text.upper()
                        
                        # Check for expected functions based on column
                        if col_letter == "B":
                            # B column should have IF, COUNTIF, LOOKUP, ROW
                            if (re.search(r'(_XLFN\._XLWS\.)?IF\s*\(', formula_upper) and
                                re.search(r'(_XLFN\._XLWS\.)?COUNTIF\s*\(', formula_upper) and
                                re.search(r'(_XLFN\._XLWS\.)?LOOKUP\s*\(', formula_upper) and
                                re.search(r'(_XLFN\._XLWS\.)?ROW\s*\(', formula_upper)):
                                col_passed = True
                                logger.info(f"✓ Found B column formula in {cell_coord}: {formula_text[:100]}...")
                                break
                        elif col_letter == "D":
                            # D column should have UNIQUE
                            if re.search(r'(_XLFN\._XLWS\.)?UNIQUE\s*\(', formula_upper):
                                col_passed = True
                                logger.info(f"✓ Found D column formula in {cell_coord}: {formula_text[:100]}...")
                                break
                        elif col_letter == "E":
                            # E column should have TEXTJOIN and IF
                            if (re.search(r'(_XLFN\._XLWS\.)?TEXTJOIN\s*\(', formula_upper) and
                                re.search(r'(_XLFN\._XLWS\.)?IF\s*\(', formula_upper)):
                                col_passed = True
                                logger.info(f"✓ Found E column formula in {cell_coord}: {formula_text[:100]}...")
                                break
                        elif col_letter == "F":
                            # F column should have FILTER and TEXTSPLIT
                            if (re.search(r'(_XLFN\._XLWS\.)?FILTER\s*\(', formula_upper) and
                                re.search(r'(_XLFN\._XLWS\.)?TEXTSPLIT\s*\(', formula_upper)):
                                col_passed = True
                                logger.info(f"✓ Found F column formula in {cell_coord}: {formula_text[:100]}...")
                                break
                
                except Exception as e:
                    continue
            
            column_checks[col_letter] = col_passed
            if not col_passed:
                logger.warning(f"✗ Column {col_letter} does not contain expected formula")
                all_passed = False
        
        # Final verification
        if all_passed:
            logger.info("=" * 60)
            logger.info(f"✓ Multi-column formula verification passed")
            for col, passed in column_checks.items():
                logger.info(f"  - Column {col}: {'✓' if passed else '✗'}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ Multi-column formula verification failed")
            for col, passed in column_checks.items():
                logger.error(f"  - Column {col}: {'✓' if passed else '✗'}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_sumproduct_condition_count(result: str, expected: str = None, **options) -> float:
    """
    Verify if SUMPRODUCT formula with condition counting exists in specified cell.
    
    This function checks:
    1. Whether specified cell contains SUMPRODUCT formula
    2. Whether formula uses multiplication operator (*) to combine conditions
    3. Whether formula checks column equality condition (e.g., C:C="A")
    4. Whether formula checks non-empty condition (e.g., B:B<>"")
    5. Whether value cell contains expected value (e.g., K1="A")
    
    Expected formula pattern:
    - L1: =SUMPRODUCT((C:C="A")*(B:B<>""))
    - K1: A (value)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formula_cell: Cell containing SUMPRODUCT formula (e.g., "L1")
            - value_cell: Cell containing expected value (e.g., "K1")
            - expected_value: Expected value in value_cell (e.g., "A")
            - condition_column: Column letter for equality condition (e.g., "C")
            - condition_value: Value to check for equality (e.g., "A")
            - non_empty_column: Column letter for non-empty check (e.g., "B")
            - expected_functions: List of expected function names (default: ["SUMPRODUCT"])
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formula_cell = options.get('formula_cell', 'L1')
        value_cell = options.get('value_cell', 'K1')
        expected_value = options.get('expected_value', 'A')
        condition_column = options.get('condition_column', 'C')
        condition_value = options.get('condition_value', 'A')
        non_empty_column = options.get('non_empty_column', 'B')
        expected_functions = options.get('expected_functions', ['SUMPRODUCT'])
        
        logger.info(f"Verifying SUMPRODUCT condition count formula in file: {result}")
        logger.info(f"Formula cell: {formula_cell}, Value cell: {value_cell}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        all_checks_passed = True
        
        # Check 1: Verify value cell contains expected value
        try:
            value_cell_obj = ws[value_cell]
            value_cell_value = value_cell_obj.value
            if value_cell_value is None:
                logger.warning(f"Cell {value_cell} is empty")
                all_checks_passed = False
            elif str(value_cell_value).strip() != str(expected_value).strip():
                logger.warning(f"Cell {value_cell} contains '{value_cell_value}', expected '{expected_value}'")
                all_checks_passed = False
            else:
                logger.info(f"✓ Cell {value_cell} contains expected value: {value_cell_value}")
        except Exception as e:
            logger.error(f"Could not access value cell {value_cell}: {e}")
            all_checks_passed = False
        
        # Check 2: Verify formula cell contains SUMPRODUCT formula
        try:
            formula_cell_obj = ws[formula_cell]
        except Exception as e:
            logger.error(f"Could not access formula cell {formula_cell}: {e}")
            return 0.0
        
        # Check if cell contains a formula
        if formula_cell_obj.data_type != "f":
            logger.error(f"Cell {formula_cell} does not contain a formula")
            return 0.0
        
        # Get formula text
        formula_text = None
        if hasattr(formula_cell_obj, "_value") and isinstance(formula_cell_obj._value, str) and formula_cell_obj._value.startswith("="):
            formula_text = formula_cell_obj._value
        elif hasattr(formula_cell_obj, "formula"):
            formula_text = formula_cell_obj.formula
        elif formula_cell_obj.value is not None and isinstance(formula_cell_obj.value, str) and formula_cell_obj.value.startswith("="):
            formula_text = formula_cell_obj.value
        
        if formula_text is None:
            logger.error(f"Could not extract formula from cell {formula_cell}")
            return 0.0
        
        formula_upper = formula_text.upper()
        logger.debug(f"Cell {formula_cell} formula: {formula_text}")
        
        # Check 3: Formula contains SUMPRODUCT function
        if not re.search(r'\bSUMPRODUCT\s*\(', formula_upper):
            logger.warning(f"Cell {formula_cell} formula does not contain SUMPRODUCT function")
            all_checks_passed = False
        else:
            logger.info(f"✓ Cell {formula_cell} contains SUMPRODUCT function")
        
        # Check 4: Formula uses multiplication operator (*) to combine conditions
        if '*' not in formula_text:
            logger.warning(f"Cell {formula_cell} formula does not use multiplication operator (*) to combine conditions")
            all_checks_passed = False
        else:
            logger.info(f"✓ Cell {formula_cell} formula uses multiplication operator (*)")
        
        # Check 5: Formula checks equality condition (e.g., C:C="A")
        # Pattern: column:column="value" or column:column='value'
        equality_pattern = rf'{condition_column}\s*:\s*{condition_column}\s*=\s*["\']?{re.escape(condition_value)}["\']?'
        if not re.search(equality_pattern, formula_text, re.IGNORECASE):
            logger.warning(f"Cell {formula_cell} formula does not check equality condition {condition_column}:{condition_column}=\"{condition_value}\"")
            all_checks_passed = False
        else:
            logger.info(f"✓ Cell {formula_cell} formula checks equality condition {condition_column}:{condition_column}=\"{condition_value}\"")
        
        # Check 6: Formula checks non-empty condition (e.g., B:B<>"")
        # Pattern: column:column<>"" or column:column<>'' or column:column<>""
        non_empty_pattern = rf'{non_empty_column}\s*:\s*{non_empty_column}\s*<>\s*["\']+["\']*'
        if not re.search(non_empty_pattern, formula_text, re.IGNORECASE):
            logger.warning(f"Cell {formula_cell} formula does not check non-empty condition {non_empty_column}:{non_empty_column}<>\"\"")
            all_checks_passed = False
        else:
            logger.info(f"✓ Cell {formula_cell} formula checks non-empty condition {non_empty_column}:{non_empty_column}<>\"\"")
        
        # Check 7: Formula structure should be SUMPRODUCT((condition1)*(condition2))
        # Check for parentheses around conditions
        if not re.search(r'SUMPRODUCT\s*\(\s*\([^)]+\)\s*\*\s*\([^)]+\)\s*\)', formula_upper):
            logger.warning(f"Cell {formula_cell} formula may not have correct structure SUMPRODUCT((condition1)*(condition2))")
            # This is a warning, not a failure, as formula format may vary
        
        if all_checks_passed:
            logger.info(f"✓ All checks passed for SUMPRODUCT condition count formula")
            return 1.0
        else:
            logger.error(f"✗ SUMPRODUCT condition count formula verification failed")
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_cell_text_format(result: str, expected: str = None, **options) -> float:
    """
    Verify if cells in specified column are formatted as text format.
    
    This function checks:
    1. Whether cells in specified column have text format (number_format="@")
    2. Whether cells contain values (formulas or data)
    
    Text format is identified by number_format="@", which is the format code for text format
    in Excel/LibreOffice. When a cell is formatted as text, numbers will be displayed
    in their full form instead of scientific notation.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_column: Column to check (e.g., "B")
            - start_row: Starting row number (e.g., 1)
            - expected_format: Expected number format (default: "@" for text format)
            - data_column: Column to use for auto-detecting end row (optional, defaults to check_column)
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_column = options.get('check_column', 'B')
        start_row = options.get('start_row', 1)
        expected_format = options.get('expected_format', '@')
        data_column = options.get('data_column', check_column)
        
        logger.info(f"Verifying text format in column {check_column} in file: {result}")
        logger.info(f"Start row: {start_row}, Expected format: {expected_format}")
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=False)
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        max_row = ws.max_row
        end_row = start_row
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:
                    break
            else:
                empty_count = 0
                end_row = row_num
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Check each cell in the specified column
        all_passed = True
        cells_checked = 0
        cells_with_text_format = 0
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{check_column}{row_num}"
            try:
                cell = ws[cell_coord]
                
                # Skip if cell is empty
                if cell.value is None:
                    continue
                
                cells_checked += 1
                
                # Check number format
                cell_format = cell.number_format
                logger.debug(f"Cell {cell_coord} format: {cell_format}, value: {cell.value}")
                
                # Text format is "@" in Excel/LibreOffice
                if cell_format == expected_format or cell_format == "@":
                    cells_with_text_format += 1
                    logger.info(f"✓ Cell {cell_coord} has text format: {cell_format}")
                else:
                    logger.warning(f"Cell {cell_coord} does not have text format. Current format: {cell_format}, expected: {expected_format}")
                    all_passed = False
                    
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                all_passed = False
                continue
        
        if cells_checked == 0:
            logger.error(f"No cells with values found in column {check_column}")
            return 0.0
        
        # At least 90% of cells should have text format (for tolerance)
        format_ratio = cells_with_text_format / cells_checked if cells_checked > 0 else 0
        logger.info(f"Cells checked: {cells_checked}, Cells with text format: {cells_with_text_format}, Ratio: {format_ratio:.2%}")
        
        if format_ratio >= 0.9:
            logger.info(f"✓ Text format verification passed ({format_ratio:.2%} of cells have text format)")
            return 1.0
        else:
            logger.error(f"✗ Text format verification failed ({format_ratio:.2%} of cells have text format, expected >= 90%)")
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_sumproduct_mid_class_size_sum(result: str, expected: str = None, **options) -> float:
    """
    Verify if SUMPRODUCT formulas with MID function exist for class and size aggregation.
    
    This function checks:
    1. Whether cells in formula_range contain SUMPRODUCT formulas with MID function
    2. Whether formulas use --MID to extract class number from header row
    3. Whether formulas check class column (A) and size column (C) conditions
    4. Whether formulas sum quantity column (D)
    5. Whether sum_range contains SUM formulas for totals
    
    Expected formula pattern:
    - G7: =SUMPRODUCT((($A$6:$A$313)=--MID(G$6,1,3))*(($C$6:$C$313)=$F7),$D$6:$D$313)
    - G20: =SUM(G7:G19)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formula_range: Range containing SUMPRODUCT formulas (e.g., "G7:AS19")
            - sum_range: Range containing SUM formulas (e.g., "G20:AS20")
            - expected_functions: List of expected function names (default: ["SUMPRODUCT", "MID"])
            - class_range: Class column range (default: "$A$6:$A$313")
            - size_range: Size column range (default: "$C$6:$C$313")
            - quantity_range: Quantity column range (default: "$D$6:$D$313")
            - header_row: Row number for class headers (default: 6)
            - size_column: Column letter for size values (default: "F")
            - start_row: Starting row for formulas (default: 7)
            - end_row: Ending row for formulas (default: 19)
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formula_range = options.get('formula_range', 'G7:AS19')
        sum_range = options.get('sum_range', 'G20:AS20')
        expected_functions = options.get('expected_functions', ['SUMPRODUCT', 'MID'])
        class_range = options.get('class_range', '$A$6:$A$313')
        size_range = options.get('size_range', '$C$6:$C$313')
        quantity_range = options.get('quantity_range', '$D$6:$D$313')
        header_row = options.get('header_row', 6)
        size_column = options.get('size_column', 'F')
        start_row = options.get('start_row', 7)
        end_row = options.get('end_row', 19)
        
        logger.info(f"Verifying SUMPRODUCT MID class size sum formulas in file: {result}")
        logger.info(f"Formula range: {formula_range}, Sum range: {sum_range}")
        
        # Parse formula range
        try:
            range_clean = formula_range.replace('$', '')
            if ':' in range_clean:
                start_cell, end_cell = range_clean.split(':')
                start_col_letter = ''.join([c for c in start_cell if c.isalpha()])
                start_row_num = int(''.join([c for c in start_cell if c.isdigit()]))
                start_col_idx = column_index_from_string(start_col_letter)
                end_col_letter = ''.join([c for c in end_cell if c.isalpha()])
                end_row_num = int(''.join([c for c in end_cell if c.isdigit()]))
                end_col_idx = column_index_from_string(end_col_letter)
            else:
                logger.error(f"Invalid range format: {formula_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse formula range {formula_range}: {e}")
            return 0.0
        
        # Parse sum range
        try:
            sum_range_clean = sum_range.replace('$', '')
            if ':' in sum_range_clean:
                sum_start_cell, sum_end_cell = sum_range_clean.split(':')
                sum_start_col_letter = ''.join([c for c in sum_start_cell if c.isalpha()])
                sum_row_num = int(''.join([c for c in sum_start_cell if c.isdigit()]))
                sum_start_col_idx = column_index_from_string(sum_start_col_letter)
                sum_end_col_letter = ''.join([c for c in sum_end_cell if c.isalpha()])
                sum_end_col_idx = column_index_from_string(sum_end_col_letter)
            else:
                logger.error(f"Invalid sum range format: {sum_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse sum range {sum_range}: {e}")
            return 0.0
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        all_checks_passed = True
        formula_cells_checked = 0
        formula_cells_passed = 0
        sum_cells_checked = 0
        sum_cells_passed = 0
        
        # Check SUMPRODUCT formulas in formula_range
        logger.info(f"Checking SUMPRODUCT formulas in range {formula_range}")
        for row_num in range(start_row_num, end_row_num + 1):
            for col_idx in range(start_col_idx, end_col_idx + 1):
                col_letter = get_column_letter(col_idx)
                cell_coord = f"{col_letter}{row_num}"
                
                try:
                    cell = ws[cell_coord]
                    
                    # Skip if cell is empty (optional, but we'll check formulas)
                    if cell.value is None:
                        continue
                    
                    formula_cells_checked += 1
                    
                    # Check if cell contains a formula
                    if cell.data_type != "f":
                        logger.warning(f"Cell {cell_coord} does not contain a formula")
                        all_checks_passed = False
                        continue
                    
                    # Get formula text
                    formula_text = None
                    if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                        formula_text = cell._value
                    elif hasattr(cell, "formula"):
                        formula_text = cell.formula
                    elif cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                    
                    if formula_text is None:
                        logger.warning(f"Could not extract formula from cell {cell_coord}")
                        all_checks_passed = False
                        continue
                    
                    formula_upper = formula_text.upper()
                    logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                    
                    # Check 1: Formula contains SUMPRODUCT function
                    if not re.search(r'\bSUMPRODUCT\s*\(', formula_upper):
                        logger.warning(f"Cell {cell_coord} formula does not contain SUMPRODUCT function")
                        all_checks_passed = False
                        continue
                    
                    # Check 2: Formula contains MID function
                    if not re.search(r'\bMID\s*\(', formula_upper):
                        logger.warning(f"Cell {cell_coord} formula does not contain MID function")
                        all_checks_passed = False
                        continue
                    
                    # Check 3: Formula contains --MID pattern (double negation with MID)
                    if not re.search(r'--\s*MID\s*\(', formula_upper):
                        logger.warning(f"Cell {cell_coord} formula does not contain --MID pattern")
                        all_checks_passed = False
                        continue
                    
                    # Check 4: Formula references class_range (A column)
                    class_range_pattern = re.escape(class_range).replace('\\$', '\\$?')
                    if not re.search(class_range_pattern, formula_text):
                        logger.warning(f"Cell {cell_coord} formula does not reference class range {class_range}")
                        all_checks_passed = False
                        continue
                    
                    # Check 5: Formula references size_range (C column)
                    size_range_pattern = re.escape(size_range).replace('\\$', '\\$?')
                    if not re.search(size_range_pattern, formula_text):
                        logger.warning(f"Cell {cell_coord} formula does not reference size range {size_range}")
                        all_checks_passed = False
                        continue
                    
                    # Check 6: Formula references quantity_range (D column)
                    quantity_range_pattern = re.escape(quantity_range).replace('\\$', '\\$?')
                    if not re.search(quantity_range_pattern, formula_text):
                        logger.warning(f"Cell {cell_coord} formula does not reference quantity range {quantity_range}")
                        all_checks_passed = False
                        continue
                    
                    # Check 7: MID function references header row with column reference (e.g., G$6, H$6)
                    mid_header_pattern = rf'{col_letter}\$?{header_row}'
                    if not re.search(mid_header_pattern, formula_text, re.IGNORECASE):
                        logger.warning(f"Cell {cell_coord} formula MID function does not reference header row {col_letter}{header_row}")
                        all_checks_passed = False
                        continue
                    
                    # Check 8: Formula references size column with row reference (e.g., $F7, $F8)
                    size_ref_pattern = rf'\${size_column}\$?{row_num}'
                    if not re.search(size_ref_pattern, formula_text, re.IGNORECASE):
                        logger.warning(f"Cell {cell_coord} formula does not reference size column {size_column}{row_num}")
                        all_checks_passed = False
                        continue
                    
                    formula_cells_passed += 1
                    logger.info(f"✓ Cell {cell_coord} has valid SUMPRODUCT MID formula")
                    
                except Exception as e:
                    logger.error(f"Error checking cell {cell_coord}: {e}")
                    all_checks_passed = False
                    continue
        
        # Check SUM formulas in sum_range
        logger.info(f"Checking SUM formulas in range {sum_range}")
        for col_idx in range(sum_start_col_idx, sum_end_col_idx + 1):
            col_letter = get_column_letter(col_idx)
            cell_coord = f"{col_letter}{sum_row_num}"
            
            try:
                cell = ws[cell_coord]
                sum_cells_checked += 1
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.warning(f"Cell {cell_coord} does not contain a formula")
                    all_checks_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                elif cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula_text = cell.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {cell_coord}")
                    all_checks_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check: Formula contains SUM function
                if not re.search(r'\bSUM\s*\(', formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not contain SUM function")
                    all_checks_passed = False
                    continue
                
                # Check: SUM formula references the correct column range (e.g., G7:G19)
                expected_sum_range = f"{col_letter}{start_row}:{col_letter}{end_row}"
                if expected_sum_range not in formula_text.replace('$', ''):
                    logger.warning(f"Cell {cell_coord} SUM formula does not reference range {expected_sum_range}")
                    all_checks_passed = False
                    continue
                
                sum_cells_passed += 1
                logger.info(f"✓ Cell {cell_coord} has valid SUM formula")
                
            except Exception as e:
                logger.error(f"Error checking sum cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
        
        # Calculate pass ratios
        formula_ratio = formula_cells_passed / formula_cells_checked if formula_cells_checked > 0 else 0
        sum_ratio = sum_cells_passed / sum_cells_checked if sum_cells_checked > 0 else 0
        
        logger.info(f"Formula cells: {formula_cells_passed}/{formula_cells_checked} passed ({formula_ratio:.2%})")
        logger.info(f"Sum cells: {sum_cells_passed}/{sum_cells_checked} passed ({sum_ratio:.2%})")
        
        # At least 90% of cells should pass (for tolerance)
        if formula_ratio >= 0.9 and sum_ratio >= 0.9:
            logger.info(f"✓ SUMPRODUCT MID class size sum verification passed")
            return 1.0
        else:
            logger.error(f"✗ SUMPRODUCT MID class size sum verification failed")
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_data_validation_list(result: str, expected: str = None, **options) -> float:
    """
    Verify if data validation list is set correctly for specified cell.
    
    This function checks:
    1. Whether specified cell has data validation
    2. Whether validation type is list
    3. Whether validation formula1 contains expected values
    4. Whether validation list does not contain spaces (if no_spaces is True)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_cell: Cell to check (e.g., "D11")
            - expected_values: List of expected values in validation list (e.g., ["张三", "李四", "王武", "赵六"])
            - validation_type: Expected validation type (default: "list")
            - no_spaces: Whether to check that validation list does not contain spaces (default: True)
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_cell = options.get('check_cell', 'D11')
        expected_values = options.get('expected_values', [])
        validation_type = options.get('validation_type', 'list')
        no_spaces = options.get('no_spaces', True)
        
        logger.info(f"Verifying data validation list in cell {check_cell} in file: {result}")
        logger.info(f"Expected values: {expected_values}")
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=False)
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Get cell
        try:
            cell = ws[check_cell]
        except Exception as e:
            logger.error(f"Could not access cell {check_cell}: {e}")
            return 0.0
        
        # Get data validations for the worksheet
        data_validations = ws.data_validations.dataValidation
        
        if not data_validations:
            logger.error(f"No data validations found in worksheet")
            return 0.0
        
        # Find data validation that applies to the check_cell
        cell_validations = []
        from openpyxl.utils import column_index_from_string
        
        # Parse check_cell coordinates
        check_col = ''.join([c for c in check_cell if c.isalpha()])
        check_row = int(''.join([c for c in check_cell if c.isdigit()]))
        check_col_idx = column_index_from_string(check_col)
        
        for dv in data_validations:
            # Check if this validation applies to the check_cell
            try:
                for range_str in dv.ranges.ranges:
                    # Try to parse the range
                    range_str_clean = str(range_str).replace('$', '')
                    if ':' in range_str_clean:
                        # It's a range like "D11:D11" or "D11"
                        start_cell, end_cell = range_str_clean.split(':') if ':' in range_str_clean else (range_str_clean, range_str_clean)
                        start_col = ''.join([c for c in start_cell if c.isalpha()])
                        start_row = int(''.join([c for c in start_cell if c.isdigit()]))
                        start_col_idx = column_index_from_string(start_col)
                        end_col = ''.join([c for c in end_cell if c.isalpha()])
                        end_row = int(''.join([c for c in end_cell if c.isdigit()]))
                        end_col_idx = column_index_from_string(end_col)
                        
                        if (start_col_idx <= check_col_idx <= end_col_idx and 
                            start_row <= check_row <= end_row):
                            cell_validations.append(dv)
                            break
                    else:
                        # Single cell
                        if range_str_clean == check_cell:
                            cell_validations.append(dv)
                            break
            except Exception as e:
                logger.debug(f"Error checking range for validation: {e}")
                # Fallback to string matching
                if check_cell in str(dv.ranges):
                    cell_validations.append(dv)
                    continue
        
        if not cell_validations:
            logger.error(f"No data validation found for cell {check_cell}")
            return 0.0
        
        # Use the first validation that applies to the cell
        dv = cell_validations[0]
        logger.debug(f"Found data validation: type={dv.type}, formula1={dv.formula1}")
        
        # Check 1: Validation type (optional check, skip for LibreOffice 25 compatibility)
        # LibreOffice Calc may use different type names in different versions
        # We'll log the type but not fail if it doesn't match
        logger.info(f"Data validation type: {dv.type}")
        # Skip type validation - just log it for debugging
        
        # Check 1.1: Allow blank cells (should be False)
        allow_blank = getattr(dv, 'allowBlank', None)
        if allow_blank is not None:
            if allow_blank:
                logger.warning(f"Data validation allows blank cells, but it should not")
                # Don't fail, just warn
            else:
                logger.info(f"✓ Data validation does not allow blank cells")
        
        # Check 1.2: Show selection list (should be True)
        show_dropdown = getattr(dv, 'showDropDown', None)
        if show_dropdown is None:
            # Try alternative attribute names
            show_dropdown = getattr(dv, 'showDropdown', None)
        if show_dropdown is not None:
            if not show_dropdown:
                logger.warning(f"Data validation does not show selection list, but it should")
                # Don't fail, just warn
            else:
                logger.info(f"✓ Data validation shows selection list")
        
        # Check 2: Parse formula1 to get validation values
        # formula1 can be a comma-separated string like "张三,李四,王武,赵六"
        # or it can reference a cell range like "$B$1:$B$48"
        formula1 = dv.formula1 if hasattr(dv, 'formula1') else None
        
        if formula1 is None:
            logger.error(f"Data validation formula1 is None")
            return 0.0
        
        formula1_str = str(formula1)
        logger.info(f"Data validation formula1 (raw): {repr(formula1)}")
        logger.info(f"Data validation formula1 (str): {formula1_str}")
        
        # Parse formula1 - check if it's a cell range reference
        validation_values = []
        formula1_clean = formula1_str.strip().strip('"').strip("'")
        
        # Check if it's a cell range reference (contains $ or :)
        is_range_reference = '$' in formula1_clean or (':' in formula1_clean and any(c.isalpha() for c in formula1_clean))
        
        if is_range_reference:
            # It's a cell range reference - read values from the range
            logger.info(f"Formula1 is a cell range reference: {formula1_clean}")
            try:
                # Parse the range (e.g., "$B$1:$B$48" or "B1:B48")
                range_str = formula1_clean.replace('$', '')
                if ':' in range_str:
                    start_cell, end_cell = range_str.split(':')
                    # Read all values from the range
                    # Need to get calculated values, not formulas
                    # Load workbook with data_only=True to get calculated values
                    try:
                        wb_data = openpyxl.load_workbook(result, data_only=True)
                        ws_data = wb_data.active
                        for row in ws_data[start_cell:end_cell]:
                            for cell in row:
                                if cell.value is not None:
                                    cell_value = str(cell.value).strip()
                                    # Skip empty strings and formula-like values that didn't calculate
                                    if cell_value and not cell_value.startswith('=') and cell_value not in validation_values:
                                        validation_values.append(cell_value)
                    except Exception as e:
                        logger.warning(f"Failed to load workbook with data_only=True: {e}")
                        # Fallback: try to get values from current worksheet
                        for row in ws[start_cell:end_cell]:
                            for cell in row:
                                if cell.value is not None:
                                    cell_value = str(cell.value).strip()
                                    # Skip formula text, only get non-formula values
                                    if cell_value and not cell_value.startswith('=') and cell_value not in validation_values:
                                        validation_values.append(cell_value)
                else:
                    # Single cell
                    try:
                        wb_data = openpyxl.load_workbook(result, data_only=True)
                        ws_data = wb_data.active
                        cell = ws_data[range_str]
                        if cell.value is not None:
                            cell_value = str(cell.value).strip()
                            if cell_value and not cell_value.startswith('='):
                                validation_values.append(cell_value)
                    except Exception as e:
                        logger.warning(f"Failed to load workbook with data_only=True: {e}")
                        cell = ws[range_str]
                        if cell.value is not None:
                            cell_value = str(cell.value).strip()
                            if cell_value and not cell_value.startswith('='):
                                validation_values.append(cell_value)
                
                logger.info(f"Read values from cell range: {validation_values}")
            except Exception as e:
                logger.warning(f"Failed to read values from cell range: {e}")
                # Fallback: check if expected values appear in formula1 string
                for val in expected_values:
                    if val in formula1_str:
                        validation_values.append(val)
                logger.info(f"Fallback: extracted values from formula1 string: {validation_values}")
        else:
            # It's a direct input list (comma or semicolon separated)
            # Try semicolon first (LibreOffice format)
            if ';' in formula1_clean:
                validation_values = [v.strip().strip('"').strip("'") for v in formula1_clean.split(';') if v.strip()]
                logger.info(f"Parsed as semicolon-separated list: {validation_values}")
            # Try comma (Excel format)
            elif ',' in formula1_clean:
                validation_values = [v.strip().strip('"').strip("'") for v in formula1_clean.split(',') if v.strip()]
                logger.info(f"Parsed as comma-separated list: {validation_values}")
            else:
                # Single value
                single_val = formula1_clean.strip().strip('"').strip("'")
                if single_val:
                    validation_values = [single_val]
                    logger.info(f"Parsed as single value: {validation_values}")
        
        # If we still don't have values, try a flexible approach
        if not validation_values or len(validation_values) < len(expected_values):
            logger.info(f"Trying flexible extraction: checking if expected values appear in formula1")
            found_in_formula = []
            for val in expected_values:
                if val in formula1_str:
                    found_in_formula.append(val)
            if found_in_formula:
                validation_values = found_in_formula
                logger.info(f"Found values in formula1: {validation_values}")
        
        logger.info(f"Final parsed validation values: {validation_values}")
        
        # Check 3: All expected values are in validation list
        # Use flexible matching: check if values are in parsed list OR in formula1 string
        all_values_found = True
        for expected_val in expected_values:
            found = False
            # Check in parsed validation values
            if expected_val in validation_values:
                found = True
            # Also check if value appears in formula1 string (flexible matching)
            elif expected_val in formula1_str:
                found = True
                logger.info(f"Found '{expected_val}' in formula1 string (flexible match)")
            
            if not found:
                logger.warning(f"Expected value '{expected_val}' not found in validation list or formula1")
                all_values_found = False
        
        if not all_values_found:
            logger.error(f"Not all expected values found in validation list")
            return 0.0
        else:
            logger.info(f"✓ All expected values found in validation list")
        
        # Check 4: No spaces in validation list (if no_spaces is True)
        if no_spaces:
            has_spaces = False
            for val in validation_values:
                if val.strip() != val or ' ' in val:
                    logger.warning(f"Validation value '{val}' contains spaces")
                    has_spaces = True
            
            if has_spaces:
                logger.error(f"Validation list contains spaces, which is not allowed")
                return 0.0
            else:
                logger.info(f"✓ Validation list does not contain spaces")
        
        # Check 5: Validation list only contains expected values (no extra values)
        extra_values = [v for v in validation_values if v not in expected_values]
        if extra_values:
            logger.warning(f"Validation list contains extra values: {extra_values}")
            # This is a warning, not a failure, as long as all expected values are present
        
        logger.info(f"✓ Data validation list verification passed")
        return 1.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_iferror_year_text_substitute(result: str, expected: str = None, **options) -> float:
    """
    Verify if IFERROR(YEAR(TEXT(SUBSTITUTE(...)))) formulas exist to extract year from dates.
    
    This function checks:
    1. Whether cells in formula_column contain IFERROR formulas
    2. Whether formulas contain YEAR, TEXT, SUBSTITUTE, and LEFT functions
    3. Whether formulas reference the correct source column with relative row
    4. Whether formula structure is correct: IFERROR(YEAR(TEXT(SUBSTITUTE(...),...)),LEFT(...))
    
    Expected formula pattern:
    - R4: =IFERROR(YEAR(TEXT(SUBSTITUTE(B4,".","-"),"yyyy-mm-dd")),LEFT(B4,4))
    - R5: =IFERROR(YEAR(TEXT(SUBSTITUTE(B5,".","-"),"yyyy-mm-dd")),LEFT(B5,4))
    
    The function automatically detects the number of data rows by checking the source column
    for non-empty cells. It stops checking after finding 3 consecutive empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formula_column: Column with formulas (e.g., "R")
            - source_column: Source column (e.g., "B")
            - start_row: Starting row number (e.g., 4)
            - expected_functions: List of expected function names (default: ["IFERROR", "YEAR", "TEXT", "SUBSTITUTE", "LEFT"])
            - data_column: Column to check for data to determine end_row (default: source_column)
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formula_column = options.get('formula_column', 'R')
        source_column = options.get('source_column', 'B')
        start_row = options.get('start_row', 4)
        expected_functions = options.get('expected_functions', ['IFERROR', 'YEAR', 'TEXT', 'SUBSTITUTE', 'LEFT'])
        data_column = options.get('data_column', source_column)
        
        logger.info(f"Verifying IFERROR YEAR TEXT SUBSTITUTE formulas in file: {result}")
        logger.info(f"Formula column: {formula_column}, Source column: {source_column}, Start row: {start_row}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:
                    break
            else:
                empty_count = 0
                end_row = row_num
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Check formulas in formula column
        all_checks_passed = True
        rows_checked = 0
        rows_passed = 0
        
        for row_num in range(start_row, end_row + 1):
            formula_cell = ws[f"{formula_column}{row_num}"]
            source_cell = ws[f"{source_column}{row_num}"]
            
            # Skip if source cell is empty
            if source_cell.value is None:
                continue
            
            rows_checked += 1
            
            # Check if cell contains a formula
            if formula_cell.data_type != "f":
                logger.warning(f"Cell {formula_column}{row_num} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(formula_cell, "_value") and isinstance(formula_cell._value, str) and formula_cell._value.startswith("="):
                formula = formula_cell._value
            elif hasattr(formula_cell, "formula"):
                formula = formula_cell.formula
            elif formula_cell.value is not None and isinstance(formula_cell.value, str) and formula_cell.value.startswith("="):
                formula = formula_cell.value
            
            if formula is None:
                logger.warning(f"Could not extract formula from cell {formula_column}{row_num}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {formula_column}{row_num} formula: {formula}")
            
            # Check 1: Formula contains all expected functions
            all_functions_found = True
            for func in expected_functions:
                func_pattern = rf'\b{func}\s*\('
                if not re.search(func_pattern, formula_upper):
                    logger.warning(f"Cell {formula_column}{row_num} formula does not contain {func} function")
                    logger.warning(f"Formula: {formula}")
                    all_functions_found = False
                    all_checks_passed = False
                    break
            
            if not all_functions_found:
                continue
            
            # Check 2: Formula contains IFERROR function
            iferror_pattern = r'\bIFERROR\s*\('
            if not re.search(iferror_pattern, formula_upper):
                logger.warning(f"Cell {formula_column}{row_num} formula does not contain IFERROR function")
                all_checks_passed = False
                continue
            
            # Check 3: Formula contains YEAR(TEXT(SUBSTITUTE(...))) structure
            year_text_substitute_pattern = r'\bYEAR\s*\(\s*TEXT\s*\(\s*SUBSTITUTE\s*\('
            if not re.search(year_text_substitute_pattern, formula_upper):
                logger.warning(f"Cell {formula_column}{row_num} formula does not contain YEAR(TEXT(SUBSTITUTE(...))) structure")
                all_checks_passed = False
                continue
            
            # Check 4: SUBSTITUTE function references source column with correct row
            expected_source_cell = f"{source_column}{row_num}"
            if not re.search(rf'{source_column}{row_num}\b', formula, re.IGNORECASE):
                logger.warning(f"Cell {formula_column}{row_num} formula does not reference source cell {expected_source_cell}")
                all_checks_passed = False
                continue
            
            # Check 5: SUBSTITUTE replaces "." with "-"
            if not re.search(r'SUBSTITUTE\s*\([^,]+,\s*["\']\.\s*["\']\s*,\s*["\']-\s*["\']', formula_upper):
                logger.warning(f"Cell {formula_column}{row_num} formula SUBSTITUTE does not replace \".\" with \"-\"")
                all_checks_passed = False
                continue
            
            # Check 6: TEXT function uses date format (flexible check)
            # Since TEXT function may have nested functions as first parameter, we use a simple approach:
            # Check if the formula contains TEXT function and date format components
            # This is more flexible and handles different format string representations
            text_format_match = False
            
            # First check if TEXT function exists (already verified above, but double-check)
            if not re.search(r'\bTEXT\s*\(', formula_upper):
                logger.warning(f"Cell {formula_column}{row_num} formula does not contain TEXT function")
                all_checks_passed = False
                continue
            
            # Check for various format string patterns (with quotes)
            format_patterns = [
                r'["\']yyyy-mm-dd["\']',  # "yyyy-mm-dd" or 'yyyy-mm-dd'
                r'["\']yyyy[_-]mm[_-]dd["\']',  # Allow underscore or hyphen
                r'["\']YYYY-MM-DD["\']',  # Uppercase
                r'["\']YYYY[_-]MM[_-]DD["\']',  # Uppercase with underscore
            ]
            
            for pattern in format_patterns:
                if re.search(pattern, formula_upper):
                    text_format_match = True
                    logger.debug(f"Cell {formula_column}{row_num} TEXT format matched pattern: {pattern}")
                    break
            
            # If no exact match, check if format components exist (very flexible)
            if not text_format_match:
                # Check for year, month, day components in any order
                has_year = 'yyyy' in formula_upper or 'YYYY' in formula_upper
                has_month = 'mm' in formula_upper or 'MM' in formula_upper
                has_day = 'dd' in formula_upper or 'DD' in formula_upper
                
                if has_year and has_month and has_day:
                    # Format string components exist, likely valid
                    text_format_match = True
                    logger.debug(f"Cell {formula_column}{row_num} TEXT format contains yyyy-mm-dd components (flexible match)")
            
            if not text_format_match:
                logger.warning(f"Cell {formula_column}{row_num} formula TEXT does not appear to use date format")
                logger.warning(f"Formula: {formula}")
                # For debugging: show what format strings are actually in the formula
                format_strings = re.findall(r'["\'][^"\']*yyyy[^"\']*["\']|["\'][^"\']*YYYY[^"\']*["\']', formula_upper)
                if format_strings:
                    logger.debug(f"Found format strings in formula: {format_strings}")
                all_checks_passed = False
                continue
            
            # Check 7: LEFT function references source column with correct row
            left_pattern = rf'\bLEFT\s*\(\s*{source_column}{row_num}\s*,\s*4\s*\)'
            if not re.search(left_pattern, formula_upper):
                logger.warning(f"Cell {formula_column}{row_num} formula LEFT does not reference {expected_source_cell} with length 4")
                all_checks_passed = False
                continue
            
            rows_passed += 1
            logger.info(f"✓ Cell {formula_column}{row_num} has valid IFERROR YEAR TEXT SUBSTITUTE formula")
        
        if rows_checked == 0:
            logger.error(f"No rows with data found in column {data_column}")
            return 0.0
        
        # At least 90% of rows should pass (for tolerance)
        pass_ratio = rows_passed / rows_checked if rows_checked > 0 else 0
        logger.info(f"Rows checked: {rows_checked}, Rows passed: {rows_passed}, Ratio: {pass_ratio:.2%}")
        
        if pass_ratio >= 0.9:
            logger.info(f"✓ IFERROR YEAR TEXT SUBSTITUTE formula verification passed ({pass_ratio:.2%} of rows have correct formulas)")
            return 1.0
        else:
            logger.error(f"✗ IFERROR YEAR TEXT SUBSTITUTE formula verification failed ({pass_ratio:.2%} of rows have correct formulas, expected >= 90%)")
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_index_large_offset_match_top5(result: str, expected: str = None, **options) -> float:
    """
    Verify if INDEX(LARGE(OFFSET(MATCH(...)))) and IF(VLOOKUP(MATCH(...))) formulas exist for top 5 lookup.
    
    This function checks:
    1. Whether J column contains INDEX, LARGE, OFFSET, MATCH, COUNTIF, RIGHT, ROW functions
    2. Whether K column contains IF, VLOOKUP, MATCH functions
    3. Whether formulas reference correct ranges and cells
    4. Whether formula structure is correct
    
    Expected formula patterns:
    - J3: =INDEX(B:B,RIGHT(LARGE(((A$4:A$23=N$4)*(OFFSET($B$4,,MATCH(H3,$C$3:$F$3,),20)<>0))*(OFFSET($B$4,,MATCH(H3,$C$3:$F$3,),20)*100+ROW($4:$23)),COUNTIF(H$3:H3,H3)),2))&""
    - K3: =IF(J3="","",VLOOKUP(J3,B:F,MATCH(H3,B$3:F$3,),))
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - j_column: Column with INDEX formula (e.g., "J")
            - k_column: Column with IF VLOOKUP formula (e.g., "K")
            - start_row: Starting row number (e.g., 3)
            - end_row: Ending row number (e.g., 23)
            - j_expected_functions: List of expected functions in J column (default: ["INDEX", "LARGE", "OFFSET", "MATCH", "COUNTIF", "RIGHT", "ROW"])
            - k_expected_functions: List of expected functions in K column (default: ["IF", "VLOOKUP", "MATCH"])
            - product_range: Product range reference (default: "A$4:A$23")
            - product_cell: Product cell reference (default: "N$4")
            - country_header_range: Country header range (default: "$C$3:$F$3")
            - code_column: Code column (default: "B")
            - data_range: Data range for VLOOKUP (default: "B:F")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        j_column = options.get('j_column', 'J')
        k_column = options.get('k_column', 'K')
        start_row = options.get('start_row', 3)
        end_row = options.get('end_row', 23)
        j_expected_functions = options.get('j_expected_functions', ['INDEX', 'LARGE', 'OFFSET', 'MATCH', 'COUNTIF', 'RIGHT', 'ROW'])
        k_expected_functions = options.get('k_expected_functions', ['IF', 'VLOOKUP', 'MATCH'])
        product_range = options.get('product_range', 'A$4:A$23')
        product_cell = options.get('product_cell', 'N$4')
        country_header_range = options.get('country_header_range', '$C$3:$F$3')
        code_column = options.get('code_column', 'B')
        data_range = options.get('data_range', 'B:F')
        
        logger.info(f"Verifying INDEX LARGE OFFSET MATCH TOP5 formulas in file: {result}")
        logger.info(f"J column: {j_column}, K column: {k_column}, Range: {start_row} to {end_row}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        j_rows_checked = 0
        j_rows_passed = 0
        k_rows_checked = 0
        k_rows_passed = 0
        
        # Check J column formulas
        # Note: This is filtered data, not all rows need to have formulas
        # J column uses array formulas (entered with CTRL+SHIFT+ENTER, formatted as {=formula})
        logger.info(f"Checking J column formulas (array formulas)...")
        for row_num in range(start_row, end_row + 1):
            j_cell = ws[f"{j_column}{row_num}"]
            
            # Get formula text - try multiple methods for array formulas
            # Array formulas are entered with Ctrl+Shift+Enter and displayed as {=formula}
            # In openpyxl, array formulas are stored as ArrayFormula objects
            formula = None
            
            # Method 1: Handle ArrayFormula object (for array formulas)
            if hasattr(j_cell, "_value") and j_cell._value is not None:
                from openpyxl.worksheet.formula import ArrayFormula
                if isinstance(j_cell._value, ArrayFormula):
                    # ArrayFormula object has 'text' attribute containing the formula
                    try:
                        formula = j_cell._value.text
                        if formula:
                            logger.debug(f"Cell {j_column}{row_num} array formula extracted from ArrayFormula.text")
                        else:
                            # If text is None or empty, try to get from ref or convert to string
                            formula = str(j_cell._value)
                            logger.debug(f"Cell {j_column}{row_num} array formula extracted from ArrayFormula (converted to string)")
                    except (AttributeError, TypeError) as e:
                        # Fallback: convert to string
                        formula = str(j_cell._value)
                        logger.debug(f"Cell {j_column}{row_num} array formula extracted from ArrayFormula (fallback to string): {e}")
                elif isinstance(j_cell._value, str):
                    raw_value = j_cell._value
                    # Handle array formula format {=formula}
                    if raw_value.startswith("{") and raw_value.endswith("}"):
                        # Remove curly braces for array formula
                        formula = raw_value[1:-1]  # Remove { and }
                        logger.debug(f"Cell {j_column}{row_num} array formula extracted from _value (removed braces)")
                    elif raw_value.startswith("="):
                        formula = raw_value
                        logger.debug(f"Cell {j_column}{row_num} formula extracted from _value")
                    # Check if it looks like a formula without = prefix
                    elif any(func in raw_value.upper() for func in ['INDEX', 'LARGE', 'OFFSET', 'MATCH', 'COUNTIF', 'RIGHT', 'ROW']):
                        # Handle array formula without = prefix
                        if raw_value.startswith("{") and raw_value.endswith("}"):
                            formula = f"={raw_value[1:-1]}"  # Remove braces and add =
                        else:
                            formula = f"={raw_value}"  # Add = prefix
                        logger.debug(f"Cell {j_column}{row_num} formula extracted from _value (added = prefix)")
            
            # Method 2: Try formula attribute
            if formula is None:
                if hasattr(j_cell, "formula") and j_cell.formula:
                    raw_formula = j_cell.formula
                    # Handle array formula format
                    if raw_formula.startswith("{") and raw_formula.endswith("}"):
                        formula = raw_formula[1:-1]  # Remove braces
                        logger.debug(f"Cell {j_column}{row_num} array formula extracted from formula attribute (removed braces)")
                    elif raw_formula.startswith("="):
                        formula = raw_formula
                        logger.debug(f"Cell {j_column}{row_num} formula extracted from formula attribute")
                    else:
                        formula = f"={raw_formula}"  # Add = prefix
                        logger.debug(f"Cell {j_column}{row_num} formula extracted from formula attribute (added = prefix)")
            
            # Method 3: Check if it's a regular formula (data_type == "f")
            if formula is None and j_cell.data_type == "f":
                if j_cell.value is not None and isinstance(j_cell.value, str) and j_cell.value.startswith("="):
                    formula = j_cell.value
                    logger.debug(f"Cell {j_column}{row_num} formula extracted from value (data_type=f)")
            
            # Method 4: Check array_formulas attribute of worksheet
            if formula is None:
                try:
                    # Check if this cell is part of an array formula range
                    if hasattr(ws, 'array_formulas'):
                        from openpyxl.utils import range_boundaries, column_index_from_string
                        col_idx = column_index_from_string(j_column)
                        for af in ws.array_formulas:
                            if af.ref:
                                try:
                                    min_col, min_row, max_col, max_row = range_boundaries(str(af.ref))
                                    if min_col <= col_idx <= max_col and min_row <= row_num <= max_row:
                                        # This cell is in the array formula range
                                        if hasattr(af, 'text') and af.text:
                                            formula = af.text
                                            logger.debug(f"Cell {j_column}{row_num} array formula extracted from ws.array_formulas[].text")
                                        elif hasattr(af, 'formula') and af.formula:
                                            formula = af.formula
                                            logger.debug(f"Cell {j_column}{row_num} array formula extracted from ws.array_formulas[].formula")
                                        break
                                except Exception as e:
                                    logger.debug(f"Error parsing array formula range: {e}")
                                    continue
                except Exception as e:
                    logger.debug(f"Error checking array_formulas: {e}")
            
            if formula is None:
                # Not a formula, skip (this is expected for filtered data)
                logger.debug(f"Cell {j_column}{row_num} has no formula (skipping)")
                continue
            
            # Clean up formula text: remove braces, ensure it starts with =
            if formula:
                # Remove curly braces if present
                formula = formula.strip()
                if formula.startswith("{") and formula.endswith("}"):
                    formula = formula[1:-1].strip()
                # Ensure it starts with =
                if not formula.startswith("="):
                    formula = f"={formula}"
            
            j_rows_checked += 1
            
            formula_upper = formula.upper()
            logger.info(f"Cell {j_column}{row_num} formula: {formula}")
            
            # Check if formula contains all expected functions
            all_functions_found = True
            for func in j_expected_functions:
                func_pattern = rf'\b{func}\s*\('
                if not re.search(func_pattern, formula_upper):
                    logger.warning(f"Cell {j_column}{row_num} formula does not contain {func} function")
                    all_functions_found = False
                    break
            
            if not all_functions_found:
                continue
            
            # Check formula structure: INDEX(B:B,...)
            if not re.search(rf'\bINDEX\s*\(\s*{code_column}\s*:\s*{code_column}\s*,', formula_upper):
                logger.warning(f"Cell {j_column}{row_num} formula INDEX does not reference {code_column}:{code_column}")
                continue
            
            # Check for LARGE function
            if not re.search(r'\bLARGE\s*\(', formula_upper):
                logger.warning(f"Cell {j_column}{row_num} formula does not contain LARGE function")
                continue
            
            # Check for OFFSET and MATCH combination
            if not (re.search(r'\bOFFSET\s*\(', formula_upper) and re.search(r'\bMATCH\s*\(', formula_upper)):
                logger.warning(f"Cell {j_column}{row_num} formula does not contain OFFSET and MATCH")
                continue
            
            # Check for COUNTIF function
            if not re.search(r'\bCOUNTIF\s*\(', formula_upper):
                logger.warning(f"Cell {j_column}{row_num} formula does not contain COUNTIF function")
                continue
            
            # Check for RIGHT function
            if not re.search(r'\bRIGHT\s*\(', formula_upper):
                logger.warning(f"Cell {j_column}{row_num} formula does not contain RIGHT function")
                continue
            
            j_rows_passed += 1
            logger.info(f"✓ Cell {j_column}{row_num} has valid INDEX LARGE OFFSET formula")
        
        # Check K column formulas
        # Note: This is filtered data, not all rows need to have formulas
        # We only check rows that actually contain formulas
        logger.info(f"Checking K column formulas...")
        for row_num in range(start_row, end_row + 1):
            k_cell = ws[f"{k_column}{row_num}"]
            j_cell = ws[f"{j_column}{row_num}"]
            
            # Skip if J cell is empty (K might be empty too)
            if j_cell.value is None:
                continue
            
            # Check if cell contains a formula
            if k_cell.data_type != "f":
                # Not a formula, skip (this is expected for filtered data)
                continue
            
            k_rows_checked += 1
            
            # Get formula text
            formula = None
            if hasattr(k_cell, "_value") and isinstance(k_cell._value, str) and k_cell._value.startswith("="):
                formula = k_cell._value
            elif hasattr(k_cell, "formula"):
                formula = k_cell.formula
            elif k_cell.value is not None and isinstance(k_cell.value, str) and k_cell.value.startswith("="):
                formula = k_cell.value
            
            if formula is None:
                logger.warning(f"Could not extract formula from cell {k_column}{row_num}")
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {k_column}{row_num} formula: {formula}")
            
            # Check if formula contains all expected functions
            all_functions_found = True
            for func in k_expected_functions:
                func_pattern = rf'\b{func}\s*\('
                if not re.search(func_pattern, formula_upper):
                    logger.warning(f"Cell {k_column}{row_num} formula does not contain {func} function")
                    all_functions_found = False
                    break
            
            if not all_functions_found:
                continue
            
            # Check formula structure: IF(J3="","",VLOOKUP(...))
            expected_j_cell = f"{j_column}{row_num}"
            if not re.search(rf'\bIF\s*\(\s*{j_column}{row_num}\s*=\s*["\']+["\']*\s*,', formula_upper):
                logger.warning(f"Cell {k_column}{row_num} formula IF does not check {expected_j_cell} for empty")
                continue
            
            # Check for VLOOKUP function
            if not re.search(r'\bVLOOKUP\s*\(', formula_upper):
                logger.warning(f"Cell {k_column}{row_num} formula does not contain VLOOKUP function")
                continue
            
            # Check VLOOKUP references J column
            if not re.search(rf'VLOOKUP\s*\(\s*{j_column}{row_num}\s*,', formula_upper):
                logger.warning(f"Cell {k_column}{row_num} formula VLOOKUP does not reference {expected_j_cell}")
                continue
            
            # Check for MATCH function in VLOOKUP
            if not re.search(r'VLOOKUP\s*\([^,]+,\s*[^,]+,\s*MATCH\s*\(', formula_upper):
                logger.warning(f"Cell {k_column}{row_num} formula VLOOKUP does not use MATCH for column index")
                continue
            
            k_rows_passed += 1
            logger.info(f"✓ Cell {k_column}{row_num} has valid IF VLOOKUP MATCH formula")
        
        # Calculate pass ratios
        # For filtered data, we only need to verify that formulas exist
        # Both J and K columns must have formulas for verification to succeed
        j_ratio = j_rows_passed / j_rows_checked if j_rows_checked > 0 else 0
        k_ratio = k_rows_passed / k_rows_checked if k_rows_checked > 0 else 0
        
        logger.info(f"J column: {j_rows_passed}/{j_rows_checked} passed ({j_ratio:.2%})")
        logger.info(f"K column: {k_rows_passed}/{k_rows_checked} passed ({k_ratio:.2%})")
        
        # Both J and K columns must have formulas
        if j_rows_checked == 0:
            logger.error(f"✗ No formulas found in J column")
            return 0.0
        
        if k_rows_checked == 0:
            logger.error(f"✗ No formulas found in K column")
            return 0.0
        
        # If both columns have formulas, verification passes (no need for 90% threshold)
        logger.info(f"✓ INDEX LARGE OFFSET MATCH TOP5 formula verification passed (formulas found in both J and K columns)")
        return 1.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_sumproduct_value_regex(result: str, expected: str = None, **options) -> float:
    """
    Verify if SUMPRODUCT formula with VALUE and REGEX functions exists in specified cell.
    
    This function checks:
    1. Whether specified cell contains SUMPRODUCT formula
    2. Whether formula contains VALUE function
    3. Whether formula contains REGEX function
    4. Whether formula references the correct cell range (e.g., C23:C25)
    5. Whether formula structure is correct
    
    Expected formula pattern:
    - C26: =SUMPRODUCT(VALUE(REGEX(C23:C25,"^\d+(\.\d+)?")), VALUE(REGEX(C23:C25,"\d+(\.\d+)?$")))
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formula_cell: Cell containing SUMPRODUCT formula (e.g., "C26")
            - data_range: Cell range referenced in formula (e.g., "C23:C25")
            - expected_functions: List of expected function names (default: ["SUMPRODUCT", "VALUE", "REGEX"])
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formula_cell = options.get('formula_cell', 'C26')
        data_range = options.get('data_range', 'C23:C25')
        expected_functions = options.get('expected_functions', ['SUMPRODUCT', 'VALUE', 'REGEX'])
        
        logger.info(f"Verifying SUMPRODUCT VALUE REGEX formula in file: {result}")
        logger.info(f"Formula cell: {formula_cell}, Data range: {data_range}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        all_checks_passed = True
        
        # Check 1: Verify formula cell contains formula
        try:
            formula_cell_obj = ws[formula_cell]
        except Exception as e:
            logger.error(f"Could not access formula cell {formula_cell}: {e}")
            return 0.0
        
        # Check if cell contains a formula
        if formula_cell_obj.data_type != "f":
            logger.error(f"Cell {formula_cell} does not contain a formula")
            return 0.0
        
        # Get formula text
        formula_text = None
        if hasattr(formula_cell_obj, "_value") and isinstance(formula_cell_obj._value, str) and formula_cell_obj._value.startswith("="):
            formula_text = formula_cell_obj._value
        elif hasattr(formula_cell_obj, "formula"):
            formula_text = formula_cell_obj.formula
        elif formula_cell_obj.value is not None and isinstance(formula_cell_obj.value, str) and formula_cell_obj.value.startswith("="):
            formula_text = formula_cell_obj.value
        
        if formula_text is None:
            logger.error(f"Could not extract formula from cell {formula_cell}")
            return 0.0
        
        formula_upper = formula_text.upper()
        logger.info(f"Cell {formula_cell} formula: {formula_text}")
        
        # Check 2: Formula contains all expected functions
        for func in expected_functions:
            # For REGEX, also check for LibreOffice format _xlfn.ORG.LIBREOFFICE.REGEX
            if func.upper() == 'REGEX':
                func_pattern = rf'\b(REGEX|_XLFN\.ORG\.LIBREOFFICE\.REGEX)\s*\('
            else:
                func_pattern = rf'\b{func}\s*\('
            if not re.search(func_pattern, formula_upper):
                logger.warning(f"Cell {formula_cell} formula does not contain {func} function")
                all_checks_passed = False
            else:
                logger.info(f"✓ Cell {formula_cell} contains {func} function")
        
        # Check 3: Formula references the correct data range
        # Normalize range format (remove $ signs for comparison)
        data_range_normalized = data_range.replace('$', '').upper()
        formula_normalized = formula_text.replace('$', '').upper()
        if data_range_normalized not in formula_normalized:
            logger.warning(f"Cell {formula_cell} formula does not reference data range {data_range}")
            all_checks_passed = False
        else:
            logger.info(f"✓ Cell {formula_cell} formula references data range {data_range}")
        
        # Check 4: Formula structure - SUMPRODUCT should contain VALUE(REGEX(...))
        # Check for VALUE(REGEX(...)) pattern, including LibreOffice format
        # Pattern: VALUE(REGEX(...)) or VALUE(_XLFN.ORG.LIBREOFFICE.REGEX(...))
        value_regex_pattern = r'VALUE\s*\(\s*(REGEX|_XLFN\.ORG\.LIBREOFFICE\.REGEX)\s*\('
        if not re.search(value_regex_pattern, formula_upper):
            logger.warning(f"Cell {formula_cell} formula does not contain VALUE(REGEX(...)) pattern")
            all_checks_passed = False
        else:
            logger.info(f"✓ Cell {formula_cell} formula contains VALUE(REGEX(...)) pattern")
        
        # Check 5: Formula should have two VALUE(REGEX(...)) calls (for multiplication in SUMPRODUCT)
        value_regex_count = len(re.findall(value_regex_pattern, formula_upper))
        if value_regex_count < 2:
            logger.warning(f"Cell {formula_cell} formula should contain at least 2 VALUE(REGEX(...)) calls, found {value_regex_count}")
            all_checks_passed = False
        else:
            logger.info(f"✓ Cell {formula_cell} formula contains {value_regex_count} VALUE(REGEX(...)) calls")
        
        if all_checks_passed:
            logger.info(f"✓ All checks passed for SUMPRODUCT VALUE REGEX formula")
            return 1.0
        else:
            logger.error(f"✗ SUMPRODUCT VALUE REGEX formula verification failed")
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0

def verify_countifs_conditional_formatting(result: str, expected: str = None, **options) -> float:
    """
    Verify conditional formatting with COUNTIFS formula and INT formulas in multiple sheets.
    
    This function checks:
    1. "投保日期" sheet: C2:C79 must have INT(B2) formulas (each cell must be checked)
    2. "出勤日期" sheet: A2:A73 must have conditional formatting with COUNTIFS formula
    3. "出勤日期" sheet: C2:C79 must have INT(B2) formulas (each cell must be checked)
    4. ALL cells in specified ranges must be verified (cannot be missing)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - insurance_sheet_name: Name of insurance sheet (default: "投保日期")
            - insurance_formula_range: Range with INT formulas in insurance sheet (default: "C2:C79")
            - attendance_sheet_name: Name of attendance sheet (default: "出勤日期")
            - attendance_cf_range: Range with conditional formatting in attendance sheet (default: "A2:A73")
            - attendance_formula_range: Range with INT formulas in attendance sheet (default: "C2:C79")
            - expected_cf_formula_pattern: Expected conditional formatting formula (default: "COUNTIFS($投保日期.$A:$A,$A2,$投保日期.$C:$C,$C2)>0")
            - expected_int_formula_pattern: Expected INT formula pattern (default: "INT(B2)")
    
    Returns:
        float: 1.0 if all verifications pass, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        # Get options with defaults
        insurance_sheet_name = options.get('insurance_sheet_name', '投保日期')
        insurance_formula_range = options.get('insurance_formula_range', 'C2:C79')
        attendance_sheet_name = options.get('attendance_sheet_name', '出勤日期')
        attendance_cf_range = options.get('attendance_cf_range', 'A2:A73')
        attendance_formula_range = options.get('attendance_formula_range', 'C2:C79')
        expected_cf_formula_pattern = options.get('expected_cf_formula_pattern', 'COUNTIFS($投保日期.$A:$A,$A2,$投保日期.$C:$C,$C2)>0')
        expected_int_formula_pattern = options.get('expected_int_formula_pattern', 'INT(B2)')
        
        logger.info(f"Verifying COUNTIFS conditional formatting and INT formulas in file: {result}")
        logger.info(f"Insurance sheet '{insurance_sheet_name}': {insurance_formula_range} with INT formulas")
        logger.info(f"Attendance sheet '{attendance_sheet_name}': {attendance_cf_range} with conditional formatting")
        logger.info(f"Attendance sheet '{attendance_sheet_name}': {attendance_formula_range} with INT formulas")
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=False)
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check if sheets exist
        if insurance_sheet_name not in wb.sheetnames:
            logger.error(f"Sheet '{insurance_sheet_name}' not found. Available sheets: {wb.sheetnames}")
            return 0.0
        if attendance_sheet_name not in wb.sheetnames:
            logger.error(f"Sheet '{attendance_sheet_name}' not found. Available sheets: {wb.sheetnames}")
            return 0.0
        
        insurance_ws = wb[insurance_sheet_name]
        attendance_ws = wb[attendance_sheet_name]
        
        # Helper function to parse range
        def parse_range(range_str):
            range_clean = range_str.replace('$', '')
            if ':' in range_clean:
                start_cell, end_cell = range_clean.split(':')
                start_col_letter = ''.join([c for c in start_cell if c.isalpha()])
                start_row = int(''.join([c for c in start_cell if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                end_col_letter = ''.join([c for c in end_cell if c.isalpha()])
                end_row = int(''.join([c for c in end_cell if c.isdigit()]))
                end_col = column_index_from_string(end_col_letter)
                return start_col, start_row, end_col, end_row, start_col_letter
            else:
                raise ValueError(f"Invalid range format: {range_str}")
        
        # Helper function to verify INT formulas in a range
        def verify_int_formulas(ws, sheet_name, formula_range, source_col='B'):
            try:
                start_col, start_row, end_col, end_row, start_col_letter = parse_range(formula_range)
            except Exception as e:
                logger.error(f"Failed to parse range {formula_range}: {e}")
                return False
            
            all_passed = True
            checked_count = 0
            passed_count = 0
            
            for row_num in range(start_row, end_row + 1):
                cell_coord = f"{start_col_letter}{row_num}"
                expected_source_cell = f"{source_col}{row_num}"
                
                try:
                    cell = ws[cell_coord]
                    checked_count += 1
                    
                    # Check if cell contains a formula
                    if cell.data_type != "f":
                        logger.error(f"Sheet '{sheet_name}' cell {cell_coord} does not contain a formula")
                        all_passed = False
                        continue
                    
                    # Get formula text
                    formula_text = None
                    if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                        formula_text = cell._value
                    elif hasattr(cell, "formula"):
                        formula_text = cell.formula
                    elif cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                    
                    if formula_text is None:
                        logger.error(f"Sheet '{sheet_name}' could not extract formula from cell {cell_coord}")
                        all_passed = False
                        continue
                    
                    formula_upper = formula_text.upper()
                    logger.debug(f"Sheet '{sheet_name}' cell {cell_coord} formula: {formula_text}")
                    
                    # Check if formula contains INT function
                    int_pattern = r'\bINT\s*\('
                    if not re.search(int_pattern, formula_upper):
                        logger.error(f"Sheet '{sheet_name}' cell {cell_coord} formula does not contain INT function")
                        logger.error(f"  Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check if formula references the correct source cell (B2, B3, etc.)
                    # Pattern: INT(B2) or INT($B2) or INT(B$2) or INT($B$2)
                    source_pattern = rf'INT\s*\(\s*\$?{source_col}\$?\d+\s*\)'
                    if not re.search(source_pattern, formula_upper):
                        logger.error(f"Sheet '{sheet_name}' cell {cell_coord} formula does not reference {expected_source_cell}")
                        logger.error(f"  Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    passed_count += 1
                    
                except Exception as e:
                    logger.error(f"Sheet '{sheet_name}' error checking cell {cell_coord}: {e}")
                    all_passed = False
            
            if not all_passed or checked_count == 0:
                logger.error(f"Sheet '{sheet_name}' INT formula verification failed")
                logger.error(f"  Checked: {checked_count} cells")
                logger.error(f"  Passed: {passed_count} cells")
                logger.error(f"  Range: {formula_range}")
                return False
            
            logger.info(f"✓ Sheet '{sheet_name}' INT formula verification passed")
            logger.info(f"  - Checked: {checked_count} cells")
            logger.info(f"  - Range: {formula_range}")
            return True
        
        # Step 1: Verify INT formulas in insurance sheet
        logger.info("=" * 60)
        logger.info(f"Step 1: Verifying INT formulas in '{insurance_sheet_name}' sheet")
        logger.info("=" * 60)
        if not verify_int_formulas(insurance_ws, insurance_sheet_name, insurance_formula_range):
            return 0.0
        
        # Step 2: Verify conditional formatting in attendance sheet
        logger.info("=" * 60)
        logger.info(f"Step 2: Verifying conditional formatting in '{attendance_sheet_name}' sheet")
        logger.info("=" * 60)
        
        try:
            cf_start_col, cf_start_row, cf_end_col, cf_end_row, cf_start_col_letter = parse_range(attendance_cf_range)
        except Exception as e:
            logger.error(f"Failed to parse conditional formatting range {attendance_cf_range}: {e}")
            return 0.0
        
        conditional_formattings = attendance_ws.conditional_formatting
        
        if not conditional_formattings:
            logger.error(f"No conditional formatting found in '{attendance_sheet_name}' sheet")
            return 0.0
        
        # Log all conditional formatting rules for debugging
        logger.info(f"Found {len(conditional_formattings)} conditional formatting rule(s)")
        for i, fmt in enumerate(conditional_formattings):
            # Count cell ranges (fmt.cells is MultiCellRange, can't use len())
            cell_range_count = sum(1 for _ in fmt.cells)
            logger.info(f"  CF Rule {i+1}: {cell_range_count} cell range(s), {len(fmt.rules)} rule(s)")
            for j, rge in enumerate(fmt.cells):
                logger.info(f"    Range {j+1}: {rge}")
            for j, r in enumerate(fmt.rules):
                logger.info(f"    Rule {j+1} details:")
                logger.info(f"      - Type: {type(r).__name__}")
                logger.info(f"      - Has formula attribute: {hasattr(r, 'formula')}")
                if hasattr(r, 'formula'):
                    logger.info(f"      - Formula attribute value: {r.formula}")
                    logger.info(f"      - Formula type: {type(r.formula)}")
                    if r.formula:
                        if isinstance(r.formula, list):
                            logger.info(f"      - Formula is a list with {len(r.formula)} item(s)")
                            for k, f in enumerate(r.formula):
                                logger.info(f"        Item {k}: {f} (type: {type(f)})")
                            formula_text = r.formula[0] if len(r.formula) > 0 else None
                        else:
                            formula_text = str(r.formula)
                        if formula_text:
                            logger.info(f"      - Extracted formula text: {formula_text}")
                            logger.info(f"      - Formula text (upper): {formula_text.upper()}")
                        else:
                            logger.info(f"      - Could not extract formula text")
                    else:
                        logger.info(f"      - Formula is empty/None")
                else:
                    logger.info(f"      - No formula attribute")
                logger.info(f"      - All attributes: {dir(r)}")
        
        found_matching_cf = False
        matching_formula = None
        matching_range_cells = None
        
        # Check each conditional formatting rule
        for fmt in conditional_formattings:
            fmt_applies_to_range = False
            for rge in fmt.cells:
                if not (rge.max_col < cf_start_col or rge.min_col > cf_end_col or 
                        rge.max_row < cf_start_row or rge.min_row > cf_end_row):
                    fmt_applies_to_range = True
                    matching_range_cells = rge
                    logger.info(f"Found conditional formatting that applies to target range: {rge}")
                    break
            
            if not fmt_applies_to_range:
                continue
            
            for r in fmt.rules:
                logger.info(f"  Processing rule: {type(r).__name__}")
                logger.info(f"    Rule attributes: {[attr for attr in dir(r) if not attr.startswith('_')]}")
                
                if not hasattr(r, 'formula'):
                    logger.warning(f"    Rule has no 'formula' attribute, skipping")
                    continue
                
                if not r.formula:
                    logger.warning(f"    Rule formula is empty/None, skipping")
                    logger.info(f"    Formula value: {r.formula}")
                    continue
                
                logger.info(f"    Formula raw value: {r.formula}")
                logger.info(f"    Formula type: {type(r.formula)}")
                
                # Extract formula text
                if isinstance(r.formula, list):
                    logger.info(f"    Formula is a list with {len(r.formula)} item(s)")
                    for idx, item in enumerate(r.formula):
                        logger.info(f"      List item {idx}: {item} (type: {type(item)})")
                    formula_text = r.formula[0] if len(r.formula) > 0 else None
                else:
                    formula_text = str(r.formula)
                
                if not formula_text:
                    logger.warning(f"    Could not extract formula text from {r.formula}")
                    continue
                
                formula_upper = formula_text.upper()
                
                logger.info(f"    Extracted formula text: {formula_text}")
                logger.info(f"    Formula text (upper): {formula_upper}")
                logger.info(f"    Checking conditional formatting formula: {formula_text}")
                
                # Check if formula contains COUNTIFS
                countifs_pattern = r'\bCOUNTIFS\s*\('
                if not re.search(countifs_pattern, formula_upper):
                    logger.debug(f"Formula does not contain COUNTIFS: {formula_text}")
                    continue
                
                logger.info(f"  Formula contains COUNTIFS, checking structure...")
                
                # Check for COUNTIFS structure with sheet reference
                # LibreOffice Calc uses . for sheet references: 投保日期.$A:$A
                # Excel also uses . for sheet references: $投保日期.$A:$A
                escaped_sheet_name = re.escape(insurance_sheet_name)
                
                # More flexible matching - check components separately
                has_countifs = re.search(r'\bCOUNTIFS\s*\(', formula_upper)
                if not has_countifs:
                    logger.debug(f"Formula does not contain COUNTIFS: {formula_text}")
                    continue
                
                logger.info(f"  Formula contains COUNTIFS, checking structure...")
                
                # Sheet reference formats (LibreOffice uses .):
                # - $投保日期. or '投保日期'. or 投保日期.
                # Also check for ! format (Excel sometimes uses this)
                has_sheet_ref = (re.search(rf'\$\s*{escaped_sheet_name}\s*\.', formula_upper) or
                                re.search(rf"'\s*{escaped_sheet_name}\s*'\s*\.", formula_upper) or
                                re.search(rf'{escaped_sheet_name}\s*\.', formula_upper) or
                                re.search(rf'\$\s*{escaped_sheet_name}\s*!', formula_upper) or
                                re.search(rf"'\s*{escaped_sheet_name}\s*'\s*!", formula_upper) or
                                re.search(rf'{escaped_sheet_name}\s*!', formula_upper))
                
                # Column references: $A:$A or A:A (with or without $)
                has_a_col_ref = re.search(r'\$\s*A\s*:\s*\$\s*A', formula_upper) or re.search(r'A\s*:\s*A', formula_upper)
                has_c_col_ref = re.search(r'\$\s*C\s*:\s*\$\s*C', formula_upper) or re.search(r'C\s*:\s*C', formula_upper)
                
                # Cell references: $A2 or A2 (with or without $, with row number)
                has_a2_ref = re.search(r'\$\s*A\d+', formula_upper) or re.search(r'A\d+', formula_upper)
                has_c2_ref = re.search(r'\$\s*C\d+', formula_upper) or re.search(r'C\d+', formula_upper)
                
                # Greater than comparison
                has_greater_than = re.search(r'>\s*0', formula_upper)
                
                logger.info(f"  Checks: COUNTIFS=True, SheetRef={bool(has_sheet_ref)}, "
                          f"A_Col={bool(has_a_col_ref)}, C_Col={bool(has_c_col_ref)}, "
                          f"A2_Ref={bool(has_a2_ref)}, C2_Ref={bool(has_c2_ref)}, >0={bool(has_greater_than)}")
                
                # Check if all required components are present
                # Sheet reference is helpful but not strictly required if pattern matches
                if not (has_a_col_ref and has_c_col_ref and has_a2_ref and has_c2_ref and has_greater_than):
                    logger.warning(f"  Formula structure check failed - missing required components")
                    continue
                
                # Since all component checks passed, we can accept the formula
                # The component checks already verified:
                # - COUNTIFS function exists
                # - A:A column reference exists
                # - A2 cell reference exists
                # - C:C column reference exists
                # - C2 cell reference exists
                # - >0 comparison exists
                # - Sheet reference exists (optional but helpful)
                
                logger.info(f"  All component checks passed, accepting formula")
                found_matching_cf = True
                matching_formula = formula_text
                logger.info(f"✓ Found matching COUNTIFS conditional formatting formula")
                logger.info(f"  - Formula: {formula_text}")
                break
            
            if found_matching_cf:
                break
        
        if not found_matching_cf:
            logger.error("✗ No matching COUNTIFS conditional formatting found")
            logger.error("  Please check if:")
            logger.error("  1. Conditional formatting is applied to the correct range")
            logger.error("  2. Formula contains COUNTIFS function")
            logger.error("  3. Formula references the correct columns (A and C)")
            logger.error("  4. Formula has >0 comparison")
            return 0.0
        
        if not matching_range_cells:
            logger.error("✗ Conditional formatting range not found")
            return 0.0
        
        # Verify all cells have conditional formatting
        cf_cf_start_col = matching_range_cells.min_col
        cf_cf_start_row = matching_range_cells.min_row
        cf_cf_end_col = matching_range_cells.max_col
        cf_cf_end_row = matching_range_cells.max_row
        
        if cf_cf_start_col > cf_start_col or cf_cf_end_col < cf_end_col or \
           cf_cf_start_row > cf_start_row or cf_cf_end_row < cf_end_row:
            logger.error("✗ Conditional formatting range does not fully cover target range")
            logger.error(f"  Target range: {attendance_cf_range}")
            logger.error(f"  CF range: cols {cf_cf_start_col}-{cf_cf_end_col}, rows {cf_cf_start_row}-{cf_cf_end_row}")
            return 0.0
        
        total_cf_cells = (cf_end_row - cf_start_row + 1) * (cf_end_col - cf_start_col + 1)
        cells_with_cf = set()
        
        for fmt in conditional_formattings:
            for rge in fmt.cells:
                if not (rge.max_col < cf_start_col or rge.min_col > cf_end_col or 
                        rge.max_row < cf_start_row or rge.min_row > cf_end_row):
                    for r in fmt.rules:
                        if not r.formula:
                            continue
                        formula_text = r.formula[0] if isinstance(r.formula, list) else str(r.formula)
                        formula_upper = formula_text.upper()
                        
                        # Use the same component check logic as above
                        countifs_pattern = r'\bCOUNTIFS\s*\('
                        if not re.search(countifs_pattern, formula_upper):
                            continue
                        
                        # Check all required components
                        has_a_col_ref = re.search(r'\$\s*A\s*:\s*\$\s*A', formula_upper) or re.search(r'A\s*:\s*A', formula_upper)
                        has_c_col_ref = re.search(r'\$\s*C\s*:\s*\$\s*C', formula_upper) or re.search(r'C\s*:\s*C', formula_upper)
                        has_a2_ref = re.search(r'\$\s*A\d+', formula_upper) or re.search(r'A\d+', formula_upper)
                        has_c2_ref = re.search(r'\$\s*C\d+', formula_upper) or re.search(r'C\d+', formula_upper)
                        has_greater_than = re.search(r'>\s*0', formula_upper)
                        
                        # If all components are present, this is a matching rule
                        if has_a_col_ref and has_c_col_ref and has_a2_ref and has_c2_ref and has_greater_than:
                            # Add all cells in the overlapping range
                            for row in range(max(cf_start_row, rge.min_row), min(cf_end_row, rge.max_row) + 1):
                                for col in range(max(cf_start_col, rge.min_col), min(cf_end_col, rge.max_col) + 1):
                                    cells_with_cf.add((row, col))
                            break
        
        missing_cf_cells = []
        for row in range(cf_start_row, cf_end_row + 1):
            for col in range(cf_start_col, cf_end_col + 1):
                if (row, col) not in cells_with_cf:
                    col_letter = get_column_letter(col)
                    missing_cf_cells.append(f"{col_letter}{row}")
        
        if missing_cf_cells:
            logger.error(f"✗ {len(missing_cf_cells)} cells in conditional formatting range do not have conditional formatting")
            logger.error(f"  Missing cells (first 20): {', '.join(missing_cf_cells[:20])}")
            if len(missing_cf_cells) > 20:
                logger.error(f"  ... and {len(missing_cf_cells) - 20} more cells")
            return 0.0
        
        logger.info(f"✓ Conditional formatting verification passed")
        logger.info(f"  - Formula: {matching_formula}")
        logger.info(f"  - Range: {attendance_cf_range} (all {total_cf_cells} cells verified)")
        
        # Step 3: Verify INT formulas in attendance sheet
        logger.info("=" * 60)
        logger.info(f"Step 3: Verifying INT formulas in '{attendance_sheet_name}' sheet")
        logger.info("=" * 60)
        if not verify_int_formulas(attendance_ws, attendance_sheet_name, attendance_formula_range):
            return 0.0
        
        logger.info("=" * 60)
        logger.info(f"✓ All verifications passed")
        logger.info(f"  - Insurance sheet '{insurance_sheet_name}': {insurance_formula_range} ✓")
        logger.info(f"  - Attendance sheet '{attendance_sheet_name}': {attendance_cf_range} (conditional formatting) ✓")
        logger.info(f"  - Attendance sheet '{attendance_sheet_name}': {attendance_formula_range} ✓")
        logger.info("=" * 60)
        return 1.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_if_date_range_display(result: str, expected: str = None, **options) -> float:
    """
    Verify if IF formulas with date range comparison exist in ALL cells of specified range.
    
    This function STRICTLY checks ALL cells in the specified range - no tolerance, no auto-detection.
    Every single cell in the specified range must contain the correct formula.
    
    This function checks:
    1. Whether ALL cells in the specified formula range (e.g., D2:L5) contain formulas
    2. Whether formulas contain IF function
    3. Whether formulas contain array multiplication: ($D$1:$L$1>=$A2)*($D$1:$L$1<=$B2)
    4. Whether formulas reference the correct date range (e.g., $D$1:$L$1)
    5. Whether formulas reference the correct start date column with relative row (e.g., $A2, $A3, etc.)
    6. Whether formulas reference the correct end date column with relative row (e.g., $B2, $B3, etc.)
    7. Whether IF true value is 1
    8. Whether IF false value is empty string ""
    
    The formula =IF(($D$1:$L$1>=$A2)*($D$1:$L$1<=$B2),1,"") works as follows:
    - ($D$1:$L$1>=$A2) returns an array indicating if each date in row 1 is >= start date (A2)
    - ($D$1:$L$1<=$B2) returns an array indicating if each date in row 1 is <= end date (B2)
    - The two arrays are multiplied (*), resulting in 1 where both conditions are true, 0 otherwise
    - IF function returns 1 if the condition is true (non-zero), "" otherwise
    
    IMPORTANT: This function checks ALL cells in the specified formula range. If any cell is missing a formula, verification fails.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formula_range: Range containing formulas (e.g., "D2:L5") - ALL cells must have formulas
            - date_range: Date range reference (default: "$D$1:$L$1")
            - start_date_col: Start date column letter (default: "A")
            - end_date_col: End date column letter (default: "B")
            - expected_functions: List of expected function names (default: ["IF"])
    
    Returns:
        float: 1.0 if ALL cells in specified range contain correct formulas, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formula_range = options.get('formula_range', 'D2:L5')
        date_range = options.get('date_range', '$D$1:$L$1')
        start_date_col = options.get('start_date_col', 'A')
        end_date_col = options.get('end_date_col', 'B')
        expected_functions = options.get('expected_functions', ['IF'])
        
        logger.info(f"Verifying IF date range display formulas in file: {result}")
        logger.info(f"Formula range: {formula_range}")
        logger.info(f"Date range: {date_range}")
        logger.info(f"Start date column: {start_date_col}")
        logger.info(f"End date column: {end_date_col}")
        logger.info(f"Expected functions: {expected_functions}")
        
        # Parse the formula range
        try:
            range_clean = formula_range.replace("$", "")
            if ":" in range_clean:
                start_cell, end_cell = range_clean.split(":")
                start_col_letter = "".join([c for c in start_cell if c.isalpha()])
                start_row = int("".join([c for c in start_cell if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                end_col_letter = "".join([c for c in end_cell if c.isalpha()])
                end_row = int("".join([c for c in end_cell if c.isdigit()]))
                end_col = column_index_from_string(end_col_letter)
            else:
                logger.error(f"Invalid range format: {formula_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse range {formula_range}: {e}")
            return 0.0
        
        # Parse the date range
        try:
            date_range_clean = date_range.replace("$", "")
            if ":" in date_range_clean:
                date_start_cell, date_end_cell = date_range_clean.split(":")
                date_start_col_letter = "".join([c for c in date_start_cell if c.isalpha()])
                date_end_col_letter = "".join([c for c in date_end_cell if c.isalpha()])
            else:
                logger.error(f"Invalid date range format: {date_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse date range {date_range}: {e}")
            return 0.0
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check ALL cells in formula range (both rows and columns)
        logger.info(f"Checking all cells in range {formula_range} (rows {start_row} to {end_row}, cols {start_col_letter} to {end_col_letter})")
        
        all_passed = True
        checked_count = 0
        passed_count = 0
        
        for row_num in range(start_row, end_row + 1):
            for col_num in range(start_col, end_col + 1):
                col_letter = get_column_letter(col_num)
                cell_coord = f"{col_letter}{row_num}"
                expected_start_cell = f"${start_date_col}${row_num}"
                expected_end_cell = f"${end_date_col}${row_num}"
                
                try:
                    cell = ws[cell_coord]
                    checked_count += 1
                    
                    # Check if cell contains a formula
                    if cell.data_type != "f":
                        logger.error(f"Cell {cell_coord} does not contain a formula")
                        all_passed = False
                        continue
                    
                    # Get formula text
                    formula_text = None
                    if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                        formula_text = cell._value
                    elif hasattr(cell, "formula"):
                        formula_text = cell.formula
                    elif cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                    
                    if formula_text is None:
                        logger.error(f"Could not extract formula from cell {cell_coord}")
                        all_passed = False
                        continue
                    
                    formula_upper = formula_text.upper()
                    logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                    
                    # Check 1: Formula contains IF function
                    if_pattern = r'\bIF\s*\('
                    if not re.search(if_pattern, formula_upper):
                        logger.error(f"Cell {cell_coord} formula does not contain IF function")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 2: Formula contains array multiplication pattern
                    # Pattern: ($D$1:$L$1>=$A2)*($D$1:$L$1<=$B2)
                    # Allow variations in spacing and reference format
                    # Check for two parenthesized expressions with * between them
                    array_mult_pattern = r'\(\s*[^)]+\s*\)\s*\*\s*\(\s*[^)]+\s*\)'
                    if not re.search(array_mult_pattern, formula_text):
                        logger.error(f"Cell {cell_coord} formula does not contain array multiplication pattern (two parenthesized expressions with *)")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 3: Formula references the correct date range ($D$1:$L$1)
                    # Allow variations: $D$1:$L$1, D$1:L$1, $D1:$L1, D1:L1
                    date_range_patterns = [
                        rf'\$\s*{re.escape(date_start_col_letter)}\s*\$\s*1\s*:\s*\$\s*{re.escape(date_end_col_letter)}\s*\$\s*1',  # $D$1:$L$1
                        rf'\b{re.escape(date_start_col_letter)}\s*\$\s*1\s*:\s*{re.escape(date_end_col_letter)}\s*\$\s*1',  # D$1:L$1
                        rf'\$\s*{re.escape(date_start_col_letter)}\s*1\s*:\s*\$\s*{re.escape(date_end_col_letter)}\s*1',  # $D1:$L1
                        rf'\b{re.escape(date_start_col_letter)}\s*1\s*:\s*{re.escape(date_end_col_letter)}\s*1',  # D1:L1
                    ]
                    date_range_found = False
                    for pattern in date_range_patterns:
                        if re.search(pattern, formula_upper):
                            date_range_found = True
                            break
                    
                    if not date_range_found:
                        logger.error(f"Cell {cell_coord} formula does not reference date range {date_range}")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 4: Formula references start date column with correct row ($A2, $A3, etc.)
                    # Allow variations: $A2, A$2, $A$2, A2
                    start_date_patterns = [
                        rf'\$\s*{re.escape(start_date_col.upper())}\s*\$\s*{row_num}\b',  # $A$2
                        rf'\$\s*{re.escape(start_date_col.upper())}\s*{row_num}\b',  # $A2
                        rf'\b{re.escape(start_date_col.upper())}\s*\$\s*{row_num}\b',  # A$2
                        rf'\b{re.escape(start_date_col.upper())}\s*{row_num}\b',  # A2
                    ]
                    start_date_found = False
                    for pattern in start_date_patterns:
                        if re.search(pattern, formula_upper):
                            start_date_found = True
                            break
                    
                    if not start_date_found:
                        logger.error(f"Cell {cell_coord} formula does not reference start date cell {expected_start_cell}")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 5: Formula references end date column with correct row ($B2, $B3, etc.)
                    # Allow variations: $B2, B$2, $B$2, B2
                    end_date_patterns = [
                        rf'\$\s*{re.escape(end_date_col.upper())}\s*\$\s*{row_num}\b',  # $B$2
                        rf'\$\s*{re.escape(end_date_col.upper())}\s*{row_num}\b',  # $B2
                        rf'\b{re.escape(end_date_col.upper())}\s*\$\s*{row_num}\b',  # B$2
                        rf'\b{re.escape(end_date_col.upper())}\s*{row_num}\b',  # B2
                    ]
                    end_date_found = False
                    for pattern in end_date_patterns:
                        if re.search(pattern, formula_upper):
                            end_date_found = True
                            break
                    
                    if not end_date_found:
                        logger.error(f"Cell {cell_coord} formula does not reference end date cell {expected_end_cell}")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 6: Formula contains >= comparison for start date
                    greater_equal_pattern = r'>\s*='
                    if not re.search(greater_equal_pattern, formula_text):
                        logger.error(f"Cell {cell_coord} formula does not contain >= comparison")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 7: Formula contains <= comparison for end date
                    less_equal_pattern = r'<\s*='
                    if not re.search(less_equal_pattern, formula_text):
                        logger.error(f"Cell {cell_coord} formula does not contain <= comparison")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 8: IF true value is 1
                    # Pattern: Look for ",1," or ", 1," in the formula
                    # Since we've already verified IF function exists, we can check for the pattern
                    # We need to find ,1, that appears after the condition (which may contain parentheses)
                    # A simpler approach: check if formula contains the pattern ,1, followed by empty string
                    true_value_pattern = r',\s*1\s*,'
                    if not re.search(true_value_pattern, formula_text):
                        logger.error(f"Cell {cell_coord} formula IF true value is not 1")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 9: IF false value is empty string ""
                    # Pattern: Look for "" or " " after ,1,
                    # Check if formula ends with ,1,"") or ,1, "")
                    false_value_patterns = [
                        r',\s*1\s*,\s*""\s*\)',  # ,1,"")
                        r',\s*1\s*,\s*"\s*"\s*\)',  # ,1," ")
                    ]
                    false_value_found = False
                    for pattern in false_value_patterns:
                        if re.search(pattern, formula_text, re.IGNORECASE):
                            false_value_found = True
                            break
                    
                    if not false_value_found:
                        logger.error(f"Cell {cell_coord} formula IF false value is not empty string")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 10: Formula closes parentheses correctly
                    open_count = formula_text.count('(')
                    close_count = formula_text.count(')')
                    if open_count != close_count:
                        logger.error(f"Cell {cell_coord} formula has mismatched parentheses")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    passed_count += 1
                    logger.info(f"✓ Cell {cell_coord} has valid formula: {formula_text}")
                    
                except Exception as e:
                    logger.error(f"Error checking cell {cell_coord}: {e}")
                    all_passed = False
        
        if not all_passed:
            logger.error(f"✗ Formula verification failed: {passed_count}/{checked_count} cells passed")
            return 0.0
        
        if checked_count == 0:
            logger.error(f"No cells found in range {formula_range}")
            return 0.0
        
        logger.info("=" * 60)
        logger.info(f"✓ All {checked_count} cells in range {formula_range} contain correct IF date range formulas")
        logger.info(f"  - All cells passed verification")
        logger.info(f"  - Formula structure: IF(($D$1:$L$1>=$A2)*($D$1:$L$1<=$B2),1,\"\")")
        logger.info("=" * 60)
        return 1.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_count_find_vstack_filter_night_shift(result: str, expected: str = None, **options) -> float:
    """
    Verify if COUNT(FIND("夜",LET(x,VSTACK(...),FILTER(...)))) formulas exist in ALL cells of specified range
    to count night shifts across multiple sheets (Sheet1-Sheet5).
    
    This function checks:
    1. Whether ALL cells in the specified range (e.g., B3:B6) contain formulas
    2. Whether formulas contain COUNT, FIND, LET, VSTACK, FILTER, and CHOOSECOLS functions
    3. Whether FIND function searches for "夜" character
    4. Whether VSTACK function references all 5 sheets (Sheet1-Sheet5) with range A$1:H$17
    5. Whether FILTER function uses CHOOSECOLS(x,1)=A3 (or A4, A5, A6) to filter by name
    6. Whether formula structure sums results from all 5 sheets
    7. Whether each cell references the correct name cell (A3, A4, A5, A6)
    
    IMPORTANT: This function checks ALL cells in the specified range. If any cell is missing a formula, verification fails.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_range: Range to check (e.g., "B3:B6") - ALL cells must have formulas
            - name_col: Column letter for name reference (default: "A")
            - name_start_row: Starting row for name cells (default: 3)
            - expected_functions: List of expected function names (default: ["COUNT", "FIND", "LET", "VSTACK", "FILTER", "CHOOSECOLS"])
            - sheet_names: List of sheet names to check (default: ["Sheet1", "Sheet2", "Sheet3", "Sheet4", "Sheet5"])
            - sheet_range: Range reference in each sheet (default: "A$1:H$17")
            - search_text: Text to search for in FIND function (default: "夜")
    
    Returns:
        float: 1.0 if ALL cells in specified range contain correct formulas, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        # Get options with defaults
        check_range = options.get('check_range', 'B3:B6')
        name_col = options.get('name_col', 'A')
        name_start_row = options.get('name_start_row', 3)
        expected_functions = options.get('expected_functions', ['COUNT', 'FIND', 'LET', 'VSTACK', 'FILTER', 'CHOOSECOLS'])
        sheet_names = options.get('sheet_names', ['Sheet1', 'Sheet2', 'Sheet3', 'Sheet4', 'Sheet5'])
        sheet_range = options.get('sheet_range', 'A$1:H$17')
        search_text = options.get('search_text', '夜')
        
        logger.info(f"Verifying COUNT(FIND(VSTACK(FILTER))) night shift formulas in file: {result}")
        logger.info(f"Range to check: {check_range}")
        logger.info(f"Expected functions: {expected_functions}")
        logger.info(f"Sheet names: {sheet_names}")
        logger.info(f"Sheet range: {sheet_range}")
        logger.info(f"Search text: {search_text}")
        
        # Parse the range
        try:
            range_clean = check_range.replace('$', '')
            if ':' in range_clean:
                start_cell, end_cell = range_clean.split(':')
                start_col_letter = ''.join([c for c in start_cell if c.isalpha()])
                start_row = int(''.join([c for c in start_cell if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                end_col_letter = ''.join([c for c in end_cell if c.isalpha()])
                end_row = int(''.join([c for c in end_cell if c.isdigit()]))
                end_col = column_index_from_string(end_col_letter)
            else:
                logger.error(f"Invalid range format: {check_range}. Expected format like 'B3:B6'")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse range {check_range}: {e}")
            return 0.0
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=False)
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check if Sheet6 exists (where formulas should be)
        result_sheet_name = options.get('result_sheet_name', 'Sheet6')
        if result_sheet_name not in wb.sheetnames:
            logger.error(f"Sheet '{result_sheet_name}' not found. Available sheets: {wb.sheetnames}")
            return 0.0
        
        result_ws = wb[result_sheet_name]
        
        # Check if all source sheets exist
        for sheet_name in sheet_names:
            if sheet_name not in wb.sheetnames:
                logger.error(f"Source sheet '{sheet_name}' not found. Available sheets: {wb.sheetnames}")
                return 0.0
        
        all_passed = True
        checked_count = 0
        passed_count = 0
        
        # Verify each cell in the range
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{start_col_letter}{row_num}"
            expected_name_cell = f"{name_col}{row_num}"
            
            try:
                cell = result_ws[cell_coord]
                checked_count += 1
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.error(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                elif cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula_text = cell.value
                
                if formula_text is None:
                    logger.error(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains all expected functions
                # LibreOffice Calc may use internal names like _xlfn.VSTACK, _xlfn.LET, etc.
                # Also support plain function names for Excel compatibility
                for func_name in expected_functions:
                    # Pattern: VSTACK or _xlfn.VSTACK or _xlfn._xlws.FILTER (FILTER uses _xlws namespace)
                    if func_name == "FILTER":
                        # FILTER uses _xlfn._xlws.FILTER format, but also allow plain FILTER
                        func_pattern = rf'(?:_xlfn\._xlws\.)?{re.escape(func_name)}\s*\('
                    else:
                        # Other functions use _xlfn.FUNCTION or plain FUNCTION (COUNT, FIND may not have prefix)
                        func_pattern = rf'(?:_xlfn\.)?{re.escape(func_name)}\s*\('
                    if not re.search(func_pattern, formula_upper):
                        logger.error(f"Cell {cell_coord} formula does not contain {func_name} function")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        break
                
                if not all_passed:
                    continue
                
                # Check 2: Formula contains FIND("夜", ...)
                # Pattern: FIND("夜",...) or _xlfn.FIND("夜",...)
                find_pattern = rf'(?:_xlfn\.)?FIND\s*\(\s*["\'""]{re.escape(search_text)}["\'""]\s*,'
                if not re.search(find_pattern, formula_text, re.IGNORECASE):
                    logger.error(f"Cell {cell_coord} formula does not contain FIND(\"{search_text}\", ...)")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: Formula contains VSTACK for all 5 sheets
                # Pattern: VSTACK(Sheet1!A$1:H$17) or _xlfn.VSTACK(Sheet1!A$1:H$17) or VSTACK($Sheet1.A$1:H$17)
                # LibreOffice uses ! for sheet references, Excel uses .
                # Note: $ symbols in range may be present or absent
                # IMPORTANT: sheet_name must be uppercased to match formula_upper!
                sheet_range_clean = sheet_range.replace("$", "")
                for sheet_name in sheet_names:
                    sheet_name_upper = sheet_name.upper()  # Convert to uppercase for matching
                    # Check if VSTACK exists and contains the sheet reference
                    # Use a simple approach: check if VSTACK exists and sheet name with range exists
                    has_vstack = re.search(r'(?:_xlfn\.)?VSTACK', formula_upper)
                    # Check for sheet reference pattern: Sheet1!A...H...17 or Sheet1.A...H...17
                    # The range should contain A, some characters, 1, :, H, some characters, 17
                    sheet_ref_pattern = rf'{re.escape(sheet_name_upper)}[!\.]A.*?1.*?:.*?H.*?17'
                    has_sheet_ref = re.search(sheet_ref_pattern, formula_upper)
                    
                    logger.info(f"Checking VSTACK for {sheet_name} (upper: {sheet_name_upper})")
                    logger.debug(f"Has VSTACK: {has_vstack is not None}")
                    logger.debug(f"Has sheet ref pattern: {has_sheet_ref is not None}")
                    logger.debug(f"Sheet ref pattern: {sheet_ref_pattern}")
                    logger.debug(f"Formula (upper, first 200 chars): {formula_upper[:200]}")
                    
                    if not has_vstack:
                        logger.error(f"✗ Cell {cell_coord} formula does not contain VSTACK function")
                        logger.error(f"Full formula: {formula_text}")
                        all_passed = False
                        break
                    
                    if not has_sheet_ref:
                        logger.error(f"✗ Cell {cell_coord} formula does not contain sheet reference for {sheet_name}")
                        logger.error(f"Pattern used: {sheet_ref_pattern}")
                        logger.error(f"Full formula: {formula_text}")
                        # Try to find what sheet references exist
                        all_sheet_refs = re.findall(rf'[A-Z]+\d+[!\.]A[^)]+', formula_upper)
                        logger.error(f"Found sheet references in formula: {all_sheet_refs}")
                        all_passed = False
                        break
                    
                    logger.info(f"✓ Matched VSTACK and sheet reference for {sheet_name}")
                
                if not all_passed:
                    continue
                
                # Check 4: Formula contains FILTER with CHOOSECOLS(x,1)=A3 (or A4, A5, A6)
                # Pattern: FILTER(x,CHOOSECOLS(x,1)=A3) or _xlfn._xlws.FILTER(_xlpm.x,CHOOSECOLS(_xlpm.x,1)=A3)
                # Variable name can be x or _xlpm.x
                # The actual format is: _xlfn._xlws.FILTER(_xlpm.x,_xlfn.CHOOSECOLS(_xlpm.x,1)=A3)
                # Use a more flexible pattern: FILTER followed by CHOOSECOLS with 1 and =A3 (or A4, A5, A6)
                # This allows for whitespace and various formats
                filter_pattern = rf'(?:_xlfn\._xlws\.)?FILTER.*?CHOOSECOLS.*?1.*?=.*?{re.escape(name_col)}{row_num}'
                logger.debug(f"Checking FILTER pattern: {filter_pattern}")
                logger.debug(f"Looking for FILTER with CHOOSECOLS(x,1)={expected_name_cell}")
                match_result = re.search(filter_pattern, formula_upper)
                if not match_result:
                    logger.error(f"✗ Cell {cell_coord} formula does not contain FILTER with CHOOSECOLS(x,1)={expected_name_cell}")
                    logger.error(f"Pattern used: {filter_pattern}")
                    logger.error(f"Formula: {formula_text}")
                    # Try to find what FILTER patterns exist
                    all_filter = re.findall(r'(?:_xlfn\._xlws\.)?FILTER\s*\([^)]+\)', formula_upper)
                    logger.error(f"Found FILTER patterns in formula: {all_filter}")
                    # Try to find CHOOSECOLS patterns
                    all_choosecols = re.findall(r'(?:_xlfn\.)?CHOOSECOLS\s*\([^)]+\)', formula_upper)
                    logger.error(f"Found CHOOSECOLS patterns: {all_choosecols}")
                    all_passed = False
                    continue
                else:
                    logger.debug(f"✓ Matched FILTER pattern: {match_result.group()[:80]}...")
                
                # Check 5: Formula contains LET(x,VSTACK(...))
                # Pattern: LET(x,VSTACK(...)) or _xlfn.LET(_xlpm.x,_xlfn.VSTACK(...))
                # Use a more flexible pattern: LET followed by VSTACK
                let_pattern = r'(?:_xlfn\.)?LET.*?VSTACK'
                logger.debug(f"Checking LET pattern: {let_pattern}")
                match_result = re.search(let_pattern, formula_upper)
                if not match_result:
                    logger.error(f"✗ Cell {cell_coord} formula does not contain LET(x,VSTACK(...)) structure")
                    logger.error(f"Pattern used: {let_pattern}")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                else:
                    logger.debug(f"✓ Matched LET pattern: {match_result.group()[:80]}...")
                
                # Check 6: Formula contains COUNT(FIND(...)) structure
                # Pattern: COUNT(FIND(...)) or _xlfn.COUNT(_xlfn.FIND(...))
                count_find_pattern = r'(?:_xlfn\.)?COUNT\s*\(\s*(?:_xlfn\.)?FIND\s*\('
                if not re.search(count_find_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain COUNT(FIND(...)) structure")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 7: Formula should sum results from all 5 sheets (contains 5 COUNT(FIND(...)) patterns)
                count_find_matches = re.findall(r'(?:_xlfn\.)?COUNT\s*\(\s*(?:_xlfn\.)?FIND\s*\(', formula_upper)
                if len(count_find_matches) < len(sheet_names):
                    logger.error(f"Cell {cell_coord} formula does not contain COUNT(FIND(...)) for all {len(sheet_names)} sheets")
                    logger.error(f"Found {len(count_find_matches)} COUNT(FIND(...)) patterns, expected {len(sheet_names)}")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 8: Formula closes parentheses correctly
                open_count = formula_text.count('(')
                close_count = formula_text.count(')')
                if open_count != close_count:
                    logger.error(f"Cell {cell_coord} formula has mismatched parentheses")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                passed_count += 1
                logger.info(f"✓ Cell {cell_coord} has valid formula")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        if not all_passed:
            logger.error(f"✗ Formula verification failed: {passed_count}/{checked_count} cells passed")
            return 0.0
        
        if checked_count == 0:
            logger.error(f"No cells found in range {check_range}")
            return 0.0
        
        logger.info("=" * 60)
        logger.info(f"✓ All {checked_count} cells in range {check_range} contain correct COUNT(FIND(VSTACK(FILTER))) formulas")
        logger.info(f"  - All cells passed verification")
        logger.info(f"  - Formula structure: COUNT(FIND(\"{search_text}\",LET(x,VSTACK(...),FILTER(x,CHOOSECOLS(x,1)=A3))))")
        logger.info(f"  - Sheets checked: {sheet_names}")
        logger.info("=" * 60)
        return 1.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_sumpRODUCT_text_month_sum(result: str, expected: str = None, **options) -> float:
    """
    Verify if SUMPRODUCT with TEXT function formulas exist in specified ranges for month-based conditional summing.
    
    This function checks:
    1. B22:D24 range: SUMPRODUCT((TEXT($A$3:$A$17,"yyyymm")=TEXT($A22,"yyyymm"))*B$3:B$17) formulas
    2. E22:E24 range: E21+C22-D22 formulas (with relative row references)
    3. B25:D25 range: B22+B23+B24 formulas (sum of rows 22-24)
    4. ALL cells in specified ranges must be verified (cannot be missing)
    
    IMPORTANT: This function checks ALL cells in the specified ranges. If any cell is missing a formula, verification fails.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - sumproduct_range: Range with SUMPRODUCT formulas (default: "B22:D24")
            - sumproduct_date_range: Date range for TEXT function (default: "$A$3:$A$17")
            - sumproduct_date_cell: Date cell reference for comparison (default: "$A22")
            - sumproduct_sum_range: Sum range reference (default: "B$3:B$17")
            - sumproduct_text_format: TEXT format string (default: "yyyymm")
            - calculation_range: Range with calculation formulas (default: "E22:E24")
            - calculation_base_cell: Base cell for calculation (default: "E21")
            - calculation_add_col: Column to add (default: "C")
            - calculation_sub_col: Column to subtract (default: "D")
            - total_range: Range with total formulas (default: "B25:D25")
            - total_start_row: Starting row for total (default: 22)
            - total_end_row: Ending row for total (default: 24)
    
    Returns:
        float: 1.0 if ALL cells in specified ranges contain correct formulas, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        # Get options with defaults
        sumproduct_range = options.get('sumproduct_range', 'B22:D24')
        sumproduct_date_range = options.get('sumproduct_date_range', '$A$3:$A$17')
        sumproduct_date_cell = options.get('sumproduct_date_cell', '$A22')
        sumproduct_sum_range = options.get('sumproduct_sum_range', 'B$3:B$17')
        sumproduct_text_format = options.get('sumproduct_text_format', 'yyyymm')
        calculation_range = options.get('calculation_range', 'E22:E24')
        calculation_base_cell = options.get('calculation_base_cell', 'E21')
        calculation_add_col = options.get('calculation_add_col', 'C')
        calculation_sub_col = options.get('calculation_sub_col', 'D')
        total_range = options.get('total_range', 'B25:D25')
        total_start_row = options.get('total_start_row', 22)
        total_end_row = options.get('total_end_row', 24)
        
        logger.info(f"Verifying SUMPRODUCT TEXT month sum formulas in file: {result}")
        logger.info(f"SUMPRODUCT range: {sumproduct_range}")
        logger.info(f"Calculation range: {calculation_range}")
        logger.info(f"Total range: {total_range}")
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=False)
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        all_passed = True
        
        # Helper function to parse range
        def parse_range(range_str):
            range_clean = range_str.replace('$', '')
            if ':' in range_clean:
                start_cell, end_cell = range_clean.split(':')
                start_col_letter = ''.join([c for c in start_cell if c.isalpha()])
                start_row = int(''.join([c for c in start_cell if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                end_col_letter = ''.join([c for c in end_cell if c.isalpha()])
                end_row = int(''.join([c for c in end_cell if c.isdigit()]))
                end_col = column_index_from_string(end_col_letter)
                return start_col, start_row, end_col, end_row, start_col_letter
            else:
                raise ValueError(f"Invalid range format: {range_str}")
        
        # Check 1: SUMPRODUCT formulas in B22:D24
        logger.info("=" * 60)
        logger.info("Step 1: Verifying SUMPRODUCT formulas")
        logger.info("=" * 60)
        try:
            start_col, start_row, end_col, end_row, start_col_letter = parse_range(sumproduct_range)
        except Exception as e:
            logger.error(f"Failed to parse SUMPRODUCT range {sumproduct_range}: {e}")
            return 0.0
        
        checked_count = 0
        passed_count = 0
        
        for row_num in range(start_row, end_row + 1):
            for col_num in range(start_col, end_col + 1):
                cell_coord = f"{get_column_letter(col_num)}{row_num}"
                checked_count += 1
                
                try:
                    cell = ws[cell_coord]
                    
                    # Check if cell contains a formula
                    if cell.data_type != "f":
                        logger.error(f"Cell {cell_coord} does not contain a formula")
                        all_passed = False
                        continue
                    
                    # Get formula text
                    formula_text = None
                    if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                        formula_text = cell._value
                    elif hasattr(cell, "formula"):
                        formula_text = cell.formula
                    elif cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                    
                    if formula_text is None:
                        logger.error(f"Could not extract formula from cell {cell_coord}")
                        all_passed = False
                        continue
                    
                    formula_upper = formula_text.upper()
                    logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                    
                    # Check for SUMPRODUCT function
                    if not re.search(r'(?:_xlfn\.)?SUMPRODUCT', formula_upper):
                        logger.error(f"Cell {cell_coord} formula does not contain SUMPRODUCT function")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check for TEXT function (appears twice)
                    text_matches = re.findall(r'(?:_xlfn\.)?TEXT', formula_upper)
                    if len(text_matches) < 2:
                        logger.error(f"Cell {cell_coord} formula does not contain two TEXT functions")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check for date range reference
                    # Allow both with and without $ symbols
                    date_range_clean = sumproduct_date_range.replace("$", "")
                    # Create pattern that matches A3:A17 with optional $ symbols
                    # Pattern: A$?3:$?A$?17 or A3:A17
                    date_range_pattern = r'A\$?3.*?:\$?A\$?17'
                    if not re.search(date_range_pattern, formula_upper):
                        logger.error(f"Cell {cell_coord} formula does not contain date range {sumproduct_date_range}")
                        logger.error(f"Pattern: {date_range_pattern}")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check for date cell reference (with row relative)
                    date_cell_pattern = rf'\$?A\$?{row_num}'
                    if not re.search(date_cell_pattern, formula_upper):
                        logger.error(f"Cell {cell_coord} formula does not contain date cell reference A{row_num}")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check for sum range (column should match current column)
                    col_letter = get_column_letter(col_num)
                    sum_range_pattern = rf'{re.escape(col_letter)}\$3:{re.escape(col_letter)}\$17'
                    if not re.search(sum_range_pattern, formula_upper):
                        logger.error(f"Cell {cell_coord} formula does not contain sum range {col_letter}$3:{col_letter}$17")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check for TEXT format "yyyymm"
                    if sumproduct_text_format not in formula_text:
                        logger.error(f"Cell {cell_coord} formula does not contain TEXT format '{sumproduct_text_format}'")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    passed_count += 1
                    logger.debug(f"✓ Cell {cell_coord} has valid SUMPRODUCT formula")
                    
                except Exception as e:
                    logger.error(f"Error checking cell {cell_coord}: {e}")
                    all_passed = False
        
        if not all_passed or checked_count == 0:
            logger.error(f"SUMPRODUCT formula verification failed: {passed_count}/{checked_count} cells passed")
            return 0.0
        
        logger.info(f"✓ SUMPRODUCT formulas verified: {passed_count}/{checked_count} cells")
        
        # Check 2: Calculation formulas in E22:E24
        logger.info("=" * 60)
        logger.info("Step 2: Verifying calculation formulas")
        logger.info("=" * 60)
        try:
            calc_start_col, calc_start_row, calc_end_col, calc_end_row, calc_start_col_letter = parse_range(calculation_range)
        except Exception as e:
            logger.error(f"Failed to parse calculation range {calculation_range}: {e}")
            return 0.0
        
        calc_checked_count = 0
        calc_passed_count = 0
        
        for row_num in range(calc_start_row, calc_end_row + 1):
            cell_coord = f"{calc_start_col_letter}{row_num}"
            calc_checked_count += 1
            
            try:
                cell = ws[cell_coord]
                
                if cell.data_type != "f":
                    logger.error(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                elif cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula_text = cell.value
                
                if formula_text is None:
                    logger.error(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check formula structure: should be base_cell + add_col - sub_col
                # When formula is filled down, relative references adjust:
                # E22: E21+C22-D22 (base_cell is E21, which is 1 row above)
                # E23: E22+C23-D23 (base_cell becomes E22, which is 1 row above)
                # E24: E23+C24-D24 (base_cell becomes E23, which is 1 row above)
                # So base_cell should be E{row_num-1} (relative reference, adjusts with row)
                expected_base_row = row_num - 1
                base_cell_pattern = rf'E\$?{expected_base_row}'
                if not re.search(base_cell_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain expected base cell E{expected_base_row}")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check for add column (C with current row) - relative reference
                add_pattern = rf'{re.escape(calculation_add_col)}\$?{row_num}'
                if not re.search(add_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain add column {calculation_add_col}{row_num}")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check for subtract column (D with current row) - relative reference
                sub_pattern = rf'{re.escape(calculation_sub_col)}\$?{row_num}'
                if not re.search(sub_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain subtract column {calculation_sub_col}{row_num}")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                calc_passed_count += 1
                logger.debug(f"✓ Cell {cell_coord} has valid calculation formula")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                all_passed = False
        
        if not all_passed or calc_checked_count == 0:
            logger.error(f"Calculation formula verification failed: {calc_passed_count}/{calc_checked_count} cells passed")
            return 0.0
        
        logger.info(f"✓ Calculation formulas verified: {calc_passed_count}/{calc_checked_count} cells")
        
        # Check 3: Total formulas in B25:D25
        logger.info("=" * 60)
        logger.info("Step 3: Verifying total formulas")
        logger.info("=" * 60)
        try:
            # Parse total_range to get the cell range (B25:D25)
            total_start_col, total_formula_row, total_end_col, _, total_start_col_letter = parse_range(total_range)
            # Use total_start_row and total_end_row from options to check which rows should be summed
            # (e.g., rows 22-24 should be summed in row 25)
        except Exception as e:
            logger.error(f"Failed to parse total range {total_range}: {e}")
            return 0.0
        
        total_checked_count = 0
        total_passed_count = 0
        
        for col_num in range(total_start_col, total_end_col + 1):
            cell_coord = f"{get_column_letter(col_num)}{total_formula_row}"
            total_checked_count += 1
            
            try:
                cell = ws[cell_coord]
                
                if cell.data_type != "f":
                    logger.error(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                elif cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula_text = cell.value
                
                if formula_text is None:
                    logger.error(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check that formula sums rows from total_start_row to total_end_row (from options)
                # Formula should contain B22, B23, B24 (for B25), or C22, C23, C24 (for C25), etc.
                col_letter = get_column_letter(col_num)
                for sum_row in range(total_start_row, total_end_row + 1):
                    # Pattern should match col_letter followed by sum_row (with optional $)
                    sum_cell_pattern = rf'{re.escape(col_letter)}\$?{sum_row}'
                    if not re.search(sum_cell_pattern, formula_upper):
                        logger.error(f"Cell {cell_coord} formula does not contain sum cell {col_letter}{sum_row}")
                        logger.error(f"Pattern: {sum_cell_pattern}")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        break
                
                if not all_passed:
                    continue
                
                total_passed_count += 1
                logger.debug(f"✓ Cell {cell_coord} has valid total formula")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                all_passed = False
        
        if not all_passed or total_checked_count == 0:
            logger.error(f"Total formula verification failed: {total_passed_count}/{total_checked_count} cells passed")
            return 0.0
        
        logger.info(f"✓ Total formulas verified: {total_passed_count}/{total_checked_count} cells")
        
        logger.info("=" * 60)
        logger.info(f"✓ All formula verifications passed")
        logger.info(f"  - SUMPRODUCT formulas: {passed_count}/{checked_count}")
        logger.info(f"  - Calculation formulas: {calc_passed_count}/{calc_checked_count}")
        logger.info(f"  - Total formulas: {total_passed_count}/{total_checked_count}")
        logger.info("=" * 60)
        return 1.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_index_row_column_transpose(result: str, expected: str = None, **options) -> float:
    """
    Verify if IFERROR(INDEX(ROW(), COLUMN())) formulas exist in specified range for transposing data by fixed row count.
    
    This function checks:
    1. Whether ALL cells in the specified range (e.g., D1:G98) contain formulas
    2. Whether formulas contain IFERROR, INDEX, ROW, and COLUMN functions
    3. Whether INDEX references the correct source column (e.g., $A:$A)
    4. Whether formula structure is: IFERROR(INDEX($A:$A, (ROW()-1)*4 + COLUMN()-COLUMN($D:$D) + 1), "")
    5. Whether ROW() and COLUMN() functions are used correctly (relative references adjust with fill)
    6. Whether the multiplier (4) matches the expected row count per group
    7. Whether the target column reference ($D:$D) is correct
    
    IMPORTANT: This function checks ALL cells in the specified range. If any cell is missing a formula, verification fails.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_range: Range to check (e.g., "D1:G98") - ALL cells must have formulas
            - source_column: Source column for INDEX (default: "A")
            - target_column: Target column reference for COLUMN (default: "D")
            - rows_per_group: Number of rows per group for transposition (default: 4)
            - expected_functions: List of expected function names (default: ["IFERROR", "INDEX", "ROW", "COLUMN"])
    
    Returns:
        float: 1.0 if ALL cells in specified range contain correct formulas, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        # Get options with defaults
        check_range = options.get('check_range', 'D1:G98')
        source_column = options.get('source_column', 'A')
        target_column = options.get('target_column', 'D')
        rows_per_group = options.get('rows_per_group', 4)
        expected_functions = options.get('expected_functions', ['IFERROR', 'INDEX', 'ROW', 'COLUMN'])
        
        logger.info(f"Verifying INDEX ROW COLUMN transpose formulas in file: {result}")
        logger.info(f"Range to check: {check_range}")
        logger.info(f"Source column: {source_column}")
        logger.info(f"Target column: {target_column}")
        logger.info(f"Rows per group: {rows_per_group}")
        logger.info(f"Expected functions: {expected_functions}")
        
        # Parse the range
        try:
            range_clean = check_range.replace('$', '')
            if ':' in range_clean:
                start_cell, end_cell = range_clean.split(':')
                start_col_letter = ''.join([c for c in start_cell if c.isalpha()])
                start_row = int(''.join([c for c in start_cell if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                end_col_letter = ''.join([c for c in end_cell if c.isalpha()])
                end_row = int(''.join([c for c in end_cell if c.isdigit()]))
                end_col = column_index_from_string(end_col_letter)
            else:
                logger.error(f"Invalid range format: {check_range}. Expected format like 'D1:G98'")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse range {check_range}: {e}")
            return 0.0
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=False)
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        all_passed = True
        checked_count = 0
        passed_count = 0
        
        # Verify each cell in the range
        for row_num in range(start_row, end_row + 1):
            for col_num in range(start_col, end_col + 1):
                cell_coord = f"{get_column_letter(col_num)}{row_num}"
                checked_count += 1
                
                try:
                    cell = ws[cell_coord]
                    
                    # Check if cell contains a formula
                    if cell.data_type != "f":
                        logger.error(f"Cell {cell_coord} does not contain a formula")
                        all_passed = False
                        continue
                    
                    # Get formula text
                    formula_text = None
                    if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                        formula_text = cell._value
                    elif hasattr(cell, "formula"):
                        formula_text = cell.formula
                    elif cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                    
                    if formula_text is None:
                        logger.error(f"Could not extract formula from cell {cell_coord}")
                        all_passed = False
                        continue
                    
                    formula_upper = formula_text.upper()
                    logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                    
                    # Check 1: Formula contains all expected functions
                    for func_name in expected_functions:
                        func_pattern = rf'(?:_xlfn\.)?{re.escape(func_name)}\s*\('
                        if not re.search(func_pattern, formula_upper):
                            logger.error(f"Cell {cell_coord} formula does not contain {func_name} function")
                            logger.error(f"Formula: {formula_text}")
                            all_passed = False
                            break
                    
                    if not all_passed:
                        continue
                    
                    # Check 2: Formula contains INDEX with source column
                    source_col_pattern = rf'\$?{re.escape(source_column)}\$?:\$?{re.escape(source_column)}\$?'
                    if not re.search(source_col_pattern, formula_upper):
                        logger.error(f"Cell {cell_coord} formula does not contain INDEX source column {source_column}:{source_column}")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 3: Formula contains ROW() function (without arguments or with relative reference)
                    row_pattern = r'(?:_xlfn\.)?ROW\s*\(\s*\)'
                    if not re.search(row_pattern, formula_upper):
                        logger.error(f"Cell {cell_coord} formula does not contain ROW() function")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 4: Formula contains COLUMN() function (with target column reference)
                    target_col_pattern = rf'(?:_xlfn\.)?COLUMN\s*\(\s*\$?{re.escape(target_column)}\$?:\$?{re.escape(target_column)}\$?\s*\)'
                    if not re.search(target_col_pattern, formula_upper):
                        logger.error(f"Cell {cell_coord} formula does not contain COLUMN(${target_column}:${target_column}) function")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 5: Formula contains the multiplier pattern (ROW()-1)*rows_per_group
                    # Pattern: (ROW()-1)*4 or (ROW()-1)*rows_per_group
                    # The structure is: (ROW()-1) as a group, then * rows_per_group
                    # Formula structure: (ROW()-1)*4, where ROW()-1 is inside parentheses
                    # Allow flexible spacing and LibreOffice internal format
                    multiplier_pattern = rf'\(.*?ROW.*?-\s*1.*?\)\s*\*\s*{rows_per_group}'
                    if not re.search(multiplier_pattern, formula_upper):
                        logger.error(f"Cell {cell_coord} formula does not contain (ROW()-1)*{rows_per_group} pattern")
                        logger.error(f"Pattern used: {multiplier_pattern}")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 6: Formula contains IFERROR with empty string ""
                    # Pattern: IFERROR(..., "") or _xlfn.IFERROR(..., "")
                    # Note: [^,]+ doesn't work well with nested functions, use .*? instead
                    # Match IFERROR followed by opening paren, any content, comma, empty string, closing paren
                    iferror_pattern = r'(?:_xlfn\.)?IFERROR\s*\(.*?,\s*["\'\"]{2}\s*\)'
                    if not re.search(iferror_pattern, formula_upper):
                        logger.error(f"Cell {cell_coord} formula does not contain IFERROR(..., \"\") structure")
                        logger.error(f"Pattern used: {iferror_pattern}")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 7: Formula closes parentheses correctly
                    open_count = formula_text.count('(')
                    close_count = formula_text.count(')')
                    if open_count != close_count:
                        logger.error(f"Cell {cell_coord} formula has mismatched parentheses")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    passed_count += 1
                    logger.debug(f"✓ Cell {cell_coord} has valid formula")
                    
                except Exception as e:
                    logger.error(f"Error checking cell {cell_coord}: {e}")
                    import traceback
                    logger.error(traceback.format_exc())
                    all_passed = False
        
        if not all_passed:
            logger.error(f"✗ Formula verification failed: {passed_count}/{checked_count} cells passed")
            return 0.0
        
        if checked_count == 0:
            logger.error(f"No cells found in range {check_range}")
            return 0.0
        
        logger.info("=" * 60)
        logger.info(f"✓ All {checked_count} cells in range {check_range} contain correct INDEX ROW COLUMN transpose formulas")
        logger.info(f"  - All cells passed verification")
        logger.info(f"  - Formula structure: IFERROR(INDEX(${source_column}:${source_column}, (ROW()-1)*{rows_per_group} + COLUMN()-COLUMN(${target_column}:${target_column}) + 1), \"\")")
        logger.info("=" * 60)
        return 1.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_unique_sumif_sumifs_formulas(result: str, expected: str = None, **options) -> float:
    """
    Verify if three types of formulas exist in Sheet2:
    1. A2:A188: IFERROR(INDEX(MATCH(COUNTIF))) formulas for extracting unique values
    2. B2:B188: SUMIFS formulas with date condition (TODAY()-3)
    3. C2:C188: SUMIF formulas for total sum
    
    This function checks:
    1. Whether ALL cells in A2:A188 contain IFERROR(INDEX(MATCH(COUNTIF))) formulas
    2. Whether ALL cells in B2:B188 contain SUMIFS formulas with date condition
    3. Whether ALL cells in C2:C188 contain SUMIF formulas
    4. Whether formulas reference the correct source sheet (商品销售统计)
    5. Whether formulas have correct cell references (absolute/relative as needed)
    6. Whether headers are correct (编码, 3天销量, 总销量)
    
    IMPORTANT: This function checks ALL cells in the specified ranges. If any cell is missing a formula, verification fails.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - result_sheet_name: Name of result sheet (default: "Sheet2")
            - source_sheet_name: Name of source sheet (default: "商品销售统计")
            - unique_range: Range with unique value formulas (default: "A2:A188")
            - sumifs_range: Range with SUMIFS formulas (default: "B2:B188")
            - sumif_range: Range with SUMIF formulas (default: "C2:C188")
            - header_row: Row number for headers (default: 1)
            - expected_headers: Dict mapping columns to header text (default: {"A": "编码", "B": "3天销量", "C": "总销量"})
            - source_range_b: Source range for INDEX in column A (default: "$B$2:$B$1000")
            - source_range_a: Source range for date condition in SUMIFS (default: "A:A")
            - source_range_c: Source range for sum in SUMIFS/SUMIF (default: "C:C")
    
    Returns:
        float: 1.0 if ALL cells in specified ranges contain correct formulas, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        # Get options with defaults
        result_sheet_name = options.get('result_sheet_name', 'Sheet2')
        source_sheet_name = options.get('source_sheet_name', '商品销售统计')
        unique_range = options.get('unique_range', 'A2:A188')
        sumifs_range = options.get('sumifs_range', 'B2:B188')
        sumif_range = options.get('sumif_range', 'C2:C188')
        header_row = options.get('header_row', 1)
        expected_headers = options.get('expected_headers', {'A': '编码', 'B': '3天销量', 'C': '总销量'})
        source_range_b = options.get('source_range_b', '$B$2:$B$1000')
        source_range_a = options.get('source_range_a', 'A:A')
        source_range_c = options.get('source_range_c', 'C:C')
        
        logger.info(f"Verifying unique SUMIF SUMIFS formulas in file: {result}")
        logger.info(f"Result sheet: {result_sheet_name}")
        logger.info(f"Source sheet: {source_sheet_name}")
        logger.info(f"Unique range: {unique_range}")
        logger.info(f"SUMIFS range: {sumifs_range}")
        logger.info(f"SUMIF range: {sumif_range}")
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=False)
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check if sheets exist
        if result_sheet_name not in wb.sheetnames:
            logger.error(f"Sheet '{result_sheet_name}' not found. Available sheets: {wb.sheetnames}")
            return 0.0
        if source_sheet_name not in wb.sheetnames:
            logger.error(f"Sheet '{source_sheet_name}' not found. Available sheets: {wb.sheetnames}")
            return 0.0
        
        result_ws = wb[result_sheet_name]
        all_passed = True
        
        # Helper function to parse range
        def parse_range(range_str):
            range_clean = range_str.replace('$', '')
            if ':' in range_clean:
                start_cell, end_cell = range_clean.split(':')
                start_col_letter = ''.join([c for c in start_cell if c.isalpha()])
                start_row = int(''.join([c for c in start_cell if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                end_col_letter = ''.join([c for c in end_cell if c.isalpha()])
                end_row = int(''.join([c for c in end_cell if c.isdigit()]))
                end_col = column_index_from_string(end_col_letter)
                return start_col, start_row, end_col, end_row, start_col_letter
            else:
                raise ValueError(f"Invalid range format: {range_str}")
        
        # Check 1: Headers
        logger.info("=" * 60)
        logger.info("Step 1: Verifying headers")
        logger.info("=" * 60)
        for col_letter, expected_header in expected_headers.items():
            header_cell = f"{col_letter}{header_row}"
            try:
                cell = result_ws[header_cell]
                cell_value = str(cell.value) if cell.value is not None else ""
                if expected_header not in cell_value:
                    logger.error(f"Header in {header_cell} is '{cell_value}', expected to contain '{expected_header}'")
                    all_passed = False
                else:
                    logger.debug(f"✓ Header {header_cell}: {cell_value}")
            except Exception as e:
                logger.error(f"Error checking header {header_cell}: {e}")
                all_passed = False
        
        if not all_passed:
            return 0.0
        
        logger.info("✓ Headers verified")
        
        # Check 2: Unique value formulas in A2:A188
        logger.info("=" * 60)
        logger.info("Step 2: Verifying unique value formulas (IFERROR+INDEX+MATCH+COUNTIF)")
        logger.info("=" * 60)
        try:
            start_col, start_row, end_col, end_row, start_col_letter = parse_range(unique_range)
        except Exception as e:
            logger.error(f"Failed to parse unique range {unique_range}: {e}")
            return 0.0
        
        unique_checked_count = 0
        unique_passed_count = 0
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{start_col_letter}{row_num}"
            unique_checked_count += 1
            
            try:
                cell = result_ws[cell_coord]
                
                if cell.data_type != "f":
                    logger.error(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                elif cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula_text = cell.value
                
                if formula_text is None:
                    logger.error(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check for IFERROR, INDEX, MATCH, COUNTIF functions
                required_functions = ['IFERROR', 'INDEX', 'MATCH', 'COUNTIF']
                for func_name in required_functions:
                    func_pattern = rf'(?:_xlfn\.)?{re.escape(func_name)}\s*\('
                    if not re.search(func_pattern, formula_upper):
                        logger.error(f"Cell {cell_coord} formula does not contain {func_name} function")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        break
                
                if not all_passed:
                    continue
                
                # Check for source sheet reference
                if source_sheet_name not in formula_text:
                    logger.error(f"Cell {cell_coord} formula does not contain source sheet '{source_sheet_name}'")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check for source range B2:B1000 (with optional $)
                source_range_clean = source_range_b.replace("$", "")
                source_range_pattern = rf'{re.escape(source_sheet_name)}.*?B.*?2.*?:.*?B.*?1000'
                if not re.search(source_range_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain source range {source_range_b}")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check for COUNTIF range $A$1:A1 pattern (expanding range)
                # Pattern should match $A$1:A1, $A$1:A2, etc. (relative row reference)
                countif_range_pattern = rf'\$A\$1:A[0-9]+'
                if not re.search(countif_range_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain COUNTIF range pattern $A$1:A{row_num-1}")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check for IFERROR empty string ""
                iferror_pattern = r'(?:_xlfn\.)?IFERROR\s*\(.*?,\s*["\'\"]{2}\s*\)'
                if not re.search(iferror_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain IFERROR(..., \"\") structure")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                unique_passed_count += 1
                logger.debug(f"✓ Cell {cell_coord} has valid unique formula")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        if not all_passed or unique_checked_count == 0:
            logger.error(f"Unique formula verification failed: {unique_passed_count}/{unique_checked_count} cells passed")
            return 0.0
        
        logger.info(f"✓ Unique formulas verified: {unique_passed_count}/{unique_checked_count} cells")
        
        # Check 3: SUMIFS formulas in B2:B188
        logger.info("=" * 60)
        logger.info("Step 3: Verifying SUMIFS formulas with date condition")
        logger.info("=" * 60)
        try:
            start_col, start_row, end_col, end_row, start_col_letter = parse_range(sumifs_range)
        except Exception as e:
            logger.error(f"Failed to parse SUMIFS range {sumifs_range}: {e}")
            return 0.0
        
        sumifs_checked_count = 0
        sumifs_passed_count = 0
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{start_col_letter}{row_num}"
            sumifs_checked_count += 1
            
            try:
                cell = result_ws[cell_coord]
                
                if cell.data_type != "f":
                    logger.error(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                elif cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula_text = cell.value
                
                if formula_text is None:
                    logger.error(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check for SUMIFS function
                sumifs_pattern = rf'(?:_xlfn\.)?SUMIFS\s*\('
                if not re.search(sumifs_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain SUMIFS function")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check for source sheet reference
                if source_sheet_name not in formula_text:
                    logger.error(f"Cell {cell_coord} formula does not contain source sheet '{source_sheet_name}'")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check for sum range C:C
                sum_range_pattern = rf'{re.escape(source_sheet_name)}.*?C.*?:.*?C'
                if not re.search(sum_range_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain sum range {source_sheet_name}.C:C")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check for criteria range B:B
                criteria_b_pattern = rf'{re.escape(source_sheet_name)}.*?B.*?:.*?B'
                if not re.search(criteria_b_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain criteria range {source_sheet_name}.B:B")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check for criteria value A{row_num} (relative reference)
                criteria_a_pattern = rf'A\$?{row_num}'
                if not re.search(criteria_a_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain criteria value A{row_num}")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check for date condition A:A and TODAY()-3
                date_range_pattern = rf'{re.escape(source_sheet_name)}.*?A.*?:.*?A'
                if not re.search(date_range_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain date range {source_sheet_name}.A:A")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check for TODAY()-3 pattern
                today_pattern = r'(?:_xlfn\.)?TODAY\s*\(\s*\)\s*-\s*3'
                if not re.search(today_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain TODAY()-3 pattern")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check for ">="& pattern
                ge_pattern = r'">="\s*&|">="\s*&'
                if not re.search(ge_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain \">=\"& pattern")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                sumifs_passed_count += 1
                logger.debug(f"✓ Cell {cell_coord} has valid SUMIFS formula")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        if not all_passed or sumifs_checked_count == 0:
            logger.error(f"SUMIFS formula verification failed: {sumifs_passed_count}/{sumifs_checked_count} cells passed")
            return 0.0
        
        logger.info(f"✓ SUMIFS formulas verified: {sumifs_passed_count}/{sumifs_checked_count} cells")
        
        # Check 4: SUMIF formulas in C2:C188
        logger.info("=" * 60)
        logger.info("Step 4: Verifying SUMIF formulas")
        logger.info("=" * 60)
        try:
            start_col, start_row, end_col, end_row, start_col_letter = parse_range(sumif_range)
        except Exception as e:
            logger.error(f"Failed to parse SUMIF range {sumif_range}: {e}")
            return 0.0
        
        sumif_checked_count = 0
        sumif_passed_count = 0
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{start_col_letter}{row_num}"
            sumif_checked_count += 1
            
            try:
                cell = result_ws[cell_coord]
                
                if cell.data_type != "f":
                    logger.error(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                elif cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula_text = cell.value
                
                if formula_text is None:
                    logger.error(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check for SUMIF function
                sumif_pattern = rf'(?:_xlfn\.)?SUMIF\s*\('
                if not re.search(sumif_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain SUMIF function")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check for source sheet reference
                if source_sheet_name not in formula_text:
                    logger.error(f"Cell {cell_coord} formula does not contain source sheet '{source_sheet_name}'")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check for criteria range B:B
                criteria_b_pattern = rf'{re.escape(source_sheet_name)}.*?B.*?:.*?B'
                if not re.search(criteria_b_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain criteria range {source_sheet_name}.B:B")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check for criteria value A{row_num} (relative reference)
                criteria_a_pattern = rf'A\$?{row_num}'
                if not re.search(criteria_a_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain criteria value A{row_num}")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check for sum range C:C
                sum_range_pattern = rf'{re.escape(source_sheet_name)}.*?C.*?:.*?C'
                if not re.search(sum_range_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain sum range {source_sheet_name}.C:C")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                sumif_passed_count += 1
                logger.debug(f"✓ Cell {cell_coord} has valid SUMIF formula")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        if not all_passed or sumif_checked_count == 0:
            logger.error(f"SUMIF formula verification failed: {sumif_passed_count}/{sumif_checked_count} cells passed")
            return 0.0
        
        logger.info(f"✓ SUMIF formulas verified: {sumif_passed_count}/{sumif_checked_count} cells")
        
        logger.info("=" * 60)
        logger.info(f"✓ All formula verifications passed")
        logger.info(f"  - Headers: ✓")
        logger.info(f"  - Unique formulas: {unique_passed_count}/{unique_checked_count}")
        logger.info(f"  - SUMIFS formulas: {sumifs_passed_count}/{sumifs_checked_count}")
        logger.info(f"  - SUMIF formulas: {sumif_passed_count}/{sumif_checked_count}")
        logger.info("=" * 60)
        return 1.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_drop_sort_hstack_len_substitute(result: str, expected: str = None, **options) -> float:
    """
    Verify if DROP(SORT(HSTACK(LEN(...)))) dynamic array formulas exist in specified cells.
    
    This function checks:
    1. Whether C1 contains DROP(SORT(HSTACK(LEN(A1:A49),A1:A49),1),,1) formula
    2. Whether D1 contains DROP(SORT(HSTACK(LEN(SUBSTITUTE(A1:A49," ","")),A1:A49),1),,1) formula
    3. Whether formulas contain all required functions (DROP, SORT, HSTACK, LEN, SUBSTITUTE)
    4. Whether formulas reference the correct source range (A1:A49)
    5. Whether formulas have correct structure and parameters
    
    IMPORTANT: This function checks both C1 and D1 cells. If any cell is missing a formula or has incorrect structure, verification fails.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - c1_cell: Cell for first formula (default: "C1")
            - d1_cell: Cell for second formula (default: "D1")
            - source_range: Source range for formulas (default: "A1:A49")
            - expected_functions_c1: List of expected functions for C1 (default: ["DROP", "SORT", "HSTACK", "LEN"])
            - expected_functions_d1: List of expected functions for D1 (default: ["DROP", "SORT", "HSTACK", "LEN", "SUBSTITUTE"])
    
    Returns:
        float: 1.0 if both cells contain correct formulas, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        # Get options with defaults
        c1_cell = options.get('c1_cell', 'C1')
        d1_cell = options.get('d1_cell', 'D1')
        source_range = options.get('source_range', 'A1:A49')
        expected_functions_c1 = options.get('expected_functions_c1', ['DROP', 'SORT', 'HSTACK', 'LEN'])
        expected_functions_d1 = options.get('expected_functions_d1', ['DROP', 'SORT', 'HSTACK', 'LEN', 'SUBSTITUTE'])
        
        logger.info(f"Verifying DROP SORT HSTACK LEN SUBSTITUTE formulas in file: {result}")
        logger.info(f"C1 cell: {c1_cell}")
        logger.info(f"D1 cell: {d1_cell}")
        logger.info(f"Source range: {source_range}")
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=False)
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        ws = wb.active
        all_passed = True
        
        # Helper function to extract formula text (including array formulas)
        def get_formula_text(cell):
            formula_text = None
            
            # Method 1: Check if value is ArrayFormula object (for dynamic array formulas)
            if cell.value is not None:
                try:
                    from openpyxl.worksheet.formula import ArrayFormula
                    if isinstance(cell.value, ArrayFormula):
                        if hasattr(cell.value, "text"):
                            formula_text = cell.value.text
                        elif hasattr(cell.value, "formula"):
                            formula_text = cell.value.formula
                        elif hasattr(cell.value, "__str__"):
                            formula_str = str(cell.value)
                            if formula_str.startswith("=") or any(func in formula_str.upper() for func in ["DROP", "SORT", "HSTACK"]):
                                formula_text = formula_str
                except ImportError:
                    pass
            
            # Method 2: Check _value attribute
            if formula_text is None and hasattr(cell, "_value"):
                if isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                # Also check if _value is ArrayFormula
                try:
                    from openpyxl.worksheet.formula import ArrayFormula
                    if isinstance(cell._value, ArrayFormula):
                        if hasattr(cell._value, "text"):
                            formula_text = cell._value.text
                        elif hasattr(cell._value, "formula"):
                            formula_text = cell._value.formula
                except ImportError:
                    pass
            
            # Method 3: Check formula attribute
            if formula_text is None and hasattr(cell, "formula"):
                formula_text = cell.formula
            
            # Method 4: Check value as string
            if formula_text is None and cell.value is not None:
                if isinstance(cell.value, str) and cell.value.startswith("="):
                    formula_text = cell.value
            
            # Method 5: Check array_formulas attribute on worksheet
            if formula_text is None and hasattr(ws, "array_formulas"):
                cell_coord = cell.coordinate
                for array_range, array_formula in ws.array_formulas.items():
                    if cell_coord in array_range:
                        formula_text = array_formula
                        break
            
            return formula_text
        
        # Check C1: DROP(SORT(HSTACK(LEN(A1:A49),A1:A49),1),,1)
        logger.info("=" * 60)
        logger.info(f"Step 1: Verifying C1 formula: DROP(SORT(HSTACK(LEN(A1:A49),A1:A49),1),,1)")
        logger.info("=" * 60)
        
        try:
            cell = ws[c1_cell]
            
            # Check if cell contains a formula (including array formulas)
            is_formula = False
            if cell.data_type == "f":
                is_formula = True
            # Also check if it's an array formula
            elif hasattr(ws, "array_formulas"):
                for array_range, array_formula in ws.array_formulas.items():
                    if c1_cell in array_range:
                        is_formula = True
                        break
            # Check if value is ArrayFormula object
            if not is_formula and cell.value is not None:
                try:
                    from openpyxl.worksheet.formula import ArrayFormula
                    if isinstance(cell.value, ArrayFormula):
                        is_formula = True
                except ImportError:
                    pass
            
            if not is_formula:
                logger.error(f"Cell {c1_cell} does not contain a formula (data_type: {cell.data_type}, value type: {type(cell.value)})")
                logger.error(f"Cell value: {cell.value}")
                if hasattr(cell, "_value"):
                    logger.error(f"Cell _value: {cell._value}")
                return 0.0
            
            formula_text = get_formula_text(cell)
            if formula_text is None:
                logger.error(f"Could not extract formula from cell {c1_cell}")
                logger.error(f"Cell data_type: {cell.data_type}")
                logger.error(f"Cell value: {cell.value}")
                logger.error(f"Cell value type: {type(cell.value)}")
                if hasattr(cell, "_value"):
                    logger.error(f"Cell _value: {cell._value}")
                if hasattr(cell, "formula"):
                    logger.error(f"Cell formula attribute: {cell.formula}")
                if hasattr(ws, "array_formulas"):
                    logger.error(f"Worksheet array_formulas: {ws.array_formulas}")
                return 0.0
            
            formula_upper = formula_text.upper()
            logger.debug(f"Cell {c1_cell} formula: {formula_text}")
            
            # Check for all required functions
            for func_name in expected_functions_c1:
                func_pattern = rf'(?:_xlfn\.)?{re.escape(func_name)}\s*\('
                if not re.search(func_pattern, formula_upper):
                    logger.error(f"Cell {c1_cell} formula does not contain {func_name} function")
                    logger.error(f"Formula: {formula_text}")
                    return 0.0
            
            # Check for DROP function
            drop_pattern = r'(?:_xlfn\.)?DROP\s*\('
            if not re.search(drop_pattern, formula_upper):
                logger.error(f"Cell {c1_cell} formula does not contain DROP function")
                logger.error(f"Formula: {formula_text}")
                return 0.0
            
            # Check for SORT function (including _xlfn._xlws.SORT format)
            sort_pattern = r'(?:_xlfn\.)?(?:_xlws\.)?SORT\s*\('
            if not re.search(sort_pattern, formula_upper):
                logger.error(f"Cell {c1_cell} formula does not contain SORT function")
                logger.error(f"Formula: {formula_text}")
                return 0.0
            
            # Check for HSTACK function (including _xlfn.HSTACK format)
            hstack_pattern = r'(?:_xlfn\.)?HSTACK\s*\('
            if not re.search(hstack_pattern, formula_upper):
                logger.error(f"Cell {c1_cell} formula does not contain HSTACK function")
                logger.error(f"Formula: {formula_text}")
                return 0.0
            
            # Check for LEN function
            len_pattern = r'(?:_xlfn\.)?LEN\s*\('
            if not re.search(len_pattern, formula_upper):
                logger.error(f"Cell {c1_cell} formula does not contain LEN function")
                logger.error(f"Formula: {formula_text}")
                return 0.0
            
            # Check for source range A1:A49 (with optional $)
            source_range_clean = source_range.replace("$", "")
            source_range_pattern = rf'A.*?1.*?:.*?A.*?49'
            if not re.search(source_range_pattern, formula_upper):
                logger.error(f"Cell {c1_cell} formula does not contain source range {source_range}")
                logger.error(f"Formula: {formula_text}")
                return 0.0
            
            # Check for SORT parameter 1 (sort by first column)
            # Find SORT( position and check if ,1) or , 1) appears after it
            # This handles nested functions by looking for the pattern after SORT(
            sort_match = re.search(r'(?:_xlfn\.)?(?:_xlws\.)?SORT\s*\(', formula_upper)
            if sort_match:
                sort_start = sort_match.end()
                # Find the matching closing parenthesis by counting brackets
                paren_count = 1
                i = sort_start
                while i < len(formula_upper) and paren_count > 0:
                    if formula_upper[i] == '(':
                        paren_count += 1
                    elif formula_upper[i] == ')':
                        paren_count -= 1
                    i += 1
                if paren_count == 0:
                    sort_content = formula_upper[sort_start:i-1]
                    # Check if sort_content ends with ",1" or ", 1", or contains ",1" or ", 1" followed by , or )
                    # Also check if it ends with ",1" (parameter at the end)
                    if not (re.search(r',\s*1\s*[,\)]', sort_content) or re.search(r',\s*1\s*$', sort_content)):
                        logger.error(f"Cell {c1_cell} formula SORT function does not have parameter 1")
                        logger.error(f"Formula: {formula_text}")
                        logger.error(f"SORT content: {sort_content}")
                        return 0.0
                else:
                    logger.error(f"Cell {c1_cell} formula SORT function has unbalanced parentheses")
                    logger.error(f"Formula: {formula_text}")
                    return 0.0
            else:
                logger.error(f"Cell {c1_cell} formula does not contain SORT function")
                logger.error(f"Formula: {formula_text}")
                return 0.0
            
            # Check for DROP parameters ,,1 (drop first column)
            # Use bracket balancing to find DROP function arguments
            drop_match = re.search(r'(?:_xlfn\.)?DROP\s*\(', formula_upper)
            if drop_match:
                drop_start = drop_match.end()
                # Find the matching closing parenthesis by counting brackets
                paren_count = 1
                i = drop_start
                while i < len(formula_upper) and paren_count > 0:
                    if formula_upper[i] == '(':
                        paren_count += 1
                    elif formula_upper[i] == ')':
                        paren_count -= 1
                    i += 1
                if paren_count == 0:
                    drop_content = formula_upper[drop_start:i-1]
                    # Check if drop_content ends with ",,1" or ", , 1" (allowing flexible spacing)
                    if not (re.search(r',\s*,\s*1\s*$', drop_content) or re.search(r',\s*,\s*1\s*[,\)]', drop_content)):
                        logger.error(f"Cell {c1_cell} formula DROP function does not have parameters ,,1")
                        logger.error(f"Formula: {formula_text}")
                        logger.error(f"DROP content: {drop_content}")
                        return 0.0
                else:
                    logger.error(f"Cell {c1_cell} formula DROP function has unbalanced parentheses")
                    logger.error(f"Formula: {formula_text}")
                    return 0.0
            else:
                logger.error(f"Cell {c1_cell} formula does not contain DROP function")
                logger.error(f"Formula: {formula_text}")
                return 0.0
            
            # Check for HSTACK structure: HSTACK(LEN(...), A1:A49)
            # C1 should NOT contain SUBSTITUTE
            if 'SUBSTITUTE' in formula_upper:
                logger.error(f"Cell {c1_cell} formula should NOT contain SUBSTITUTE function (this looks like D1 formula)")
                logger.error(f"Formula: {formula_text}")
                return 0.0
            
            # Match HSTACK(LEN(...), A1:A49) with optional prefixes
            hstack_structure_pattern = r'(?:_xlfn\.)?HSTACK\s*\(\s*LEN\s*\([^)]+\)\s*,\s*A.*?1.*?:.*?A.*?49'
            if not re.search(hstack_structure_pattern, formula_upper):
                logger.error(f"Cell {c1_cell} formula HSTACK does not have correct structure: HSTACK(LEN(...), A1:A49)")
                logger.error(f"Formula: {formula_text}")
                return 0.0
            
            logger.info(f"✓ C1 formula verified: {formula_text}")
            
        except Exception as e:
            logger.error(f"Error checking cell {c1_cell}: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return 0.0
        
        # Check D1: DROP(SORT(HSTACK(LEN(SUBSTITUTE(A1:A49," ","")),A1:A49),1),,1)
        logger.info("=" * 60)
        logger.info(f"Step 2: Verifying D1 formula: DROP(SORT(HSTACK(LEN(SUBSTITUTE(A1:A49,\" \",\"\")),A1:A49),1),,1)")
        logger.info("=" * 60)
        
        try:
            cell = ws[d1_cell]
            
            # Check if cell contains a formula (including array formulas)
            is_formula = False
            if cell.data_type == "f":
                is_formula = True
            # Also check if it's an array formula
            elif hasattr(ws, "array_formulas"):
                for array_range, array_formula in ws.array_formulas.items():
                    if d1_cell in array_range:
                        is_formula = True
                        break
            # Check if value is ArrayFormula object
            if not is_formula and cell.value is not None:
                try:
                    from openpyxl.worksheet.formula import ArrayFormula
                    if isinstance(cell.value, ArrayFormula):
                        is_formula = True
                except ImportError:
                    pass
            
            if not is_formula:
                logger.error(f"Cell {d1_cell} does not contain a formula (data_type: {cell.data_type}, value type: {type(cell.value)})")
                logger.error(f"Cell value: {cell.value}")
                if hasattr(cell, "_value"):
                    logger.error(f"Cell _value: {cell._value}")
                return 0.0
            
            formula_text = get_formula_text(cell)
            if formula_text is None:
                logger.error(f"Could not extract formula from cell {d1_cell}")
                logger.error(f"Cell data_type: {cell.data_type}")
                logger.error(f"Cell value: {cell.value}")
                logger.error(f"Cell value type: {type(cell.value)}")
                if hasattr(cell, "_value"):
                    logger.error(f"Cell _value: {cell._value}")
                if hasattr(cell, "formula"):
                    logger.error(f"Cell formula attribute: {cell.formula}")
                if hasattr(ws, "array_formulas"):
                    logger.error(f"Worksheet array_formulas: {ws.array_formulas}")
                return 0.0
            
            formula_upper = formula_text.upper()
            logger.debug(f"Cell {d1_cell} formula: {formula_text}")
            
            # Check for all required functions
            for func_name in expected_functions_d1:
                func_pattern = rf'(?:_xlfn\.)?{re.escape(func_name)}\s*\('
                if not re.search(func_pattern, formula_upper):
                    logger.error(f"Cell {d1_cell} formula does not contain {func_name} function")
                    logger.error(f"Formula: {formula_text}")
                    return 0.0
            
            # Check for DROP function
            drop_pattern = r'(?:_xlfn\.)?DROP\s*\('
            if not re.search(drop_pattern, formula_upper):
                logger.error(f"Cell {d1_cell} formula does not contain DROP function")
                logger.error(f"Formula: {formula_text}")
                return 0.0
            
            # Check for SORT function (including _xlfn._xlws.SORT format)
            sort_pattern = r'(?:_xlfn\.)?(?:_xlws\.)?SORT\s*\('
            if not re.search(sort_pattern, formula_upper):
                logger.error(f"Cell {d1_cell} formula does not contain SORT function")
                logger.error(f"Formula: {formula_text}")
                return 0.0
            
            # Check for HSTACK function (including _xlfn.HSTACK format)
            hstack_pattern = r'(?:_xlfn\.)?HSTACK\s*\('
            if not re.search(hstack_pattern, formula_upper):
                logger.error(f"Cell {d1_cell} formula does not contain HSTACK function")
                logger.error(f"Formula: {formula_text}")
                return 0.0
            
            # Check for LEN function
            len_pattern = r'(?:_xlfn\.)?LEN\s*\('
            if not re.search(len_pattern, formula_upper):
                logger.error(f"Cell {d1_cell} formula does not contain LEN function")
                logger.error(f"Formula: {formula_text}")
                return 0.0
            
            # Check for SUBSTITUTE function
            substitute_pattern = r'(?:_xlfn\.)?SUBSTITUTE\s*\('
            if not re.search(substitute_pattern, formula_upper):
                logger.error(f"Cell {d1_cell} formula does not contain SUBSTITUTE function")
                logger.error(f"Formula: {formula_text}")
                return 0.0
            
            # Check for source range A1:A49 (with optional $)
            source_range_clean = source_range.replace("$", "")
            source_range_pattern = rf'A.*?1.*?:.*?A.*?49'
            if not re.search(source_range_pattern, formula_upper):
                logger.error(f"Cell {d1_cell} formula does not contain source range {source_range}")
                logger.error(f"Formula: {formula_text}")
                return 0.0
            
            # Check for SUBSTITUTE parameters: SUBSTITUTE(A1:A49," ","")
            # Allow flexible matching for quotes and spaces
            substitute_param_pattern = r'SUBSTITUTE\s*\(\s*A.*?1.*?:.*?A.*?49\s*,\s*["\'\"]\s+["\'\"]\s*,\s*["\'\"]{2}\s*\)'
            if not re.search(substitute_param_pattern, formula_upper):
                logger.error(f"Cell {d1_cell} formula SUBSTITUTE function does not have correct parameters: SUBSTITUTE(A1:A49,\" \",\"\")")
                logger.error(f"Formula: {formula_text}")
                return 0.0
            
            # Check for SORT parameter 1 (sort by first column)
            # Find SORT( position and check if ,1) or , 1) appears after it
            # This handles nested functions by looking for the pattern after SORT(
            sort_match = re.search(r'(?:_xlfn\.)?(?:_xlws\.)?SORT\s*\(', formula_upper)
            if sort_match:
                sort_start = sort_match.end()
                # Find the matching closing parenthesis by counting brackets
                paren_count = 1
                i = sort_start
                while i < len(formula_upper) and paren_count > 0:
                    if formula_upper[i] == '(':
                        paren_count += 1
                    elif formula_upper[i] == ')':
                        paren_count -= 1
                    i += 1
                if paren_count == 0:
                    sort_content = formula_upper[sort_start:i-1]
                    # Check if sort_content ends with ",1" or ", 1", or contains ",1" or ", 1" followed by , or )
                    # Also check if it ends with ",1" (parameter at the end)
                    if not (re.search(r',\s*1\s*[,\)]', sort_content) or re.search(r',\s*1\s*$', sort_content)):
                        logger.error(f"Cell {d1_cell} formula SORT function does not have parameter 1")
                        logger.error(f"Formula: {formula_text}")
                        logger.error(f"SORT content: {sort_content}")
                        return 0.0
                else:
                    logger.error(f"Cell {d1_cell} formula SORT function has unbalanced parentheses")
                    logger.error(f"Formula: {formula_text}")
                    return 0.0
            else:
                logger.error(f"Cell {d1_cell} formula does not contain SORT function")
                logger.error(f"Formula: {formula_text}")
                return 0.0
            
            # Check for DROP parameters ,,1 (drop first column)
            # Use bracket balancing to find DROP function arguments
            drop_match = re.search(r'(?:_xlfn\.)?DROP\s*\(', formula_upper)
            if drop_match:
                drop_start = drop_match.end()
                # Find the matching closing parenthesis by counting brackets
                paren_count = 1
                i = drop_start
                while i < len(formula_upper) and paren_count > 0:
                    if formula_upper[i] == '(':
                        paren_count += 1
                    elif formula_upper[i] == ')':
                        paren_count -= 1
                    i += 1
                if paren_count == 0:
                    drop_content = formula_upper[drop_start:i-1]
                    # Check if drop_content ends with ",,1" or ", , 1" (allowing flexible spacing)
                    if not (re.search(r',\s*,\s*1\s*$', drop_content) or re.search(r',\s*,\s*1\s*[,\)]', drop_content)):
                        logger.error(f"Cell {d1_cell} formula DROP function does not have parameters ,,1")
                        logger.error(f"Formula: {formula_text}")
                        logger.error(f"DROP content: {drop_content}")
                        return 0.0
                else:
                    logger.error(f"Cell {d1_cell} formula DROP function has unbalanced parentheses")
                    logger.error(f"Formula: {formula_text}")
                    return 0.0
            else:
                logger.error(f"Cell {d1_cell} formula does not contain DROP function")
                logger.error(f"Formula: {formula_text}")
                return 0.0
            
            # Check for HSTACK structure: HSTACK(LEN(SUBSTITUTE(...)), A1:A49)
            # D1 MUST contain SUBSTITUTE
            if 'SUBSTITUTE' not in formula_upper:
                logger.error(f"Cell {d1_cell} formula MUST contain SUBSTITUTE function")
                logger.error(f"Formula: {formula_text}")
                return 0.0
            
            # Match HSTACK(LEN(SUBSTITUTE(...)), A1:A49) with optional prefixes
            hstack_structure_pattern = r'(?:_xlfn\.)?HSTACK\s*\(\s*LEN\s*\(\s*SUBSTITUTE\s*\([^)]+\)\s*\)\s*,\s*A.*?1.*?:.*?A.*?49'
            if not re.search(hstack_structure_pattern, formula_upper):
                logger.error(f"Cell {d1_cell} formula HSTACK does not have correct structure: HSTACK(LEN(SUBSTITUTE(...)), A1:A49)")
                logger.error(f"Formula: {formula_text}")
                return 0.0
            
            logger.info(f"✓ D1 formula verified: {formula_text}")
            
        except Exception as e:
            logger.error(f"Error checking cell {d1_cell}: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return 0.0
        
        logger.info("=" * 60)
        logger.info(f"✓ All formula verifications passed")
        logger.info(f"  - C1 formula: ✓")
        logger.info(f"  - D1 formula: ✓")
        logger.info("=" * 60)
        return 1.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_left_mid_right_date_format(result: str, expected: str = None, **options) -> float:
    """
    Verify if LEFT/MID/RIGHT formulas exist in ALL cells of specified range to convert date format.
    
    This function STRICTLY checks ALL cells in the specified range - no tolerance, no auto-detection.
    Every single cell in the specified range must contain the correct formula.
    
    This function checks:
    1. Whether ALL cells in the specified formula range (e.g., B11:B240) contain formulas
    2. Whether formulas contain LEFT, MID, and RIGHT functions
    3. Whether formulas reference the correct source column cell with relative row (e.g., A11, A12, etc.)
    4. Whether formulas have correct parameters: LEFT(source,4), MID(source,5,2), RIGHT(source,2)
    5. Whether formulas contain connection operators & and separator "/"
    6. Whether formulas have the correct structure: =LEFT(A11,4)&"/"&MID(A11,5,2)&"/"&RIGHT(A11,2)
    
    The formula =LEFT(A11,4)&"/"&MID(A11,5,2)&"/"&RIGHT(A11,2) works as follows:
    - LEFT(A11,4) extracts the first 4 characters (year) from A11
    - MID(A11,5,2) extracts 2 characters starting from position 5 (month) from A11
    - RIGHT(A11,2) extracts the last 2 characters (day) from A11
    - & operators concatenate the parts with "/" separator to form YYYY/MM/DD format
    
    IMPORTANT: This function checks ALL cells in the specified formula range. If any cell is missing a formula, verification fails.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formula_range: Range containing formulas (e.g., "B11:B240") - ALL cells must have formulas
            - source_column: Source column for formula (default: "A")
            - expected_functions: List of expected function names (default: ["LEFT", "MID", "RIGHT"])
    
    Returns:
        float: 1.0 if ALL cells in specified range contain correct formulas, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formula_range = options.get('formula_range', 'B11:B240')
        source_column = options.get('source_column', 'A')
        expected_functions = options.get('expected_functions', ['LEFT', 'MID', 'RIGHT'])
        
        logger.info(f"Verifying LEFT/MID/RIGHT date format formulas in file: {result}")
        logger.info(f"Formula range: {formula_range}")
        logger.info(f"Source column: {source_column}")
        logger.info(f"Expected functions: {expected_functions}")
        
        # Parse the formula range
        try:
            range_clean = formula_range.replace("$", "")
            if ":" in range_clean:
                start_cell, end_cell = range_clean.split(":")
                start_col_letter = "".join([c for c in start_cell if c.isalpha()])
                start_row = int("".join([c for c in start_cell if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                end_col_letter = "".join([c for c in end_cell if c.isalpha()])
                end_row = int("".join([c for c in end_cell if c.isdigit()]))
                end_col = column_index_from_string(end_col_letter)
            else:
                logger.error(f"Invalid range format: {formula_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse range {formula_range}: {e}")
            return 0.0
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check ALL cells in formula range
        logger.info(f"Checking all cells in range {formula_range} (rows {start_row} to {end_row})")
        
        all_passed = True
        checked_count = 0
        passed_count = 0
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{start_col_letter}{row_num}"
            expected_source_cell = f"{source_column}{row_num}"
            
            try:
                cell = ws[cell_coord]
                checked_count += 1
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.error(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                elif cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula_text = cell.value
                
                if formula_text is None:
                    logger.error(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains all expected functions
                for func_name in expected_functions:
                    func_pattern = rf'\b{re.escape(func_name.upper())}\s*\('
                    if not re.search(func_pattern, formula_upper):
                        logger.error(f"Cell {cell_coord} formula does not contain {func_name} function")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        break
                
                if not all_passed:
                    continue
                
                # Check 2: Formula contains LEFT function with parameter 4
                left_pattern = r'\bLEFT\s*\([^,)]+,\s*4\s*\)'
                if not re.search(left_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain LEFT(...,4)")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: Formula contains MID function with parameters 5,2
                mid_pattern = r'\bMID\s*\([^,)]+,\s*5\s*,\s*2\s*\)'
                if not re.search(mid_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain MID(...,5,2)")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: Formula contains RIGHT function with parameter 2
                right_pattern = r'\bRIGHT\s*\([^,)]+,\s*2\s*\)'
                if not re.search(right_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain RIGHT(...,2)")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 5: Formula references the correct source column with correct row
                # Allow both relative (A11) and absolute ($A11) references, but prefer relative
                source_cell_patterns = [
                    rf'\b{re.escape(source_column.upper())}\s*{row_num}\b',  # A11 (relative)
                    rf'\$\s*{re.escape(source_column.upper())}\s*{row_num}\b',  # $A11 (mixed)
                ]
                source_cell_found = False
                for pattern in source_cell_patterns:
                    if re.search(pattern, formula_upper):
                        source_cell_found = True
                        break
                
                if not source_cell_found:
                    logger.error(f"Cell {cell_coord} formula does not reference {expected_source_cell}")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 6: Formula contains connection operator &
                if '&' not in formula_text:
                    logger.error(f"Cell {cell_coord} formula does not contain connection operator &")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 7: Formula contains separator "/"
                # Check for "/" in various formats: "/", '"/"', "'/'", etc.
                if '/' not in formula_text:
                    logger.error(f"Cell {cell_coord} formula does not contain separator \"/\"")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 8: Formula structure should be LEFT(...)&"/"&MID(...)&"/"&RIGHT(...)
                # Check that LEFT, MID, RIGHT are connected with & and "/"
                structure_pattern = r'LEFT\s*\([^)]+\)\s*&\s*["\']?/?["\']?\s*&\s*MID\s*\([^)]+\)\s*&\s*["\']?/?["\']?\s*&\s*RIGHT\s*\([^)]+\)'
                if not re.search(structure_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not have correct structure: LEFT(...)&\"/\"&MID(...)&\"/\"&RIGHT(...)")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 9: Formula closes parentheses correctly
                open_count = formula_text.count('(')
                close_count = formula_text.count(')')
                if open_count != close_count:
                    logger.error(f"Cell {cell_coord} formula has mismatched parentheses")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                passed_count += 1
                logger.info(f"✓ Cell {cell_coord} has valid formula: {formula_text}")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                all_passed = False
        
        if not all_passed:
            logger.error(f"✗ Formula verification failed: {passed_count}/{checked_count} cells passed")
            return 0.0
        
        if checked_count == 0:
            logger.error(f"No cells found in range {formula_range}")
            return 0.0
        
        logger.info("=" * 60)
        logger.info(f"✓ All {checked_count} cells in range {formula_range} contain correct LEFT/MID/RIGHT date format formulas")
        logger.info(f"  - All cells passed verification")
        logger.info(f"  - Formula structure: LEFT(source,4)&\"/\"&MID(source,5,2)&\"/\"&RIGHT(source,2)")
        logger.info("=" * 60)
        return 1.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_vlookup_sheet2(result: str, expected: str = None, **options) -> float:
    """
    Verify if VLOOKUP formulas exist in specified range to lookup values from sheet2.
    
    This function STRICTLY checks ALL cells in the specified range - no tolerance, no auto-detection.
    Every single cell in the specified range must contain the correct formula.
    
    This function checks:
    1. Whether ALL cells in the specified formula range (e.g., J1:J2) contain formulas
    2. Whether formulas contain VLOOKUP function
    3. Whether VLOOKUP lookup_value references the correct column with relative row (e.g., C1, C2)
    4. Whether VLOOKUP table_array references sheet2.A:C (worksheet reference)
    5. Whether VLOOKUP col_index is 3
    6. Whether VLOOKUP range_lookup is 0 (exact match)
    7. Whether formula structure is correct: =VLOOKUP(C1,sheet2.A:C,3,0)
    
    The formula =VLOOKUP(C1,sheet2.A:C,3,0) works as follows:
    - VLOOKUP searches for the value in C1 in the first column (A) of sheet2
    - If found, returns the value from the 3rd column (C) of the same row
    - 0 means exact match (not approximate)
    - When filled down, C1 becomes C2, C3, etc. (relative reference)
    - sheet2.A:C remains constant (absolute reference to worksheet and range)
    
    IMPORTANT: This function checks ALL cells in the specified formula range. If any cell is missing a formula, verification fails.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formula_range: Range containing formulas (e.g., "J1:J2") - ALL cells must have formulas
            - lookup_value_col: Column letter for VLOOKUP lookup value (default: "C")
            - sheet_name: Sheet name for VLOOKUP table array (default: "sheet2")
            - table_array: VLOOKUP table array range (default: "A:C")
            - col_index: VLOOKUP column index (default: 3)
            - range_lookup: VLOOKUP range lookup (default: 0 for exact match)
            - expected_functions: List of expected function names (default: ["VLOOKUP"])
    
    Returns:
        float: 1.0 if ALL cells in specified range contain correct formulas, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formula_range = options.get('formula_range', 'J1:J2')
        lookup_value_col = options.get('lookup_value_col', 'C')
        sheet_name = options.get('sheet_name', 'sheet2')
        table_array = options.get('table_array', 'A:C')
        col_index = options.get('col_index', 3)
        range_lookup = options.get('range_lookup', 0)
        expected_functions = options.get('expected_functions', ['VLOOKUP'])
        
        logger.info(f"Verifying VLOOKUP sheet2 formulas in file: {result}")
        logger.info(f"Formula range: {formula_range}")
        logger.info(f"Lookup value column: {lookup_value_col}")
        logger.info(f"Sheet name: {sheet_name}")
        logger.info(f"Table array: {table_array}")
        logger.info(f"Column index: {col_index}")
        logger.info(f"Range lookup: {range_lookup}")
        logger.info(f"Expected functions: {expected_functions}")
        
        # Parse the formula range
        try:
            range_clean = formula_range.replace("$", "")
            if ":" in range_clean:
                start_cell, end_cell = range_clean.split(":")
                start_col_letter = "".join([c for c in start_cell if c.isalpha()])
                start_row = int("".join([c for c in start_cell if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                end_col_letter = "".join([c for c in end_cell if c.isalpha()])
                end_row = int("".join([c for c in end_cell if c.isdigit()]))
                end_col = column_index_from_string(end_col_letter)
            else:
                logger.error(f"Invalid range format: {formula_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse range {formula_range}: {e}")
            return 0.0
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check ALL cells in formula range
        logger.info(f"Checking all cells in range {formula_range} (rows {start_row} to {end_row}, cols {start_col_letter} to {end_col_letter})")
        
        all_passed = True
        checked_count = 0
        passed_count = 0
        
        for row_num in range(start_row, end_row + 1):
            for col_num in range(start_col, end_col + 1):
                col_letter = get_column_letter(col_num)
                cell_coord = f"{col_letter}{row_num}"
                expected_lookup_cell = f"{lookup_value_col}{row_num}"
                
                try:
                    cell = ws[cell_coord]
                    checked_count += 1
                    
                    # Check if cell contains a formula
                    if cell.data_type != "f":
                        logger.error(f"Cell {cell_coord} does not contain a formula")
                        all_passed = False
                        continue
                    
                    # Get formula text
                    formula_text = None
                    if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                        formula_text = cell._value
                    elif hasattr(cell, "formula"):
                        formula_text = cell.formula
                    elif cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                    
                    if formula_text is None:
                        logger.error(f"Could not extract formula from cell {cell_coord}")
                        all_passed = False
                        continue
                    
                    formula_upper = formula_text.upper()
                    logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                    
                    # Check 1: Formula contains VLOOKUP function
                    vlookup_pattern = r'\bVLOOKUP\s*\('
                    if not re.search(vlookup_pattern, formula_upper):
                        logger.error(f"Cell {cell_coord} formula does not contain VLOOKUP function")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 2: VLOOKUP references the correct lookup value (C1, C2, etc.)
                    # Allow variations: C1, $C1, C$1, $C$1
                    lookup_cell_patterns = [
                        rf'\$\s*{re.escape(lookup_value_col.upper())}\s*\$\s*{row_num}\b',  # $C$1
                        rf'\$\s*{re.escape(lookup_value_col.upper())}\s*{row_num}\b',  # $C1
                        rf'\b{re.escape(lookup_value_col.upper())}\s*\$\s*{row_num}\b',  # C$1
                        rf'\b{re.escape(lookup_value_col.upper())}\s*{row_num}\b',  # C1
                    ]
                    lookup_cell_found = False
                    for pattern in lookup_cell_patterns:
                        if re.search(pattern, formula_upper):
                            lookup_cell_found = True
                            break
                    
                    if not lookup_cell_found:
                        logger.error(f"Cell {cell_coord} formula does not reference lookup value cell {expected_lookup_cell}")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 3: VLOOKUP references sheet2.A:C or sheet2!A:C (worksheet reference)
                    # Allow variations: sheet2.A:C, sheet2!A:C, sheet2.$A:$C, sheet2!$A:$C, 'sheet2'.A:C, etc.
                    # Excel uses ! (exclamation mark), LibreOffice Calc uses . (dot)
                    # Note: formula_upper is uppercase, so we need to use uppercase sheet_name
                    sheet_name_upper = sheet_name.upper()
                    sheet_ref_patterns = [
                        rf'{re.escape(sheet_name_upper)}\s*\.\s*A\s*:\s*C',  # SHEET2.A:C (LibreOffice Calc)
                        rf'{re.escape(sheet_name_upper)}\s*!\s*A\s*:\s*C',  # SHEET2!A:C (Excel)
                        rf'{re.escape(sheet_name_upper)}\s*\.\s*\$\s*A\s*:\s*\$\s*C',  # SHEET2.$A:$C
                        rf'{re.escape(sheet_name_upper)}\s*!\s*\$\s*A\s*:\s*\$\s*C',  # SHEET2!$A:$C
                        rf'[\'"]\s*{re.escape(sheet_name_upper)}\s*[\'"]\s*\.\s*A\s*:\s*C',  # 'SHEET2'.A:C
                        rf'[\'"]\s*{re.escape(sheet_name_upper)}\s*[\'"]\s*!\s*A\s*:\s*C',  # 'SHEET2'!A:C
                        rf'[\'"]\s*{re.escape(sheet_name_upper)}\s*[\'"]\s*\.\s*\$\s*A\s*:\s*\$\s*C',  # 'SHEET2'.$A:$C
                        rf'[\'"]\s*{re.escape(sheet_name_upper)}\s*[\'"]\s*!\s*\$\s*A\s*:\s*\$\s*C',  # 'SHEET2'!$A:$C
                    ]
                    sheet_ref_found = False
                    for pattern in sheet_ref_patterns:
                        if re.search(pattern, formula_upper):
                            sheet_ref_found = True
                            break
                    
                    if not sheet_ref_found:
                        logger.error(f"Cell {cell_coord} formula does not reference sheet '{sheet_name}' with range {table_array}")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 4: VLOOKUP col_index is 3
                    # Pattern: Look for ,3, or , 3, after the table array
                    col_index_pattern = rf',\s*{col_index}\s*,'
                    if not re.search(col_index_pattern, formula_text):
                        logger.error(f"Cell {cell_coord} formula VLOOKUP col_index is not {col_index}")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 5: VLOOKUP range_lookup is 0
                    # Pattern: Look for ,0) or , 0) at the end of VLOOKUP
                    range_lookup_patterns = [
                        rf',\s*{range_lookup}\s*\)',  # ,0)
                        rf',\s*{range_lookup}\s*$',  # ,0 (end of formula)
                    ]
                    range_lookup_found = False
                    for pattern in range_lookup_patterns:
                        if re.search(pattern, formula_text):
                            range_lookup_found = True
                            break
                    
                    if not range_lookup_found:
                        logger.error(f"Cell {cell_coord} formula VLOOKUP range_lookup is not {range_lookup}")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 6: Formula closes parentheses correctly
                    open_count = formula_text.count('(')
                    close_count = formula_text.count(')')
                    if open_count != close_count:
                        logger.error(f"Cell {cell_coord} formula has mismatched parentheses")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    passed_count += 1
                    logger.info(f"✓ Cell {cell_coord} has valid formula: {formula_text}")
                    
                except Exception as e:
                    logger.error(f"Error checking cell {cell_coord}: {e}")
                    all_passed = False
        
        if not all_passed:
            logger.error(f"Formula verification failed: {passed_count}/{checked_count} cells passed")
            return 0.0
        
        if checked_count == 0:
            logger.error(f"No cells found in range {formula_range}")
            return 0.0
        
        logger.info("=" * 60)
        logger.info(f"✓ All {checked_count} cells in range {formula_range} contain correct VLOOKUP sheet2 formulas")
        logger.info(f"  - All cells passed verification")
        logger.info(f"  - Formula structure: =VLOOKUP(C{start_row},sheet2.A:C,3,0)")
        logger.info("=" * 60)
        return 1.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_index_match_small_transform(result: str, expected: str = None, **options) -> float:
    """
    Verify if INDEX+UNIQUE+FILTER+COLUMN and INDEX+SMALL+IF+ROW formulas exist in specified ranges to transform A and B column data into a cross-table format.
    
    This function STRICTLY checks ALL cells in the specified ranges - no tolerance, no auto-detection.
    Every single cell in the specified ranges must contain the correct formula.
    
    This function checks:
    1. Whether ALL cells in header range (e.g., E1:H1) contain INDEX(UNIQUE(FILTER(...)), COLUMN(...)) formulas
    2. Whether ALL cells in data range (e.g., E2:H25) contain IFERROR(INDEX(SMALL(IF(ROW)))) formulas
    3. Whether header formulas use FILTER($A$2:$A$25, $A$2:$A$25<>"") pattern
    4. Whether header formulas use UNIQUE to extract unique values
    5. Whether header formulas use COLUMN(A1) for column indexing
    6. Whether data formulas reference $B:$B and use SMALL(IF($A$2:$A$25=E$1, ROW($A$2:$A$25), ""), ROW(A1)) pattern
    7. Whether formulas have correct structure and function combinations
    
    The header formula =INDEX(UNIQUE(FILTER($A$2:$A$25, $A$2:$A$25<>"")), COLUMN(A1)) works as follows:
    - FILTER($A$2:$A$25, $A$2:$A$25<>"") filters out empty values from A2:A25
    - UNIQUE(...) extracts unique values from the filtered array
    - INDEX(..., COLUMN(A1)) extracts the Nth value from the unique array, where N=COLUMN(A1) (1 for E1, 2 for F1, etc.)
    - COLUMN(A1) returns 1 in E1, 2 in F1, 3 in G1, 4 in H1
    
    The data formula =IFERROR(INDEX($B:$B, SMALL(IF($A$2:$A$25=E$1, ROW($A$2:$A$25), ""), ROW(A1))), "") works as follows:
    - IF($A$2:$A$25=E$1, ROW($A$2:$A$25), "") returns row numbers where A2:A25 matches E1, or "" otherwise
    - SMALL(..., ROW(A1)) extracts the Nth smallest row number (N=ROW(A1), which increments with row)
    - INDEX($B:$B, SMALL(...)) extracts the corresponding value from column B
    - IFERROR wraps to return "" if no match found
    
    IMPORTANT: This function checks ALL cells in the specified ranges. If any cell is missing a formula, verification fails.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - header_range: Range containing header formulas (e.g., "E1:H1") - ALL cells must have formulas
            - data_range: Range containing data formulas (e.g., "E2:H25") - ALL cells must have formulas
            - source_column_a: Source column A for FILTER (default: "A")
            - source_column_b: Source column B for INDEX (default: "B")
            - source_range_a: Source range for FILTER and IF (default: "$A$2:$A$25")
            - expected_functions_header: List of expected function names for header (default: ["INDEX", "UNIQUE", "FILTER", "COLUMN"])
            - expected_functions_data: List of expected function names for data (default: ["IFERROR", "INDEX", "SMALL", "IF", "ROW"])
    
    Returns:
        float: 1.0 if ALL cells in specified ranges contain correct formulas, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        header_range = options.get('header_range', 'E1:H1')
        data_range = options.get('data_range', 'E2:H25')
        source_column_a = options.get('source_column_a', 'A')
        source_column_b = options.get('source_column_b', 'B')
        source_range_a = options.get('source_range_a', '$A$2:$A$25')
        expected_functions_header = options.get('expected_functions_header', ['INDEX', 'UNIQUE', 'FILTER', 'COLUMN'])
        expected_functions_data = options.get('expected_functions_data', ['IFERROR', 'INDEX', 'SMALL', 'IF', 'ROW'])
        
        logger.info(f"Verifying INDEX+UNIQUE+FILTER+COLUMN and INDEX+SMALL+IF+ROW transform formulas in file: {result}")
        logger.info(f"Header range: {header_range}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Source column A: {source_column_a}")
        logger.info(f"Source column B: {source_column_b}")
        
        # Helper function to parse range
        def parse_range(range_str):
            range_clean = range_str.replace('$', '')
            if ':' in range_clean:
                start_cell, end_cell = range_clean.split(':')
                start_col_letter = ''.join([c for c in start_cell if c.isalpha()])
                start_row = int(''.join([c for c in start_cell if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                end_col_letter = ''.join([c for c in end_cell if c.isalpha()])
                end_row = int(''.join([c for c in end_cell if c.isdigit()]))
                end_col = column_index_from_string(end_col_letter)
                return start_col, start_row, end_col, end_row, start_col_letter
            else:
                raise ValueError(f"Invalid range format: {range_str}")
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=False)
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        all_passed = True
        checked_count = 0
        passed_count = 0
        
        # Step 1: Verify header range (E1:H1)
        logger.info("=" * 60)
        logger.info("Step 1: Verifying header formulas (INDEX+UNIQUE+FILTER+COLUMN)")
        logger.info("=" * 60)
        
        try:
            start_col, start_row, end_col, end_row, start_col_letter = parse_range(header_range)
        except Exception as e:
            logger.error(f"Failed to parse header range {header_range}: {e}")
            return 0.0
        
        for row_num in range(start_row, end_row + 1):
            for col_num in range(start_col, end_col + 1):
                col_letter = get_column_letter(col_num)
                cell_coord = f"{col_letter}{row_num}"
                checked_count += 1
                
                try:
                    cell = ws[cell_coord]
                    
                    # Check if cell contains a formula
                    if cell.data_type != "f":
                        logger.error(f"Cell {cell_coord} does not contain a formula")
                        all_passed = False
                        continue
                    
                    # Get formula text
                    formula_text = None
                    if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                        formula_text = cell._value
                    elif hasattr(cell, "formula"):
                        formula_text = cell.formula
                    elif cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                    
                    if formula_text is None:
                        logger.error(f"Could not extract formula from cell {cell_coord}")
                        all_passed = False
                        continue
                    
                    formula_upper = formula_text.upper()
                    logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                    
                    # Check 1: Formula contains all expected functions
                    # Allow Excel compatibility prefixes: _xlfn. and _xlfn._xlws.
                    for func_name in expected_functions_header:
                        # Pattern allows: FUNC( or _xlfn.FUNC( or _xlfn._xlws.FUNC(
                        func_patterns = [
                            rf'\b{re.escape(func_name.upper())}\s*\(',
                            rf'_XLFN\.{re.escape(func_name.upper())}\s*\(',
                            rf'_XLFN\._XLWS\.{re.escape(func_name.upper())}\s*\('
                        ]
                        func_found = False
                        for pattern in func_patterns:
                            if re.search(pattern, formula_upper):
                                func_found = True
                                break
                        if not func_found:
                            logger.error(f"Cell {cell_coord} formula does not contain {func_name} function")
                            logger.error(f"Formula: {formula_text}")
                            all_passed = False
                            break
                    
                    if not all_passed:
                        continue
                    
                    # Check 2: INDEX function (outermost)
                    index_patterns = [
                        r'\bINDEX\s*\(',
                        r'_XLFN\.INDEX\s*\('
                    ]
                    index_found = False
                    for pattern in index_patterns:
                        if re.search(pattern, formula_upper):
                            index_found = True
                            break
                    if not index_found:
                        logger.error(f"Cell {cell_coord} formula does not contain INDEX function")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 3: UNIQUE function (allow _xlfn. prefix)
                    unique_patterns = [
                        r'\bUNIQUE\s*\(',
                        r'_XLFN\.UNIQUE\s*\('
                    ]
                    unique_found = False
                    for pattern in unique_patterns:
                        if re.search(pattern, formula_upper):
                            unique_found = True
                            break
                    if not unique_found:
                        logger.error(f"Cell {cell_coord} formula does not contain UNIQUE function")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 4: FILTER function (allow _xlfn._xlws. or _xlfn. prefix)
                    filter_patterns = [
                        r'\bFILTER\s*\(',
                        r'_XLFN\.FILTER\s*\(',
                        r'_XLFN\._XLWS\.FILTER\s*\('
                    ]
                    filter_found = False
                    for pattern in filter_patterns:
                        if re.search(pattern, formula_upper):
                            filter_found = True
                            break
                    if not filter_found:
                        logger.error(f"Cell {cell_coord} formula does not contain FILTER function")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 5: FILTER references $A$2:$A$25 (or similar absolute range)
                    # Allow FILTER or _xlfn.FILTER or _xlfn._xlws.FILTER
                    filter_range_patterns = [
                        rf'FILTER\s*\(\s*\$?\s*{re.escape(source_column_a.upper())}\$?\d+\s*:\s*\$?\s*{re.escape(source_column_a.upper())}\$?\d+',
                        rf'_XLFN\.FILTER\s*\(\s*\$?\s*{re.escape(source_column_a.upper())}\$?\d+\s*:\s*\$?\s*{re.escape(source_column_a.upper())}\$?\d+',
                        rf'_XLFN\._XLWS\.FILTER\s*\(\s*\$?\s*{re.escape(source_column_a.upper())}\$?\d+\s*:\s*\$?\s*{re.escape(source_column_a.upper())}\$?\d+'
                    ]
                    filter_range_found = False
                    for pattern in filter_range_patterns:
                        if re.search(pattern, formula_upper):
                            filter_range_found = True
                            break
                    if not filter_range_found:
                        logger.error(f"Cell {cell_coord} formula FILTER does not reference correct range (e.g., ${source_column_a}$2:${source_column_a}$25)")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 6: FILTER condition pattern: $A$2:$A$25<>""
                    filter_condition_pattern = rf'{re.escape(source_column_a.upper())}\$?\d+\s*:\s*\$?\s*{re.escape(source_column_a.upper())}\$?\d+\s*<>\s*\"\"'
                    if not re.search(filter_condition_pattern, formula_upper):
                        logger.error(f"Cell {cell_coord} formula FILTER does not have correct condition pattern ($A$2:$A$25<>\"\")")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 7: COLUMN function with relative reference (A1 pattern)
                    column_pattern = r'\bCOLUMN\s*\('
                    if not re.search(column_pattern, formula_upper):
                        logger.error(f"Cell {cell_coord} formula does not contain COLUMN function")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 8: COLUMN uses relative reference (A1, B1, etc., not $A$1)
                    column_ref_pattern = r'COLUMN\s*\(\s*[A-Z]+\d+\s*\)'
                    if not re.search(column_ref_pattern, formula_upper):
                        logger.error(f"Cell {cell_coord} formula COLUMN does not use relative reference (A1 pattern)")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 9: Formula structure: INDEX(UNIQUE(FILTER(...)), COLUMN(...))
                    # Verify UNIQUE wraps FILTER (allow Excel compatibility prefixes)
                    unique_filter_patterns = [
                        r'UNIQUE\s*\(\s*FILTER',
                        r'_XLFN\.UNIQUE\s*\(\s*FILTER',
                        r'_XLFN\.UNIQUE\s*\(\s*_XLFN\.FILTER',
                        r'_XLFN\.UNIQUE\s*\(\s*_XLFN\._XLWS\.FILTER'
                    ]
                    unique_filter_found = False
                    for pattern in unique_filter_patterns:
                        if re.search(pattern, formula_upper):
                            unique_filter_found = True
                            break
                    if not unique_filter_found:
                        logger.error(f"Cell {cell_coord} formula does not have UNIQUE(FILTER(...)) structure")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 10: INDEX wraps UNIQUE (allow Excel compatibility prefixes)
                    index_unique_patterns = [
                        r'INDEX\s*\(\s*UNIQUE',
                        r'INDEX\s*\(\s*_XLFN\.UNIQUE',
                        r'_XLFN\.INDEX\s*\(\s*UNIQUE',
                        r'_XLFN\.INDEX\s*\(\s*_XLFN\.UNIQUE'
                    ]
                    index_unique_found = False
                    for pattern in index_unique_patterns:
                        if re.search(pattern, formula_upper):
                            index_unique_found = True
                            break
                    if not index_unique_found:
                        logger.error(f"Cell {cell_coord} formula does not have INDEX(UNIQUE(...)) structure")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    passed_count += 1
                    logger.debug(f"✓ Cell {cell_coord} has valid header formula")
                    
                except Exception as e:
                    logger.error(f"Error checking cell {cell_coord}: {e}")
                    all_passed = False
                    continue
        
        if not all_passed:
            logger.error(f"Header formula verification failed: {passed_count}/{checked_count} cells passed")
            return 0.0
        
        header_checked = checked_count
        header_passed = passed_count
        
        # Step 2: Verify data range (E2:H25)
        logger.info("=" * 60)
        logger.info("Step 2: Verifying data formulas (INDEX+SMALL+IF+ROW)")
        logger.info("=" * 60)
        
        checked_count = 0
        passed_count = 0
        
        try:
            start_col, start_row, end_col, end_row, start_col_letter = parse_range(data_range)
        except Exception as e:
            logger.error(f"Failed to parse data range {data_range}: {e}")
            return 0.0
        
        for row_num in range(start_row, end_row + 1):
            for col_num in range(start_col, end_col + 1):
                col_letter = get_column_letter(col_num)
                cell_coord = f"{col_letter}{row_num}"
                checked_count += 1
                
                try:
                    cell = ws[cell_coord]
                    
                    # Check if cell contains a formula
                    if cell.data_type != "f":
                        logger.error(f"Cell {cell_coord} does not contain a formula")
                        all_passed = False
                        continue
                    
                    # Get formula text
                    formula_text = None
                    if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                        formula_text = cell._value
                    elif hasattr(cell, "formula"):
                        formula_text = cell.formula
                    elif cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                    
                    if formula_text is None:
                        logger.error(f"Could not extract formula from cell {cell_coord}")
                        all_passed = False
                        continue
                    
                    formula_upper = formula_text.upper()
                    logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                    
                    # Check 1: Formula contains all expected functions
                    for func_name in expected_functions_data:
                        func_pattern = rf'\b{re.escape(func_name.upper())}\s*\('
                        if not re.search(func_pattern, formula_upper):
                            logger.error(f"Cell {cell_coord} formula does not contain {func_name} function")
                            logger.error(f"Formula: {formula_text}")
                            all_passed = False
                            break
                    
                    if not all_passed:
                        continue
                    
                    # Check 2: INDEX references $B:$B
                    index_b_pattern = rf'\$\s*{re.escape(source_column_b.upper())}\s*:\s*\$\s*{re.escape(source_column_b.upper())}'
                    if not re.search(index_b_pattern, formula_upper):
                        logger.error(f"Cell {cell_coord} formula INDEX does not reference ${source_column_b}:${source_column_b}")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 3: SMALL function
                    small_pattern = r'\bSMALL\s*\('
                    if not re.search(small_pattern, formula_upper):
                        logger.error(f"Cell {cell_coord} formula does not contain SMALL function")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 4: IF function with pattern IF($A$2:$A$25=E$1, ROW($A$2:$A$25), "")
                    if_pattern = rf'IF\s*\(\s*\$?\s*{re.escape(source_column_a.upper())}\$?\d+\s*:\s*\$?\s*{re.escape(source_column_a.upper())}\$?\d+\s*=\s*[A-Z]+\$?\d+'
                    if not re.search(if_pattern, formula_upper):
                        logger.error(f"Cell {cell_coord} formula does not have correct IF pattern")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 5: ROW function in IF condition
                    row_in_if_pattern = rf'ROW\s*\(\s*\$?\s*{re.escape(source_column_a.upper())}\$?\d+\s*:\s*\$?\s*{re.escape(source_column_a.upper())}\$?\d+\s*\)'
                    if not re.search(row_in_if_pattern, formula_upper):
                        logger.error(f"Cell {cell_coord} formula does not have ROW in IF condition")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 6: ROW(A1) pattern in SMALL (relative reference)
                    row_small_pattern = r'ROW\s*\(\s*[A-Z]+\d+\s*\)'
                    if not re.search(row_small_pattern, formula_upper):
                        logger.error(f"Cell {cell_coord} formula does not have ROW(A1) pattern in SMALL")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 7: IFERROR wrapper
                    iferror_pattern = r'IFERROR\s*\('
                    if not re.search(iferror_pattern, formula_upper):
                        logger.error(f"Cell {cell_coord} formula does not contain IFERROR function")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    passed_count += 1
                    logger.debug(f"✓ Cell {cell_coord} has valid data formula")
                    
                except Exception as e:
                    logger.error(f"Error checking cell {cell_coord}: {e}")
                    all_passed = False
                    continue
        
        if not all_passed:
            logger.error(f"Data formula verification failed: {passed_count}/{checked_count} cells passed")
            return 0.0
        
        if checked_count == 0:
            logger.error(f"No cells found in data range {data_range}")
            return 0.0
        
        logger.info("=" * 60)
        logger.info(f"✓ All {header_checked} cells in header range {header_range} contain correct INDEX+UNIQUE+FILTER+COLUMN formulas")
        logger.info(f"✓ All {checked_count} cells in data range {data_range} contain correct INDEX+SMALL+IF+ROW formulas")
        logger.info(f"  - Header formula: =INDEX(UNIQUE(FILTER(${source_column_a}$2:${source_column_a}$25, ${source_column_a}$2:${source_column_a}$25<>\"\")), COLUMN(A1))")
        logger.info(f"  - Data formula: =IFERROR(INDEX(${source_column_b}:${source_column_b}, SMALL(IF(${source_column_a}$2:${source_column_a}$25=E$1, ROW(...), \"\"), ROW(A1))), \"\")")
        logger.info("=" * 60)
        return 1.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_tv_episode_range_calculate(result: str, expected: str = None, **options) -> float:
    """
    Verify if formulas exist in B1 and B2:B25 to calculate TV episode ranges.
    
    This function checks:
    1. Whether B1 contains formula: =1&"-"&MIDB(A1,FINDB("共",A1)+2,2)
    2. Whether B2:B25 contains formula: =SUMPRODUCT(--MID(A$1:A1, FIND("共",A$1:A1)+1, FIND("集",A$1:A1)-FIND("共",A$1:A1)-1)) + 1 & "-" & SUMPRODUCT(--MID(A$1:A1, FIND("共",A$1:A1)+1, FIND("集",A$1:A1)-FIND("共",A$1:A1)-1)) + --MID(A2, FIND("共",A2)+1, FIND("集",A2)-FIND("共",A2)-1)
    3. Whether formulas reference the correct source column cells
    4. Whether all specified cells contain formulas
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - b1_cell: B1 cell coordinate (default: "B1")
            - b1_formula_range: B1 formula range (default: "B1")
            - b2_b25_range: B2:B25 formula range (default: "B2:B25")
            - source_column: Source column for formula (default: "A")
            - expected_functions_b1: List of expected function names for B1 (default: ["MIDB", "FINDB"])
            - expected_functions_b2: List of expected function names for B2:B25 (default: ["SUMPRODUCT", "MID", "FIND"])
    
    Returns:
        float: 1.0 if ALL cells contain correct formulas, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        b1_cell = options.get('b1_cell', 'B1')
        b1_formula_range = options.get('b1_formula_range', 'B1')
        b2_b25_range = options.get('b2_b25_range', 'B2:B25')
        source_column = options.get('source_column', 'A')
        expected_functions_b1 = options.get('expected_functions_b1', ['MIDB', 'FINDB'])
        expected_functions_b2 = options.get('expected_functions_b2', ['SUMPRODUCT', 'MID', 'FIND'])
        
        logger.info(f"Verifying TV episode range calculation formulas in file: {result}")
        logger.info(f"B1 cell: {b1_cell}")
        logger.info(f"B2:B25 range: {b2_b25_range}")
        logger.info(f"Source column: {source_column}")
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        all_passed = True
        
        # Check B1 cell
        logger.info(f"Checking B1 cell: {b1_cell}")
        try:
            cell = ws[b1_cell]
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {b1_cell} does not contain a formula")
                all_passed = False
            else:
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                elif cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula_text = cell.value
                
                if formula_text is None:
                    logger.error(f"Could not extract formula from cell {b1_cell}")
                    all_passed = False
                else:
                    formula_upper = formula_text.upper()
                    logger.debug(f"Cell {b1_cell} formula: {formula_text}")
                    
                    # Check 1: Formula contains MIDB function
                    midb_pattern = r'\bMIDB\s*\('
                    if not re.search(midb_pattern, formula_upper):
                        logger.error(f"Cell {b1_cell} formula does not contain MIDB function")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                    
                    # Check 2: Formula contains FINDB function
                    findb_pattern = r'\bFINDB\s*\('
                    if not re.search(findb_pattern, formula_upper):
                        logger.error(f"Cell {b1_cell} formula does not contain FINDB function")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                    
                    # Check 3: Formula contains "1" and "-" concatenation
                    # Check for 1& pattern and "-" concatenation separately for flexibility
                    has_one_and = re.search(r'1\s*&', formula_upper)
                    has_dash_concat = re.search(r'&\s*["\']?\s*-\s*["\']?\s*&', formula_text) or re.search(r'&\s*["\']?\s*-\s*["\']?', formula_text)
                    if not has_one_and or not has_dash_concat:
                        logger.error(f"Cell {b1_cell} formula does not contain 1&\"-\"& pattern")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                    
                    # Check 4: Formula references A1
                    a1_pattern = rf'\b{re.escape(source_column.upper())}\s*1\b'
                    if not re.search(a1_pattern, formula_upper):
                        logger.error(f"Cell {b1_cell} formula does not reference {source_column}1")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                    
                    # Check 5: Formula contains "共" character
                    if '"共"' not in formula_text and "'共'" not in formula_text:
                        logger.error(f"Cell {b1_cell} formula does not contain \"共\" character")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                    
                    # Check 6: Formula contains +2 pattern (FINDB result + 2)
                    if not re.search(r'FINDB.*\+\s*2', formula_upper):
                        logger.error(f"Cell {b1_cell} formula does not contain FINDB+2 pattern")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                    
                    # Check 7: Formula contains MIDB with 2 as length parameter
                    # More flexible check: MIDB exists and has 2 as the last parameter before closing paren
                    midb_match = re.search(r'MIDB\s*\([^)]+\)', formula_upper)
                    if not midb_match:
                        logger.error(f"Cell {b1_cell} formula does not contain MIDB function call")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                    else:
                        # Check if MIDB call ends with ,2) or has 2 as last parameter
                        midb_call = midb_match.group(0)
                        # Extract parameters by finding commas and checking last one
                        # Simple check: if MIDB exists and formula contains ",2)" pattern nearby
                        if not re.search(r'MIDB.*,\s*2\s*\)', formula_upper):
                            logger.error(f"Cell {b1_cell} formula MIDB does not have 2 as length parameter")
                            logger.error(f"Formula: {formula_text}")
                            all_passed = False
                    
                    if all_passed:
                        logger.info(f"✓ Cell {b1_cell} has valid formula: {formula_text}")
        except Exception as e:
            logger.error(f"Error checking cell {b1_cell}: {e}")
            all_passed = False
        
        # Parse B2:B25 range
        try:
            range_clean = b2_b25_range.replace("$", "")
            if ":" in range_clean:
                start_cell, end_cell = range_clean.split(":")
                start_col_letter = "".join([c for c in start_cell if c.isalpha()])
                start_row = int("".join([c for c in start_cell if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                end_col_letter = "".join([c for c in end_cell if c.isalpha()])
                end_row = int("".join([c for c in end_cell if c.isdigit()]))
                end_col = column_index_from_string(end_col_letter)
            else:
                logger.error(f"Invalid range format: {b2_b25_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse range {b2_b25_range}: {e}")
            return 0.0
        
        # Check ALL cells in B2:B25 range
        logger.info(f"Checking all cells in range {b2_b25_range} (rows {start_row} to {end_row})")
        
        checked_count = 0
        passed_count = 0
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{start_col_letter}{row_num}"
            expected_source_cell = f"{source_column}{row_num}"
            
            try:
                cell = ws[cell_coord]
                checked_count += 1
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.error(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                elif cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula_text = cell.value
                
                if formula_text is None:
                    logger.error(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains all expected functions
                missing_functions = []
                for func_name in expected_functions_b2:
                    func_pattern = rf'\b{re.escape(func_name.upper())}\s*\('
                    if not re.search(func_pattern, formula_upper):
                        missing_functions.append(func_name)
                
                if missing_functions:
                    logger.error(f"Cell {cell_coord} formula does not contain functions: {missing_functions}")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 2: Formula contains SUMPRODUCT function
                sumproduct_pattern = r'\bSUMPRODUCT\s*\('
                if not re.search(sumproduct_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain SUMPRODUCT function")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: Formula contains MID function
                mid_pattern = r'\bMID\s*\('
                if not re.search(mid_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain MID function")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: Formula contains FIND function
                find_pattern = r'\bFIND\s*\('
                if not re.search(find_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain FIND function")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 5: Formula contains absolute reference A$1:A{row_num-1} pattern (for cumulative sum)
                # The pattern should be A$1:A{row_num-1} where row_num-1 is the previous row
                # More flexible: allow A$1:A{number} where number is 1 to row_num-1
                # Patterns: A$1:A1 (for B2), A$1:A2 (for B3), A$1:A3 (for B4), etc.
                prev_row = row_num - 1
                # Check for A$1:A{number} pattern where number can be 1 to row_num-1
                # This pattern appears in SUMPRODUCT to calculate cumulative sum
                a1_a1_found = False
                # Pattern: A$1:A{number} where number is 1 to prev_row
                for check_row in range(1, row_num):
                    pattern1 = rf'{re.escape(source_column.upper())}\s*\$\s*1\s*:\s*{re.escape(source_column.upper())}\s*{check_row}\b'  # A$1:A{number}
                    pattern2 = rf'\$\s*{re.escape(source_column.upper())}\s*\$\s*1\s*:\s*{re.escape(source_column.upper())}\s*{check_row}\b'  # $A$1:A{number}
                    if re.search(pattern1, formula_upper) or re.search(pattern2, formula_upper):
                        a1_a1_found = True
                        break
                # Also check for A$1:$A1 pattern (absolute reference)
                if not a1_a1_found:
                    pattern3 = rf'{re.escape(source_column.upper())}\s*\$\s*1\s*:\s*\$\s*{re.escape(source_column.upper())}\s*1\b'  # A$1:$A1
                    if re.search(pattern3, formula_upper):
                        a1_a1_found = True
                
                if not a1_a1_found:
                    logger.error(f"Cell {cell_coord} formula does not contain A$1:A{{number}} pattern for cumulative sum (expected A$1:A1 to A$1:A{prev_row})")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 6: Formula references current row source cell (e.g., A2, A3, etc.)
                source_cell_pattern = rf'\b{re.escape(source_column.upper())}\s*{row_num}\b'
                if not re.search(source_cell_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not reference {expected_source_cell}")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 7: Formula contains "共" character
                if '"共"' not in formula_text and "'共'" not in formula_text:
                    logger.error(f"Cell {cell_coord} formula does not contain \"共\" character")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 8: Formula contains "集" character
                if '"集"' not in formula_text and "'集'" not in formula_text:
                    logger.error(f"Cell {cell_coord} formula does not contain \"集\" character")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 9: Formula contains concatenation with "-" (range separator)
                # More flexible: allow &"-"& or & "-" & or &"-" patterns
                dash_concat_patterns = [
                    r'&\s*["\']?\s*-\s*["\']?\s*&',  # &"-"&
                    r'&\s*["\']?\s*-\s*["\']?',  # &"-"
                ]
                dash_concat_found = False
                for pattern in dash_concat_patterns:
                    if re.search(pattern, formula_text):
                        dash_concat_found = True
                        break
                if not dash_concat_found:
                    logger.error(f"Cell {cell_coord} formula does not contain \"-\" concatenation pattern")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 10: Formula contains +1 pattern (start of range)
                # More flexible: allow +1& or + 1& or +1 & patterns
                if not re.search(r'\+\s*1\s*&', formula_upper) and not re.search(r'\+\s*1\s*["\']?\s*&', formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain +1& pattern")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 11: Formula contains double negative (--MID) pattern for numeric conversion
                double_negative_pattern = r'--\s*MID'
                if not re.search(double_negative_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain --MID pattern for numeric conversion")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 12: Formula closes parentheses correctly
                open_count = formula_text.count('(')
                close_count = formula_text.count(')')
                if open_count != close_count:
                    logger.error(f"Cell {cell_coord} formula has mismatched parentheses")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                passed_count += 1
                logger.info(f"✓ Cell {cell_coord} has valid formula: {formula_text}")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                all_passed = False
        
        if not all_passed:
            logger.error(f"✗ Formula verification failed: {passed_count}/{checked_count} cells in B2:B25 passed")
            return 0.0
        
        if checked_count == 0:
            logger.error(f"No cells found in range {b2_b25_range}")
            return 0.0
        
        logger.info("=" * 60)
        logger.info(f"✓ All cells contain correct TV episode range calculation formulas")
        logger.info(f"  - B1 formula: =1&\"-\"&MIDB(A1,FINDB(\"共\",A1)+2,2)")
        logger.info(f"  - B2:B25 formula: =SUMPRODUCT(--MID(A$1:A1, FIND(\"共\",A$1:A1)+1, FIND(\"集\",A$1:A1)-FIND(\"共\",A$1:A1)-1)) + 1 & \"-\" & SUMPRODUCT(...) + --MID(A2, ...)")
        logger.info(f"  - All {checked_count} cells in B2:B25 passed verification")
        logger.info("=" * 60)
        return 1.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_seat_number_arrangement(result: str, expected: str = None, **options) -> float:
    """
    Verify if seat number arrangement formulas exist in ALL cells of specified ranges.
    
    This function STRICTLY checks ALL cells in the specified ranges - no tolerance, no auto-detection.
    Every single cell in the specified ranges must contain the correct formula.
    
    This function checks:
    1. Whether ALL cells in D2:D427 contain formula: =TEXT(OFFSET(J$2,SMALL(IF(COLUMN(A:CZ)<=K$3:K$11,J$3:J$11,99),ROW(A1)),),"00")
    2. Whether ALL cells in E2:E427 contain formula: =D2&TEXT(COUNTIF(D$2:D2,D2),"00")
    3. Whether formulas contain all expected functions (TEXT, OFFSET, SMALL, IF, COLUMN, ROW, COUNTIF)
    4. Whether formulas reference the correct cells and ranges
    
    The formula =TEXT(OFFSET(J$2,SMALL(IF(COLUMN(A:CZ)<=K$3:K$11,J$3:J$11,99),ROW(A1)),),"00") works as follows:
    - COLUMN(A:CZ) generates column numbers from 1 to 104
    - IF(COLUMN(A:CZ)<=K$3:K$11,J$3:J$11,99) creates an array where values from J$3:J$11 are kept if column number <= corresponding K$3:K$11 value, otherwise 99
    - SMALL(...,ROW(A1)) gets the nth smallest value (n increases as formula is copied down)
    - OFFSET(J$2, ...,) offsets from J$2 by the calculated rows
    - TEXT(...,"00") formats the result as two-digit number with leading zero
    
    The formula =D2&TEXT(COUNTIF(D$2:D2,D2),"00") works as follows:
    - COUNTIF(D$2:D2,D2) counts occurrences of current D cell value from D$2 to current row
    - TEXT(...,"00") formats the count as two-digit number with leading zero
    - D2&... concatenates the D column value with the count
    
    IMPORTANT: This function checks ALL cells in the specified ranges. If any cell is missing a formula, verification fails.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - d_range: Range containing D column formulas (default: "D2:D427")
            - e_range: Range containing E column formulas (default: "E2:E427")
            - expected_functions_d: List of expected function names for D column (default: ["TEXT", "OFFSET", "SMALL", "IF", "COLUMN", "ROW"])
            - expected_functions_e: List of expected function names for E column (default: ["TEXT", "COUNTIF"])
    
    Returns:
        float: 1.0 if ALL cells in specified ranges contain correct formulas, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        d_range = options.get('d_range', 'D2:D427')
        e_range = options.get('e_range', 'E2:E427')
        expected_functions_d = options.get('expected_functions_d', ['TEXT', 'OFFSET', 'SMALL', 'IF', 'COLUMN', 'ROW'])
        expected_functions_e = options.get('expected_functions_e', ['TEXT', 'COUNTIF'])
        
        logger.info(f"Verifying seat number arrangement formulas in file: {result}")
        logger.info(f"D column formula range: {d_range}")
        logger.info(f"E column formula range: {e_range}")
        
        # Parse the D range
        try:
            d_range_clean = d_range.replace("$", "")
            if ":" in d_range_clean:
                d_start_cell, d_end_cell = d_range_clean.split(":")
                d_start_col_letter = "".join([c for c in d_start_cell if c.isalpha()])
                d_start_row = int("".join([c for c in d_start_cell if c.isdigit()]))
                d_start_col = column_index_from_string(d_start_col_letter)
                d_end_col_letter = "".join([c for c in d_end_cell if c.isalpha()])
                d_end_row = int("".join([c for c in d_end_cell if c.isdigit()]))
                d_end_col = column_index_from_string(d_end_col_letter)
            else:
                logger.error(f"Invalid D range format: {d_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse D range {d_range}: {e}")
            return 0.0
        
        # Parse the E range
        try:
            e_range_clean = e_range.replace("$", "")
            if ":" in e_range_clean:
                e_start_cell, e_end_cell = e_range_clean.split(":")
                e_start_col_letter = "".join([c for c in e_start_cell if c.isalpha()])
                e_start_row = int("".join([c for c in e_start_cell if c.isdigit()]))
                e_start_col = column_index_from_string(e_start_col_letter)
                e_end_col_letter = "".join([c for c in e_end_cell if c.isalpha()])
                e_end_row = int("".join([c for c in e_end_cell if c.isdigit()]))
                e_end_col = column_index_from_string(e_end_col_letter)
            else:
                logger.error(f"Invalid E range format: {e_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse E range {e_range}: {e}")
            return 0.0
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=False)
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        all_passed = True
        checked_count = 0
        passed_count = 0
        
        # Verify D column formulas
        logger.info(f"Checking all cells in D range {d_range} (rows {d_start_row} to {d_end_row})")
        for row_num in range(d_start_row, d_end_row + 1):
            cell_coord = f"{d_start_col_letter}{row_num}"
            
            try:
                cell = ws[cell_coord]
                checked_count += 1
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.error(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                elif cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula_text = cell.value
                
                if formula_text is None:
                    logger.error(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains all expected functions for D column
                for func_name in expected_functions_d:
                    func_pattern = rf'\b{re.escape(func_name.upper())}\s*\('
                    if not re.search(func_pattern, formula_upper):
                        logger.error(f"Cell {cell_coord} formula does not contain {func_name} function")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        break
                
                if not all_passed:
                    continue
                
                # Check 2: Formula contains TEXT function
                text_pattern = r'\bTEXT\s*\('
                if not re.search(text_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain TEXT function")
                    all_passed = False
                    continue
                
                # Check 3: Formula contains OFFSET function
                offset_pattern = r'\bOFFSET\s*\('
                if not re.search(offset_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain OFFSET function")
                    all_passed = False
                    continue
                
                # Check 4: Formula contains SMALL function
                small_pattern = r'\bSMALL\s*\('
                if not re.search(small_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain SMALL function")
                    all_passed = False
                    continue
                
                # Check 5: Formula contains IF function
                if_pattern = r'\bIF\s*\('
                if not re.search(if_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain IF function")
                    all_passed = False
                    continue
                
                # Check 6: Formula contains COLUMN function
                column_pattern = r'\bCOLUMN\s*\('
                if not re.search(column_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain COLUMN function")
                    all_passed = False
                    continue
                
                # Check 7: Formula contains ROW function
                row_pattern = r'\bROW\s*\('
                if not re.search(row_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain ROW function")
                    all_passed = False
                    continue
                
                # Check 8: Formula references J$2 (absolute row reference)
                j2_pattern = r'J\s*\$\s*2\b'
                if not re.search(j2_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not reference J$2")
                    all_passed = False
                    continue
                
                # Check 9: Formula references K$3:K$11 range
                k3_k11_pattern = r'K\s*\$\s*3\s*:\s*K\s*\$\s*11\b'
                if not re.search(k3_k11_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not reference K$3:K$11")
                    all_passed = False
                    continue
                
                # Check 10: Formula references J$3:J$11 range
                j3_j11_pattern = r'J\s*\$\s*3\s*:\s*J\s*\$\s*11\b'
                if not re.search(j3_j11_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not reference J$3:J$11")
                    all_passed = False
                    continue
                
                # Check 11: Formula contains COLUMN(A:CZ) pattern
                column_range_pattern = r'COLUMN\s*\(\s*A\s*:\s*CZ\s*\)'
                if not re.search(column_range_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain COLUMN(A:CZ) pattern")
                    all_passed = False
                    continue
                
                # Check 12: Formula contains ROW(A{n}) pattern (relative reference, where n can be any number)
                # When formula is copied down, ROW(A1) becomes ROW(A2), ROW(A3), etc.
                row_a_pattern = r'ROW\s*\(\s*A\s*\d+\s*\)'
                if not re.search(row_a_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain ROW(A{{n}}) pattern (relative reference)")
                    all_passed = False
                    continue
                
                # Check 13: Formula contains "00" format string in TEXT function
                text_format_pattern = r'["\']\s*00\s*["\']'
                if not re.search(text_format_pattern, formula_text):
                    logger.error(f"Cell {cell_coord} formula does not contain \"00\" format string in TEXT function")
                    all_passed = False
                    continue
                
                # Check 14: Formula contains value 99 (used in IF function)
                if '99' not in formula_text:
                    logger.error(f"Cell {cell_coord} formula does not contain value 99")
                    all_passed = False
                    continue
                
                # Check 15: Formula structure should be TEXT(OFFSET(J$2,SMALL(IF(COLUMN(A:CZ)<=K$3:K$11,J$3:J$11,99),ROW(A1)),),"00")
                # Check that OFFSET is inside TEXT
                text_offset_pattern = r'TEXT\s*\(\s*OFFSET\s*\('
                if not re.search(text_offset_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not have correct TEXT(OFFSET(...)) structure")
                    all_passed = False
                    continue
                
                # Check 16: Formula closes parentheses correctly
                open_count = formula_text.count('(')
                close_count = formula_text.count(')')
                if open_count != close_count:
                    logger.error(f"Cell {cell_coord} formula has mismatched parentheses")
                    all_passed = False
                    continue
                
                passed_count += 1
                logger.info(f"✓ Cell {cell_coord} has valid D column formula")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                all_passed = False
        
        # Verify E column formulas
        logger.info(f"Checking all cells in E range {e_range} (rows {e_start_row} to {e_end_row})")
        for row_num in range(e_start_row, e_end_row + 1):
            cell_coord = f"{e_start_col_letter}{row_num}"
            expected_d_cell = f"D{row_num}"
            
            try:
                cell = ws[cell_coord]
                checked_count += 1
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.error(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                elif cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula_text = cell.value
                
                if formula_text is None:
                    logger.error(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains all expected functions for E column
                for func_name in expected_functions_e:
                    func_pattern = rf'\b{re.escape(func_name.upper())}\s*\('
                    if not re.search(func_pattern, formula_upper):
                        logger.error(f"Cell {cell_coord} formula does not contain {func_name} function")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        break
                
                if not all_passed:
                    continue
                
                # Check 2: Formula contains TEXT function
                text_pattern = r'\bTEXT\s*\('
                if not re.search(text_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain TEXT function")
                    all_passed = False
                    continue
                
                # Check 3: Formula contains COUNTIF function
                countif_pattern = r'\bCOUNTIF\s*\('
                if not re.search(countif_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain COUNTIF function")
                    all_passed = False
                    continue
                
                # Check 4: Formula references current row D cell (e.g., D2, D3, etc.)
                d_cell_pattern = rf'\bD\s*{row_num}\b'
                if not re.search(d_cell_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not reference {expected_d_cell}")
                    all_passed = False
                    continue
                
                # Check 5: Formula references D$2:D{row_num} range (expanding range)
                d_range_pattern = rf'D\s*\$\s*2\s*:\s*D\s*{row_num}\b'
                if not re.search(d_range_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not reference D$2:D{row_num} range")
                    all_passed = False
                    continue
                
                # Check 6: Formula contains "00" format string in TEXT function
                text_format_pattern = r'["\']\s*00\s*["\']'
                if not re.search(text_format_pattern, formula_text):
                    logger.error(f"Cell {cell_coord} formula does not contain \"00\" format string in TEXT function")
                    all_passed = False
                    continue
                
                # Check 7: Formula contains concatenation operator &
                if '&' not in formula_text:
                    logger.error(f"Cell {cell_coord} formula does not contain concatenation operator &")
                    all_passed = False
                    continue
                
                # Check 8: Formula structure should be D2&TEXT(COUNTIF(D$2:D2,D2),"00")
                # Check that COUNTIF is inside TEXT
                text_countif_pattern = r'TEXT\s*\(\s*COUNTIF\s*\('
                if not re.search(text_countif_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not have correct TEXT(COUNTIF(...)) structure")
                    all_passed = False
                    continue
                
                # Check 9: Formula closes parentheses correctly
                open_count = formula_text.count('(')
                close_count = formula_text.count(')')
                if open_count != close_count:
                    logger.error(f"Cell {cell_coord} formula has mismatched parentheses")
                    all_passed = False
                    continue
                
                passed_count += 1
                logger.info(f"✓ Cell {cell_coord} has valid E column formula")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                all_passed = False
        
        if not all_passed:
            logger.error(f"✗ Formula verification failed: {passed_count}/{checked_count} cells passed")
            return 0.0
        
        if checked_count == 0:
            logger.error(f"No cells found in ranges {d_range} and {e_range}")
            return 0.0
        
        logger.info("=" * 60)
        logger.info(f"✓ All {checked_count} cells in ranges {d_range} and {e_range} contain correct seat number arrangement formulas")
        logger.info(f"  - D column formula: =TEXT(OFFSET(J$2,SMALL(IF(COLUMN(A:CZ)<=K$3:K$11,J$3:J$11,99),ROW(A1)),),\"00\")")
        logger.info(f"  - E column formula: =D2&TEXT(COUNTIF(D$2:D2,D2),\"00\")")
        logger.info(f"  - All cells passed verification")
        logger.info("=" * 60)
        return 1.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_pie_chart_sorted_data(result: str, expected: str = None, **options) -> float:
    """
    Verify if a pie chart exists with sorted data (descending order) and data labels.
    
    This function checks:
    1. Whether the data column is sorted in descending order (from large to small)
    2. Whether at least one pie chart exists in the worksheet
    3. Whether the chart type is pieChart
    4. Whether the chart has data labels enabled (checks dLbls.showVal, showPercent, or showCatName)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - data_column: Column containing data values to check sorting (e.g., "B")
            - start_row: Starting row number for data (e.g., 2, default: 2)
            - category_column: Column containing category labels (e.g., "A", optional)
            - expected_chart_type: Expected chart type (default: "pieChart")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        data_column = options.get('data_column', 'B')
        start_row = options.get('start_row', 2)
        category_column = options.get('category_column', 'A')
        expected_chart_type = options.get('expected_chart_type', 'pieChart')
        
        logger.info(f"Verifying pie chart with sorted data in file: {result}")
        logger.info(f"Data column: {data_column}, Start row: {start_row}")
        logger.info(f"Expected chart type: {expected_chart_type}")
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result)
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check 1: Verify data is sorted in descending order
        logger.info(f"Checking if data in column {data_column} is sorted in descending order...")
        max_row = ws.max_row
        data_values = []
        
        # Collect data values from the specified column
        for row_num in range(start_row, max_row + 1):
            cell = ws[f"{data_column}{row_num}"]
            if cell.value is None:
                # Stop at first empty cell (assuming data is contiguous)
                break
            try:
                # Try to convert to number
                if isinstance(cell.value, (int, float)):
                    data_values.append(float(cell.value))
                elif isinstance(cell.value, str):
                    # Try to parse string as number
                    try:
                        data_values.append(float(cell.value))
                    except ValueError:
                        logger.warning(f"Cell {data_column}{row_num} contains non-numeric value: {cell.value}")
                        break
                else:
                    data_values.append(float(cell.value))
            except (ValueError, TypeError):
                logger.warning(f"Cell {data_column}{row_num} cannot be converted to number: {cell.value}")
                break
        
        if len(data_values) < 2:
            logger.error(f"Insufficient data values found: {len(data_values)} (need at least 2)")
            return 0.0
        
        logger.info(f"Found {len(data_values)} data values")
        
        # Check if data is sorted in descending order
        is_descending = True
        for i in range(len(data_values) - 1):
            if data_values[i] < data_values[i + 1]:
                is_descending = False
                logger.warning(f"Data not sorted: {data_values[i]} < {data_values[i + 1]} at row {start_row + i}")
                break
        
        if not is_descending:
            logger.error(f"Data in column {data_column} is not sorted in descending order")
            logger.error(f"  First few values: {data_values[:5]}")
            return 0.0
        
        logger.info(f"✓ Data is sorted in descending order: {data_values[:5]}...")
        
        # Check 2: Verify pie chart exists
        logger.info("Checking for pie chart...")
        charts = ws._charts
        if not charts or len(charts) == 0:
            logger.error("No charts found in the worksheet")
            return 0.0
        
        logger.info(f"Found {len(charts)} chart(s) in the worksheet")
        
        # Check each chart
        pie_chart_found = False
        for chart_idx, chart in enumerate(charts):
            logger.info(f"Checking chart {chart_idx + 1}...")
            
            # Check chart type
            chart_type = None
            if hasattr(chart, 'tagname'):
                chart_type = chart.tagname
            elif hasattr(chart, 'chart_type'):
                chart_type = str(chart.chart_type)
            
            logger.info(f"Chart type: {chart_type}")
            
            # Check if it's a pie chart
            if chart_type and 'pie' in chart_type.lower():
                logger.info(f"✓ Chart {chart_idx + 1} is a pie chart")
                pie_chart_found = True
                
                # Check if it has series (data)
                if hasattr(chart, 'series') and chart.series:
                    series_count = len(chart.series)
                    logger.info(f"Chart {chart_idx + 1} has {series_count} series")
                else:
                    logger.info(f"Chart {chart_idx + 1} series information not available")
                    logger.error(f"Chart {chart_idx + 1} has no series")
                    return 0.0
                
                # Check 3: Verify data labels
                # Note: LibreOffice Calc stores data labels at the series level, not chart level
                data_labels_enabled = False
                
                # First check chart-level data labels (for Excel-created charts)
                if hasattr(chart, 'dLbls') and chart.dLbls is not None:
                    if hasattr(chart.dLbls, 'showVal') and chart.dLbls.showVal:
                        data_labels_enabled = True
                        logger.info(f"✓ Chart {chart_idx + 1} has data labels enabled at chart level (showVal=True)")
                    elif hasattr(chart.dLbls, 'showPercent') and chart.dLbls.showPercent:
                        data_labels_enabled = True
                        logger.info(f"✓ Chart {chart_idx + 1} has data labels enabled at chart level (showPercent=True)")
                    elif hasattr(chart.dLbls, 'showCatName') and chart.dLbls.showCatName:
                        data_labels_enabled = True
                        logger.info(f"✓ Chart {chart_idx + 1} has data labels enabled at chart level (showCatName=True)")
                
                # Check series-level data labels (for LibreOffice Calc-created charts)
                if not data_labels_enabled and hasattr(chart, 'series') and chart.series:
                    for ser_idx, ser in enumerate(chart.series):
                        if hasattr(ser, 'dLbls') and ser.dLbls is not None:
                            # Check if any label type is enabled
                            if hasattr(ser.dLbls, 'showVal') and ser.dLbls.showVal:
                                data_labels_enabled = True
                                logger.info(f"✓ Chart {chart_idx + 1} series {ser_idx + 1} has data labels enabled (showVal=True)")
                                break
                            elif hasattr(ser.dLbls, 'showPercent') and ser.dLbls.showPercent:
                                data_labels_enabled = True
                                logger.info(f"✓ Chart {chart_idx + 1} series {ser_idx + 1} has data labels enabled (showPercent=True)")
                                break
                            elif hasattr(ser.dLbls, 'showCatName') and ser.dLbls.showCatName:
                                data_labels_enabled = True
                                logger.info(f"✓ Chart {chart_idx + 1} series {ser_idx + 1} has data labels enabled (showCatName=True)")
                                break
                        # Also check labels attribute (alternative name)
                        elif hasattr(ser, 'labels') and ser.labels is not None:
                            if hasattr(ser.labels, 'showVal') and ser.labels.showVal:
                                data_labels_enabled = True
                                logger.info(f"✓ Chart {chart_idx + 1} series {ser_idx + 1} has data labels enabled (via labels.showVal=True)")
                                break
                            elif hasattr(ser.labels, 'showPercent') and ser.labels.showPercent:
                                data_labels_enabled = True
                                logger.info(f"✓ Chart {chart_idx + 1} series {ser_idx + 1} has data labels enabled (via labels.showPercent=True)")
                                break
                            elif hasattr(ser.labels, 'showCatName') and ser.labels.showCatName:
                                data_labels_enabled = True
                                logger.info(f"✓ Chart {chart_idx + 1} series {ser_idx + 1} has data labels enabled (via labels.showCatName=True)")
                                break
                
                if not data_labels_enabled:
                    logger.error(f"Chart {chart_idx + 1} does not have data labels enabled")
                    logger.error(f"  Chart-level dLbls: {getattr(chart, 'dLbls', 'N/A')}")
                    if hasattr(chart, 'series') and chart.series:
                        for ser_idx, ser in enumerate(chart.series):
                            logger.error(f"  Series {ser_idx + 1} dLbls: {getattr(ser, 'dLbls', 'N/A')}")
                            logger.error(f"  Series {ser_idx + 1} labels: {getattr(ser, 'labels', 'N/A')}")
                    return 0.0
                
                break
            else:
                logger.warning(f"Chart {chart_idx + 1} is not a pie chart (type: {chart_type})")
        
        if not pie_chart_found:
            logger.error("No pie chart found in the worksheet")
            return 0.0
        
        # If we get here, all checks passed
        logger.info("=" * 60)
        logger.info(f"✓ Pie chart verification passed")
        logger.info(f"  - Data column {data_column} is sorted in descending order")
        logger.info(f"  - Pie chart exists in the worksheet")
        logger.info(f"  - Data labels are enabled")
        logger.info(f"  - Data values: {len(data_values)} values, first few: {data_values[:5]}")
        logger.info("=" * 60)
        return 1.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_combination_chart_bar_line(result: str, expected: str = None, **options) -> float:
    """
    Verify if a combination chart exists with bar chart and line chart series, 
    where line chart series use secondary axis.
    
    This function checks:
    1. Whether at least one chart exists in the worksheet
    2. Whether the chart type is comboChart (combination chart)
    3. Whether the chart has at least the minimum number of bar series
    4. Whether the chart has at least the minimum number of line series
    5. Whether line series use secondary axis (if required)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - min_bar_series: Minimum number of bar series expected (default: 2)
            - min_line_series: Minimum number of line series expected (default: 2)
            - require_secondary_axis: Whether to require secondary axis for line series (default: True)
            - expected_chart_type: Expected chart type (default: "comboChart")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        min_bar_series = options.get('min_bar_series', 2)
        min_line_series = options.get('min_line_series', 2)
        require_secondary_axis = options.get('require_secondary_axis', True)
        expected_chart_type = options.get('expected_chart_type', 'comboChart')
        
        logger.info(f"Verifying combination chart (bar + line) in file: {result}")
        logger.info(f"Minimum bar series: {min_bar_series}")
        logger.info(f"Minimum line series: {min_line_series}")
        logger.info(f"Require secondary axis: {require_secondary_axis}")
        logger.info(f"Expected chart type: {expected_chart_type}")
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result)
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check if charts exist
        charts = ws._charts
        if not charts or len(charts) == 0:
            logger.error("No charts found in the worksheet")
            return 0.0
        
        logger.info(f"Found {len(charts)} chart(s) in the worksheet")
        
        # Check each chart
        for chart_idx, chart in enumerate(charts):
            logger.info(f"Checking chart {chart_idx + 1}...")
            
            # Check chart type
            chart_type = None
            if hasattr(chart, 'tagname'):
                chart_type = chart.tagname
            elif hasattr(chart, 'chart_type'):
                chart_type = str(chart.chart_type)
            
            logger.info(f"Chart type: {chart_type}")
            
            # Check if it's a combination chart
            is_combo_chart = False
            if chart_type:
                chart_type_lower = chart_type.lower()
                if 'combo' in chart_type_lower or 'combination' in chart_type_lower:
                    is_combo_chart = True
                    logger.info(f"✓ Chart {chart_idx + 1} is a combination chart")
            
            # If not explicitly a combo chart, check if it has mixed series types
            if not is_combo_chart:
                logger.info(f"Chart type '{chart_type}' is not explicitly a combo chart, checking for mixed series types...")
            
            # First, check chart structure for combo chart indicators (multiple axes and chart types)
            # This is the most reliable indicator of a combination chart
            has_multiple_axes = False
            has_bar_and_line = False
            
            # Check by reading XML directly (more reliable for LibreOffice Calc charts)
            xml_bar_series_count = 0
            xml_line_series_count = 0
            try:
                from zipfile import ZipFile
                import xml.etree.ElementTree as ET
                
                # Get the workbook file path
                wb_path = result
                with ZipFile(wb_path, 'r') as zip_file:
                    # Find chart XML files
                    chart_files = [f for f in zip_file.namelist() if 'charts/chart' in f and f.endswith('.xml')]
                    for chart_file in chart_files:
                        xml_content = zip_file.read(chart_file).decode('utf-8')
                        root = ET.fromstring(xml_content)
                        
                        # Check for barChart and lineChart in plotArea
                        plot_areas = root.findall('.//{http://schemas.openxmlformats.org/drawingml/2006/chart}plotArea')
                        for plot_area in plot_areas:
                            bar_charts = plot_area.findall('.//{http://schemas.openxmlformats.org/drawingml/2006/chart}barChart')
                            line_charts = plot_area.findall('.//{http://schemas.openxmlformats.org/drawingml/2006/chart}lineChart')
                            
                            if len(bar_charts) > 0 and len(line_charts) > 0:
                                has_bar_and_line = True
                                is_combo_chart = True
                                logger.info(f"✓ Chart has both barChart ({len(bar_charts)}) and lineChart ({len(line_charts)}) in plotArea XML (definitive combo chart indicator)")
                                
                                # Count series in barChart
                                for bar_chart in bar_charts:
                                    bar_series = bar_chart.findall('.//{http://schemas.openxmlformats.org/drawingml/2006/chart}ser')
                                    xml_bar_series_count = len(bar_series)
                                    logger.info(f"  barChart has {xml_bar_series_count} series in XML")
                                
                                # Count series in lineChart
                                for line_chart in line_charts:
                                    line_series = line_chart.findall('.//{http://schemas.openxmlformats.org/drawingml/2006/chart}ser')
                                    xml_line_series_count = len(line_series)
                                    logger.info(f"  lineChart has {xml_line_series_count} series in XML")
                            
                            # Check for multiple value axes
                            val_axes = plot_area.findall('.//{http://schemas.openxmlformats.org/drawingml/2006/chart}valAx')
                            if len(val_axes) >= 2:
                                has_multiple_axes = True
                                is_combo_chart = True
                                logger.info(f"✓ Chart has {len(val_axes)} value axes in XML (combo chart indicator)")
                        break  # Only check first chart file
            except Exception as e:
                logger.warning(f"Could not read chart XML: {e}, falling back to openpyxl attributes")
            
            # Fallback: check openpyxl attributes if XML check didn't work
            if not has_multiple_axes and hasattr(chart, 'plotArea'):
                plot_area = chart.plotArea
                # Check for multiple value axes (indicates combo chart with secondary axis)
                if hasattr(plot_area, 'valAx'):
                    val_axes = plot_area.valAx if isinstance(plot_area.valAx, list) else [plot_area.valAx]
                    if len(val_axes) >= 2:
                        has_multiple_axes = True
                        is_combo_chart = True
                        logger.info(f"✓ Chart has {len(val_axes)} value axes (combo chart indicator)")
            
            # Check for combo chart structure and get series from it
            all_series = []
            if hasattr(chart, 'comboChart') and chart.comboChart is not None:
                is_combo_chart = True
                logger.info("✓ Chart has comboChart structure")
                # Get series from comboChart structure
                if hasattr(chart.comboChart, 'ser'):
                    combo_series = chart.comboChart.ser if isinstance(chart.comboChart.ser, list) else [chart.comboChart.ser]
                    all_series = combo_series
                    logger.info(f"Found {len(all_series)} series in comboChart structure")
            
            # Also check regular series attribute (for non-combo charts or as fallback)
            if hasattr(chart, 'series') and chart.series:
                if len(all_series) == 0:
                    all_series = list(chart.series)
                    logger.info(f"Found {len(all_series)} series in chart.series")
                else:
                    # If we have both, prefer comboChart series but log both
                    regular_series_count = len(chart.series)
                    logger.info(f"Also found {regular_series_count} series in chart.series (using comboChart series)")
            
            if len(all_series) == 0:
                logger.warning(f"Chart {chart_idx + 1} has no series")
                continue
            
            series_count = len(all_series)
            logger.info(f"Chart {chart_idx + 1} has {series_count} total series")
            
            # Analyze series types
            bar_series_count = 0
            line_series_count = 0
            line_series_with_secondary_axis = 0
            
            # Analyze series to determine types
            for ser_idx, ser in enumerate(all_series):
                # Check series axis (secondary axis indicates line series in combo chart)
                uses_secondary_axis = False
                if hasattr(ser, 'axId'):
                    # Check if series uses secondary axis (axId > 0 or specific value)
                    ax_id = getattr(ser.axId, 'val', None) if hasattr(ser.axId, 'val') else getattr(ser, 'axId', None)
                    if ax_id is not None:
                        # Typically, primary axis is 0, secondary axis is 1 or higher
                        if isinstance(ax_id, (int, float)) and ax_id > 0:
                            uses_secondary_axis = True
                            logger.info(f"Series {ser_idx + 1} uses secondary axis (axId={ax_id})")
                            line_series_count += 1
                            line_series_with_secondary_axis += 1
                        else:
                            bar_series_count += 1
                    else:
                        # If axId is not available, we'll infer from multiple axes
                        pass
                else:
                    # If series doesn't have axId, check if we have multiple axes
                    # In combo charts with multiple axes, series without axId might be on primary axis
                    if has_multiple_axes:
                        # If we have multiple axes but series doesn't specify, assume primary (bar)
                        bar_series_count += 1
            
            # If we detected barChart and lineChart in plotArea, this is definitely a combo chart
            # Use series counts from XML if available
            if has_bar_and_line:
                logger.info("Chart has both barChart and lineChart in plotArea - this is a combination chart")
                # If we got series counts from XML, use them directly
                if xml_bar_series_count > 0 and xml_line_series_count > 0:
                    bar_series_count = xml_bar_series_count
                    line_series_count = xml_line_series_count
                    if require_secondary_axis and has_multiple_axes:
                        line_series_with_secondary_axis = xml_line_series_count
                    logger.info(f"Using series counts from XML: {bar_series_count} bar series, {line_series_count} line series")
                # Otherwise, infer from series count
                elif series_count == 4:
                    bar_series_count = 2
                    line_series_count = 2
                    if require_secondary_axis and has_multiple_axes:
                        line_series_with_secondary_axis = 2
                    logger.info(f"Inferred from barChart+lineChart structure with 4 series: 2 bar series, 2 line series")
                elif series_count >= (min_bar_series + min_line_series):
                    # Assume first min_bar_series are bars, rest are lines
                    bar_series_count = min_bar_series
                    line_series_count = min_line_series
                    if require_secondary_axis and has_multiple_axes:
                        line_series_with_secondary_axis = min_line_series
                    logger.info(f"Inferred from barChart+lineChart structure: {bar_series_count} bar series, {line_series_count} line series")
            
            # If we detected multiple axes but couldn't determine series types from axId,
            # infer from the structure
            elif has_multiple_axes and (bar_series_count == 0 and line_series_count == 0):
                logger.info("Multiple axes detected but series axId not available, inferring series types...")
                # In a combo chart with multiple axes, typically:
                # - First series are on primary axis (bars)
                # - Later series are on secondary axis (lines)
                # For a chart with 4 series and multiple axes, assume 2 bars + 2 lines
                if series_count == 4:
                    bar_series_count = 2
                    line_series_count = 2
                    if require_secondary_axis:
                        line_series_with_secondary_axis = 2
                    logger.info(f"Inferred from 4 series + multiple axes: 2 bar series, 2 line series")
                elif series_count >= (min_bar_series + min_line_series):
                    # Assume first min_bar_series are bars, rest are lines
                    bar_series_count = min(min_bar_series, series_count - min_line_series)
                    line_series_count = min(min_line_series, series_count - bar_series_count)
                    if require_secondary_axis:
                        line_series_with_secondary_axis = line_series_count
                    logger.info(f"Inferred: {bar_series_count} bar series, {line_series_count} line series")
                elif series_count >= 2:
                    # Even if we don't have 4 series, if we have multiple axes, it's likely a combo chart
                    # Assume at least 1 bar and 1 line series
                    bar_series_count = max(1, series_count // 2)
                    line_series_count = series_count - bar_series_count
                    if require_secondary_axis:
                        line_series_with_secondary_axis = line_series_count
                    logger.info(f"Inferred (flexible): {bar_series_count} bar series, {line_series_count} line series")
            
            # For combo charts, if we couldn't determine series types from axId,
            # try to infer from comboChart structure (which may have series type info)
            if is_combo_chart and (bar_series_count == 0 and line_series_count == 0):
                if hasattr(chart, 'comboChart') and chart.comboChart is not None:
                    # Check if comboChart has series type information
                    if hasattr(chart.comboChart, 'ser'):
                        combo_series = chart.comboChart.ser if isinstance(chart.comboChart.ser, list) else [chart.comboChart.ser]
                        # Try to determine series types from comboChart series
                        for combo_ser in combo_series:
                            # Check if series has chart type specified (e.g., line, bar)
                            # In comboChart, series may have different types
                            if hasattr(combo_ser, 'idx'):
                                # Check series order/index to infer type
                                # Typically first series are bars, later are lines
                                pass
                        
                        # If we have exactly 4 series and multiple axes, assume 2 bars + 2 lines
                        if len(combo_series) == 4 and has_multiple_axes:
                            bar_series_count = 2
                            line_series_count = 2
                            if require_secondary_axis:
                                line_series_with_secondary_axis = 2
                            logger.info(f"Inferred from comboChart: 2 bar series + 2 line series")
                        elif len(combo_series) >= (min_bar_series + min_line_series):
                            # Assume first half are bars, second half are lines
                            bar_series_count = min_bar_series
                            line_series_count = min_line_series
                            if require_secondary_axis:
                                line_series_with_secondary_axis = min_line_series
                            logger.info(f"Inferred from comboChart: {bar_series_count} bar series + {line_series_count} line series")
            
            logger.info(f"Bar series count: {bar_series_count} (minimum: {min_bar_series})")
            logger.info(f"Line series count: {line_series_count} (minimum: {min_line_series})")
            if require_secondary_axis:
                logger.info(f"Line series with secondary axis: {line_series_with_secondary_axis} (minimum: {min_line_series})")
            
            # If we have barChart+lineChart in plotArea, multiple axes, or combo chart structure, it's definitely a combination chart
            # Check if we meet the requirements
            if has_bar_and_line or has_multiple_axes or is_combo_chart:
                logger.info("Chart has barChart+lineChart, multiple axes, or combo chart structure - checking requirements...")
                # If we detected barChart and lineChart, this is definitely a combo chart
                if has_bar_and_line:
                    # With barChart and lineChart in plotArea, and 4 series, it should be 2 bars + 2 lines
                    if series_count == 4:
                        if bar_series_count == 0 and line_series_count == 0:
                            bar_series_count = 2
                            line_series_count = 2
                            if require_secondary_axis and has_multiple_axes:
                                line_series_with_secondary_axis = 2
                            logger.info(f"Detected barChart+lineChart with 4 series: assuming 2 bar + 2 line series")
                # For combination charts, we need at least min_bar_series and min_line_series
                # If we have 4 series and multiple axes, it should be 2 bars + 2 lines
                elif series_count == 4 and has_multiple_axes:
                    # With 4 series and multiple axes, assume 2 bars + 2 lines
                    if bar_series_count == 0 and line_series_count == 0:
                        bar_series_count = 2
                        line_series_count = 2
                        if require_secondary_axis:
                            line_series_with_secondary_axis = 2
                        logger.info(f"Detected 4 series with multiple axes: assuming 2 bar + 2 line series")
                
                # Check if we meet the minimum requirements
                if bar_series_count >= min_bar_series and line_series_count >= min_line_series:
                    if not require_secondary_axis or line_series_with_secondary_axis >= min_line_series:
                        logger.info("=" * 60)
                        logger.info(f"✓ Combination chart verification passed")
                        logger.info(f"  Chart type: {chart_type}")
                        logger.info(f"  Total series: {series_count}")
                        logger.info(f"  Bar series: {bar_series_count} (minimum: {min_bar_series})")
                        logger.info(f"  Line series: {line_series_count} (minimum: {min_line_series})")
                        if require_secondary_axis:
                            logger.info(f"  Line series with secondary axis: {line_series_with_secondary_axis} (minimum: {min_line_series})")
                        logger.info(f"  Multiple axes detected: {has_multiple_axes}")
                        logger.info(f"  BarChart+LineChart in plotArea: {has_bar_and_line}")
                        logger.info("=" * 60)
                        return 1.0
                elif bar_series_count >= 1 and line_series_count >= 1:
                    # If we have at least some bar and line series, and multiple axes, accept it
                    logger.info("Chart has multiple axes with some bar and line series - accepting as combination chart")
                    if not require_secondary_axis or line_series_with_secondary_axis >= 1:
                        logger.info("=" * 60)
                        logger.info(f"✓ Combination chart verification passed (lenient check)")
                        logger.info(f"  Chart type: {chart_type}")
                        logger.info(f"  Total series: {series_count}")
                        logger.info(f"  Bar series: {bar_series_count} (minimum: {min_bar_series})")
                        logger.info(f"  Line series: {line_series_count} (minimum: {min_line_series})")
                        if require_secondary_axis:
                            logger.info(f"  Line series with secondary axis: {line_series_with_secondary_axis} (minimum: {min_line_series})")
                        logger.info(f"  Multiple axes detected: {has_multiple_axes}")
                        logger.info("=" * 60)
                        return 1.0
            
            # Verify requirements (strict check for non-combo charts)
            if bar_series_count < min_bar_series:
                logger.warning(f"Chart {chart_idx + 1} has {bar_series_count} bar series, but minimum required is {min_bar_series}")
                continue
            
            if line_series_count < min_line_series:
                logger.warning(f"Chart {chart_idx + 1} has {line_series_count} line series, but minimum required is {min_line_series}")
                continue
            
            if require_secondary_axis and line_series_with_secondary_axis < min_line_series:
                logger.warning(f"Chart {chart_idx + 1} has {line_series_with_secondary_axis} line series with secondary axis, but minimum required is {min_line_series}")
                continue
            
            # If we have sufficient series, verification passes
            if bar_series_count >= min_bar_series and line_series_count >= min_line_series:
                logger.info("=" * 60)
                logger.info(f"✓ Combination chart verification passed")
                logger.info(f"  Chart type: {chart_type}")
                logger.info(f"  Total series: {series_count}")
                logger.info(f"  Bar series: {bar_series_count} (minimum: {min_bar_series})")
                logger.info(f"  Line series: {line_series_count} (minimum: {min_line_series})")
                if require_secondary_axis:
                    logger.info(f"  Line series with secondary axis: {line_series_with_secondary_axis} (minimum: {min_line_series})")
                logger.info("=" * 60)
                return 1.0
        
        # If we get here, verification failed
        logger.error("=" * 60)
        logger.error(f"✗ Combination chart verification failed")
        logger.error(f"  Expected chart type: {expected_chart_type}")
        logger.error(f"  Minimum bar series: {min_bar_series}")
        logger.error(f"  Minimum line series: {min_line_series}")
        if require_secondary_axis:
            logger.error(f"  Required secondary axis for line series: Yes")
        logger.error("=" * 60)
        return 0.0
             
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0

def verify_combination_chart_formatted(result: str, expected: str = None, **options) -> float:
    """
    Verify if a formatted combination chart exists with bar chart and line chart series,
    where line chart series use secondary axis, and optionally check axis maximum value.
    
    This function checks:
    1. Whether at least one chart exists in the worksheet
    2. Whether the chart has both barChart and lineChart in plotArea (combination chart)
    3. Whether the chart has at least the minimum number of bar series
    4. Whether the chart has at least the minimum number of line series
    5. Whether line series use secondary axis (if required)
    6. Whether the primary axis maximum value matches the expected value (if check_axis_max is True)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - min_bar_series: Minimum number of bar series expected (default: 2)
            - min_line_series: Minimum number of line series expected (default: 2)
            - require_secondary_axis: Whether to require secondary axis for line series (default: True)
            - expected_chart_type: Expected chart type (default: "comboChart")
            - check_axis_max: Whether to check axis maximum value (default: False)
            - axis_max_value: Expected maximum value for primary axis (default: None)
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        min_bar_series = options.get('min_bar_series', 2)
        min_line_series = options.get('min_line_series', 2)
        require_secondary_axis = options.get('require_secondary_axis', True)
        expected_chart_type = options.get('expected_chart_type', 'comboChart')
        check_axis_max = options.get('check_axis_max', False)
        axis_max_value = options.get('axis_max_value', None)
        
        logger.info(f"Verifying formatted combination chart in file: {result}")
        logger.info(f"Minimum bar series: {min_bar_series}")
        logger.info(f"Minimum line series: {min_line_series}")
        logger.info(f"Require secondary axis: {require_secondary_axis}")
        if check_axis_max:
            logger.info(f"Check axis maximum: {axis_max_value}")
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result)
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check if charts exist
        charts = ws._charts
        if not charts or len(charts) == 0:
            logger.error("No charts found in the worksheet")
            return 0.0
        
        logger.info(f"Found {len(charts)} chart(s) in the worksheet")
        
        # Check each chart
        for chart_idx, chart in enumerate(charts):
            logger.info(f"Checking chart {chart_idx + 1}...")
            
            # Check chart type
            chart_type = None
            if hasattr(chart, 'tagname'):
                chart_type = chart.tagname
            elif hasattr(chart, 'chart_type'):
                chart_type = str(chart.chart_type)
            
            logger.info(f"Chart type: {chart_type}")
            
            # Check if it's a combination chart
            is_combo_chart = False
            has_multiple_axes = False
            has_bar_and_line = False
            xml_bar_series_count = 0
            xml_line_series_count = 0
            primary_axis_max = None
            
            # Check by reading XML directly (more reliable for LibreOffice Calc charts)
            try:
                from zipfile import ZipFile
                import xml.etree.ElementTree as ET
                
                wb_path = result
                with ZipFile(wb_path, 'r') as zip_file:
                    chart_files = [f for f in zip_file.namelist() if 'charts/chart' in f and f.endswith('.xml')]
                    for chart_file in chart_files:
                        xml_content = zip_file.read(chart_file).decode('utf-8')
                        root = ET.fromstring(xml_content)
                        
                        plot_areas = root.findall('.//{http://schemas.openxmlformats.org/drawingml/2006/chart}plotArea')
                        for plot_area in plot_areas:
                            bar_charts = plot_area.findall('.//{http://schemas.openxmlformats.org/drawingml/2006/chart}barChart')
                            line_charts = plot_area.findall('.//{http://schemas.openxmlformats.org/drawingml/2006/chart}lineChart')
                            
                            if len(bar_charts) > 0 and len(line_charts) > 0:
                                has_bar_and_line = True
                                is_combo_chart = True
                                logger.info(f"✓ Chart has both barChart ({len(bar_charts)}) and lineChart ({len(line_charts)}) in plotArea XML")
                                
                                # Count series in barChart
                                for bar_chart in bar_charts:
                                    bar_series = bar_chart.findall('.//{http://schemas.openxmlformats.org/drawingml/2006/chart}ser')
                                    xml_bar_series_count = len(bar_series)
                                    logger.info(f"  barChart has {xml_bar_series_count} series in XML")
                                
                                # Count series in lineChart
                                for line_chart in line_charts:
                                    line_series = line_chart.findall('.//{http://schemas.openxmlformats.org/drawingml/2006/chart}ser')
                                    xml_line_series_count = len(line_series)
                                    logger.info(f"  lineChart has {xml_line_series_count} series in XML")
                            
                            # Check for multiple value axes
                            val_axes = plot_area.findall('.//{http://schemas.openxmlformats.org/drawingml/2006/chart}valAx')
                            if len(val_axes) >= 2:
                                has_multiple_axes = True
                                is_combo_chart = True
                                logger.info(f"✓ Chart has {len(val_axes)} value axes in XML")
                                
                                # Check primary axis maximum value
                                if check_axis_max and axis_max_value is not None:
                                    # Primary axis is usually the first one
                                    primary_axis = val_axes[0]
                                    max_elem = primary_axis.find('.//{http://schemas.openxmlformats.org/drawingml/2006/chart}max')
                                    if max_elem is not None:
                                        max_val = max_elem.get('val')
                                        if max_val:
                                            try:
                                                primary_axis_max = float(max_val)
                                                logger.info(f"Primary axis maximum value: {primary_axis_max}")
                                            except ValueError:
                                                logger.warning(f"Could not parse axis max value: {max_val}")
                        break
            except Exception as e:
                logger.warning(f"Could not read chart XML: {e}, falling back to openpyxl attributes")
            
            # Get series count
            all_series = []
            if hasattr(chart, 'series') and chart.series:
                all_series = list(chart.series)
            
            series_count = len(all_series)
            logger.info(f"Chart {chart_idx + 1} has {series_count} total series")
            
            # Use XML series counts if available
            bar_series_count = xml_bar_series_count if xml_bar_series_count > 0 else 0
            line_series_count = xml_line_series_count if xml_line_series_count > 0 else 0
            line_series_with_secondary_axis = line_series_count if has_multiple_axes and require_secondary_axis else 0
            
            # If we detected barChart and lineChart, use XML counts
            if has_bar_and_line:
                if xml_bar_series_count > 0 and xml_line_series_count > 0:
                    bar_series_count = xml_bar_series_count
                    line_series_count = xml_line_series_count
                    if require_secondary_axis and has_multiple_axes:
                        line_series_with_secondary_axis = xml_line_series_count
                    logger.info(f"Using series counts from XML: {bar_series_count} bar series, {line_series_count} line series")
                elif series_count == 4:
                    bar_series_count = 2
                    line_series_count = 2
                    if require_secondary_axis and has_multiple_axes:
                        line_series_with_secondary_axis = 2
                    logger.info(f"Inferred from barChart+lineChart structure with 4 series: 2 bar series, 2 line series")
            
            logger.info(f"Bar series count: {bar_series_count} (minimum: {min_bar_series})")
            logger.info(f"Line series count: {line_series_count} (minimum: {min_line_series})")
            if require_secondary_axis:
                logger.info(f"Line series with secondary axis: {line_series_with_secondary_axis} (minimum: {min_line_series})")
            
            # Verify requirements
            if bar_series_count < min_bar_series:
                logger.warning(f"Chart {chart_idx + 1} has {bar_series_count} bar series, but minimum required is {min_bar_series}")
                continue
            
            if line_series_count < min_line_series:
                logger.warning(f"Chart {chart_idx + 1} has {line_series_count} line series, but minimum required is {min_line_series}")
                continue
            
            if require_secondary_axis and line_series_with_secondary_axis < min_line_series:
                logger.warning(f"Chart {chart_idx + 1} has {line_series_with_secondary_axis} line series with secondary axis, but minimum required is {min_line_series}")
                continue
            
            # Check axis maximum value if required
            if check_axis_max and axis_max_value is not None:
                if primary_axis_max is None:
                    logger.warning(f"Could not determine primary axis maximum value")
                    # Don't fail if we can't check axis max, but log it
                elif abs(primary_axis_max - axis_max_value) > 0.01:  # Allow small floating point differences
                    logger.warning(f"Primary axis maximum value is {primary_axis_max}, but expected {axis_max_value}")
                    # Don't fail on axis max mismatch, as it's a formatting detail
                else:
                    logger.info(f"✓ Primary axis maximum value is {primary_axis_max} (expected: {axis_max_value})")
            
            # If we have a combo chart or sufficient series, verification passes
            if has_bar_and_line or (bar_series_count >= min_bar_series and line_series_count >= min_line_series):
                logger.info("=" * 60)
                logger.info(f"✓ Formatted combination chart verification passed")
                logger.info(f"  Chart type: {chart_type}")
                logger.info(f"  Total series: {series_count}")
                logger.info(f"  Bar series: {bar_series_count} (minimum: {min_bar_series})")
                logger.info(f"  Line series: {line_series_count} (minimum: {min_line_series})")
                if require_secondary_axis:
                    logger.info(f"  Line series with secondary axis: {line_series_with_secondary_axis} (minimum: {min_line_series})")
                logger.info(f"  Multiple axes detected: {has_multiple_axes}")
                logger.info(f"  BarChart+LineChart in plotArea: {has_bar_and_line}")
                if check_axis_max and primary_axis_max is not None:
                    logger.info(f"  Primary axis maximum: {primary_axis_max}")
                logger.info("=" * 60)
                return 1.0
        
        # If we get here, verification failed
        logger.error("=" * 60)
        logger.error(f"✗ Formatted combination chart verification failed")
        logger.error(f"  Expected chart type: {expected_chart_type}")
        logger.error(f"  Minimum bar series: {min_bar_series}")
        logger.error(f"  Minimum line series: {min_line_series}")
        if require_secondary_axis:
            logger.error(f"  Required secondary axis for line series: Yes")
        if check_axis_max:
            logger.error(f"  Expected axis maximum: {axis_max_value}")
        logger.error("=" * 60)
        return 0.0
             
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_combo_chart_bar_line_gradient(result: str, expected: str = None, **options) -> float:
    """
    Verify if a combination chart exists with bar chart (with gradient fill) and line chart series,
    where line chart series use secondary axis.
    
    This function checks:
    1. Whether at least one chart exists in the worksheet
    2. Whether the chart has both barChart and lineChart in plotArea (combination chart)
    3. Whether the chart has at least the minimum number of bar series
    4. Whether the chart has at least the minimum number of line series
    5. Whether line series use secondary axis (if required)
    6. Whether bar series have gradient fill (if check_gradient_fill is True)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - min_bar_series: Minimum number of bar series expected (default: 1)
            - min_line_series: Minimum number of line series expected (default: 1)
            - require_secondary_axis: Whether to require secondary axis for line series (default: True)
            - expected_chart_type: Expected chart type (default: "comboChart")
            - check_gradient_fill: Whether to check for gradient fill in bar series (default: False)
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        min_bar_series = options.get('min_bar_series', 1)
        min_line_series = options.get('min_line_series', 1)
        require_secondary_axis = options.get('require_secondary_axis', True)
        expected_chart_type = options.get('expected_chart_type', 'comboChart')
        check_gradient_fill = options.get('check_gradient_fill', False)
        
        logger.info(f"Verifying combo chart with gradient fill in file: {result}")
        logger.info(f"Minimum bar series: {min_bar_series}")
        logger.info(f"Minimum line series: {min_line_series}")
        logger.info(f"Require secondary axis: {require_secondary_axis}")
        logger.info(f"Check gradient fill: {check_gradient_fill}")
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result)
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check if charts exist
        charts = ws._charts
        if not charts or len(charts) == 0:
            logger.error("No charts found in the worksheet")
            return 0.0
        
        logger.info(f"Found {len(charts)} chart(s) in the worksheet")
        
        # Check each chart
        for chart_idx, chart in enumerate(charts):
            logger.info(f"Checking chart {chart_idx + 1}...")
            
            # Check chart type
            chart_type = None
            if hasattr(chart, 'tagname'):
                chart_type = chart.tagname
            elif hasattr(chart, 'chart_type'):
                chart_type = str(chart.chart_type)
            
            logger.info(f"Chart type: {chart_type}")
            
            # Check if it's a combination chart
            is_combo_chart = False
            has_multiple_axes = False
            has_bar_and_line = False
            xml_bar_series_count = 0
            xml_line_series_count = 0
            has_gradient_fill = False
            
            # Check by reading XML directly (more reliable for LibreOffice Calc charts)
            try:
                from zipfile import ZipFile
                import xml.etree.ElementTree as ET
                
                wb_path = result
                with ZipFile(wb_path, 'r') as zip_file:
                    chart_files = [f for f in zip_file.namelist() if 'charts/chart' in f and f.endswith('.xml')]
                    for chart_file in chart_files:
                        xml_content = zip_file.read(chart_file).decode('utf-8')
                        root = ET.fromstring(xml_content)
                        
                        plot_areas = root.findall('.//{http://schemas.openxmlformats.org/drawingml/2006/chart}plotArea')
                        for plot_area in plot_areas:
                            bar_charts = plot_area.findall('.//{http://schemas.openxmlformats.org/drawingml/2006/chart}barChart')
                            line_charts = plot_area.findall('.//{http://schemas.openxmlformats.org/drawingml/2006/chart}lineChart')
                            
                            if len(bar_charts) > 0 and len(line_charts) > 0:
                                has_bar_and_line = True
                                is_combo_chart = True
                                logger.info(f"✓ Chart has both barChart ({len(bar_charts)}) and lineChart ({len(line_charts)}) in plotArea XML")
                                
                                # Count series in barChart
                                for bar_chart in bar_charts:
                                    bar_series = bar_chart.findall('.//{http://schemas.openxmlformats.org/drawingml/2006/chart}ser')
                                    xml_bar_series_count = len(bar_series)
                                    logger.info(f"  barChart has {xml_bar_series_count} series in XML")
                                    
                                    # Check for gradient fill in bar series
                                    if check_gradient_fill:
                                        for ser in bar_series:
                                            # Check for gradient fill in series
                                            sp_pr = ser.find('.//{http://schemas.openxmlformats.org/drawingml/2006/main}spPr')
                                            if sp_pr is not None:
                                                grad_fill = sp_pr.find('.//{http://schemas.openxmlformats.org/drawingml/2006/main}gradFill')
                                                if grad_fill is not None:
                                                    has_gradient_fill = True
                                                    logger.info(f"  Found gradient fill in bar series")
                                
                                # Count series in lineChart
                                for line_chart in line_charts:
                                    line_series = line_chart.findall('.//{http://schemas.openxmlformats.org/drawingml/2006/chart}ser')
                                    xml_line_series_count = len(line_series)
                                    logger.info(f"  lineChart has {xml_line_series_count} series in XML")
                            
                            # Check for multiple value axes
                            val_axes = plot_area.findall('.//{http://schemas.openxmlformats.org/drawingml/2006/chart}valAx')
                            if len(val_axes) >= 2:
                                has_multiple_axes = True
                                is_combo_chart = True
                                logger.info(f"✓ Chart has {len(val_axes)} value axes in XML")
                        break
            except Exception as e:
                logger.warning(f"Could not read chart XML: {e}, falling back to openpyxl attributes")
            
            # Get series count
            all_series = []
            if hasattr(chart, 'series') and chart.series:
                all_series = list(chart.series)
            
            series_count = len(all_series)
            logger.info(f"Chart {chart_idx + 1} has {series_count} total series")
            
            # Use XML series counts if available
            bar_series_count = xml_bar_series_count if xml_bar_series_count > 0 else 0
            line_series_count = xml_line_series_count if xml_line_series_count > 0 else 0
            line_series_with_secondary_axis = line_series_count if has_multiple_axes and require_secondary_axis else 0
            
            # If we detected barChart and lineChart, use XML counts
            if has_bar_and_line:
                if xml_bar_series_count > 0 and xml_line_series_count > 0:
                    bar_series_count = xml_bar_series_count
                    line_series_count = xml_line_series_count
                    if require_secondary_axis and has_multiple_axes:
                        line_series_with_secondary_axis = xml_line_series_count
                    logger.info(f"Using series counts from XML: {bar_series_count} bar series, {line_series_count} line series")
                elif series_count >= (min_bar_series + min_line_series):
                    # Infer series types
                    bar_series_count = min_bar_series
                    line_series_count = min_line_series
                    if require_secondary_axis and has_multiple_axes:
                        line_series_with_secondary_axis = min_line_series
                    logger.info(f"Inferred from barChart+lineChart structure: {bar_series_count} bar series, {line_series_count} line series")
            
            logger.info(f"Bar series count: {bar_series_count} (minimum: {min_bar_series})")
            logger.info(f"Line series count: {line_series_count} (minimum: {min_line_series})")
            if require_secondary_axis:
                logger.info(f"Line series with secondary axis: {line_series_with_secondary_axis} (minimum: {min_line_series})")
            if check_gradient_fill:
                logger.info(f"Gradient fill detected: {has_gradient_fill}")
            
            # Verify requirements
            if bar_series_count < min_bar_series:
                logger.warning(f"Chart {chart_idx + 1} has {bar_series_count} bar series, but minimum required is {min_bar_series}")
                continue
            
            if line_series_count < min_line_series:
                logger.warning(f"Chart {chart_idx + 1} has {line_series_count} line series, but minimum required is {min_line_series}")
                continue
            
            if require_secondary_axis and line_series_with_secondary_axis < min_line_series:
                logger.warning(f"Chart {chart_idx + 1} has {line_series_with_secondary_axis} line series with secondary axis, but minimum required is {min_line_series}")
                continue
            
            # Check gradient fill if required
            if check_gradient_fill and not has_gradient_fill:
                logger.warning(f"Chart {chart_idx + 1} does not have gradient fill in bar series")
                # Don't fail on gradient fill, as it's a formatting detail that may not be detectable
                # But log it for information
            
            # If we have a combo chart or sufficient series, verification passes
            if has_bar_and_line or (bar_series_count >= min_bar_series and line_series_count >= min_line_series):
                logger.info("=" * 60)
                logger.info(f"✓ Combo chart with gradient fill verification passed")
                logger.info(f"  Chart type: {chart_type}")
                logger.info(f"  Total series: {series_count}")
                logger.info(f"  Bar series: {bar_series_count} (minimum: {min_bar_series})")
                logger.info(f"  Line series: {line_series_count} (minimum: {min_line_series})")
                if require_secondary_axis:
                    logger.info(f"  Line series with secondary axis: {line_series_with_secondary_axis} (minimum: {min_line_series})")
                logger.info(f"  Multiple axes detected: {has_multiple_axes}")
                logger.info(f"  BarChart+LineChart in plotArea: {has_bar_and_line}")
                if check_gradient_fill:
                    logger.info(f"  Gradient fill detected: {has_gradient_fill}")
                logger.info("=" * 60)
                return 1.0
        
        # If we get here, verification failed
        logger.error("=" * 60)
        logger.error(f"✗ Combo chart with gradient fill verification failed")
        logger.error(f"  Expected chart type: {expected_chart_type}")
        logger.error(f"  Minimum bar series: {min_bar_series}")
        logger.error(f"  Minimum line series: {min_line_series}")
        if require_secondary_axis:
            logger.error(f"  Required secondary axis for line series: Yes")
        if check_gradient_fill:
            logger.error(f"  Required gradient fill: Yes")
        logger.error("=" * 60)
        return 0.0
             
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_bar_chart_with_data_table(result: str, expected: str = None, **options) -> float:
    """
    Verify if a bar chart exists with an embedded data table.
    
    This function checks:
    1. Whether at least one chart exists in the worksheet
    2. Whether the chart type is barChart
    3. Whether the chart has at least the minimum number of series
    4. Whether the chart has a data table (dTable element in XML)
    5. Whether axis titles exist (if check_axis_title is specified)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - expected_chart_type: Expected chart type (default: "barChart")
            - min_series_count: Minimum number of series expected (default: 3)
            - check_data_table: Whether to check for data table (default: True)
            - check_axis_title: Whether to check axis title (default: False, True means should NOT exist)
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        expected_chart_type = options.get('expected_chart_type', 'barChart')
        min_series_count = options.get('min_series_count', 3)
        check_data_table = options.get('check_data_table', True)
        check_axis_title = options.get('check_axis_title', False)
        
        logger.info(f"Verifying bar chart with data table in file: {result}")
        logger.info(f"Expected chart type: {expected_chart_type}")
        logger.info(f"Minimum series count: {min_series_count}")
        logger.info(f"Check data table: {check_data_table}")
        logger.info(f"Check axis title (should not exist): {check_axis_title}")
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result)
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check if charts exist
        charts = ws._charts
        if not charts or len(charts) == 0:
            logger.error("No charts found in the worksheet")
            return 0.0
        
        logger.info(f"Found {len(charts)} chart(s) in the worksheet")
        
        # Check each chart
        for chart_idx, chart in enumerate(charts):
            logger.info(f"Checking chart {chart_idx + 1}...")
            
            # Check chart type
            chart_type = None
            if hasattr(chart, 'tagname'):
                chart_type = chart.tagname
            elif hasattr(chart, 'chart_type'):
                chart_type = str(chart.chart_type)
            
            logger.info(f"Chart type: {chart_type}")
            
            # Check if it's a bar chart
            is_bar_chart = False
            if chart_type:
                chart_type_lower = chart_type.lower()
                if 'bar' in chart_type_lower or 'column' in chart_type_lower:
                    is_bar_chart = True
                    logger.info(f"✓ Chart {chart_idx + 1} is a bar/column chart")
            
            if not is_bar_chart:
                logger.warning(f"Chart {chart_idx + 1} is not a bar chart (type: {chart_type})")
                continue
            
            # Check series count
            if not hasattr(chart, 'series') or not chart.series:
                logger.warning(f"Chart {chart_idx + 1} has no series")
                continue
            
            series_count = len(chart.series)
            logger.info(f"Chart {chart_idx + 1} has {series_count} series")
            
            if series_count < min_series_count:
                logger.warning(f"Chart {chart_idx + 1} has {series_count} series, but minimum required is {min_series_count}")
                continue
            
            # Check for data table and axis titles in XML
            has_data_table = False
            has_axis_title = False
            
            if check_data_table or check_axis_title:
                try:
                    from zipfile import ZipFile
                    import xml.etree.ElementTree as ET
                    
                    wb_path = result
                    with ZipFile(wb_path, 'r') as zip_file:
                        chart_files = [f for f in zip_file.namelist() if 'charts/chart' in f and f.endswith('.xml')]
                        for chart_file in chart_files:
                            xml_content = zip_file.read(chart_file).decode('utf-8')
                            root = ET.fromstring(xml_content)
                            
                            # Check for data table (dTable element)
                            if check_data_table:
                                d_tables = root.findall('.//{http://schemas.openxmlformats.org/drawingml/2006/chart}dTable')
                                if len(d_tables) > 0:
                                    has_data_table = True
                                    logger.info(f"✓ Chart has data table (dTable element found)")
                                else:
                                    logger.warning(f"Chart does not have data table (dTable element not found)")
                            
                            # Check for axis titles
                            if check_axis_title:
                                # Check for value axis title
                                val_axis_titles = root.findall('.//{http://schemas.openxmlformats.org/drawingml/2006/chart}valAx/{http://schemas.openxmlformats.org/drawingml/2006/chart}title')
                                cat_axis_titles = root.findall('.//{http://schemas.openxmlformats.org/drawingml/2006/chart}catAx/{http://schemas.openxmlformats.org/drawingml/2006/chart}title')
                                
                                if len(val_axis_titles) > 0 or len(cat_axis_titles) > 0:
                                    has_axis_title = True
                                    logger.info(f"Chart has axis titles (valAx titles: {len(val_axis_titles)}, catAx titles: {len(cat_axis_titles)})")
                                else:
                                    logger.info(f"✓ Chart does not have axis titles (as expected)")
                            
                            break
                except Exception as e:
                    logger.warning(f"Could not read chart XML: {e}")
            
            # Verify requirements
            if check_data_table and not has_data_table:
                logger.warning(f"Chart {chart_idx + 1} does not have data table")
                continue
            
            if check_axis_title and has_axis_title:
                logger.warning(f"Chart {chart_idx + 1} has axis titles, but they should be removed")
                continue
            
            # If we get here, verification passes
            logger.info("=" * 60)
            logger.info(f"✓ Bar chart with data table verification passed")
            logger.info(f"  Chart type: {chart_type}")
            logger.info(f"  Series count: {series_count} (minimum: {min_series_count})")
            if check_data_table:
                logger.info(f"  Data table: {'Present' if has_data_table else 'Not checked'}")
            if check_axis_title:
                logger.info(f"  Axis titles: {'Removed' if not has_axis_title else 'Present (should be removed)'}")
            logger.info("=" * 60)
            return 1.0
        
        # If we get here, verification failed
        logger.error("=" * 60)
        logger.error(f"✗ Bar chart with data table verification failed")
        logger.error(f"  Expected chart type: {expected_chart_type}")
        logger.error(f"  Minimum series count: {min_series_count}")
        if check_data_table:
            logger.error(f"  Required data table: Yes")
        if check_axis_title:
            logger.error(f"  Axis titles should be removed: Yes")
        logger.error("=" * 60)
        return 0.0
             
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_stacked_bar_chart_difference(result: str, expected: str = None, **options) -> float:
    """
    Verify if a bar chart (stacked or clustered) exists showing target value and difference (gap) between actual and target.
    
    This function checks:
    1. Whether at least one chart exists in the worksheet
    2. Whether the chart type is barChart (stacked or clustered, both are acceptable)
    3. Whether the chart has at least the minimum number of series
    4. Whether the chart is stacked or clustered (grouping attribute, for information only)
    5. Whether data labels exist (if check_data_labels is True)
    
    Note: This function accepts both stacked and clustered bar charts.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - expected_chart_type: Expected chart type (default: "barChart")
            - min_series_count: Minimum number of series expected (default: 2)
            - check_stacked: Whether to check if chart is stacked (default: True)
            - check_data_labels: Whether to check for data labels (default: True)
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        expected_chart_type = options.get('expected_chart_type', 'barChart')
        min_series_count = options.get('min_series_count', 2)
        check_stacked = options.get('check_stacked', True)
        check_data_labels = options.get('check_data_labels', True)
        
        logger.info(f"Verifying bar chart (stacked or clustered) with difference in file: {result}")
        logger.info(f"Expected chart type: {expected_chart_type}")
        logger.info(f"Minimum series count: {min_series_count}")
        logger.info(f"Check stacked: {check_stacked}")
        logger.info(f"Check data labels: {check_data_labels}")
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result)
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check if charts exist
        charts = ws._charts
        if not charts or len(charts) == 0:
            logger.error("No charts found in the worksheet")
            return 0.0
        
        logger.info(f"Found {len(charts)} chart(s) in the worksheet")
        
        # Check each chart
        for chart_idx, chart in enumerate(charts):
            logger.info(f"Checking chart {chart_idx + 1}...")
            
            # Check chart type
            chart_type = None
            if hasattr(chart, 'tagname'):
                chart_type = chart.tagname
            elif hasattr(chart, 'chart_type'):
                chart_type = str(chart.chart_type)
            
            logger.info(f"Chart type: {chart_type}")
            
            # Check if it's a bar chart
            is_bar_chart = False
            if chart_type:
                chart_type_lower = chart_type.lower()
                if 'bar' in chart_type_lower or 'column' in chart_type_lower:
                    is_bar_chart = True
                    logger.info(f"✓ Chart {chart_idx + 1} is a bar/column chart")
            
            if not is_bar_chart:
                logger.warning(f"Chart {chart_idx + 1} is not a bar chart (type: {chart_type})")
                continue
            
            # Check series count
            if not hasattr(chart, 'series') or not chart.series:
                logger.warning(f"Chart {chart_idx + 1} has no series")
                continue
            
            series_count = len(chart.series)
            logger.info(f"Chart {chart_idx + 1} has {series_count} series")
            
            if series_count < min_series_count:
                logger.warning(f"Chart {chart_idx + 1} has {series_count} series, but minimum required is {min_series_count}")
                continue
            
            # Check if chart is stacked or clustered (for information, both are acceptable)
            is_stacked = False
            is_clustered = False
            # Always check grouping to determine chart type (for logging)
            if hasattr(chart, 'grouping'):
                grouping = chart.grouping
                if grouping and 'stack' in str(grouping).lower():
                    is_stacked = True
                    logger.info(f"Chart grouping: {grouping} (stacked)")
                elif grouping and 'clustered' in str(grouping).lower():
                    is_clustered = True
                    logger.info(f"Chart grouping: {grouping} (clustered)")
                else:
                    logger.info(f"Chart grouping: {grouping}")
            
            # Also check XML for grouping attribute
            if not is_stacked and not is_clustered:
                try:
                    from zipfile import ZipFile
                    import xml.etree.ElementTree as ET
                    
                    wb_path = result
                    with ZipFile(wb_path, 'r') as zip_file:
                        chart_files = [f for f in zip_file.namelist() if 'charts/chart' in f and f.endswith('.xml')]
                        for chart_file in chart_files:
                            xml_content = zip_file.read(chart_file).decode('utf-8')
                            root = ET.fromstring(xml_content)
                            
                            # Check for grouping attribute in barChart
                            bar_charts = root.findall('.//{http://schemas.openxmlformats.org/drawingml/2006/chart}barChart')
                            for bar_chart in bar_charts:
                                grouping_attr = bar_chart.get('grouping')
                                if grouping_attr:
                                    if 'stack' in grouping_attr.lower():
                                        is_stacked = True
                                        logger.info(f"Chart is stacked (grouping attribute: {grouping_attr})")
                                    elif 'clustered' in grouping_attr.lower() or grouping_attr.lower() == 'clustered':
                                        is_clustered = True
                                        logger.info(f"Chart is clustered (grouping attribute: {grouping_attr})")
                                    else:
                                        logger.info(f"Chart grouping attribute: {grouping_attr}")
                                break
                            break
                except Exception as e:
                    logger.warning(f"Could not read chart XML for grouping check: {e}")
            
            # Log chart type detected
            if is_stacked:
                logger.info(f"✓ Detected stacked bar chart")
            elif is_clustered:
                logger.info(f"✓ Detected clustered bar chart")
            else:
                logger.info(f"Chart type: bar chart (grouping not determined, accepting as valid)")
            # Check for data labels
            has_data_labels = False
            if check_data_labels:
                # Check chart-level data labels
                if hasattr(chart, 'dLbls') and chart.dLbls is not None:
                    has_data_labels = True
                    logger.info(f"✓ Chart has data labels at chart level")
                else:
                    # Check series-level data labels
                    for ser_idx, ser in enumerate(chart.series):
                        if hasattr(ser, 'dLbls') and ser.dLbls is not None:
                            has_data_labels = True
                            logger.info(f"✓ Series {ser_idx + 1} has data labels")
                            break
                    
                    # Also check XML for data labels
                    if not has_data_labels:
                        try:
                            from zipfile import ZipFile
                            import xml.etree.ElementTree as ET
                            
                            wb_path = result
                            with ZipFile(wb_path, 'r') as zip_file:
                                chart_files = [f for f in zip_file.namelist() if 'charts/chart' in f and f.endswith('.xml')]
                                for chart_file in chart_files:
                                    xml_content = zip_file.read(chart_file).decode('utf-8')
                                    root = ET.fromstring(xml_content)
                                    
                                    # Check for dLbls elements
                                    d_lbls = root.findall('.//{http://schemas.openxmlformats.org/drawingml/2006/chart}dLbls')
                                    if len(d_lbls) > 0:
                                        has_data_labels = True
                                        logger.info(f"✓ Chart has data labels in XML ({len(d_lbls)} dLbls elements found)")
                                        break
                        except Exception as e:
                            logger.warning(f"Could not read chart XML for data labels check: {e}")
            
            # Verify requirements
            # Note: We accept both stacked and clustered bar charts
            # If check_stacked is True, we prefer stacked but don't fail on clustered
            if check_stacked:
                if is_stacked:
                    logger.info(f"✓ Chart is stacked (as preferred)")
                elif is_clustered:
                    logger.info(f"Chart is clustered (also acceptable)")
                else:
                    logger.info(f"Chart grouping not determined (accepting as bar chart)")
            # If check_stacked is False, we accept any bar chart type
            
            if check_data_labels and not has_data_labels:
                logger.warning(f"Chart {chart_idx + 1} does not have data labels")
                continue
            
            # If we get here, verification passes
            logger.info("=" * 60)
            logger.info(f"✓ Bar chart with difference verification passed")
            logger.info(f"  Chart type: {chart_type}")
            logger.info(f"  Series count: {series_count} (minimum: {min_series_count})")
            if check_stacked:
                logger.info(f"  Stacked: {is_stacked}")
            if check_data_labels:
                logger.info(f"  Data labels: {'Present' if has_data_labels else 'Not checked'}")
            logger.info("=" * 60)
            return 1.0
        
        # If we get here, verification failed
        logger.error("=" * 60)
        logger.error(f"✗ Bar chart with difference verification failed")
        logger.error(f"  Expected chart type: {expected_chart_type}")
        logger.error(f"  Minimum series count: {min_series_count}")
        if check_stacked:
            logger.error(f"  Required stacked: Yes")
        if check_data_labels:
            logger.error(f"  Required data labels: Yes")
        logger.error("=" * 60)
        return 0.0
             
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_chart_with_scrollbar(result: str, expected: str = None, **options) -> float:
    """
    Verify if a chart exists with scrollbar control using named ranges with OFFSET formulas.
    
    This function checks:
    1. Whether at least one chart exists in the worksheet
    2. Whether the chart type matches the expected type
    3. Whether named ranges exist (if check_named_ranges is True)
    4. Whether named ranges use OFFSET formulas (if check_offset_formula is True)
    5. Whether the control cell (F1) exists and has a value
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - expected_chart_type: Expected chart type (default: "barChart")
            - check_named_ranges: Whether to check for named ranges (default: True)
            - named_range_prefixes: List of named range names to check (default: ["G1", "H1", "I1"])
            - check_offset_formula: Whether to check if named ranges use OFFSET (default: True)
            - control_cell: Cell that controls the scrollbar (default: "F1")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        expected_chart_type = options.get('expected_chart_type', 'barChart')
        check_named_ranges = options.get('check_named_ranges', True)
        named_range_prefixes = options.get('named_range_prefixes', ['G1', 'H1', 'I1'])
        check_offset_formula = options.get('check_offset_formula', True)
        control_cell = options.get('control_cell', 'F1')
        
        logger.info(f"Verifying chart with scrollbar in file: {result}")
        logger.info(f"Expected chart type: {expected_chart_type}")
        logger.info(f"Check named ranges: {check_named_ranges}")
        logger.info(f"Named range prefixes: {named_range_prefixes}")
        logger.info(f"Check OFFSET formula: {check_offset_formula}")
        logger.info(f"Control cell: {control_cell}")
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result)
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check if charts exist
        charts = ws._charts
        if not charts or len(charts) == 0:
            logger.error("No charts found in the worksheet")
            return 0.0
        
        logger.info(f"Found {len(charts)} chart(s) in the worksheet")
        
        # Check chart type - accept both bar chart and combination chart (bar + line)
        chart_found = False
        has_bar_chart = False
        has_line_chart = False
        
        for chart_idx, chart in enumerate(charts):
            logger.info(f"Checking chart {chart_idx + 1}...")
            
            chart_type = None
            if hasattr(chart, 'tagname'):
                chart_type = chart.tagname
            elif hasattr(chart, 'chart_type'):
                chart_type = str(chart.chart_type)
            
            logger.info(f"Chart type: {chart_type}")
            
            # Check if it's a bar chart, combo chart, or contains bar chart
            if chart_type:
                chart_type_lower = chart_type.lower()
                if expected_chart_type.lower() in chart_type_lower or 'bar' in chart_type_lower or 'column' in chart_type_lower:
                    chart_found = True
                    has_bar_chart = True
                    logger.info(f"✓ Chart {chart_idx + 1} is a bar/column chart")
                elif 'combo' in chart_type_lower or 'combination' in chart_type_lower:
                    chart_found = True
                    logger.info(f"✓ Chart {chart_idx + 1} is a combination chart")
            
            # Check XML for barChart and lineChart in plotArea (for combo charts)
            try:
                from zipfile import ZipFile
                import xml.etree.ElementTree as ET
                
                wb_path = result
                with ZipFile(wb_path, 'r') as zip_file:
                    chart_files = [f for f in zip_file.namelist() if 'charts/chart' in f and f.endswith('.xml')]
                    for chart_file in chart_files:
                        xml_content = zip_file.read(chart_file).decode('utf-8')
                        root = ET.fromstring(xml_content)
                        
                        plot_areas = root.findall('.//{http://schemas.openxmlformats.org/drawingml/2006/chart}plotArea')
                        for plot_area in plot_areas:
                            bar_charts = plot_area.findall('.//{http://schemas.openxmlformats.org/drawingml/2006/chart}barChart')
                            line_charts = plot_area.findall('.//{http://schemas.openxmlformats.org/drawingml/2006/chart}lineChart')
                            
                            if len(bar_charts) > 0:
                                has_bar_chart = True
                                chart_found = True
                                logger.info(f"✓ Chart has barChart in plotArea")
                            
                            if len(line_charts) > 0:
                                has_line_chart = True
                                chart_found = True
                                logger.info(f"✓ Chart has lineChart in plotArea")
                            
                            if has_bar_chart and has_line_chart:
                                logger.info(f"✓ Chart is a combination chart (bar + line)")
                        break
            except Exception as e:
                logger.warning(f"Could not read chart XML: {e}")
            
            if chart_found:
                break
        
        if not chart_found:
            logger.error(f"No bar chart or combination chart found")
            return 0.0
        
        if not has_bar_chart:
            logger.error(f"Chart does not contain bar chart series")
            return 0.0
        
        # Check named ranges
        named_ranges_found = []
        named_ranges_with_offset = []
        
        if check_named_ranges:
            logger.info("Checking named ranges...")
            if hasattr(wb, 'defined_names'):
                defined_names = wb.defined_names
                logger.info(f"Found {len(defined_names)} defined name(s)")
                
                for name, name_obj in defined_names.items():
                    formula = name_obj.value if hasattr(name_obj, 'value') else str(name_obj)
                    
                    logger.info(f"Named range: {name}, Formula: {formula}")
                    
                    # Check if this is one of the expected named ranges
                    for prefix in named_range_prefixes:
                        if name == prefix or name.startswith(prefix):
                            named_ranges_found.append(name)
                            logger.info(f"✓ Found expected named range: {name}")
                            
                            # Check if it uses OFFSET
                            if check_offset_formula:
                                if 'OFFSET' in formula.upper() or 'offset' in formula:
                                    named_ranges_with_offset.append(name)
                                    logger.info(f"✓ Named range {name} uses OFFSET formula")
                                else:
                                    logger.warning(f"Named range {name} does not use OFFSET formula")
                            break
            
            # Check if we found the expected named ranges
            if len(named_ranges_found) < len(named_range_prefixes):
                missing = set(named_range_prefixes) - set([n.split('_')[0] if '_' in n else n for n in named_ranges_found])
                logger.warning(f"Missing named ranges: {missing}")
                # Don't fail if some named ranges are missing, as naming might vary
            else:
                logger.info(f"✓ Found {len(named_ranges_found)} expected named range(s)")
        
        # Check for scrollbar control (ActiveX or Form control)
        has_scrollbar = False
        try:
            from zipfile import ZipFile
            import xml.etree.ElementTree as ET
            
            wb_path = result
            with ZipFile(wb_path, 'r') as zip_file:
                # Check for ActiveX controls in drawing files
                drawing_files = [f for f in zip_file.namelist() if 'drawings/drawing' in f and f.endswith('.xml')]
                for drawing_file in drawing_files:
                    try:
                        xml_content = zip_file.read(drawing_file).decode('utf-8')
                        root = ET.fromstring(xml_content)
                        
                        # Check for scrollbar control (ActiveX)
                        # Scrollbar controls might be referenced in different ways
                        # Check for control elements or shape types that might indicate scrollbar
                        controls = root.findall('.//{http://schemas.openxmlformats.org/drawingml/2006/main}control')
                        if len(controls) > 0:
                            has_scrollbar = True
                            logger.info(f"✓ Found control elements in drawing (possible scrollbar)")
                            break
                    except Exception as e:
                        logger.debug(f"Could not parse drawing file {drawing_file}: {e}")
                
                # Check for form controls in xl/ctrlProps or similar
                # Also check for VBA forms or ActiveX controls
                vba_files = [f for f in zip_file.namelist() if 'vba' in f.lower() or 'forms' in f.lower()]
                if len(vba_files) > 0:
                    logger.info(f"Found {len(vba_files)} VBA/form related files (may contain scrollbar)")
                
                # Check for embedded objects that might be scrollbar controls
                # In some cases, scrollbar might be in xl/embeddings or similar
                embedding_files = [f for f in zip_file.namelist() if 'embedding' in f.lower() or 'oleObject' in f.lower()]
                if len(embedding_files) > 0:
                    logger.info(f"Found {len(embedding_files)} embedded object files (may contain scrollbar)")
        except Exception as e:
            logger.warning(f"Could not check for scrollbar control: {e}")
        
        # Check control cell
        control_cell_value = None
        try:
            control_cell_obj = ws[control_cell]
            control_cell_value = control_cell_obj.value
            if control_cell_value is not None:
                logger.info(f"Control cell {control_cell} has value: {control_cell_value}")
                # If control cell has a value, it's likely linked to a scrollbar
                if not has_scrollbar:
                    logger.info(f"Control cell has value, assuming scrollbar exists (may not be detectable in XML)")
            else:
                logger.warning(f"Control cell {control_cell} is empty")
        except Exception as e:
            logger.warning(f"Could not read control cell {control_cell}: {e}")
        
        # Verify requirements
        if not chart_found:
            logger.error("Chart verification failed")
            return 0.0
        
        if check_named_ranges:
            if len(named_ranges_found) == 0:
                logger.warning("No named ranges found, but this might be acceptable")
            elif check_offset_formula and len(named_ranges_with_offset) == 0:
                logger.warning("Named ranges found but none use OFFSET formula")
                # Don't fail, as OFFSET might be in a different format
        
        # If we get here, verification passes
        logger.info("=" * 60)
        logger.info(f"✓ Chart with scrollbar verification passed (accepts bar chart or combination chart)")
        logger.info(f"  Chart type: {chart_type}")
        logger.info(f"  Charts found: {len(charts)}")
        if check_named_ranges:
            logger.info(f"  Named ranges found: {len(named_ranges_found)}")
            if check_offset_formula:
                logger.info(f"  Named ranges with OFFSET: {len(named_ranges_with_offset)}")
        if has_scrollbar:
            logger.info(f"  Scrollbar control: Detected")
        elif control_cell_value is not None:
            logger.info(f"  Scrollbar control: Likely exists (control cell has value)")
        if control_cell_value is not None:
            logger.info(f"  Control cell {control_cell} value: {control_cell_value}")
        logger.info("=" * 60)
        return 1.0
             
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_line_chart_with_high_low_lines(result: str, expected: str = None, **options) -> float:
    """
    Verify if a line chart exists with high-low lines (高低点连线) and data labels.
    
    This function checks:
    1. Whether at least one chart exists in the worksheet
    2. Whether the chart is a line chart
    3. Whether the chart has at least the minimum number of series
    4. Whether data labels are enabled
    5. Whether high-low lines (高低点连线) are enabled
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - expected_chart_type: Expected chart type (default: "lineChart")
            - min_series_count: Minimum number of series required (default: 2)
            - check_data_labels: Whether to check for data labels (default: True)
            - check_high_low_lines: Whether to check for high-low lines (default: True)
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        expected_chart_type = options.get('expected_chart_type', 'lineChart')
        min_series_count = options.get('min_series_count', 2)
        check_data_labels = options.get('check_data_labels', True)
        check_high_low_lines = options.get('check_high_low_lines', True)
        
        logger.info(f"Verifying line chart with high-low lines in file: {result}")
        logger.info(f"Expected chart type: {expected_chart_type}")
        logger.info(f"Minimum series count: {min_series_count}")
        logger.info(f"Check data labels: {check_data_labels}")
        logger.info(f"Check high-low lines: {check_high_low_lines}")
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result)
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check if charts exist
        charts = ws._charts
        if not charts or len(charts) == 0:
            logger.error("No charts found in the worksheet")
            return 0.0
        
        logger.info(f"Found {len(charts)} chart(s) in the worksheet")
        
        chart_found = False
        has_line_chart = False
        has_data_labels = False
        has_high_low_lines = False
        series_count = 0
        
        # Check each chart
        for chart_idx, chart in enumerate(charts):
            logger.info(f"Checking chart {chart_idx + 1}...")
            
            # Check chart type via XML for more reliable detection
            try:
                from zipfile import ZipFile
                import xml.etree.ElementTree as ET
                
                wb_path = result
                with ZipFile(wb_path, 'r') as zip_file:
                    chart_files = [f for f in zip_file.namelist() if 'charts/chart' in f and f.endswith('.xml')]
                    for chart_file in chart_files:
                        try:
                            xml_content = zip_file.read(chart_file).decode('utf-8')
                            root = ET.fromstring(xml_content)
                            
                            # Check for lineChart in plotArea
                            plot_areas = root.findall('.//{http://schemas.openxmlformats.org/drawingml/2006/chart}plotArea')
                            for plot_area in plot_areas:
                                line_charts = plot_area.findall('.//{http://schemas.openxmlformats.org/drawingml/2006/chart}lineChart')
                                
                                if len(line_charts) > 0:
                                    has_line_chart = True
                                    chart_found = True
                                    logger.info(f"✓ Chart {chart_idx + 1} has lineChart in plotArea")
                                    
                                    # Count total series across all lineCharts
                                    total_series_count = 0
                                    for line_chart in line_charts:
                                        series_elements = line_chart.findall('.//{http://schemas.openxmlformats.org/drawingml/2006/chart}ser')
                                        line_chart_series_count = len(series_elements)
                                        total_series_count += line_chart_series_count
                                        logger.info(f"Chart {chart_idx + 1} lineChart has {line_chart_series_count} series")
                                    
                                    series_count = total_series_count
                                    logger.info(f"Chart {chart_idx + 1} total series count: {series_count}")
                                    
                                    if series_count < min_series_count:
                                        logger.warning(f"Chart {chart_idx + 1} has {series_count} series, but minimum required is {min_series_count}")
                                        # Reset flags and continue checking other charts
                                        has_line_chart = False
                                        chart_found = False
                                        series_count = 0
                                        continue
                                    
                                    # Check data labels
                                    if check_data_labels:
                                        d_lbls = root.findall('.//{http://schemas.openxmlformats.org/drawingml/2006/chart}dLbls')
                                        if len(d_lbls) > 0:
                                            # Check if any data label type is enabled
                                            for d_lbl in d_lbls:
                                                # Check for showVal, showPercent, showCatName, etc.
                                                if d_lbl.get('showVal') == '1' or d_lbl.get('showPercent') == '1' or d_lbl.get('showCatName') == '1':
                                                    has_data_labels = True
                                                    logger.info(f"✓ Chart {chart_idx + 1} has data labels enabled")
                                                    break
                                            
                                            # Also check for dLbls with child elements indicating labels are shown
                                            if not has_data_labels:
                                                for d_lbl in d_lbls:
                                                    # If dLbls element exists with content, labels might be enabled
                                                    if len(list(d_lbl)) > 0:
                                                        has_data_labels = True
                                                        logger.info(f"✓ Chart {chart_idx + 1} has data labels (dLbls element found)")
                                                        break
                                    
                                    # Check high-low lines
                                    if check_high_low_lines:
                                        # Check for high-low lines in lineChart
                                        # High-low lines can be: hiLowLines, dropLines, or upDownBars
                                        hi_low_lines = root.findall('.//{http://schemas.openxmlformats.org/drawingml/2006/chart}hiLowLines')
                                        drop_lines = root.findall('.//{http://schemas.openxmlformats.org/drawingml/2006/chart}dropLines')
                                        up_down_bars = root.findall('.//{http://schemas.openxmlformats.org/drawingml/2006/chart}upDownBars')
                                        
                                        if len(hi_low_lines) > 0:
                                            has_high_low_lines = True
                                            logger.info(f"✓ Chart {chart_idx + 1} has high-low lines (hiLowLines)")
                                        elif len(drop_lines) > 0:
                                            has_high_low_lines = True
                                            logger.info(f"✓ Chart {chart_idx + 1} has drop lines (dropLines)")
                                        elif len(up_down_bars) > 0:
                                            has_high_low_lines = True
                                            logger.info(f"✓ Chart {chart_idx + 1} has up-down bars (upDownBars)")
                                        
                                        # Also check if hiLowLines is explicitly set in lineChart
                                        for line_chart in line_charts:
                                            hi_low = line_chart.find('{http://schemas.openxmlformats.org/drawingml/2006/chart}hiLowLines')
                                            if hi_low is not None:
                                                has_high_low_lines = True
                                                logger.info(f"✓ Chart {chart_idx + 1} has high-low lines in lineChart element")
                                                break
                                    
                                    # If we found a valid line chart with enough series, break
                                    if has_line_chart and series_count >= min_series_count:
                                        break
                        except Exception as e:
                            logger.debug(f"Could not parse chart XML {chart_file}: {e}")
            except Exception as e:
                logger.warning(f"Could not read chart XML: {e}")
            
            # Also check via openpyxl as fallback
            if not chart_found:
                chart_type = None
                if hasattr(chart, 'tagname'):
                    chart_type = chart.tagname
                logger.info(f"Chart type (openpyxl): {chart_type}")
                
                if chart_type and 'lineChart' in chart_type.lower():
                    has_line_chart = True
                    chart_found = True
                    logger.info(f"✓ Chart {chart_idx + 1} is a line chart (openpyxl)")
                    
                    # Check series count
                    if hasattr(chart, 'series') and chart.series:
                        series_count = len(chart.series)
                        logger.info(f"Chart {chart_idx + 1} has {series_count} series")
                        
                        if series_count < min_series_count:
                            logger.warning(f"Chart {chart_idx + 1} has {series_count} series, but minimum required is {min_series_count}")
                            continue
                    else:
                        logger.warning(f"Chart {chart_idx + 1} has no series")
                        continue
            
            if chart_found and has_line_chart:
                break
        
        if not chart_found:
            logger.error("No line chart found")
            return 0.0
        
        if not has_line_chart:
            logger.error("Chart is not a line chart")
            return 0.0
        
        if series_count < min_series_count:
            logger.error(f"Chart has {series_count} series, but minimum required is {min_series_count}")
            return 0.0
        
        # Verify requirements (warnings but don't fail)
        if check_data_labels and not has_data_labels:
            logger.warning("Data labels not found, but this may be acceptable depending on implementation")
        
        if check_high_low_lines and not has_high_low_lines:
            logger.warning("High-low lines not found, but this may be acceptable depending on implementation")
        
        # Success
        logger.info("=" * 60)
        logger.info(f"✓ Line chart with high-low lines verification passed")
        logger.info(f"  Chart type: lineChart")
        logger.info(f"  Series count: {series_count} (minimum required: {min_series_count})")
        if check_data_labels:
            logger.info(f"  Data labels: {'Found' if has_data_labels else 'Not found (may vary by implementation)'}")
        if check_high_low_lines:
            logger.info(f"  High-low lines: {'Found' if has_high_low_lines else 'Not found (may vary by implementation)'}")
        logger.info("=" * 60)
        return 1.0
             
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_data_bars_percentage(result: str, expected: str = None, **options) -> float:
    """
    Verify if data bars conditional formatting is applied to cells containing percentage values.
    
    This function checks:
    1. Whether cells in the specified column contain percentage values
    2. Whether data bars conditional formatting is applied to those cells
    3. Whether the conditional formatting rule type is 'dataBar'
    4. Whether the data bars are applied to the correct range
    
    The function automatically detects the number of data rows by checking for non-empty cells.
    It stops checking after finding 3 consecutive empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - data_column: Column containing percentage data (e.g., "A", default: "A")
            - start_row: Starting row number (default: 1)
            - min_data_rows: Minimum number of data rows required (default: 5)
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        from openpyxl.utils import get_column_letter, column_index_from_string
        from openpyxl.worksheet.cell_range import CellRange
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        data_column = options.get('data_column', 'A')
        start_row = options.get('start_row', 1)
        min_data_rows = options.get('min_data_rows', 5)
        
        logger.info(f"Verifying data bars conditional formatting in file: {result}")
        logger.info(f"Data column: {data_column}, Start row: {start_row}")
        logger.info(f"Minimum data rows required: {min_data_rows}")
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=True)  # data_only=True to get calculated values
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row
        data_rows = []
        
        # Find all rows with data in the data column
        # Stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            cell = ws[f"{data_column}{row_num}"]
            cell_value = cell.value
            
            if cell_value is None or (isinstance(cell_value, str) and cell_value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                data_rows.append(row_num)
                end_row = row_num
        
        if len(data_rows) < min_data_rows:
            logger.error(f"Insufficient data rows found: {len(data_rows)} (minimum required: {min_data_rows})")
            return 0.0
        
        logger.info(f"Auto-detected {len(data_rows)} data rows: rows {data_rows[0]} to {data_rows[-1]}")
        
        # Check if cells contain percentage values
        logger.info("Checking if cells contain percentage values...")
        percentage_values = []
        for row_num in data_rows:
            cell = ws[f"{data_column}{row_num}"]
            cell_value = cell.value
            
            # Check if value is a percentage
            is_percentage = False
            percentage_num = None
            
            if isinstance(cell_value, (int, float)):
                # If value is between 0 and 1, it might be a percentage (0.35 = 35%)
                if 0 <= cell_value <= 1:
                    percentage_num = cell_value * 100
                    is_percentage = True
                # If value is between 0 and 100, it might be a percentage
                elif 0 <= cell_value <= 100:
                    percentage_num = cell_value
                    is_percentage = True
            elif isinstance(cell_value, str):
                # Check if string contains percentage sign or is formatted as percentage
                if '%' in cell_value:
                    # Extract number from string like "35%" or "35.5%"
                    match = re.search(r'(\d+\.?\d*)', cell_value)
                    if match:
                        try:
                            percentage_num = float(match.group(1))
                            is_percentage = True
                        except ValueError:
                            pass
            
            if is_percentage:
                percentage_values.append((row_num, percentage_num))
                logger.debug(f"Row {row_num}: Found percentage value {percentage_num}%")
            else:
                logger.warning(f"Row {row_num}: Cell value '{cell_value}' is not recognized as percentage")
        
        if len(percentage_values) < min_data_rows:
            logger.error(f"Insufficient percentage values found: {len(percentage_values)} (minimum required: {min_data_rows})")
            return 0.0
        
        logger.info(f"✓ Found {len(percentage_values)} cells with percentage values")
        
        # Check if conditional formatting exists
        logger.info("Checking for conditional formatting...")
        conditional_formattings = ws.conditional_formatting
        if not conditional_formattings:
            logger.error("No conditional formatting rules found in the worksheet")
            return 0.0
        
        logger.info(f"Found {len(conditional_formattings)} conditional formatting rule(s)")
        
        # Check for data bar conditional formatting
        data_bar_found = False
        data_bar_applied_to_range = False
        data_bar_range = None
        
        for fmt in conditional_formattings:
            for rule in fmt.rules:
                # Check if rule type is dataBar
                rule_type = getattr(rule, 'type', None)
                logger.debug(f"Checking conditional formatting rule type: {rule_type}")
                
                if rule_type == 'dataBar' or (isinstance(rule_type, str) and 'dataBar' in rule_type.lower()):
                    data_bar_found = True
                    logger.info(f"✓ Found data bar conditional formatting rule")
                    
                    # Check if data bar is applied to the correct range
                    fmt_ranges = [str(rng) for rng in fmt.cells]
                    logger.debug(f"Data bar applied to ranges: {fmt_ranges}")
                    
                    # Check if any of the formatting ranges covers the data column
                    data_column_idx = column_index_from_string(data_column)
                    for fmt_range_str in fmt_ranges:
                        try:
                            fmt_cell_range = CellRange(fmt_range_str)
                            # Check if the range includes the data column and covers the data rows
                            if (fmt_cell_range.min_col <= data_column_idx <= fmt_cell_range.max_col and
                                fmt_cell_range.min_row <= min(data_rows) and
                                fmt_cell_range.max_row >= max(data_rows)):
                                data_bar_applied_to_range = True
                                data_bar_range = fmt_range_str
                                logger.info(f"✓ Data bar applied to range: {fmt_range_str}")
                                break
                        except Exception as e:
                            logger.debug(f"Error parsing range {fmt_range_str}: {e}")
                            # If range parsing fails, check if range string contains the data column
                            if data_column in fmt_range_str:
                                data_bar_applied_to_range = True
                                data_bar_range = fmt_range_str
                                logger.info(f"✓ Data bar applied to range: {fmt_range_str}")
                                break
                    
                    # Check data bar properties if available
                    if hasattr(rule, 'dataBar'):
                        logger.info("Data bar properties found")
                    elif hasattr(rule, 'dxf'):
                        logger.info("Data bar formatting (dxf) found")
                    
                    break
            
            if data_bar_found:
                break
        
        if not data_bar_found:
            logger.error("No data bar conditional formatting rule found")
            return 0.0
        
        if not data_bar_applied_to_range:
            logger.warning("Data bar found but may not be applied to the correct range")
            # Don't fail completely, as the range might be slightly different but still valid
            # We'll be lenient here since range matching can be tricky
        
        # If we get here, all checks passed
        logger.info("=" * 60)
        logger.info(f"✓ Data bars conditional formatting verification passed")
        logger.info(f"  - Found {len(percentage_values)} cells with percentage values")
        logger.info(f"  - Data bar conditional formatting rule found")
        if data_bar_range:
            logger.info(f"  - Data bar applied to range: {data_bar_range}")
        logger.info(f"  - Percentage values range: {min([v[1] for v in percentage_values]):.1f}% to {max([v[1] for v in percentage_values]):.1f}%")
        logger.info("=" * 60)
        return 1.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_combo_chart_with_high_low_lines_and_labels(result: str, expected: str = None, **options) -> float:
    """
    Verify if a combination chart exists with line chart, column chart, high-low lines, and data labels.
    
    This function checks:
    1. Whether difference formulas exist in the specified row (e.g., B4 = B3 - B2)
    2. Whether a combination chart exists (line chart + column chart)
    3. Whether the line chart has at least the minimum number of series (target and actual, both with invisible lines and markers)
    4. Whether the column chart has at least the minimum number of series (target)
    5. Whether high-low lines (高低点连线) are enabled to connect the two line series
    6. Whether data labels are enabled
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - target_row: Row number containing target values (default: 2)
            - actual_row: Row number containing actual values (default: 3)
            - difference_row: Row number containing difference formulas (default: 4)
            - start_column: Starting column letter (default: "B")
            - end_column: Ending column letter (default: "M")
            - min_line_series: Minimum number of line series required (default: 2)
            - min_bar_series: Minimum number of bar series required (default: 1)
            - check_high_low_lines: Whether to check for high-low lines (default: True)
            - check_data_labels: Whether to check for data labels (default: True)
            - check_difference_formula: Whether to check for difference formulas (default: True)
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        target_row = options.get('target_row', 2)
        actual_row = options.get('actual_row', 3)
        difference_row = options.get('difference_row', 4)
        start_column = options.get('start_column', 'B')
        end_column = options.get('end_column', 'M')
        min_line_series = options.get('min_line_series', 2)
        min_bar_series = options.get('min_bar_series', 1)
        check_high_low_lines = options.get('check_high_low_lines', True)
        check_data_labels = options.get('check_data_labels', True)
        check_difference_formula = options.get('check_difference_formula', True)
        
        logger.info(f"Verifying combo chart with high-low lines and data labels in file: {result}")
        logger.info(f"Target row: {target_row}, Actual row: {actual_row}, Difference row: {difference_row}")
        logger.info(f"Column range: {start_column} to {end_column}")
        logger.info(f"Minimum line series: {min_line_series}, Minimum bar series: {min_bar_series}")
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check 1: Verify difference formulas
        if check_difference_formula:
            logger.info("Checking difference formulas...")
            start_col_idx = column_index_from_string(start_column)
            end_col_idx = column_index_from_string(end_column)
            
            formula_correct = True
            formula_count = 0
            
            for col_idx in range(start_col_idx, end_col_idx + 1):
                col_letter = get_column_letter(col_idx)
                cell = ws[f"{col_letter}{difference_row}"]
                
                # Check if cell contains a formula
                if cell.data_type == "f" and cell.value is not None:
                    formula = str(cell.value)
                    formula_count += 1
                    
                    # Check if formula matches pattern: =actual_row - target_row (e.g., =B3-B2)
                    # Pattern should be like =B3-B2, =C3-C2, etc.
                    expected_pattern1 = f"={col_letter}{actual_row}-{col_letter}{target_row}"
                    expected_pattern2 = f"={col_letter}{target_row}-{col_letter}{actual_row}"  # Reverse order
                    
                    # Also check for absolute references
                    expected_pattern3 = f"=${col_letter}${actual_row}-${col_letter}${target_row}"
                    expected_pattern4 = f"=${col_letter}${target_row}-${col_letter}${actual_row}"
                    
                    formula_upper = formula.upper().replace(" ", "")
                    
                    if (expected_pattern1.upper() in formula_upper or 
                        expected_pattern2.upper() in formula_upper or
                        expected_pattern3.upper() in formula_upper or
                        expected_pattern4.upper() in formula_upper):
                        logger.debug(f"✓ Cell {col_letter}{difference_row} has correct difference formula: {formula}")
                    else:
                        logger.warning(f"Cell {col_letter}{difference_row} formula '{formula}' may not match expected pattern")
                        # Don't fail immediately, as formula might be in different format
                else:
                    logger.warning(f"Cell {col_letter}{difference_row} does not contain a formula")
            
            if formula_count == 0:
                logger.warning("No difference formulas found, but this may be acceptable")
            else:
                logger.info(f"✓ Found {formula_count} difference formula(s)")
        
        # Check 2: Verify combination chart exists
        logger.info("Checking for combination chart...")
        charts = ws._charts
        if not charts or len(charts) == 0:
            logger.error("No charts found in the worksheet")
            return 0.0
        
        logger.info(f"Found {len(charts)} chart(s) in the worksheet")
        
        chart_found = False
        has_line_chart = False
        has_bar_chart = False
        has_high_low_lines = False
        has_data_labels = False
        line_series_count = 0
        bar_series_count = 0
        
        # Check each chart via XML for more reliable detection
        try:
            from zipfile import ZipFile
            import xml.etree.ElementTree as ET
            
            wb_path = result
            with ZipFile(wb_path, 'r') as zip_file:
                chart_files = [f for f in zip_file.namelist() if 'charts/chart' in f and f.endswith('.xml')]
                for chart_file in chart_files:
                    try:
                        xml_content = zip_file.read(chart_file).decode('utf-8')
                        root = ET.fromstring(xml_content)
                        
                        # Check for plotArea
                        plot_areas = root.findall('.//{http://schemas.openxmlformats.org/drawingml/2006/chart}plotArea')
                        for plot_area in plot_areas:
                            # Check for lineChart
                            line_charts = plot_area.findall('.//{http://schemas.openxmlformats.org/drawingml/2006/chart}lineChart')
                            if len(line_charts) > 0:
                                has_line_chart = True
                                chart_found = True
                                logger.info(f"✓ Chart has lineChart in plotArea")
                                
                                # Count line series
                                for line_chart in line_charts:
                                    series_elements = line_chart.findall('.//{http://schemas.openxmlformats.org/drawingml/2006/chart}ser')
                                    line_series_count += len(series_elements)
                                    logger.info(f"Line chart has {len(series_elements)} series")
                            
                            # Check for barChart or columnChart
                            bar_charts = plot_area.findall('.//{http://schemas.openxmlformats.org/drawingml/2006/chart}barChart')
                            column_charts = plot_area.findall('.//{http://schemas.openxmlformats.org/drawingml/2006/chart}columnChart')
                            if len(bar_charts) > 0 or len(column_charts) > 0:
                                has_bar_chart = True
                                chart_found = True
                                logger.info(f"✓ Chart has barChart/columnChart in plotArea")
                                
                                # Count bar series
                                for bar_chart in bar_charts:
                                    series_elements = bar_chart.findall('.//{http://schemas.openxmlformats.org/drawingml/2006/chart}ser')
                                    bar_series_count += len(series_elements)
                                    logger.info(f"Bar chart has {len(series_elements)} series")
                                
                                for column_chart in column_charts:
                                    series_elements = column_chart.findall('.//{http://schemas.openxmlformats.org/drawingml/2006/chart}ser')
                                    bar_series_count += len(series_elements)
                                    logger.info(f"Column chart has {len(series_elements)} series")
                            
                            # Check for high-low lines
                            if check_high_low_lines:
                                hi_low_lines = root.findall('.//{http://schemas.openxmlformats.org/drawingml/2006/chart}hiLowLines')
                                drop_lines = root.findall('.//{http://schemas.openxmlformats.org/drawingml/2006/chart}dropLines')
                                up_down_bars = root.findall('.//{http://schemas.openxmlformats.org/drawingml/2006/chart}upDownBars')
                                
                                if len(hi_low_lines) > 0:
                                    has_high_low_lines = True
                                    logger.info(f"✓ Chart has high-low lines (hiLowLines)")
                                elif len(drop_lines) > 0:
                                    has_high_low_lines = True
                                    logger.info(f"✓ Chart has drop lines (dropLines)")
                                elif len(up_down_bars) > 0:
                                    has_high_low_lines = True
                                    logger.info(f"✓ Chart has up-down bars (upDownBars)")
                                
                                # Also check in lineChart element
                                for line_chart in line_charts:
                                    hi_low = line_chart.find('{http://schemas.openxmlformats.org/drawingml/2006/chart}hiLowLines')
                                    if hi_low is not None:
                                        has_high_low_lines = True
                                        logger.info(f"✓ Chart has high-low lines in lineChart element")
                                        break
                            
                            # Check for data labels
                            if check_data_labels:
                                d_lbls = root.findall('.//{http://schemas.openxmlformats.org/drawingml/2006/chart}dLbls')
                                if len(d_lbls) > 0:
                                    # Check if any data label type is enabled
                                    for d_lbl in d_lbls:
                                        # Check for showVal, showPercent, showCatName, etc.
                                        if (d_lbl.get('showVal') == '1' or 
                                            d_lbl.get('showPercent') == '1' or 
                                            d_lbl.get('showCatName') == '1' or
                                            d_lbl.get('showSerName') == '1'):
                                            has_data_labels = True
                                            logger.info(f"✓ Chart has data labels enabled")
                                            break
                                    
                                    # Also check for dLbls with child elements
                                    if not has_data_labels:
                                        for d_lbl in d_lbls:
                                            if len(list(d_lbl)) > 0:
                                                has_data_labels = True
                                                logger.info(f"✓ Chart has data labels (dLbls element found)")
                                                break
                                
                                # Also check in series elements
                                all_series = root.findall('.//{http://schemas.openxmlformats.org/drawingml/2006/chart}ser')
                                for ser in all_series:
                                    d_lbls_in_ser = ser.findall('.//{http://schemas.openxmlformats.org/drawingml/2006/chart}dLbls')
                                    if len(d_lbls_in_ser) > 0:
                                        has_data_labels = True
                                        logger.info(f"✓ Chart has data labels in series")
                                        break
                        
                        if chart_found:
                            break
                    except Exception as e:
                        logger.debug(f"Could not parse chart XML {chart_file}: {e}")
        except Exception as e:
            logger.warning(f"Could not read chart XML: {e}")
        
        # Fallback: Check via openpyxl
        if not chart_found:
            for chart_idx, chart in enumerate(charts):
                chart_type = None
                if hasattr(chart, 'tagname'):
                    chart_type = chart.tagname
                logger.info(f"Chart {chart_idx + 1} type (openpyxl): {chart_type}")
                
                if chart_type:
                    if 'lineChart' in chart_type.lower() or 'line' in chart_type.lower():
                        has_line_chart = True
                        chart_found = True
                        logger.info(f"✓ Chart {chart_idx + 1} is a line chart (openpyxl)")
                        
                        if hasattr(chart, 'series') and chart.series:
                            line_series_count = len(chart.series)
                            logger.info(f"Line chart has {line_series_count} series")
                    
                    if 'barChart' in chart_type.lower() or 'columnChart' in chart_type.lower() or 'bar' in chart_type.lower() or 'column' in chart_type.lower():
                        has_bar_chart = True
                        chart_found = True
                        logger.info(f"✓ Chart {chart_idx + 1} is a bar/column chart (openpyxl)")
                        
                        if hasattr(chart, 'series') and chart.series:
                            bar_series_count = len(chart.series)
                            logger.info(f"Bar chart has {bar_series_count} series")
        
        # Verify requirements
        if not chart_found:
            logger.error("No chart found")
            return 0.0
        
        if not has_line_chart:
            logger.error("Chart does not contain line chart")
            return 0.0
        
        if not has_bar_chart:
            logger.error("Chart does not contain bar/column chart")
            return 0.0
        
        # Calculate total series count
        total_series_count = line_series_count + bar_series_count
        
        # Validation logic:
        # - Line chart has 2 series: "2010年年初目标" (target) and "2010年实际产值" (actual)
        # - Both line series should have no line color and no marker color (invisible)
        # - High-low lines connect these two invisible line series to show the difference
        # - Column chart shows the target values ("2010年年初目标")
        
        if bar_series_count < min_bar_series:
            logger.error(f"Bar chart has {bar_series_count} series, but minimum required is {min_bar_series}")
            return 0.0
        
        # If high-low lines exist, we need at least 2 line series to connect
        # (target and actual, both with invisible lines and markers)
        if has_high_low_lines:
            logger.info(f"High-low lines found, requiring at least 2 line series to connect")
            if line_series_count < 2:
                logger.error(f"Line chart has {line_series_count} series, but with high-low lines we need at least 2 line series (target and actual)")
                return 0.0
            logger.info(f"✓ Line chart has {line_series_count} series (sufficient for high-low lines)")
        else:
            # Without high-low lines detected, be more flexible
            # If total series count is sufficient (>= 3) and data labels exist, 
            # it's possible that the chart is correct but high-low lines weren't detected
            if line_series_count < min_line_series:
                if total_series_count >= 3 and has_data_labels:
                    logger.warning(f"Line chart has {line_series_count} series (less than required {min_line_series}), but total series count ({total_series_count}) and data labels suggest chart may be correct")
                    logger.info(f"Allowing flexible validation: line={line_series_count}, bar={bar_series_count}, total={total_series_count}, data_labels={has_data_labels}")
                else:
                    logger.error(f"Line chart has {line_series_count} series, but minimum required is {min_line_series}")
                    logger.error(f"Total series: {total_series_count}, Data labels: {has_data_labels}")
                    return 0.0
        
        # Warnings for optional features (don't fail)
        if check_high_low_lines and not has_high_low_lines:
            logger.warning("High-low lines not found, but this may be acceptable depending on implementation")
        
        if check_data_labels and not has_data_labels:
            logger.warning("Data labels not found, but this may be acceptable depending on implementation")
        
        # Success
        logger.info("=" * 60)
        logger.info(f"✓ Combination chart with high-low lines and data labels verification passed")
        logger.info(f"  Chart type: combination chart (line + bar/column)")
        logger.info(f"  Line series count: {line_series_count} (minimum required: {min_line_series})")
        logger.info(f"  Bar series count: {bar_series_count} (minimum required: {min_bar_series})")
        if check_high_low_lines:
            logger.info(f"  High-low lines: {'Found' if has_high_low_lines else 'Not found (may vary by implementation)'}")
        if check_data_labels:
            logger.info(f"  Data labels: {'Found' if has_data_labels else 'Not found (may vary by implementation)'}")
        if check_difference_formula:
            logger.info(f"  Difference formulas: Checked")
        logger.info("=" * 60)
        return 1.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0

def verify_data_bar_conditional_formatting(result: str, expected: str = None, **options) -> float:
    """
    Verify if data bar conditional formatting exists in specified range.
    
    This function checks:
    1. Whether the specified range (e.g., B3:K14) has conditional formatting
    2. Whether the conditional formatting type is data bar
    3. Whether all cells in the target range have data bar conditional formatting
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_range: Range to check (e.g., "B3:K14")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        from openpyxl.utils import get_column_letter, column_index_from_string
        from openpyxl.worksheet.cell_range import CellRange
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_range = options.get('check_range', 'B3:K14')
        
        logger.info(f"Verifying data bar conditional formatting in file: {result}")
        logger.info(f"Range to check: {check_range}")
        
        # Parse the range
        try:
            range_clean = check_range.replace('$', '')
            if ':' in range_clean:
                start_cell, end_cell = range_clean.split(':')
                # Parse start cell
                start_col_letter = ''.join([c for c in start_cell if c.isalpha()])
                start_row = int(''.join([c for c in start_cell if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                # Parse end cell
                end_col_letter = ''.join([c for c in end_cell if c.isalpha()])
                end_row = int(''.join([c for c in end_cell if c.isdigit()]))
                end_col = column_index_from_string(end_col_letter)
            else:
                logger.error(f"Invalid range format: {check_range}. Expected format like 'B3:K14'")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse range {check_range}: {e}")
            return 0.0
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=False)
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check conditional formatting
        conditional_formattings = ws.conditional_formatting
        
        if not conditional_formattings:
            logger.error("No conditional formatting found in worksheet")
            return 0.0
        
        # Track which cells have data bar conditional formatting
        cells_with_data_bar = set()
        found_data_bar_rule = False
        
        # Check each conditional formatting rule
        for fmt in conditional_formattings:
            # Check if this formatting applies to any cell in our target range
            fmt_applies_to_range = False
            matching_range_cells = None
            
            for rge in fmt.cells:
                # Check if this range overlaps with our target range
                cf_start_col = rge.min_col
                cf_start_row = rge.min_row
                cf_end_col = rge.max_col
                cf_end_row = rge.max_row
                
                # Check if ranges overlap
                if not (cf_end_col < start_col or cf_start_col > end_col or 
                        cf_end_row < start_row or cf_start_row > end_row):
                    fmt_applies_to_range = True
                    matching_range_cells = rge
                    break
            
            if not fmt_applies_to_range:
                continue
            
            # Check each rule in this formatting
            for r in fmt.rules:
                # Check if this is a data bar rule
                # In openpyxl, data bar rules can be identified by:
                # 1. Rule type attribute
                # 2. Class name containing 'DataBar'
                # 3. Presence of dataBar attribute
                is_data_bar = False
                try:
                    # Method 1: Check rule type
                    if hasattr(r, 'type'):
                        rule_type = str(r.type).lower()
                        if 'databar' in rule_type or rule_type == 'databar':
                            is_data_bar = True
                    
                    # Method 2: Check class name
                    if not is_data_bar and hasattr(r, '__class__'):
                        class_name = r.__class__.__name__
                        if 'DataBar' in class_name:
                            is_data_bar = True
                    
                    # Method 3: Check for dataBar attribute
                    if not is_data_bar and hasattr(r, 'dataBar'):
                        if r.dataBar is not None:
                            is_data_bar = True
                    
                    # Method 4: Check rule attributes - data bars typically don't have formulas
                    # but have dataBar attribute or are identified by absence of other rule types
                    if not is_data_bar:
                        has_formula = hasattr(r, 'formula') and r.formula is not None and len(r.formula) > 0
                        has_color_scale = hasattr(r, 'colorScale') and r.colorScale is not None
                        has_icon_set = hasattr(r, 'iconSet') and r.iconSet is not None
                        # If rule has no formula, color scale, or icon set, and applies to numeric range,
                        # it's likely a data bar (data bars are applied to numeric values)
                        if not has_formula and not has_color_scale and not has_icon_set:
                            # Additional check: data bars are typically applied to ranges with numeric values
                            # We'll accept this as a data bar if it matches our criteria
                            is_data_bar = True
                            logger.debug(f"Assuming data bar based on absence of formula/colorScale/iconSet")
                except Exception as e:
                    logger.debug(f"Could not determine rule type: {e}")
                    continue
                
                # Check if it's a data bar rule
                if is_data_bar:
                    found_data_bar_rule = True
                    logger.info(f"Found data bar rule in range: {matching_range_cells}")
                    
                    # Add all cells in the overlapping range to our set
                    overlap_start_col = max(start_col, matching_range_cells.min_col)
                    overlap_start_row = max(start_row, matching_range_cells.min_row)
                    overlap_end_col = min(end_col, matching_range_cells.max_col)
                    overlap_end_row = min(end_row, matching_range_cells.max_row)
                    
                    for row in range(overlap_start_row, overlap_end_row + 1):
                        for col in range(overlap_start_col, overlap_end_col + 1):
                            cell_coord = f"{get_column_letter(col)}{row}"
                            cells_with_data_bar.add(cell_coord)
        
        if not found_data_bar_rule:
            logger.error("=" * 60)
            logger.error("✗ No data bar conditional formatting found in worksheet")
            logger.error(f"  Range to check: {check_range}")
            logger.error("=" * 60)
            return 0.0
        
        # Verify that ALL cells in the target range have data bar conditional formatting
        total_target_cells = (end_row - start_row + 1) * (end_col - start_col + 1)
        missing_cells = []
        
        for row in range(start_row, end_row + 1):
            for col in range(start_col, end_col + 1):
                cell_coord = f"{get_column_letter(col)}{row}"
                if cell_coord not in cells_with_data_bar:
                    missing_cells.append(cell_coord)
        
        if missing_cells:
            logger.error("=" * 60)
            logger.error(f"✗ {len(missing_cells)} cells in target range do not have data bar conditional formatting")
            logger.error(f"  Missing cells (first 20): {', '.join(missing_cells[:20])}")
            if len(missing_cells) > 20:
                logger.error(f"  ... and {len(missing_cells) - 20} more cells")
            logger.error(f"  Total target cells: {total_target_cells}")
            logger.error(f"  Cells with data bar: {len(cells_with_data_bar)}")
            logger.error("=" * 60)
            return 0.0
        
        if len(cells_with_data_bar) < total_target_cells:
            logger.error("=" * 60)
            logger.error(f"✗ Not all target cells have data bar conditional formatting")
            logger.error(f"  Expected: {total_target_cells} cells")
            logger.error(f"  Found: {len(cells_with_data_bar)} cells")
            logger.error("=" * 60)
            return 0.0
        
        logger.info("=" * 60)
        logger.info(f"✓ Data bar conditional formatting verification passed")
        logger.info(f"  - Range: {check_range} (all {total_target_cells} cells verified)")
        logger.info(f"  - All cells have data bar conditional formatting")
        logger.info("=" * 60)
        return 1.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0

def verify_find_compare_conditional_formatting(result: str, expected: str = None, **options) -> float:
    """
    Verify if conditional formatting with FIND comparison formulas exists in specified range with font colors.
    
    This function checks:
    1. Whether the specified range (e.g., A2:B2) has conditional formatting
    2. Whether conditional formatting formula contains FIND function comparison: FIND(A1,"老赵，老钱，老孙，老李")>FIND(...)
    3. Whether formulas use relative references correctly (A2 references A1 and A2, B2 references A1 and B2)
    4. Whether font color is red
    5. Whether all specified cells have the correct conditional formatting
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_range: Range to check (e.g., "A2:B2")
            - formula_pattern: Expected formula pattern (default: 'FIND(A1,"老赵，老钱，老孙，老李")>FIND')
            - font_color: Expected font color (default: "red")
            - reference_string: Reference string used in FIND (default: "老赵，老钱，老孙，老李")
            - base_cell: Base cell reference (default: "A1")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_range = options.get('check_range', 'A2:B2')
        formula_pattern = options.get('formula_pattern', 'FIND(A1,"老赵，老钱，老孙，老李")>FIND')
        font_color = options.get('font_color', 'red')
        reference_string = options.get('reference_string', '老赵，老钱，老孙，老李')
        base_cell = options.get('base_cell', 'A1')
        
        logger.info(f"Verifying FIND comparison conditional formatting in file: {result}")
        logger.info(f"Range to check: {check_range}")
        logger.info(f"Formula pattern: {formula_pattern}")
        logger.info(f"Font color: {font_color}")
        
        # Parse the range
        try:
            range_clean = check_range.replace('$', '')
            if ':' in range_clean:
                start_cell, end_cell = range_clean.split(':')
                # Parse start cell
                start_col_letter = ''.join([c for c in start_cell if c.isalpha()])
                start_row = int(''.join([c for c in start_cell if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                # Parse end cell
                end_col_letter = ''.join([c for c in end_cell if c.isalpha()])
                end_row = int(''.join([c for c in end_cell if c.isdigit()]))
                end_col = column_index_from_string(end_col_letter)
            else:
                logger.error(f"Invalid range format: {check_range}. Expected format like 'A2:B2'")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse range {check_range}: {e}")
            return 0.0
        
        # Parse base cell
        try:
            base_col_letter = ''.join([c for c in base_cell if c.isalpha()])
            base_row = int(''.join([c for c in base_cell if c.isdigit()]))
            base_col = column_index_from_string(base_col_letter)
        except Exception as e:
            logger.error(f"Failed to parse base cell {base_cell}: {e}")
            return 0.0
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=False)
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check conditional formatting
        conditional_formattings = ws.conditional_formatting
        
        if not conditional_formattings:
            logger.error("No conditional formatting found in worksheet")
            return 0.0
        
        # Helper function to check if font color matches
        def check_font_color(font_color_obj, expected_color_name):
            """Check if font color matches expected color name"""
            if font_color_obj is None or not hasattr(font_color_obj, 'rgb'):
                logger.debug(f"Font color object is None or has no rgb attribute")
                return False
            
            color_rgb = font_color_obj.rgb
            if color_rgb is None:
                logger.debug(f"Font color RGB is None")
                return False
            
            color_str = str(color_rgb).upper()
            logger.debug(f"Checking color: {color_str} against {expected_color_name}")
            
            # Convert color name to RGB values
            if expected_color_name.lower() == 'red':
                # Red: high red, low green, low blue
                if len(color_str) >= 6:
                    if len(color_str) == 8:
                        r_val = int(color_str[2:4], 16)
                        g_val = int(color_str[4:6], 16)
                        b_val = int(color_str[6:8], 16)
                    elif len(color_str) == 6:
                        r_val = int(color_str[0:2], 16)
                        g_val = int(color_str[2:4], 16)
                        b_val = int(color_str[4:6], 16)
                    else:
                        logger.debug(f"Unexpected color string length: {len(color_str)}")
                        return False
                    # Red: R > 200, G < 100, B < 100
                    is_red = r_val > 200 and g_val < 100 and b_val < 100
                    logger.debug(f"Red check: RGB({r_val}, {g_val}, {b_val}) -> {is_red}")
                    return is_red
            
            logger.debug(f"Color name {expected_color_name} not recognized")
            return False
        
        # Check each conditional formatting rule
        found_condition = False
        condition_range_cells = None
        
        for fmt in conditional_formattings:
            # Check if this formatting applies to any cell in our target range
            fmt_applies_to_range = False
            for rge in fmt.cells:
                # Check if this range overlaps with our target range
                cf_start_col = rge.min_col
                cf_start_row = rge.min_row
                cf_end_col = rge.max_col
                cf_end_row = rge.max_row
                
                # Check if ranges overlap
                if not (cf_end_col < start_col or cf_start_col > end_col or 
                        cf_end_row < start_row or cf_start_row > end_row):
                    fmt_applies_to_range = True
                    break
            
            if not fmt_applies_to_range:
                continue
            
            # Check each rule in this formatting
            for r in fmt.rules:
                # Check formula
                if not r.formula:
                    continue
                
                formula_text = r.formula[0] if isinstance(r.formula, list) else str(r.formula)
                formula_upper = formula_text.upper()
                
                logger.debug(f"Found conditional formatting formula: {formula_text}")
                
                # Check if formula contains FIND function
                find_pattern = r'\bFIND\s*\('
                if not re.search(find_pattern, formula_upper):
                    logger.debug(f"Formula does not contain FIND function: {formula_text}")
                    continue
                
                # Check if formula contains comparison operator (>)
                if not re.search(r'>', formula_text):
                    logger.debug(f"Formula does not contain comparison operator: {formula_text}")
                    continue
                
                # Check if formula contains the reference string
                escaped_ref_string = re.escape(reference_string)
                if not re.search(escaped_ref_string, formula_text):
                    logger.debug(f"Formula does not contain reference string '{reference_string}': {formula_text}")
                    continue
                
                # Check if formula references base cell (A1)
                # Allow variations: A1, $A1, A$1, $A$1
                base_cell_patterns = [
                    rf'\b{base_col_letter}{base_row}\b',  # A1
                    rf'\${base_col_letter}{base_row}\b',  # $A1
                    rf'\b{base_col_letter}\${base_row}\b',  # A$1
                    rf'\${base_col_letter}\${base_row}\b',  # $A$1
                ]
                
                base_cell_found = False
                for pattern in base_cell_patterns:
                    if re.search(pattern, formula_text, re.IGNORECASE):
                        base_cell_found = True
                        break
                
                if not base_cell_found:
                    logger.debug(f"Formula does not reference base cell {base_cell}: {formula_text}")
                    continue
                
                # Check font color
                font_color_obj = None
                if r.dxf and r.dxf.font:
                    try:
                        if r.dxf.font.color:
                            font_color_obj = r.dxf.font.color
                    except:
                        pass
                
                if font_color_obj is None:
                    logger.debug(f"Conditional formatting rule has no font color")
                    continue
                
                # Check if font color matches
                if not check_font_color(font_color_obj, font_color):
                    logger.debug(f"Font color does not match expected {font_color}")
                    continue
                
                # Found matching condition
                found_condition = True
                condition_range_cells = fmt.cells
                logger.info(f"✓ Found matching conditional formatting rule")
                logger.info(f"  Formula: {formula_text}")
                logger.info(f"  Font color: {font_color}")
                break
            
            if found_condition:
                break
        
        if not found_condition:
            logger.error("=" * 60)
            logger.error("✗ Conditional formatting rule not found")
            logger.error(f"  Expected: FIND comparison formula with {font_color} font color")
            logger.error("=" * 60)
            return 0.0
        
        # Verify that the condition applies to the target range
        # Check if CF range covers the target range
        if condition_range_cells:
            cf_covers_range = False
            for rge in condition_range_cells:
                cf_start_col = rge.min_col
                cf_start_row = rge.min_row
                cf_end_col = rge.max_col
                cf_end_row = rge.max_row
                
                # Check if CF range covers or overlaps with target range
                if (cf_start_col <= start_col and cf_end_col >= end_col and
                    cf_start_row <= start_row and cf_end_row >= end_row):
                    cf_covers_range = True
                    logger.info(f"✓ Conditional formatting range {rge} covers target range {check_range}")
                    break
                # Also check if CF range overlaps with target range (for relative references)
                elif not (cf_end_col < start_col or cf_start_col > end_col or 
                         cf_end_row < start_row or cf_start_row > end_row):
                    # Check if formula uses relative references (will auto-apply to other cells)
                    # If CF is applied to first cell with relative references, it should work
                    cf_covers_range = True
                    logger.info(f"✓ Conditional formatting range {rge} overlaps with target range {check_range}")
                    break
            
            if not cf_covers_range:
                logger.warning(f"Conditional formatting range may not fully cover target range {check_range}")
        
        # Verify that each cell in the target range has the correct formula pattern
        # For A2: formula should reference A1 and A2
        # For B2: formula should reference A1 and B2
        all_cells_valid = True
        for row_num in range(start_row, end_row + 1):
            for col_num in range(start_col, end_col + 1):
                cell_col_letter = get_column_letter(col_num)
                cell_coord = f"{cell_col_letter}{row_num}"
                
                # Expected formula pattern for this cell:
                # FIND(A1,"老赵，老钱，老孙，老李")>FIND(cell_coord,"老赵，老钱，老孙，老李")
                # But we need to check if the formula in conditional formatting uses relative references
                # The formula should reference base_cell (A1) and the current cell
                
                # Since we're checking conditional formatting (not cell formulas),
                # we verify that the CF rule exists and applies to this cell
                # The actual formula evaluation happens at runtime
                
                logger.debug(f"Checking cell {cell_coord} for conditional formatting")
        
        if all_cells_valid:
            logger.info("=" * 60)
            logger.info(f"✓ FIND comparison conditional formatting verification passed")
            logger.info(f"  - Range: {check_range}")
            logger.info(f"  - Formula pattern: FIND({base_cell},...) > FIND(...)")
            logger.info(f"  - Font color: {font_color}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error("✗ Some cells in range do not have correct conditional formatting")
            logger.error("=" * 60)
            return 0.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_line_chart_single_series_coordinates(result: str, expected: str = None, **options) -> float:
    """
    Verify if a line chart exists with one series and matches the expected coordinates.
    
    This function checks:
    1. Whether at least one chart exists in the worksheet
    2. Whether the chart is a line chart
    3. Whether the chart has exactly one series
    4. Whether the category axis (X-axis) values match expected_x_values
    5. Whether the value axis (Y-axis) values match expected_y_values
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - sheet_idx: Sheet index to check (default: 0)
            - expected_x_values: List of expected X-axis (category) values (default: [1, 2, 3, 4, 5])
            - expected_y_values: List of expected Y-axis (value) values (default: [10, 8, 3, 11, 19, 22, 6, 9, 1, 7, 5, 2, 8, 6, 9])
            - chart_type: Expected chart type (default: "lineChart")
            - tolerance: Tolerance for numeric comparison (default: 0.01)
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        sheet_idx = options.get('sheet_idx', 0)
        expected_x_values = options.get('expected_x_values', [1, 2, 3, 4, 5])
        expected_y_values = options.get('expected_y_values', [10, 8, 3, 11, 19, 22, 6, 9, 1, 7, 5, 2, 8, 6, 9])
        expected_chart_type = options.get('chart_type', 'lineChart')
        tolerance = options.get('tolerance', 0.01)
        
        logger.info(f"Verifying line chart coordinates in file: {result}")
        logger.info(f"Sheet index: {sheet_idx}")
        logger.info(f"Expected X values: {expected_x_values}")
        logger.info(f"Expected Y values: {expected_y_values}")
        logger.info(f"Expected chart type: {expected_chart_type}")
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result)
            sheet_names = wb.sheetnames
            if sheet_idx >= len(sheet_names):
                logger.error(f"Sheet index {sheet_idx} out of range. Available sheets: {sheet_names}")
                return 0.0
            sheet_name = sheet_names[sheet_idx]
            ws = wb[sheet_name]
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return 0.0
        
        # Check if charts exist
        charts = ws._charts
        if not charts:
            logger.error("No charts found in the worksheet")
            return 0.0
        
        logger.info(f"Found {len(charts)} chart(s) in the worksheet")
        
        # Check each chart
        chart_passed = False
        for chart_idx, chart in enumerate(charts):
            logger.info(f"Checking chart {chart_idx + 1}")
            
            # Check chart type
            chart_type = chart.tagname if hasattr(chart, 'tagname') else None
            logger.info(f"Chart type: {chart_type}")
            
            # Check if it's a line chart (or compatible type)
            if chart_type and 'line' not in chart_type.lower() and 'Line' not in chart_type:
                logger.warning(f"Chart type '{chart_type}' is not a line chart, skipping")
                continue
            
            logger.info(f"✓ Chart is a line chart type: {chart_type}")
            
            # Check number of series
            series_list = list(chart.series) if hasattr(chart, 'series') else []
            series_count = len(series_list)
            logger.info(f"Number of series: {series_count}")
            
            if series_count != 1:
                logger.warning(f"Chart has {series_count} series, expected 1, skipping")
                continue
            
            logger.info(f"✓ Chart has exactly 1 series")
            
            # Get the single series
            series = series_list[0]
            
            # Extract data ranges from series
            category_range = None
            value_range = None
            
            # Get category (X-axis) range
            if hasattr(series, 'cat'):
                if hasattr(series.cat, 'numRef') and hasattr(series.cat.numRef, 'f'):
                    category_range = series.cat.numRef.f
                elif hasattr(series.cat, 'strRef') and hasattr(series.cat.strRef, 'f'):
                    category_range = series.cat.strRef.f
                elif hasattr(series.cat, 'numRef') and hasattr(series.cat.numRef, 'numCache'):
                    # If data is cached, we need to read from cache
                    logger.info("Category data is cached, will try to read from worksheet")
                elif hasattr(series.cat, 'strRef') and hasattr(series.cat.strRef, 'strCache'):
                    logger.info("Category data is cached, will try to read from worksheet")
            
            # Get value (Y-axis) range
            if hasattr(series, 'val'):
                if hasattr(series.val, 'numRef') and hasattr(series.val.numRef, 'f'):
                    value_range = series.val.numRef.f
                elif hasattr(series.val, 'strRef') and hasattr(series.val.strRef, 'f'):
                    value_range = series.val.strRef.f
                elif hasattr(series.val, 'numRef') and hasattr(series.val.numRef, 'numCache'):
                    logger.info("Value data is cached, will try to read from worksheet")
                elif hasattr(series.val, 'strRef') and hasattr(series.val.strRef, 'strCache'):
                    logger.info("Value data is cached, will try to read from worksheet")
            
            logger.info(f"Category range: {category_range}")
            logger.info(f"Value range: {value_range}")
            
            # If we have ranges, read the actual values from the worksheet
            actual_x_values = []
            actual_y_values = []
            
            def parse_range_and_read(range_str, ws):
                """Parse a range string like 'Sheet1!$A$1:$A$5' or 'A1:A5' and read values"""
                if not range_str:
                    return []
                
                # Remove sheet name if present
                if '!' in range_str:
                    range_str = range_str.split('!')[1]
                
                # Remove $ signs
                range_str = range_str.replace('$', '')
                
                # Parse range (e.g., 'A1:A5' or 'A1:A5')
                if ':' in range_str:
                    start_cell, end_cell = range_str.split(':')
                    # Parse coordinates: coordinate_to_tuple returns (row, col) where col is numeric
                    start_row, start_col = coordinate_to_tuple(start_cell)
                    end_row, end_col = coordinate_to_tuple(end_cell)
                    
                    # Convert column numbers to letters
                    start_col_letter = get_column_letter(start_col)
                    end_col_letter = get_column_letter(end_col)
                    
                    values = []
                    # If same column, read vertically
                    if start_col == end_col:
                        for row in range(start_row, end_row + 1):
                            cell_coord = f"{start_col_letter}{row}"
                            try:
                                cell = ws[cell_coord]
                                value = cell.value
                                # Convert to number if possible
                                if isinstance(value, str):
                                    try:
                                        value = float(value)
                                    except:
                                        pass
                                values.append(value)
                            except Exception as e:
                                logger.warning(f"Error reading cell {cell_coord}: {e}")
                                values.append(None)
                    # If same row, read horizontally
                    elif start_row == end_row:
                        for col_num in range(start_col, end_col + 1):
                            col_letter = get_column_letter(col_num)
                            cell_coord = f"{col_letter}{start_row}"
                            try:
                                cell = ws[cell_coord]
                                value = cell.value
                                # Convert to number if possible
                                if isinstance(value, str):
                                    try:
                                        value = float(value)
                                    except:
                                        pass
                                values.append(value)
                            except Exception as e:
                                logger.warning(f"Error reading cell {cell_coord}: {e}")
                                values.append(None)
                    else:
                        # 2D range - read row by row
                        for row in range(start_row, end_row + 1):
                            for col_num in range(start_col, end_col + 1):
                                col_letter = get_column_letter(col_num)
                                cell_coord = f"{col_letter}{row}"
                                try:
                                    cell = ws[cell_coord]
                                    value = cell.value
                                    # Convert to number if possible
                                    if isinstance(value, str):
                                        try:
                                            value = float(value)
                                        except:
                                            pass
                                    values.append(value)
                                except Exception as e:
                                    logger.warning(f"Error reading cell {cell_coord}: {e}")
                                    values.append(None)
                    return values
                else:
                    # Single cell
                    try:
                        cell = ws[range_str]
                        value = cell.value
                        if isinstance(value, str):
                            try:
                                value = float(value)
                            except:
                                pass
                        return [value]
                    except Exception as e:
                        logger.warning(f"Error reading cell {range_str}: {e}")
                        return []
            
            if category_range:
                actual_x_values = parse_range_and_read(category_range, ws)
                logger.info(f"Read X values from range: {actual_x_values}")
            
            if value_range:
                actual_y_values = parse_range_and_read(value_range, ws)
                logger.info(f"Read Y values from range: {actual_y_values}")
            
            # If we couldn't read from ranges, try to read from cache
            if not actual_x_values and hasattr(series, 'cat'):
                if hasattr(series.cat, 'numRef') and hasattr(series.cat.numRef, 'numCache'):
                    cache = series.cat.numRef.numCache
                    if hasattr(cache, 'pt') and cache.pt:
                        actual_x_values = [float(pt.v) for pt in cache.pt if hasattr(pt, 'v')]
                        logger.info(f"Read X values from cache: {actual_x_values}")
                elif hasattr(series.cat, 'strRef') and hasattr(series.cat.strRef, 'strCache'):
                    cache = series.cat.strRef.strCache
                    if hasattr(cache, 'pt') and cache.pt:
                        actual_x_values = [pt.v for pt in cache.pt if hasattr(pt, 'v')]
                        logger.info(f"Read X values from cache: {actual_x_values}")
            
            if not actual_y_values and hasattr(series, 'val'):
                if hasattr(series.val, 'numRef') and hasattr(series.val.numRef, 'numCache'):
                    cache = series.val.numRef.numCache
                    if hasattr(cache, 'pt') and cache.pt:
                        actual_y_values = [float(pt.v) for pt in cache.pt if hasattr(pt, 'v')]
                        logger.info(f"Read Y values from cache: {actual_y_values}")
                elif hasattr(series.val, 'strRef') and hasattr(series.val.strRef, 'strCache'):
                    cache = series.val.strRef.strCache
                    if hasattr(cache, 'pt') and cache.pt:
                        actual_y_values = [pt.v for pt in cache.pt if hasattr(pt, 'v')]
                        logger.info(f"Read Y values from cache: {actual_y_values}")
            
            # Normalize values for comparison (convert to numbers, handle None)
            def normalize_value(v):
                if v is None:
                    return None
                if isinstance(v, (int, float)):
                    return float(v)
                if isinstance(v, str):
                    try:
                        return float(v)
                    except:
                        return v
                return v
            
            actual_x_values = [normalize_value(v) for v in actual_x_values]
            actual_y_values = [normalize_value(v) for v in actual_y_values]
            
            # Remove None values
            actual_x_values = [v for v in actual_x_values if v is not None]
            actual_y_values = [v for v in actual_y_values if v is not None]
            
            logger.info(f"Normalized X values: {actual_x_values}")
            logger.info(f"Normalized Y values: {actual_y_values}")
            
            # Verify X values match expected
            if len(actual_x_values) != len(expected_x_values):
                logger.warning(f"X values count mismatch: expected {len(expected_x_values)}, got {len(actual_x_values)}")
                # Continue to check if values match anyway (maybe some are missing)
            
            x_match = True
            min_x_len = min(len(actual_x_values), len(expected_x_values))
            for i in range(min_x_len):
                expected_x = float(expected_x_values[i])
                actual_x = float(actual_x_values[i]) if actual_x_values[i] is not None else None
                if actual_x is None:
                    logger.warning(f"X value at index {i} is None")
                    x_match = False
                    continue
                if abs(actual_x - expected_x) > tolerance:
                    logger.warning(f"X value mismatch at index {i}: expected {expected_x}, got {actual_x}")
                    x_match = False
                else:
                    logger.info(f"✓ X value at index {i} matches: {actual_x}")
            
            if not x_match:
                logger.error("✗ X values do not match expected values")
                continue
            
            # Verify Y values match expected
            if len(actual_y_values) != len(expected_y_values):
                logger.warning(f"Y values count mismatch: expected {len(expected_y_values)}, got {len(actual_y_values)}")
            
            y_match = True
            min_y_len = min(len(actual_y_values), len(expected_y_values))
            for i in range(min_y_len):
                expected_y = float(expected_y_values[i])
                actual_y = float(actual_y_values[i]) if actual_y_values[i] is not None else None
                if actual_y is None:
                    logger.warning(f"Y value at index {i} is None")
                    y_match = False
                    continue
                if abs(actual_y - expected_y) > tolerance:
                    logger.warning(f"Y value mismatch at index {i}: expected {expected_y}, got {actual_y}")
                    y_match = False
                else:
                    logger.info(f"✓ Y value at index {i} matches: {actual_y}")
            
            # Check if all expected Y values are present (allow for more values in actual)
            if len(actual_y_values) < len(expected_y_values):
                logger.warning(f"Not enough Y values: expected {len(expected_y_values)}, got {len(actual_y_values)}")
                y_match = False
            
            if not y_match:
                logger.error("✗ Y values do not match expected values")
                continue
            
            # If we get here, all checks passed
            chart_passed = True
            logger.info("=" * 60)
            logger.info(f"✓ Line chart verification passed!")
            logger.info(f"  - Chart type: {chart_type}")
            logger.info(f"  - Series count: {series_count}")
            logger.info(f"  - X values match: {actual_x_values[:min_x_len]}")
            logger.info(f"  - Y values match: {actual_y_values[:min_y_len]}")
            logger.info("=" * 60)
            break
        
        if chart_passed:
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error("✗ Line chart verification failed - no chart matched all criteria")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_combination_chart_trendline_format(result: str, expected: str = None, **options) -> float:
    """
    Verify if a combination chart has a series named "月均" with a trendline that:
    1. Has forward and backward periods set to 0.5
    2. Has line format matching the "月均" series format
    
    This function checks:
    1. Whether at least one chart exists in the worksheet
    2. Whether the chart is a combination chart (has multiple series)
    3. Whether there is a series named "月均"
    4. Whether the "月均" series has a trendline
    5. Whether the trendline has forward and backward periods set to 0.5
    6. Whether the trendline line format matches the "月均" series format
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - sheet_idx: Sheet index to check (default: 0)
            - series_name: Series name to check (default: "月均")
            - forward_periods: Expected forward periods (default: 0.5)
            - backward_periods: Expected backward periods (default: 0.5)
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import zipfile
        import lxml.etree
        import xmltodict
        from lxml.etree import _Element
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        sheet_idx = options.get('sheet_idx', 0)
        series_name = options.get('series_name', '月均')
        forward_periods = options.get('forward_periods', 0.5)
        backward_periods = options.get('backward_periods', 0.5)
        
        logger.info(f"Verifying combination chart trendline format in file: {result}")
        logger.info(f"Sheet index: {sheet_idx}")
        logger.info(f"Series name: {series_name}")
        logger.info(f"Forward periods: {forward_periods}")
        logger.info(f"Backward periods: {backward_periods}")
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result)
            sheet_names = wb.sheetnames
            if sheet_idx >= len(sheet_names):
                logger.error(f"Sheet index {sheet_idx} out of range. Available sheets: {sheet_names}")
                return 0.0
            sheet_name = sheet_names[sheet_idx]
            ws = wb[sheet_name]
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return 0.0
        
        # Check if charts exist
        charts = ws._charts
        if not charts:
            logger.error("No charts found in the worksheet")
            return 0.0
        
        logger.info(f"Found {len(charts)} chart(s) in the worksheet")
        
        # Use XML parsing directly to find the series and trendline
        # Open the Excel file as a ZIP archive to access chart XML files
        try:
            with zipfile.ZipFile(result, 'r') as z_f:
                # Find chart files
                chart_files = [f for f in z_f.namelist() if f.startswith('xl/charts/chart') and f.endswith('.xml')]
                
                if not chart_files:
                    logger.error("No chart XML files found")
                    return 0.0
                
                logger.info(f"Found {len(chart_files)} chart XML file(s)")
                
                # Namespaces for chart XML
                chart_ns = {
                    'c': 'http://schemas.openxmlformats.org/drawingml/2006/chart',
                    'a': 'http://schemas.openxmlformats.org/drawingml/2006/main',
                    'r': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
                }
                
                trendline_found = False
                forward_ok = False
                backward_ok = False
                format_match = False
                series_found = False
                
                # Check each chart XML file
                for chart_file in chart_files:
                    try:
                        with z_f.open(chart_file) as f:
                            chart_xml = lxml.etree.parse(f)
                            root = chart_xml.getroot()
                            
                            # Find all series in the chart
                            series_elements = root.xpath('.//c:ser', namespaces=chart_ns)
                            
                            logger.info(f"Found {len(series_elements)} series in chart XML")
                            
                            # Check if this is a combination chart (has multiple series)
                            if len(series_elements) < 2:
                                logger.debug(f"Chart has only {len(series_elements)} series, skipping (not a combination chart)")
                                continue
                            
                            for ser_elem in series_elements:
                                # Try multiple ways to get series name
                                ser_name = None
                                
                                # Method 1: Direct text value in c:tx//c:v
                                ser_name_elem = ser_elem.xpath('.//c:tx//c:v', namespaces=chart_ns)
                                if ser_name_elem and ser_name_elem[0].text:
                                    ser_name = ser_name_elem[0].text
                                
                                # Method 2: Check c:tx//c:strRef (string reference) - read from worksheet
                                if not ser_name:
                                    str_ref_elem = ser_elem.xpath('.//c:tx//c:strRef', namespaces=chart_ns)
                                    if str_ref_elem:
                                        # Try to get the formula/reference
                                        f_elem = str_ref_elem[0].xpath('.//c:f', namespaces=chart_ns)
                                        if f_elem and f_elem[0].text:
                                            # This is a cell reference, read from worksheet
                                            cell_ref = f_elem[0].text
                                            logger.debug(f"Series has string reference: {cell_ref}")
                                            try:
                                                # Remove sheet name if present
                                                if '!' in cell_ref:
                                                    cell_ref = cell_ref.split('!')[1]
                                                # Remove $ signs
                                                cell_ref = cell_ref.replace('$', '')
                                                # Read cell value
                                                cell = ws[cell_ref]
                                                if cell.value:
                                                    ser_name = str(cell.value)
                                                    logger.debug(f"Read series name from cell {cell_ref}: {ser_name}")
                                            except Exception as e:
                                                logger.debug(f"Error reading cell {cell_ref}: {e}")
                                
                                # Method 3: Check if series name is in shared strings
                                if not ser_name:
                                    str_ref_elem = ser_elem.xpath('.//c:tx//c:strRef', namespaces=chart_ns)
                                    if str_ref_elem:
                                        str_cache_elem = str_ref_elem[0].xpath('.//c:strCache', namespaces=chart_ns)
                                        if str_cache_elem:
                                            pt_elem = str_cache_elem[0].xpath('.//c:pt', namespaces=chart_ns)
                                            if pt_elem:
                                                v_elem = pt_elem[0].xpath('.//c:v', namespaces=chart_ns)
                                                if v_elem and v_elem[0].text:
                                                    ser_name = v_elem[0].text
                                
                                logger.debug(f"Series name found: {ser_name}")
                                
                                if ser_name == series_name:
                                    series_found = True
                                    logger.info(f"✓ Found '{series_name}' series in chart XML")
                                    
                                    # Check for trendline
                                    trendline_elem = ser_elem.xpath('.//c:trendline', namespaces=chart_ns)
                                    if not trendline_elem:
                                        logger.warning(f"No trendline found for '{series_name}' series")
                                        continue
                                    
                                    trendline_found = True
                                    trendline = trendline_elem[0]
                                    logger.info("✓ Trendline found")
                                    
                                    # Check forward periods
                                    forward_elem = trendline.xpath('.//c:forward', namespaces=chart_ns)
                                    if forward_elem:
                                        forward_text = forward_elem[0].text
                                        forward_attrs = forward_elem[0].attrib
                                        logger.debug(f"Forward element text: {forward_text}, attributes: {forward_attrs}")
                                        
                                        if forward_text is not None and forward_text.strip():
                                            try:
                                                forward_val = float(forward_text)
                                                logger.info(f"Forward periods: {forward_val}")
                                                if abs(forward_val - forward_periods) < 0.01:
                                                    forward_ok = True
                                                    logger.info(f"✓ Forward periods match: {forward_val}")
                                                else:
                                                    logger.warning(f"Forward periods mismatch: expected {forward_periods}, got {forward_val}")
                                            except (ValueError, TypeError) as e:
                                                logger.warning(f"Error parsing forward periods: {e}, text: {forward_text}")
                                        else:
                                            # Check if value is in 'val' attribute
                                            forward_val_attr = forward_elem[0].get('val')
                                            if forward_val_attr:
                                                try:
                                                    forward_val = float(forward_val_attr)
                                                    logger.info(f"Forward periods (from val attr): {forward_val}")
                                                    if abs(forward_val - forward_periods) < 0.01:
                                                        forward_ok = True
                                                        logger.info(f"✓ Forward periods match: {forward_val}")
                                                    else:
                                                        logger.warning(f"Forward periods mismatch: expected {forward_periods}, got {forward_val}")
                                                except (ValueError, TypeError) as e:
                                                    logger.warning(f"Error parsing forward periods from val attr: {e}")
                                            else:
                                                # If element exists but has no value, it might mean 0 or default
                                                # In Excel, empty forward/backward might mean 0, but we need 0.5
                                                # Log the raw XML for debugging
                                                forward_xml = lxml.etree.tostring(forward_elem[0], encoding='unicode')
                                                logger.debug(f"Forward element XML: {forward_xml}")
                                                logger.warning("Forward periods element found but has no text or val attribute - assuming not set")
                                    else:
                                        logger.warning("Forward periods element not found")
                                    
                                    # Check backward periods
                                    backward_elem = trendline.xpath('.//c:backward', namespaces=chart_ns)
                                    if backward_elem:
                                        backward_text = backward_elem[0].text
                                        backward_attrs = backward_elem[0].attrib
                                        logger.debug(f"Backward element text: {backward_text}, attributes: {backward_attrs}")
                                        
                                        if backward_text is not None and backward_text.strip():
                                            try:
                                                backward_val = float(backward_text)
                                                logger.info(f"Backward periods: {backward_val}")
                                                if abs(backward_val - backward_periods) < 0.01:
                                                    backward_ok = True
                                                    logger.info(f"✓ Backward periods match: {backward_val}")
                                                else:
                                                    logger.warning(f"Backward periods mismatch: expected {backward_periods}, got {backward_val}")
                                            except (ValueError, TypeError) as e:
                                                logger.warning(f"Error parsing backward periods: {e}, text: {backward_text}")
                                        else:
                                            # Check if value is in 'val' attribute
                                            backward_val_attr = backward_elem[0].get('val')
                                            if backward_val_attr:
                                                try:
                                                    backward_val = float(backward_val_attr)
                                                    logger.info(f"Backward periods (from val attr): {backward_val}")
                                                    if abs(backward_val - backward_periods) < 0.01:
                                                        backward_ok = True
                                                        logger.info(f"✓ Backward periods match: {backward_val}")
                                                    else:
                                                        logger.warning(f"Backward periods mismatch: expected {backward_periods}, got {backward_val}")
                                                except (ValueError, TypeError) as e:
                                                    logger.warning(f"Error parsing backward periods from val attr: {e}")
                                            else:
                                                # If element exists but has no value, it might mean 0 or default
                                                # Log the raw XML for debugging
                                                backward_xml = lxml.etree.tostring(backward_elem[0], encoding='unicode')
                                                logger.debug(f"Backward element XML: {backward_xml}")
                                                logger.warning("Backward periods element found but has no text or val attribute - assuming not set")
                                    else:
                                        logger.warning("Backward periods element not found")
                                    
                                    # Check line format - get line properties from trendline and series
                                    # Get trendline line format
                                    trendline_sp_pr = trendline.xpath('.//c:spPr', namespaces=chart_ns)
                                    # Get series line format
                                    ser_sp_pr = ser_elem.xpath('.//c:spPr', namespaces=chart_ns)
                                    
                                    if trendline_sp_pr and ser_sp_pr:
                                        # Compare line properties (color, width, style)
                                        # Extract line properties from both
                                        trendline_ln = trendline_sp_pr[0].xpath('.//a:ln', namespaces=chart_ns)
                                        ser_ln = ser_sp_pr[0].xpath('.//a:ln', namespaces=chart_ns)
                                        
                                        if trendline_ln and ser_ln:
                                            # Compare line width
                                            trendline_w = trendline_ln[0].get('w')
                                            ser_w = ser_ln[0].get('w')
                                            
                                            # Compare line color
                                            trendline_solidFill = trendline_ln[0].xpath('.//a:solidFill', namespaces=chart_ns)
                                            ser_solidFill = ser_ln[0].xpath('.//a:solidFill', namespaces=chart_ns)
                                            
                                            # Compare line style (cap, join, etc.)
                                            trendline_cap = trendline_ln[0].get('cap')
                                            ser_cap = ser_ln[0].get('cap')
                                            
                                            # For format matching, we'll be lenient - if both have line properties, consider it a match
                                            # The exact format matching is complex and may vary between implementations
                                            if trendline_w and ser_w and trendline_w == ser_w:
                                                if (trendline_solidFill and ser_solidFill) or (not trendline_solidFill and not ser_solidFill):
                                                    format_match = True
                                                    logger.info("✓ Trendline format appears to match series format")
                                                else:
                                                    logger.warning("Trendline color format may not match")
                                            else:
                                                logger.warning(f"Trendline width ({trendline_w}) may not match series width ({ser_w})")
                                        else:
                                            # If no explicit line format, assume format matching is not critical
                                            # or format is inherited/default
                                            format_match = True
                                            logger.info("Line format comparison skipped (using default/inherited format)")
                                    else:
                                        # If no explicit format properties, assume format matching is not critical
                                        format_match = True
                                        logger.info("Format properties not found, assuming format matching is acceptable")
                                    
                                    break
                                
                                if trendline_found and series_found:
                                    break
                            
                            if trendline_found and series_found:
                                break
                    except Exception as e:
                        logger.warning(f"Error parsing chart XML file {chart_file}: {e}")
                        continue
                
                # Final verification
                if not series_found:
                    logger.error(f"✗ Could not find series named '{series_name}' in any combination chart")
                    return 0.0
                
                if not trendline_found:
                    logger.error(f"✗ Trendline not found for '{series_name}' series")
                    return 0.0
                
                if not forward_ok:
                    logger.error(f"✗ Forward periods verification failed")
                    return 0.0
                
                if not backward_ok:
                    logger.error(f"✗ Backward periods verification failed")
                    return 0.0
                
                # Format matching is important but we'll be lenient
                if not format_match:
                    logger.warning("⚠ Format matching verification had issues, but continuing")
                    # Don't fail on format mismatch alone, as format comparison is complex
                
                logger.info("=" * 60)
                logger.info(f"✓ Combination chart trendline verification passed!")
                logger.info(f"  - Series name: {series_name}")
                logger.info(f"  - Forward periods: {forward_periods}")
                logger.info(f"  - Backward periods: {backward_periods}")
                logger.info(f"  - Format matching: {'OK' if format_match else 'Warning'}")
                logger.info("=" * 60)
                return 1.0
                
        except Exception as e:
            logger.error(f"Error accessing chart XML files: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_chart_series_missing_values(result: str, expected: str = None, **options) -> float:
    """
    Verify if a chart has the expected number of line chart series and a specific series
    named "设备开动率" has its missing values configured as "continue line".
    
    This function checks:
    1. Whether at least one chart exists in the worksheet
    2. Whether the chart has the expected number of line chart series (default: 2)
    3. Whether there is a series named "设备开动率"
    4. Whether the "设备开动率" series has missing values configured as "continue line"
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - sheet_idx: Sheet index to check (default: 0)
            - expected_series_count: Expected number of line chart series (default: 2)
            - target_series_name: Series name to check (default: "设备开动率")
            - expected_missing_value_type: Expected missing value type (default: "continue_line")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import zipfile
        import lxml.etree
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        sheet_idx = options.get('sheet_idx', 0)
        expected_series_count = options.get('expected_series_count', 2)
        target_series_name = options.get('target_series_name', '设备开动率')
        expected_missing_value_type = options.get('expected_missing_value_type', 'continue_line')
        
        logger.info(f"Verifying chart series missing values in file: {result}")
        logger.info(f"Sheet index: {sheet_idx}")
        logger.info(f"Expected series count: {expected_series_count}")
        logger.info(f"Target series name: {target_series_name}")
        logger.info(f"Expected missing value type: {expected_missing_value_type}")
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result)
            sheet_names = wb.sheetnames
            if sheet_idx >= len(sheet_names):
                logger.error(f"Sheet index {sheet_idx} out of range. Available sheets: {sheet_names}")
                return 0.0
            sheet_name = sheet_names[sheet_idx]
            ws = wb[sheet_name]
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return 0.0
        
        # Check if charts exist
        charts = ws._charts
        if not charts:
            logger.error("No charts found in the worksheet")
            return 0.0
        
        logger.info(f"Found {len(charts)} chart(s) in the worksheet")
        
        # Use XML parsing directly to find the series and missing value settings
        # Open the Excel file as a ZIP archive to access chart XML files
        try:
            with zipfile.ZipFile(result, 'r') as z_f:
                # Find chart files
                chart_files = [f for f in z_f.namelist() if f.startswith('xl/charts/chart') and f.endswith('.xml')]
                
                if not chart_files:
                    logger.error("No chart XML files found")
                    return 0.0
                
                logger.info(f"Found {len(chart_files)} chart XML file(s)")
                
                # Namespaces for chart XML
                chart_ns = {
                    'c': 'http://schemas.openxmlformats.org/drawingml/2006/chart',
                    'a': 'http://schemas.openxmlformats.org/drawingml/2006/main',
                    'r': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
                }
                
                series_found = False
                series_count_ok = False
                missing_value_ok = False
                line_chart_count = 0
                
                # Check each chart XML file
                for chart_file in chart_files:
                    try:
                        with z_f.open(chart_file) as f:
                            chart_xml = lxml.etree.parse(f)
                            root = chart_xml.getroot()
                            
                            # Find all series in the chart
                            series_elements = root.xpath('.//c:ser', namespaces=chart_ns)
                            
                            logger.info(f"Found {len(series_elements)} series in chart XML")
                            
                            # Check chart type - look for line chart
                            # Check if this is a line chart or combination chart with line series
                            chart_type_elem = root.xpath('.//c:lineChart', namespaces=chart_ns)
                            if chart_type_elem:
                                logger.info("Chart contains line chart type")
                                line_chart_count = len(series_elements)
                            else:
                                # Check for combination chart
                                combo_chart_elem = root.xpath('.//c:comboChart', namespaces=chart_ns)
                                if combo_chart_elem:
                                    logger.info("Chart is a combination chart")
                                    # Count line series in combination chart
                                    line_series = root.xpath('.//c:lineChart//c:ser', namespaces=chart_ns)
                                    line_chart_count = len(line_series)
                                else:
                                    # Try to count all series as line series if chart type is unclear
                                    logger.warning("Chart type unclear, assuming all series are line series")
                                    line_chart_count = len(series_elements)
                            
                            logger.info(f"Line chart series count: {line_chart_count}")
                            
                            # Check series count
                            if line_chart_count == expected_series_count:
                                series_count_ok = True
                                logger.info(f"✓ Chart has {line_chart_count} line chart series (expected {expected_series_count})")
                            else:
                                logger.warning(f"Chart has {line_chart_count} line chart series, expected {expected_series_count}")
                                # Continue to check series name anyway
                            
                            # Check each series for the target series name
                            for ser_elem in series_elements:
                                # Try multiple ways to get series name
                                ser_name = None
                                
                                # Method 1: Direct text value in c:tx//c:v
                                ser_name_elem = ser_elem.xpath('.//c:tx//c:v', namespaces=chart_ns)
                                if ser_name_elem and ser_name_elem[0].text:
                                    ser_name = ser_name_elem[0].text
                                
                                # Method 2: Check c:tx//c:strRef (string reference) - read from worksheet
                                if not ser_name:
                                    str_ref_elem = ser_elem.xpath('.//c:tx//c:strRef', namespaces=chart_ns)
                                    if str_ref_elem:
                                        # Try to get the formula/reference
                                        f_elem = str_ref_elem[0].xpath('.//c:f', namespaces=chart_ns)
                                        if f_elem and f_elem[0].text:
                                            # This is a cell reference, read from worksheet
                                            cell_ref = f_elem[0].text
                                            logger.debug(f"Series has string reference: {cell_ref}")
                                            try:
                                                # Remove sheet name if present
                                                if '!' in cell_ref:
                                                    cell_ref = cell_ref.split('!')[1]
                                                # Remove $ signs
                                                cell_ref = cell_ref.replace('$', '')
                                                # Read cell value
                                                cell = ws[cell_ref]
                                                if cell.value:
                                                    ser_name = str(cell.value)
                                                    logger.debug(f"Read series name from cell {cell_ref}: {ser_name}")
                                            except Exception as e:
                                                logger.debug(f"Error reading cell {cell_ref}: {e}")
                                
                                # Method 3: Check if series name is in shared strings
                                if not ser_name:
                                    str_ref_elem = ser_elem.xpath('.//c:tx//c:strRef', namespaces=chart_ns)
                                    if str_ref_elem:
                                        str_cache_elem = str_ref_elem[0].xpath('.//c:strCache', namespaces=chart_ns)
                                        if str_cache_elem:
                                            pt_elem = str_cache_elem[0].xpath('.//c:pt', namespaces=chart_ns)
                                            if pt_elem:
                                                v_elem = pt_elem[0].xpath('.//c:v', namespaces=chart_ns)
                                                if v_elem and v_elem[0].text:
                                                    ser_name = v_elem[0].text
                                
                                logger.debug(f"Series name found: {ser_name}")
                                
                                if ser_name == target_series_name:
                                    series_found = True
                                    logger.info(f"✓ Found '{target_series_name}' series in chart XML")
                                    
                                    # Check for missing value settings
                                    # In Office Open XML, missing values can be configured in several ways:
                                    # 1. Through c:marker element (for line charts, missing values might affect marker display)
                                    # 2. Through c:spPr (shape properties) - but this is more about formatting
                                    # 3. Through chart-level settings
                                    
                                    # For LibreOffice Calc, missing value "continue line" setting might be stored
                                    # in the series element or in chart-level settings
                                    # We'll check for various indicators:
                                    
                                    # Check if series has smooth line property (which might indicate continue line)
                                    smooth_elem = ser_elem.xpath('.//c:smooth', namespaces=chart_ns)
                                    if smooth_elem:
                                        smooth_val = smooth_elem[0].get('val', '1')
                                        logger.debug(f"Smooth property: {smooth_val}")
                                    
                                    # Check for marker properties (missing values might affect marker display)
                                    marker_elem = ser_elem.xpath('.//c:marker', namespaces=chart_ns)
                                    if marker_elem:
                                        logger.debug("Series has marker element")
                                    
                                    # For LibreOffice Calc, the missing value "continue line" setting
                                    # might be indicated by the absence of gaps in the line
                                    # or by specific XML attributes. Since LibreOffice uses ODF format
                                    # internally but can export to OOXML, we need to check both.
                                    
                                    # In practice, if the series is configured to "continue line",
                                    # the line should connect across missing data points.
                                    # This is often the default behavior for line charts, so we'll
                                    # check if there are any explicit gap settings that would prevent continuation.
                                    
                                    # Check for explicit gap settings (if present, they might indicate "keep gaps")
                                    # In OOXML, this might be in chart-level settings
                                    gap_width_elem = root.xpath('.//c:gapWidth', namespaces=chart_ns)
                                    if gap_width_elem:
                                        logger.debug("Chart has gapWidth element")
                                    
                                    # For "continue line" setting, we expect:
                                    # 1. No explicit gap settings that would prevent continuation
                                    # 2. The series should be a line series (which we've already verified)
                                    # 3. The line should connect data points (default behavior)
                                    
                                    # Since "continue line" is often the default for line charts,
                                    # and explicit "keep gaps" or "assume zero" settings might be
                                    # stored in chart-level or series-level properties that aren't
                                    # always present in the XML, we'll use a heuristic approach:
                                    # - If the series is a line series and no explicit gap/zero settings are found,
                                    #   we assume "continue line" is set (which is the default)
                                    
                                    # Check for any explicit "assume zero" indicators
                                    # (This might be in data point settings or chart settings)
                                    assume_zero_indicators = root.xpath('.//c:dPt[.//c:spPr]', namespaces=chart_ns)
                                    
                                    # For now, we'll assume that if:
                                    # 1. The series is found with the correct name
                                    # 2. It's a line chart series
                                    # 3. No explicit "keep gaps" settings are found
                                    # Then "continue line" is configured (default behavior)
                                    
                                    # This is a reasonable heuristic since "continue line" is the default
                                    # for line charts in most spreadsheet applications
                                    missing_value_ok = True
                                    logger.info(f"✓ Missing value setting appears to be 'continue line' (default for line charts)")
                                    
                                    break
                            
                            if series_found:
                                break
                                
                    except Exception as e:
                        logger.warning(f"Error parsing chart XML file {chart_file}: {e}")
                        import traceback
                        logger.debug(traceback.format_exc())
                        continue
                
                # Final verification
                if not series_found:
                    logger.error(f"✗ Could not find series named '{target_series_name}' in any chart")
                    return 0.0
                
                if not series_count_ok:
                    logger.warning(f"⚠ Chart series count verification: expected {expected_series_count}, but continuing")
                    # Don't fail on series count mismatch alone, as it might be a combination chart
                
                if not missing_value_ok:
                    logger.error(f"✗ Missing value setting verification failed for '{target_series_name}' series")
                    return 0.0
                
                logger.info("=" * 60)
                logger.info(f"✓ Chart series missing values verification passed!")
                logger.info(f"  - Series name: {target_series_name}")
                logger.info(f"  - Series count: {line_chart_count} (expected {expected_series_count})")
                logger.info(f"  - Missing value type: {expected_missing_value_type}")
                logger.info("=" * 60)
                return 1.0
                
        except Exception as e:
            logger.error(f"Error accessing chart XML files: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_scatter_chart_initial_final_values(result: str, expected: str = None, **options) -> float:
    """
    Verify if a scatter chart has two series with initial and final values, and verify row data pattern.
    
    This function checks:
    1. Whether rows from start_row to end_row follow the pattern: two rows with data, one empty row
    2. Whether at least one chart exists in the worksheet
    3. Whether the chart has the expected number of scatter chart series (default: 2)
    4. Whether the two series have correct name, X, and Y value ranges
    5. Whether each series has missing values configured as "keep gaps"
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - sheet_idx: Sheet index to check (default: 0)
            - start_row: Starting row number (default: 2)
            - end_row: Ending row number (default: 75)
            - expected_series_count: Expected number of scatter chart series (default: 2)
            - series1_name_cell: Cell reference for first series name (e.g., "D1")
            - series1_x_range: X value range for first series (e.g., "D2:D66")
            - series1_y_range: Y value range for first series (e.g., "E2:E66")
            - series2_name_cell: Cell reference for second series name (e.g., "F1")
            - series2_x_range: X value range for second series (e.g., "F2:F75")
            - series2_y_range: Y value range for second series (e.g., "G2:G75")
            - expected_missing_value_type: Expected missing value type (default: "keep_gaps")
            - data_column: Column to use for checking row pattern (e.g., "D")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import zipfile
        import lxml.etree
        from openpyxl.utils import get_column_letter
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        sheet_idx = options.get('sheet_idx', 0)
        start_row = options.get('start_row', 2)
        end_row = options.get('end_row', 75)
        expected_series_count = options.get('expected_series_count', 2)
        series1_name_cell = options.get('series1_name_cell', 'D1')
        series1_x_range = options.get('series1_x_range', 'D2:D66')
        series1_y_range = options.get('series1_y_range', 'E2:E66')
        series2_name_cell = options.get('series2_name_cell', 'F1')
        series2_x_range = options.get('series2_x_range', 'F2:F75')
        series2_y_range = options.get('series2_y_range', 'G2:G75')
        expected_missing_value_type = options.get('expected_missing_value_type', 'keep_gaps')
        data_column = options.get('data_column', 'D')
        
        logger.info(f"Verifying scatter chart initial/final values in file: {result}")
        logger.info(f"Sheet index: {sheet_idx}")
        logger.info(f"Row pattern check: rows {start_row} to {end_row}")
        logger.info(f"Expected series count: {expected_series_count}")
        logger.info(f"Expected missing value type: {expected_missing_value_type}")
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=False)
            sheet_names = wb.sheetnames
            if sheet_idx >= len(sheet_names):
                logger.error(f"Sheet index {sheet_idx} out of range. Available sheets: {sheet_names}")
                return 0.0
            sheet_name = sheet_names[sheet_idx]
            ws = wb[sheet_name]
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return 0.0
        
        # Check row data pattern: from start_row to end_row, every 3 rows should be: data, data, empty
        # Check in the data columns (D, E, F, G columns)
        logger.info("Checking row data pattern...")
        row_pattern_ok = True
        check_columns = ['D', 'E', 'F', 'G']  # Columns used in the chart series
        
        for row_num in range(start_row, end_row + 1):
            # Calculate position in the 3-row cycle (0, 1, or 2)
            cycle_pos = (row_num - start_row) % 3
            
            # Check if row has data in any of the check columns
            has_data = False
            for col_letter in check_columns:
                cell = ws[f"{col_letter}{row_num}"]
                if cell.value is not None and (not isinstance(cell.value, str) or cell.value.strip() != ""):
                    has_data = True
                    break
            
            # Pattern: cycle_pos 0 and 1 should have data, cycle_pos 2 should be empty
            if cycle_pos == 2:
                # This row should be empty
                if has_data:
                    logger.warning(f"Row {row_num} should be empty but has data")
                    row_pattern_ok = False
                else:
                    logger.debug(f"✓ Row {row_num} is empty as expected")
            else:
                # These rows should have data
                if not has_data:
                    logger.warning(f"Row {row_num} should have data but is empty")
                    row_pattern_ok = False
                else:
                    logger.debug(f"✓ Row {row_num} has data as expected")
        
        if not row_pattern_ok:
            logger.error("✗ Row data pattern verification failed")
            return 0.0
        else:
            logger.info("✓ Row data pattern verification passed")
        
        # Check if charts exist
        charts = ws._charts
        if not charts:
            logger.error("No charts found in the worksheet")
            return 0.0
        
        logger.info(f"Found {len(charts)} chart(s) in the worksheet")
        
        # Use XML parsing to find the scatter chart and verify series
        try:
            with zipfile.ZipFile(result, 'r') as z_f:
                # Find chart files
                chart_files = [f for f in z_f.namelist() if f.startswith('xl/charts/chart') and f.endswith('.xml')]
                
                if not chart_files:
                    logger.error("No chart XML files found")
                    return 0.0
                
                logger.info(f"Found {len(chart_files)} chart XML file(s)")
                
                # Namespaces for chart XML
                chart_ns = {
                    'c': 'http://schemas.openxmlformats.org/drawingml/2006/chart',
                    'a': 'http://schemas.openxmlformats.org/drawingml/2006/main',
                    'r': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
                }
                
                chart_passed = False
                series1_found = False
                series2_found = False
                series_count_ok = False
                missing_value_ok = False
                
                # Check each chart XML file
                for chart_file in chart_files:
                    try:
                        with z_f.open(chart_file) as f:
                            chart_xml = lxml.etree.parse(f)
                            root = chart_xml.getroot()
                            
                            # Find all series in the chart
                            series_elements = root.xpath('.//c:ser', namespaces=chart_ns)
                            
                            logger.info(f"Found {len(series_elements)} series in chart XML")
                            
                            # Check chart type - look for scatter chart
                            scatter_chart_elem = root.xpath('.//c:scatterChart', namespaces=chart_ns)
                            if not scatter_chart_elem:
                                logger.warning("Chart is not a scatter chart, skipping")
                                continue
                            
                            logger.info("Chart contains scatter chart type")
                            
                            # Check series count
                            if len(series_elements) == expected_series_count:
                                series_count_ok = True
                                logger.info(f"✓ Chart has {len(series_elements)} scatter chart series (expected {expected_series_count})")
                            else:
                                logger.warning(f"Chart has {len(series_elements)} series, expected {expected_series_count}")
                                continue
                            
                            # Check each series for name, X, and Y ranges
                            for ser_elem in series_elements:
                                # Get series name
                                ser_name = None
                                ser_name_elem = ser_elem.xpath('.//c:tx//c:v', namespaces=chart_ns)
                                if ser_name_elem and ser_name_elem[0].text:
                                    ser_name = ser_name_elem[0].text
                                
                                # If name is from cell reference, read from worksheet
                                if not ser_name:
                                    str_ref_elem = ser_elem.xpath('.//c:tx//c:strRef', namespaces=chart_ns)
                                    if str_ref_elem:
                                        f_elem = str_ref_elem[0].xpath('.//c:f', namespaces=chart_ns)
                                        if f_elem and f_elem[0].text:
                                            cell_ref = f_elem[0].text
                                            if '!' in cell_ref:
                                                cell_ref = cell_ref.split('!')[1]
                                            cell_ref = cell_ref.replace('$', '')
                                            try:
                                                cell = ws[cell_ref]
                                                if cell.value:
                                                    ser_name = str(cell.value)
                                            except:
                                                pass
                                
                                logger.debug(f"Series name found: {ser_name}")
                                
                                # Get X values range
                                x_range = None
                                x_num_ref = ser_elem.xpath('.//c:xVal//c:numRef', namespaces=chart_ns)
                                if x_num_ref:
                                    f_elem = x_num_ref[0].xpath('.//c:f', namespaces=chart_ns)
                                    if f_elem and f_elem[0].text:
                                        x_range = f_elem[0].text
                                
                                # Get Y values range
                                y_range = None
                                y_num_ref = ser_elem.xpath('.//c:yVal//c:numRef', namespaces=chart_ns)
                                if y_num_ref:
                                    f_elem = y_num_ref[0].xpath('.//c:f', namespaces=chart_ns)
                                    if f_elem and f_elem[0].text:
                                        y_range = f_elem[0].text
                                
                                logger.debug(f"Series X range: {x_range}, Y range: {y_range}")
                                
                                # Check if this matches series1 or series2
                                # Read expected series1 name
                                try:
                                    expected_name1 = ws[series1_name_cell].value
                                    if expected_name1:
                                        expected_name1 = str(expected_name1)
                                except:
                                    expected_name1 = None
                                
                                # Read expected series2 name
                                try:
                                    expected_name2 = ws[series2_name_cell].value
                                    if expected_name2:
                                        expected_name2 = str(expected_name2)
                                except:
                                    expected_name2 = None
                                
                                # Normalize ranges for comparison (remove $ and sheet names)
                                def normalize_range(r):
                                    if not r:
                                        return None
                                    r = r.replace('$', '')
                                    if '!' in r:
                                        r = r.split('!')[1]
                                    return r.upper()
                                
                                x_range_norm = normalize_range(x_range)
                                y_range_norm = normalize_range(y_range)
                                series1_x_norm = normalize_range(series1_x_range)
                                series1_y_norm = normalize_range(series1_y_range)
                                series2_x_norm = normalize_range(series2_x_range)
                                series2_y_norm = normalize_range(series2_y_range)
                                
                                # Check if this is series1
                                if (ser_name == expected_name1 or 
                                    (x_range_norm == series1_x_norm and y_range_norm == series1_y_norm)):
                                    series1_found = True
                                    logger.info(f"✓ Found series 1: name={ser_name}, X={x_range}, Y={y_range}")
                                
                                # Check if this is series2
                                if (ser_name == expected_name2 or 
                                    (x_range_norm == series2_x_norm and y_range_norm == series2_y_norm)):
                                    series2_found = True
                                    logger.info(f"✓ Found series 2: name={ser_name}, X={x_range}, Y={y_range}")
                            
                            # Check missing value settings for all series
                            # For "keep gaps" setting, we need to check if there are explicit gap settings
                            # or if the default behavior is to keep gaps (opposite of continue line)
                            
                            # In LibreOffice Calc, "keep gaps" might be indicated by:
                            # 1. Explicit gap settings in the chart
                            # 2. Absence of "continue line" settings
                            # 3. Specific XML attributes
                            
                            # For scatter charts with lines, "keep gaps" means missing values create gaps
                            # This is often the default for scatter charts, so we'll check if there are
                            # any explicit "continue line" settings that would override this
                            
                            # Check for explicit "continue line" indicators (which would be wrong)
                            continue_line_indicators = root.xpath('.//c:gapWidth[@val="0"]', namespaces=chart_ns)
                            
                            # For "keep gaps", we expect:
                            # 1. No explicit "continue line" settings
                            # 2. The series should be scatter series with lines
                            # 3. Missing values should create gaps (default behavior for scatter charts)
                            
                            if expected_missing_value_type == "keep_gaps":
                                if continue_line_indicators:
                                    logger.warning("Found continue line indicators, but expected keep gaps")
                                    # This might still be okay if it's a different setting
                                else:
                                    missing_value_ok = True
                                    logger.info("✓ Missing value setting appears to be 'keep gaps' (default for scatter charts)")
                            
                            # Final check: both series found and all settings correct
                            if series1_found and series2_found and series_count_ok and missing_value_ok:
                                chart_passed = True
                                logger.info("=" * 60)
                                logger.info(f"✓ Scatter chart verification passed!")
                                logger.info(f"  - Series 1 found: {series1_found}")
                                logger.info(f"  - Series 2 found: {series2_found}")
                                logger.info(f"  - Series count: {len(series_elements)} (expected {expected_series_count})")
                                logger.info(f"  - Missing value type: {expected_missing_value_type}")
                                logger.info("=" * 60)
                                break
                    
                    except Exception as e:
                        logger.warning(f"Error parsing chart XML file {chart_file}: {e}")
                        import traceback
                        logger.debug(traceback.format_exc())
                        continue
                
                if chart_passed:
                    return 1.0
                else:
                    if not series1_found:
                        logger.error("✗ Series 1 not found")
                    if not series2_found:
                        logger.error("✗ Series 2 not found")
                    if not series_count_ok:
                        logger.error("✗ Series count mismatch")
                    if not missing_value_ok:
                        logger.error("✗ Missing value setting verification failed")
                    logger.error("=" * 60)
                    logger.error("✗ Scatter chart verification failed")
                    logger.error("=" * 60)
                    return 0.0
                    
        except Exception as e:
            logger.error(f"Error accessing chart XML files: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_pie_scatter_combination_with_image_fill(result: str, expected: str = None, **options) -> float:
    """
    Verify if a combination chart exists with doughnut chart and scatter chart, and verify:
    1. Doughnut chart series uses the specified data range (C3:C45)
    2. Scatter chart has X values from H3:H46 and Y values from G3:G46
    3. G46 and H46 cells contain 0 (origin point)
    
    This function checks:
    1. Whether at least one chart exists in the worksheet
    2. Whether the chart is a combination chart (has both doughnut and scatter chart types)
    3. Whether doughnut chart series uses the correct data range
    4. Whether scatter chart series has correct X and Y value ranges
    5. Whether origin cells (G46, H46) contain 0
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - sheet_idx: Sheet index to check (default: 0)
            - doughnut_series_range: Data range for doughnut chart (default: "C3:C45")
            - scatter_x_range: X values range for scatter chart (default: "H3:H46")
            - scatter_y_range: Y values range for scatter chart (default: "G3:G46")
            - origin_x_cell: Cell reference for origin X value (default: "H46")
            - origin_y_cell: Cell reference for origin Y value (default: "G46")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import zipfile
        import lxml.etree
        
        if result is None or not os.path.exists(result):
            logger.error(f"Excel file not found: {result}")
            return 0.0
        
        excel_file_path = result
        
        sheet_idx = options.get('sheet_idx', 0)
        doughnut_series_range = options.get('doughnut_series_range', 'C3:C45')
        scatter_x_range = options.get('scatter_x_range', 'H3:H46')
        scatter_y_range = options.get('scatter_y_range', 'G3:G46')
        origin_x_cell = options.get('origin_x_cell', 'H46')
        origin_y_cell = options.get('origin_y_cell', 'G46')
        
        logger.info(f"Verifying pie-scatter combination chart with image fill in file: {excel_file_path}")
        logger.info(f"Sheet index: {sheet_idx}")
        logger.info(f"Doughnut series range: {doughnut_series_range}")
        logger.info(f"Scatter X range: {scatter_x_range}")
        logger.info(f"Scatter Y range: {scatter_y_range}")
        logger.info(f"Origin X cell: {origin_x_cell}, Origin Y cell: {origin_y_cell}")
        
        # Try to load workbook with openpyxl, but handle compatibility issues
        # WPS may generate Excel files with XML that openpyxl cannot parse
        ws = None
        wb = None
        origin_cells_ok = False
        
        try:
            wb = openpyxl.load_workbook(excel_file_path, data_only=False)
            sheet_names = wb.sheetnames
            if sheet_idx >= len(sheet_names):
                logger.error(f"Sheet index {sheet_idx} out of range. Available sheets: {sheet_names}")
                return 0.0
            sheet_name = sheet_names[sheet_idx]
            ws = wb[sheet_name]
            
            # Check origin cells contain 0
            logger.info("Checking origin cells...")
            try:
                origin_x_value = ws[origin_x_cell].value
                origin_y_value = ws[origin_y_cell].value
                
                # Convert to float for comparison
                origin_x_float = float(origin_x_value) if origin_x_value is not None else None
                origin_y_float = float(origin_y_value) if origin_y_value is not None else None
                
                if origin_x_float != 0.0 or origin_y_float != 0.0:
                    logger.error(f"✗ Origin cells do not contain 0: {origin_x_cell}={origin_x_value}, {origin_y_cell}={origin_y_value}")
                    return 0.0
                else:
                    logger.info(f"✓ Origin cells contain 0: {origin_x_cell}={origin_x_value}, {origin_y_cell}={origin_y_value}")
                    origin_cells_ok = True
            except Exception as e:
                logger.warning(f"Failed to check origin cells with openpyxl: {e}")
        except Exception as e:
            logger.warning(f"Failed to load workbook with openpyxl (WPS compatibility issue): {e}")
            logger.info("Will use XML parsing directly to verify chart structure and cell values")
        
        # If openpyxl failed, try to read origin cells from XML
        if not origin_cells_ok:
            logger.info("Checking origin cells via XML...")
            try:
                with zipfile.ZipFile(excel_file_path, 'r') as z_f:
                    # Find worksheet XML file
                    sheet_files = [f for f in z_f.namelist() if f.startswith('xl/worksheets/sheet') and f.endswith('.xml')]
                    if sheet_idx < len(sheet_files):
                        sheet_file = sheet_files[sheet_idx]
                        with z_f.open(sheet_file) as f:
                            sheet_xml = lxml.etree.parse(f)
                            root = sheet_xml.getroot()
                            
                            # Namespace for worksheet XML
                            ws_ns = {'main': 'http://schemas.openxmlformats.org/spreadsheetml/2006/main'}
                            
                            # Find cells
                            cells = root.xpath('.//main:c[@r="{}"]'.format(origin_x_cell), namespaces=ws_ns)
                            if cells:
                                x_val_elem = cells[0].xpath('.//main:v', namespaces=ws_ns)
                                if x_val_elem:
                                    origin_x_value = float(x_val_elem[0].text) if x_val_elem[0].text else None
                                else:
                                    origin_x_value = None
                            else:
                                origin_x_value = None
                            
                            cells = root.xpath('.//main:c[@r="{}"]'.format(origin_y_cell), namespaces=ws_ns)
                            if cells:
                                y_val_elem = cells[0].xpath('.//main:v', namespaces=ws_ns)
                                if y_val_elem:
                                    origin_y_value = float(y_val_elem[0].text) if y_val_elem[0].text else None
                                else:
                                    origin_y_value = None
                            else:
                                origin_y_value = None
                            
                            if origin_x_value != 0.0 or origin_y_value != 0.0:
                                logger.error(f"✗ Origin cells do not contain 0: {origin_x_cell}={origin_x_value}, {origin_y_cell}={origin_y_value}")
                                return 0.0
                            else:
                                logger.info(f"✓ Origin cells contain 0: {origin_x_cell}={origin_x_value}, {origin_y_cell}={origin_y_value}")
                                origin_cells_ok = True
            except Exception as e:
                logger.error(f"Failed to check origin cells via XML: {e}")
                import traceback
                logger.error(traceback.format_exc())
                return 0.0
        
        # Check if charts exist (if we can load the workbook)
        if ws is not None:
            charts = ws._charts
            if not charts:
                logger.warning("No charts found via openpyxl, will check XML directly")
            else:
                logger.info(f"Found {len(charts)} chart(s) in the worksheet")
        
        # Use XML parsing to find the combination chart
        try:
            with zipfile.ZipFile(excel_file_path, 'r') as z_f:
                # Find chart files
                chart_files = [f for f in z_f.namelist() if f.startswith('xl/charts/chart') and f.endswith('.xml')]
                
                if not chart_files:
                    logger.error("No chart XML files found")
                    return 0.0
                
                logger.info(f"Found {len(chart_files)} chart XML file(s)")
                
                # Namespaces for chart XML
                chart_ns = {
                    'c': 'http://schemas.openxmlformats.org/drawingml/2006/chart',
                    'a': 'http://schemas.openxmlformats.org/drawingml/2006/main',
                    'r': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
                }
                
                chart_passed = False
                doughnut_found = False
                scatter_found = False
                doughnut_range_ok = False
                scatter_x_range_ok = False
                scatter_y_range_ok = False
                
                # Check each chart XML file
                for chart_file in chart_files:
                    try:
                        with z_f.open(chart_file) as f:
                            chart_xml = lxml.etree.parse(f)
                            root = chart_xml.getroot()
                            
                            # Find all series in the chart
                            series_elements = root.xpath('.//c:ser', namespaces=chart_ns)
                            
                            logger.info(f"Found {len(series_elements)} series in chart XML")
                            
                            # Check for doughnut chart
                            doughnut_chart_elem = root.xpath('.//c:doughnutChart', namespaces=chart_ns)
                            if doughnut_chart_elem:
                                doughnut_found = True
                                logger.info("✓ Chart contains doughnut chart type")
                                
                                # Check doughnut series data range
                                for ser_elem in series_elements:
                                    # Get values range
                                    val_num_ref = ser_elem.xpath('.//c:val//c:numRef', namespaces=chart_ns)
                                    if val_num_ref:
                                        f_elem = val_num_ref[0].xpath('.//c:f', namespaces=chart_ns)
                                        if f_elem and f_elem[0].text:
                                            val_range = f_elem[0].text
                                            # Remove sheet name if present
                                            if '!' in val_range:
                                                val_range = val_range.split('!')[1]
                                            val_range = val_range.replace('$', '')
                                            
                                            logger.debug(f"Doughnut series range: {val_range}")
                                            
                                            # Check if range matches (allow for case differences and sheet references)
                                            if val_range.upper() == doughnut_series_range.upper():
                                                doughnut_range_ok = True
                                                logger.info(f"✓ Doughnut series range matches: {val_range}")
                                                break
                                
                                if not doughnut_range_ok:
                                    logger.warning("Could not verify doughnut series range")
                            
                            # Check for scatter chart
                            scatter_chart_elem = root.xpath('.//c:scatterChart', namespaces=chart_ns)
                            if scatter_chart_elem:
                                scatter_found = True
                                logger.info("✓ Chart contains scatter chart type")
                                
                                # Check scatter chart series X and Y ranges
                                # Note: WPS may swap X and Y axes, so we check both possibilities
                                for ser_idx, ser_elem in enumerate(series_elements):
                                    # Get X values range
                                    x_range = None
                                    x_num_ref = ser_elem.xpath('.//c:xVal//c:numRef', namespaces=chart_ns)
                                    if x_num_ref:
                                        f_elem = x_num_ref[0].xpath('.//c:f', namespaces=chart_ns)
                                        if f_elem and f_elem[0].text:
                                            x_range_raw = f_elem[0].text
                                            # Remove sheet name if present
                                            if '!' in x_range_raw:
                                                x_range = x_range_raw.split('!')[1]
                                            else:
                                                x_range = x_range_raw
                                            x_range = x_range.replace('$', '')
                                            
                                            logger.info(f"Series {ser_idx} - Scatter X range (raw): {x_range_raw}")
                                            logger.info(f"Series {ser_idx} - Scatter X range (cleaned): {x_range}")
                                            logger.info(f"Series {ser_idx} - Expected X range: {scatter_x_range}")
                                    
                                    # Get Y values range
                                    y_range = None
                                    y_num_ref = ser_elem.xpath('.//c:yVal//c:numRef', namespaces=chart_ns)
                                    if y_num_ref:
                                        f_elem = y_num_ref[0].xpath('.//c:f', namespaces=chart_ns)
                                        if f_elem and f_elem[0].text:
                                            y_range_raw = f_elem[0].text
                                            # Remove sheet name if present
                                            if '!' in y_range_raw:
                                                y_range = y_range_raw.split('!')[1]
                                            else:
                                                y_range = y_range_raw
                                            y_range = y_range.replace('$', '')
                                            
                                            logger.info(f"Series {ser_idx} - Scatter Y range (raw): {y_range_raw}")
                                            logger.info(f"Series {ser_idx} - Scatter Y range (cleaned): {y_range}")
                                            logger.info(f"Series {ser_idx} - Expected Y range: {scatter_y_range}")
                                    
                                    # Check if ranges match (allow for X/Y axis swap)
                                    # Case 1: Normal match (X matches X, Y matches Y)
                                    if x_range and y_range:
                                        if x_range.upper() == scatter_x_range.upper() and y_range.upper() == scatter_y_range.upper():
                                            scatter_x_range_ok = True
                                            scatter_y_range_ok = True
                                            logger.info(f"✓ Scatter X range matches: {x_range}")
                                            logger.info(f"✓ Scatter Y range matches: {y_range}")
                                        # Case 2: Swapped match (X matches Y, Y matches X)
                                        elif x_range.upper() == scatter_y_range.upper() and y_range.upper() == scatter_x_range.upper():
                                            scatter_x_range_ok = True
                                            scatter_y_range_ok = True
                                            logger.info(f"✓ Scatter ranges match (X/Y swapped): X={x_range} matches expected Y={scatter_y_range}, Y={y_range} matches expected X={scatter_x_range}")
                                        else:
                                            logger.debug(f"Series {ser_idx} - Range mismatch: X={x_range} (expected {scatter_x_range}), Y={y_range} (expected {scatter_y_range})")
                            
                            # If we found both chart types, this is a combination chart
                            if doughnut_found and scatter_found:
                                chart_passed = True
                                logger.info("✓ Combination chart found (doughnut + scatter)")
                                break
                    
                    except Exception as e:
                        logger.warning(f"Error parsing chart XML {chart_file}: {e}")
                        import traceback
                        logger.debug(traceback.format_exc())
                        continue
                
                # Final verification
                if not chart_passed:
                    logger.error("✗ Combination chart (doughnut + scatter) not found")
                    return 0.0
                
                if not doughnut_range_ok:
                    logger.error("✗ Doughnut series range verification failed")
                    return 0.0
                
                if not scatter_x_range_ok:
                    logger.error("✗ Scatter X range verification failed")
                    return 0.0
                
                if not scatter_y_range_ok:
                    logger.error("✗ Scatter Y range verification failed")
                    return 0.0
                
                logger.info("=" * 60)
                logger.info("✓ All mandatory checks passed:")
                logger.info("  - Combination chart (doughnut + scatter) found")
                logger.info("  - Doughnut series range verified")
                logger.info("  - Scatter X and Y ranges verified")
                logger.info("  - Origin cells contain 0")
                logger.info("=" * 60)
                return 1.0
        
        except Exception as e:
            logger.error(f"Error during chart XML parsing: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_chart_error_bars_with_arrows(result: str, expected: str = None, **options) -> float:
    """
    Verify if a chart has two series ("实际" and "计划"), the "实际" series has error bars
    with positive error set to D2:D5, negative error set to 0, and error bar lines have
    arrow endpoints. Also verify that D2:D5 contains formulas =C2-B2.
    
    This function checks:
    1. Whether at least one chart exists in the worksheet
    2. Whether the chart has two series named "实际" and "计划"
    3. Whether the "实际" series has error bars
    4. Whether error bars have positive error set to D2:D5 range
    5. Whether error bars have negative error set to 0
    6. Whether error bar lines have arrow endpoints
    7. Whether D2:D5 contains formulas =C2-B2 (with relative references)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - sheet_idx: Sheet index to check (default: 0)
            - expected_series_names: List of expected series names (default: ["实际", "计划"])
            - target_series_name: Series name to check error bars (default: "实际")
            - formula_column: Column to check formulas (default: "D")
            - formula_start_row: Starting row for formula check (default: 2)
            - formula_end_row: Ending row for formula check (default: 5)
            - formula_pattern: Expected formula pattern (default: "=C2-B2")
            - error_bar_positive_range: Expected positive error range (default: "D2:D5")
            - error_bar_negative_value: Expected negative error value (default: 0)
            - error_bar_arrow_enabled: Whether arrows should be enabled (default: True)
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import zipfile
        import lxml.etree
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        sheet_idx = options.get('sheet_idx', 0)
        expected_series_names = options.get('expected_series_names', ['实际', '计划'])
        target_series_name = options.get('target_series_name', '实际')
        formula_column = options.get('formula_column', 'D')
        formula_start_row = options.get('formula_start_row', 2)
        formula_end_row = options.get('formula_end_row', 5)
        formula_pattern = options.get('formula_pattern', '=C2-B2')
        error_bar_positive_range = options.get('error_bar_positive_range', 'D2:D5')
        error_bar_negative_value = options.get('error_bar_negative_value', 0)
        error_bar_arrow_enabled = options.get('error_bar_arrow_enabled', True)
        
        logger.info(f"Verifying chart error bars with arrows in file: {result}")
        logger.info(f"Sheet index: {sheet_idx}")
        logger.info(f"Expected series names: {expected_series_names}")
        logger.info(f"Target series name: {target_series_name}")
        logger.info(f"Formula column: {formula_column}, rows: {formula_start_row}-{formula_end_row}")
        logger.info(f"Error bar positive range: {error_bar_positive_range}")
        logger.info(f"Error bar negative value: {error_bar_negative_value}")
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=False)
            sheet_names = wb.sheetnames
            logger.info(f"Available sheets: {sheet_names}")
            
            # Try to find the sheet with formulas and charts
            # First try the specified sheet_idx
            sheet_name = None
            ws = None
            if sheet_idx < len(sheet_names):
                sheet_name = sheet_names[sheet_idx]
                ws = wb[sheet_name]
                logger.info(f"Using sheet at index {sheet_idx}: {sheet_name}")
                # Check if this sheet has formulas in the expected column
                test_cell = ws[f"{formula_column}{formula_start_row}"]
                if test_cell.data_type != "f" and not (hasattr(test_cell, "_value") and isinstance(test_cell._value, str) and test_cell._value.startswith("=")):
                    # This sheet doesn't have formulas, search for one that does
                    logger.warning(f"Sheet {sheet_name} doesn't have formulas in {formula_column}{formula_start_row}, searching other sheets...")
                    sheet_name = None
                    ws = None
            
            # If we don't have a valid sheet yet, search for one with formulas
            if ws is None:
                for sn in sheet_names:
                    try:
                        test_ws = wb[sn]
                        test_cell = test_ws[f"{formula_column}{formula_start_row}"]
                        if test_cell.data_type == "f" or (hasattr(test_cell, "_value") and isinstance(test_cell._value, str) and test_cell._value.startswith("=")):
                            sheet_name = sn
                            ws = test_ws
                            logger.info(f"Found sheet with formulas: {sheet_name}")
                            break
                    except Exception as e:
                        logger.debug(f"Error checking sheet {sn}: {e}")
                        continue
            
            if ws is None:
                logger.error(f"Could not find appropriate sheet with formulas. Available sheets: {sheet_names}")
                return 0.0
                
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return 0.0
        
        # Check formulas in D2:D5
        logger.info(f"Checking formulas in {formula_column}{formula_start_row}:{formula_column}{formula_end_row} on sheet '{sheet_name}'...")
        formula_check_passed = True
        formula_count = 0
        for row_num in range(formula_start_row, formula_end_row + 1):
            cell_coord = f"{formula_column}{row_num}"
            cell = ws[cell_coord]
            
            # Check if cell contains a formula
            is_formula = False
            formula_text = None
            
            # Method 1: Check data_type
            if cell.data_type == "f":
                is_formula = True
            # Method 2: Check _value attribute
            elif hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                is_formula = True
                formula_text = cell._value
            # Method 3: Check formula attribute
            elif hasattr(cell, "formula") and cell.formula:
                is_formula = True
                formula_text = cell.formula
            # Method 4: Check if value is a formula string
            elif cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                is_formula = True
                formula_text = cell.value
            
            if not is_formula:
                logger.warning(f"Cell {cell_coord} does not contain a formula (data_type: {cell.data_type}, value: {cell.value})")
                formula_check_passed = False
                continue
            
            # Get formula text if not already obtained
            if formula_text is None:
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                elif cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula_text = cell.value
            
            if formula_text is None:
                logger.warning(f"Could not extract formula from cell {cell_coord}")
                formula_check_passed = False
                continue
            
            # Check formula pattern: should be =C{row}-B{row} (relative references)
            # Pattern: =C followed by row number, minus, B followed by row number
            expected_pattern = f"=C{row_num}-B{row_num}"
            # Also allow with $ signs: =$C$2-$B$2 or =C$2-B$2 etc.
            pattern_variations = [
                f"=C{row_num}-B{row_num}",
                f"=$C${row_num}-$B${row_num}",
                f"=C${row_num}-B${row_num}",
                f"=$C{row_num}-$B{row_num}"
            ]
            
            formula_matches = False
            for pattern in pattern_variations:
                if formula_text.replace(" ", "").upper() == pattern.replace(" ", "").upper():
                    formula_matches = True
                    break
            
            if not formula_matches:
                # Try regex match for more flexible matching
                pattern_regex = rf'=C\${row_num}-B\${row_num}|=\$C\${row_num}-\$B\${row_num}|=C{row_num}-B{row_num}'
                if re.search(pattern_regex, formula_text, re.IGNORECASE):
                    formula_matches = True
            
            if formula_matches:
                logger.info(f"✓ Cell {cell_coord} has correct formula: {formula_text}")
                formula_count += 1
            else:
                logger.warning(f"Cell {cell_coord} formula does not match expected pattern. Got: {formula_text}, expected pattern: =C{row_num}-B{row_num}")
                formula_check_passed = False
        
        if not formula_check_passed:
            logger.error(f"✗ Formula verification failed: {formula_count}/{formula_end_row - formula_start_row + 1} cells have correct formulas")
            logger.error("Note: D2:D5 should contain formulas =C2-B2, =C3-B3, =C4-B4, =C5-B5")
            # Continue to check chart anyway, but formula failure will cause overall failure
        
        # Check if charts exist - LibreOffice may not expose charts via openpyxl
        # So we'll check via XML directly
        charts = ws._charts
        if charts:
            logger.info(f"Found {len(charts)} chart(s) in the worksheet via openpyxl")
        else:
            logger.info("No charts found via openpyxl (this is normal for LibreOffice files, will check XML directly)")
        
        # Use XML parsing to find the chart and error bars
        # LibreOffice saves charts in a way that openpyxl may not read properly
        # So we need to check XML directly
        try:
            with zipfile.ZipFile(result, 'r') as z_f:
                # Find chart files - check both xl/charts/ and xl/drawings/
                chart_files = [f for f in z_f.namelist() if f.startswith('xl/charts/chart') and f.endswith('.xml')]
                drawing_files = [f for f in z_f.namelist() if 'drawing' in f and f.endswith('.xml')]
                
                logger.info(f"Found {len(chart_files)} chart XML file(s) and {len(drawing_files)} drawing file(s)")
                
                # Also check relationships to find chart files
                rel_files = [f for f in z_f.namelist() if 'xl/worksheets/_rels' in f and f.endswith('.rels')]
                for rel_file in rel_files:
                    try:
                        with z_f.open(rel_file) as f:
                            rel_xml = lxml.etree.parse(f)
                            rel_root = rel_xml.getroot()
                            # Find chart relationships
                            for rel in rel_root.xpath('.//Relationship[@Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart"]'):
                                chart_path = rel.get('Target')
                                if chart_path:
                                    # Convert relative path to absolute
                                    if not chart_path.startswith('xl/'):
                                        chart_path = 'xl/' + chart_path.lstrip('/')
                                    if chart_path not in chart_files and chart_path in z_f.namelist():
                                        chart_files.append(chart_path)
                                        logger.info(f"Found chart via relationship: {chart_path}")
                    except Exception as e:
                        logger.debug(f"Error reading relationship file {rel_file}: {e}")
                
                if not chart_files:
                    logger.warning("No chart XML files found via standard methods, checking all XML files...")
                    # Last resort: check all XML files for chart content
                    all_xml_files = [f for f in z_f.namelist() if f.endswith('.xml')]
                    for xml_file in all_xml_files:
                        try:
                            with z_f.open(xml_file) as f:
                                content = f.read().decode('utf-8', errors='ignore')
                                if 'errBars' in content or 'chartSpace' in content or 'c:ser' in content:
                                    chart_files.append(xml_file)
                                    logger.info(f"Found potential chart file: {xml_file}")
                        except:
                            continue
                
                if not chart_files:
                    logger.error("No chart XML files found")
                    return 0.0
                
                logger.info(f"Found {len(chart_files)} chart XML file(s)")
                
                # Namespaces for chart XML
                chart_ns = {
                    'c': 'http://schemas.openxmlformats.org/drawingml/2006/chart',
                    'a': 'http://schemas.openxmlformats.org/drawingml/2006/main',
                    'r': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
                }
                
                chart_found = False
                series_found = {}
                error_bar_found = False
                positive_error_ok = False
                negative_error_ok = False
                arrow_ok = False
                
                # Check each chart XML file
                for chart_file in chart_files:
                    try:
                        with z_f.open(chart_file) as f:
                            chart_xml = lxml.etree.parse(f)
                            root = chart_xml.getroot()
                            
                            # Find all series in the chart
                            series_elements = root.xpath('.//c:ser', namespaces=chart_ns)
                            
                            logger.info(f"Found {len(series_elements)} series in chart XML")
                            
                            if len(series_elements) < 2:
                                logger.debug(f"Chart has only {len(series_elements)} series, skipping")
                                continue
                            
                            chart_found = True
                            
                            # Check for expected series names
                            for ser_elem in series_elements:
                                # Get series name
                                ser_name = None
                                
                                # Method 1: Direct text value in c:tx//c:v
                                ser_name_elem = ser_elem.xpath('.//c:tx//c:v', namespaces=chart_ns)
                                if ser_name_elem and ser_name_elem[0].text:
                                    ser_name = ser_name_elem[0].text
                                
                                # Method 2: Check c:tx//c:strRef (string reference)
                                if not ser_name:
                                    str_ref_elem = ser_elem.xpath('.//c:tx//c:strRef', namespaces=chart_ns)
                                    if str_ref_elem:
                                        f_elem = str_ref_elem[0].xpath('.//c:f', namespaces=chart_ns)
                                        if f_elem and f_elem[0].text:
                                            cell_ref = f_elem[0].text
                                            logger.debug(f"Series has string reference: {cell_ref}")
                                            try:
                                                if '!' in cell_ref:
                                                    cell_ref = cell_ref.split('!')[1]
                                                cell_ref = cell_ref.replace('$', '')
                                                cell = ws[cell_ref]
                                                if cell.value:
                                                    ser_name = str(cell.value)
                                                    logger.debug(f"Read series name from cell {cell_ref}: {ser_name}")
                                            except Exception as e:
                                                logger.debug(f"Error reading cell {cell_ref}: {e}")
                                
                                logger.debug(f"Series name found: {ser_name}")
                                
                                if ser_name in expected_series_names:
                                    series_found[ser_name] = True
                                    logger.info(f"✓ Found series: {ser_name}")
                                    
                                    # If this is the target series, check for error bars
                                    if ser_name == target_series_name:
                                        # Check for error bars
                                        err_bar_elem = ser_elem.xpath('.//c:errBars', namespaces=chart_ns)
                                        if err_bar_elem:
                                            error_bar_found = True
                                            logger.info("✓ Error bars found for target series")
                                            
                                            err_bar = err_bar_elem[0]
                                            
                                            # Check positive error (should be D2:D5)
                                            pos_err_elem = err_bar.xpath('.//c:plus', namespaces=chart_ns)
                                            if pos_err_elem:
                                                # Check if it's a range reference
                                                num_ref_elem = pos_err_elem[0].xpath('.//c:numRef', namespaces=chart_ns)
                                                if num_ref_elem:
                                                    f_elem = num_ref_elem[0].xpath('.//c:f', namespaces=chart_ns)
                                                    if f_elem and f_elem[0].text:
                                                        ref_text = f_elem[0].text
                                                        logger.info(f"Positive error reference: {ref_text}")
                                                        # Check if reference matches D2:D5 (with or without sheet name, with or without $)
                                                        ref_normalized = ref_text.replace('$', '').upper()
                                                        expected_normalized = error_bar_positive_range.replace('$', '').upper()
                                                        if expected_normalized in ref_normalized or ref_normalized in expected_normalized:
                                                            positive_error_ok = True
                                                            logger.info(f"✓ Positive error range matches: {ref_text}")
                                                        else:
                                                            logger.warning(f"Positive error range mismatch: expected {error_bar_positive_range}, got {ref_text}")
                                            
                                            # Check negative error (should be 0)
                                            neg_err_elem = err_bar.xpath('.//c:minus', namespaces=chart_ns)
                                            if neg_err_elem:
                                                # Check if it's a fixed value
                                                num_lit_elem = neg_err_elem[0].xpath('.//c:numLit', namespaces=chart_ns)
                                                if num_lit_elem:
                                                    pt_elem = num_lit_elem[0].xpath('.//c:pt', namespaces=chart_ns)
                                                    if pt_elem:
                                                        v_elem = pt_elem[0].xpath('.//c:v', namespaces=chart_ns)
                                                        if v_elem and v_elem[0].text:
                                                            neg_val = float(v_elem[0].text)
                                                            logger.info(f"Negative error value: {neg_val}")
                                                            if abs(neg_val - error_bar_negative_value) < 0.01:
                                                                negative_error_ok = True
                                                                logger.info(f"✓ Negative error value matches: {neg_val}")
                                                            else:
                                                                logger.warning(f"Negative error value mismatch: expected {error_bar_negative_value}, got {neg_val}")
                                                
                                                # Also check if it's a reference that points to zeros
                                                num_ref_elem = neg_err_elem[0].xpath('.//c:numRef', namespaces=chart_ns)
                                                if num_ref_elem and not negative_error_ok:
                                                    # If it's a reference, we might need to check the actual values
                                                    # For now, if it's explicitly set to 0 or empty, we accept it
                                                    logger.debug("Negative error is a reference, checking if it's effectively 0")
                                                    # In Excel, if negative error is not set or set to 0, it might be represented differently
                                                    # We'll be lenient here
                                                    negative_error_ok = True
                                                    logger.info("✓ Negative error appears to be set (reference or 0)")
                                            
                                            # Check arrow endpoints
                                            if error_bar_arrow_enabled:
                                                # Check for line end properties (arrows)
                                                sp_pr_elem = err_bar.xpath('.//c:spPr', namespaces=chart_ns)
                                                if sp_pr_elem:
                                                    ln_elem = sp_pr_elem[0].xpath('.//a:ln', namespaces=chart_ns)
                                                    if ln_elem:
                                                        # Check for line end types (arrows)
                                                        head_end_elem = ln_elem[0].xpath('.//a:headEnd', namespaces=chart_ns)
                                                        tail_end_elem = ln_elem[0].xpath('.//a:tailEnd', namespaces=chart_ns)
                                                        
                                                        if head_end_elem or tail_end_elem:
                                                            arrow_ok = True
                                                            logger.info("✓ Error bar line has arrow endpoints")
                                                        else:
                                                            logger.warning("Error bar line does not have arrow endpoints")
                                                    else:
                                                        logger.warning("Error bar line properties not found")
                                                else:
                                                    # Arrow might be set at a different level, be lenient
                                                    logger.debug("Error bar shape properties not found, checking alternative locations")
                                                    # Check if arrows are set in the line style
                                                    arrow_ok = True  # Be lenient for now
                                                    logger.info("Assuming arrow endpoints are set (lenient check)")
                                            else:
                                                arrow_ok = True  # Not checking arrows
                                        
                                        else:
                                            logger.warning(f"No error bars found for '{target_series_name}' series")
                            
                            # Check if all expected series were found
                            if len(series_found) >= len(expected_series_names):
                                logger.info(f"✓ All expected series found: {list(series_found.keys())}")
                            else:
                                missing = [s for s in expected_series_names if s not in series_found]
                                logger.warning(f"Missing series: {missing}")
                            
                            if chart_found and len(series_found) >= len(expected_series_names):
                                break
                    
                    except Exception as e:
                        logger.warning(f"Error parsing chart XML file {chart_file}: {e}")
                        import traceback
                        logger.debug(traceback.format_exc())
                        continue
                
                # Final verification
                if not chart_found:
                    logger.error("✗ No chart found with at least 2 series")
                    return 0.0
                
                if len(series_found) < len(expected_series_names):
                    logger.error(f"✗ Not all expected series found. Found: {list(series_found.keys())}, Expected: {expected_series_names}")
                    return 0.0
                
                if not error_bar_found:
                    logger.error(f"✗ Error bars not found for '{target_series_name}' series")
                    return 0.0
                
                if not positive_error_ok:
                    logger.error(f"✗ Positive error range verification failed")
                    return 0.0
                
                if not negative_error_ok:
                    logger.error(f"✗ Negative error value verification failed")
                    return 0.0
                
                if error_bar_arrow_enabled and not arrow_ok:
                    logger.warning("⚠ Arrow endpoints verification had issues, but continuing (lenient check)")
                    # Don't fail on arrow check alone as it might be represented differently
                
                # Final check: if formula verification failed, overall verification fails
                if not formula_check_passed:
                    logger.error("=" * 60)
                    logger.error("✗ Overall verification failed: Formula check failed")
                    logger.error(f"  - Chart verification: PASSED")
                    logger.error(f"    * Chart found with {len(series_found)} series")
                    logger.error(f"    * Series names: {list(series_found.keys())}")
                    logger.error(f"    * Error bars found for '{target_series_name}' series")
                    logger.error(f"    * Positive error range: {error_bar_positive_range}")
                    logger.error(f"    * Negative error value: {error_bar_negative_value}")
                    logger.error(f"  - Formula verification: FAILED")
                    logger.error(f"    * D2:D5 should contain formulas =C2-B2, =C3-B3, =C4-B4, =C5-B5")
                    logger.error("=" * 60)
                    return 0.0
                
                logger.info("=" * 60)
                logger.info(f"✓ Chart error bars verification passed!")
                logger.info(f"  - Formulas verified: D2:D5 contain correct formulas")
                logger.info(f"  - Chart found with {len(series_found)} series")
                logger.info(f"  - Series names: {list(series_found.keys())}")
                logger.info(f"  - Error bars found for '{target_series_name}' series")
                logger.info(f"  - Positive error range: {error_bar_positive_range}")
                logger.info(f"  - Negative error value: {error_bar_negative_value}")
                logger.info(f"  - Arrow endpoints: {'OK' if arrow_ok else 'Warning'}")
                logger.info("=" * 60)
                return 1.0
                
        except Exception as e:
            logger.error(f"Error accessing chart XML files: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_line_chart_high_low_lines_with_data_labels(result: str, expected: str = None, **options) -> float:
    """
    Verify if a line chart has high-low lines connecting two series and data labels
    showing cell values from B4:J4. Also verify that B4:J4 contains formulas =B2-B3
    (with relative references).
    
    This function checks:
    1. Whether B4:J4 contains formulas =B2-B3, =C2-C3, etc. (with relative references)
    2. Whether at least one chart exists in the worksheet
    3. Whether the chart has high-low lines enabled
    4. Whether the chart has data labels enabled
    5. Whether data labels reference B4:J4 cell range
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - sheet_idx: Sheet index to check (default: 0)
            - formula_start_col: Starting column for formula check (default: "B")
            - formula_end_col: Ending column for formula check (default: "J")
            - formula_row: Row number for formula check (default: 4)
            - formula_base_pattern: Expected formula pattern for first cell (default: "=B2-B3")
            - data_label_range: Expected data label range (default: "B4:J4")
            - expected_series_count: Expected number of series (default: 2)
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import zipfile
        import lxml.etree
        import re
        from openpyxl.utils import column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        sheet_idx = options.get('sheet_idx', 0)
        formula_start_col = options.get('formula_start_col', 'B')
        formula_end_col = options.get('formula_end_col', 'J')
        formula_row = options.get('formula_row', 4)
        formula_base_pattern = options.get('formula_base_pattern', '=B2-B3')
        data_label_range = options.get('data_label_range', 'B4:J4')
        expected_series_count = options.get('expected_series_count', 2)
        
        logger.info(f"Verifying line chart with high-low lines and data labels in file: {result}")
        logger.info(f"Sheet index: {sheet_idx}")
        logger.info(f"Formula range: {formula_start_col}{formula_row}:{formula_end_col}{formula_row}")
        logger.info(f"Data label range: {data_label_range}")
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=False)
            sheet_names = wb.sheetnames
            logger.info(f"Available sheets: {sheet_names}")
            
            if sheet_idx >= len(sheet_names):
                logger.error(f"Sheet index {sheet_idx} out of range. Available sheets: {sheet_names}")
                return 0.0
            
            sheet_name = sheet_names[sheet_idx]
            ws = wb[sheet_name]
            logger.info(f"Using sheet: {sheet_name}")
                
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return 0.0
        
        # Check formulas in B4:J4
        logger.info(f"Checking formulas in {formula_start_col}{formula_row}:{formula_end_col}{formula_row}...")
        formula_check_passed = True
        formula_count = 0
        
        start_col_idx = column_index_from_string(formula_start_col)
        end_col_idx = column_index_from_string(formula_end_col)
        
        for col_idx in range(start_col_idx, end_col_idx + 1):
            col_letter = get_column_letter(col_idx)
            cell_coord = f"{col_letter}{formula_row}"
            cell = ws[cell_coord]
            
            # Check if cell contains a formula
            is_formula = False
            formula_text = None
            
            if cell.data_type == "f":
                is_formula = True
            elif hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                is_formula = True
                formula_text = cell._value
            elif hasattr(cell, "formula") and cell.formula:
                is_formula = True
                formula_text = cell.formula
            elif cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                is_formula = True
                formula_text = cell.value
            
            if not is_formula:
                logger.warning(f"Cell {cell_coord} does not contain a formula")
                formula_check_passed = False
                continue
            
            # Get formula text if not already obtained
            if formula_text is None:
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                elif cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula_text = cell.value
            
            if formula_text is None:
                logger.warning(f"Could not extract formula from cell {cell_coord}")
                formula_check_passed = False
                continue
            
            # Check formula pattern: should be ={col}2-{col}3 (relative references)
            # For B4: =B2-B3, for C4: =C2-C3, etc.
            expected_pattern = f"={col_letter}2-{col_letter}3"
            pattern_variations = [
                f"={col_letter}2-{col_letter}3",
                f"=${col_letter}$2-${col_letter}$3",
                f"={col_letter}$2-{col_letter}$3",
                f"=${col_letter}2-${col_letter}3"
            ]
            
            formula_matches = False
            for pattern in pattern_variations:
                if formula_text.replace(" ", "").upper() == pattern.replace(" ", "").upper():
                    formula_matches = True
                    break
            
            if not formula_matches:
                # Try regex match for more flexible matching
                pattern_regex = rf'={col_letter}\$?2-{col_letter}\$?3|=\${col_letter}\$?2-\${col_letter}\$?3'
                if re.search(pattern_regex, formula_text, re.IGNORECASE):
                    formula_matches = True
            
            if formula_matches:
                logger.info(f"✓ Cell {cell_coord} has correct formula: {formula_text}")
                formula_count += 1
            else:
                logger.warning(f"Cell {cell_coord} formula does not match expected pattern. Got: {formula_text}, expected: {expected_pattern}")
                formula_check_passed = False
        
        if not formula_check_passed:
            logger.error(f"✗ Formula verification failed: {formula_count}/{end_col_idx - start_col_idx + 1} cells have correct formulas")
            logger.error(f"Note: {formula_start_col}{formula_row}:{formula_end_col}{formula_row} should contain formulas =B2-B3, =C2-C3, etc.")
            # Continue to check chart anyway
        
        # Check if charts exist via XML parsing
        try:
            with zipfile.ZipFile(result, 'r') as z_f:
                # Find chart files
                chart_files = [f for f in z_f.namelist() if f.startswith('xl/charts/chart') and f.endswith('.xml')]
                drawing_files = [f for f in z_f.namelist() if 'drawing' in f and f.endswith('.xml')]
                
                logger.info(f"Found {len(chart_files)} chart XML file(s) and {len(drawing_files)} drawing file(s)")
                
                # Also check relationships to find chart files
                rel_files = [f for f in z_f.namelist() if 'xl/worksheets/_rels' in f and f.endswith('.rels')]
                for rel_file in rel_files:
                    try:
                        with z_f.open(rel_file) as f:
                            rel_xml = lxml.etree.parse(f)
                            rel_root = rel_xml.getroot()
                            for rel in rel_root.xpath('.//Relationship[@Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart"]'):
                                chart_path = rel.get('Target')
                                if chart_path:
                                    if not chart_path.startswith('xl/'):
                                        chart_path = 'xl/' + chart_path.lstrip('/')
                                    if chart_path not in chart_files and chart_path in z_f.namelist():
                                        chart_files.append(chart_path)
                                        logger.info(f"Found chart via relationship: {chart_path}")
                    except Exception as e:
                        logger.debug(f"Error reading relationship file {rel_file}: {e}")
                
                if not chart_files:
                    logger.warning("No chart XML files found via standard methods, checking all XML files...")
                    all_xml_files = [f for f in z_f.namelist() if f.endswith('.xml')]
                    for xml_file in all_xml_files:
                        try:
                            with z_f.open(xml_file) as f:
                                content = f.read().decode('utf-8', errors='ignore')
                                if 'chartSpace' in content or 'c:ser' in content or 'highLowLines' in content:
                                    chart_files.append(xml_file)
                                    logger.info(f"Found potential chart file: {xml_file}")
                        except:
                            continue
                
                if not chart_files:
                    logger.error("No chart XML files found")
                    if not formula_check_passed:
                        return 0.0
                    # If formulas are correct but no chart, still fail
                    logger.error("Chart verification failed: No chart found")
                    return 0.0
                
                logger.info(f"Found {len(chart_files)} chart XML file(s)")
                
                # Namespaces for chart XML
                chart_ns = {
                    'c': 'http://schemas.openxmlformats.org/drawingml/2006/chart',
                    'a': 'http://schemas.openxmlformats.org/drawingml/2006/main',
                    'r': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
                }
                
                chart_found = False
                high_low_lines_found = False
                data_labels_found = False
                data_label_range_ok = False
                
                # Check each chart XML file
                for chart_file in chart_files:
                    try:
                        with z_f.open(chart_file) as f:
                            chart_xml = lxml.etree.parse(f)
                            root = chart_xml.getroot()
                            
                            # Find all series in the chart
                            series_elements = root.xpath('.//c:ser', namespaces=chart_ns)
                            
                            logger.info(f"Found {len(series_elements)} series in chart XML")
                            
                            if len(series_elements) < expected_series_count:
                                logger.debug(f"Chart has only {len(series_elements)} series, expected at least {expected_series_count}, skipping")
                                continue
                            
                            chart_found = True
                            logger.info(f"✓ Chart found with {len(series_elements)} series")
                            
                            # Check for high-low lines
                            # High-low lines are typically in the plotArea or as a group element
                            high_low_elem = root.xpath('.//c:highLowLines', namespaces=chart_ns)
                            if high_low_elem:
                                high_low_lines_found = True
                                logger.info("✓ High-low lines found in chart")
                            else:
                                # Also check for upDownBars which may contain high-low lines
                                up_down_bars = root.xpath('.//c:upDownBars', namespaces=chart_ns)
                                if up_down_bars:
                                    high_low_lines_found = True
                                    logger.info("✓ Up-down bars found (may indicate high-low lines)")
                                else:
                                    logger.warning("High-low lines not found in chart XML")
                            
                            # Check for data labels
                            # Data labels can be in series elements or as chart-level settings
                            d_lbls_found = False
                            for ser_elem in series_elements:
                                d_lbls_elem = ser_elem.xpath('.//c:dLbls', namespaces=chart_ns)
                                if d_lbls_elem:
                                    d_lbls_found = True
                                    logger.info("✓ Data labels found in series")
                                    
                                    # Check if data labels reference cell values
                                    # Look for c:numRef or c:strRef in dLbls
                                    num_ref_elem = d_lbls_elem[0].xpath('.//c:numRef', namespaces=chart_ns)
                                    str_ref_elem = d_lbls_elem[0].xpath('.//c:strRef', namespaces=chart_ns)
                                    
                                    if num_ref_elem or str_ref_elem:
                                        ref_elem = num_ref_elem[0] if num_ref_elem else str_ref_elem[0]
                                        f_elem = ref_elem.xpath('.//c:f', namespaces=chart_ns)
                                        if f_elem and f_elem[0].text:
                                            ref_text = f_elem[0].text
                                            logger.info(f"Data label reference found: {ref_text}")
                                            # Check if reference matches B4:J4 (with or without sheet name, with or without $)
                                            ref_normalized = ref_text.replace('$', '').upper()
                                            expected_normalized = data_label_range.replace('$', '').upper()
                                            if expected_normalized in ref_normalized or ref_normalized in expected_normalized:
                                                data_label_range_ok = True
                                                logger.info(f"✓ Data label range matches: {ref_text}")
                                            else:
                                                logger.warning(f"Data label range mismatch: expected {data_label_range}, got {ref_text}")
                                    
                                    # Also check for showVal or showCellVal attributes
                                    show_val = d_lbls_elem[0].get('showVal')
                                    show_cell_val = d_lbls_elem[0].get('showCellVal')
                                    if show_val == '1' or show_cell_val == '1':
                                        data_labels_found = True
                                        logger.info("✓ Data labels enabled (showVal or showCellVal)")
                                    
                                    break
                            
                            if not d_lbls_found:
                                # Check chart-level data labels
                                chart_d_lbls = root.xpath('.//c:dLbls', namespaces=chart_ns)
                                if chart_d_lbls:
                                    data_labels_found = True
                                    logger.info("✓ Data labels found at chart level")
                            
                            if chart_found:
                                break
                                
                    except Exception as e:
                        logger.debug(f"Error reading chart file {chart_file}: {e}")
                        continue
                
                # Final verification
                if not chart_found:
                    logger.error("✗ No chart found with expected number of series")
                    if not formula_check_passed:
                        return 0.0
                    return 0.0
                
                if not high_low_lines_found:
                    logger.warning("⚠ High-low lines not found in chart XML (may be represented differently)")
                    # Don't fail on this alone as LibreOffice may represent it differently
                
                if not data_labels_found and not data_label_range_ok:
                    logger.warning("⚠ Data labels not found or not properly configured")
                    # Don't fail on this alone as it may be represented differently
                
                # If formulas are correct and chart exists, consider it a pass
                # (high-low lines and data labels checks are lenient due to LibreOffice representation differences)
                if formula_check_passed and chart_found:
                    logger.info("=" * 60)
                    logger.info(f"✓ Line chart with high-low lines verification passed!")
                    logger.info(f"  - Formulas verified: {formula_start_col}{formula_row}:{formula_end_col}{formula_row} contain correct formulas")
                    logger.info(f"  - Chart found with series")
                    logger.info(f"  - High-low lines: {'Found' if high_low_lines_found else 'Warning (may be represented differently)'}")
                    logger.info(f"  - Data labels: {'Found' if (data_labels_found or data_label_range_ok) else 'Warning (may be represented differently)'}")
                    logger.info("=" * 60)
                    return 1.0
                else:
                    logger.error("=" * 60)
                    logger.error("✗ Verification failed")
                    if not formula_check_passed:
                        logger.error("  - Formula verification failed")
                    if not chart_found:
                        logger.error("  - Chart verification failed")
                    logger.error("=" * 60)
                    return 0.0
                    
        except Exception as e:
            logger.error(f"Error accessing chart XML files: {e}")
            import traceback
            logger.error(traceback.format_exc())
            # If formulas are correct, still return partial success
            if formula_check_passed:
                logger.warning("Chart XML parsing failed, but formulas are correct")
                return 0.5  # Partial success
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_scatter_chart_secondary_axis_internal_ticks(result: str, expected: str = None, **options) -> float:
    """
    Verify if a scatter chart with smooth lines has a series using secondary axis (secondary X and Y axes)
    with tick marks set to internal type and secondary X axis minimum value set.
    
    This function checks:
    1. Whether at least one chart exists in the worksheet
    2. Whether the chart is a scatter chart with smooth lines
    3. Whether there is a series with data from the specified range (F3:G4)
    4. Whether the series uses secondary axis (secondary X and Y axes)
    5. Whether the secondary X and Y axes have tick marks set to internal type
    6. Whether the primary X axis has the expected minimum value
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - sheet_idx: Sheet index to check (default: 0)
            - auxiliary_data_range: Range containing auxiliary data (default: "F3:G4")
            - expected_series_x_range: Expected X values range for the series (default: "F3:F4")
            - expected_series_y_range: Expected Y values range for the series (default: "G3:G4")
            - chart_type: Expected chart type (default: "scatterChart")
            - smooth_line: Whether chart should have smooth lines (default: True)
            - secondary_axis: Whether series should use secondary axis (default: True)
            - tick_mark_type: Expected tick mark type (default: "in" for internal)
            - primary_x_axis_min: Expected minimum value for primary X axis (default: None, not checked if None)
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import zipfile
        import lxml.etree
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        sheet_idx = options.get('sheet_idx', 0)
        auxiliary_data_range = options.get('auxiliary_data_range', 'F3:G4')
        expected_series_x_range = options.get('expected_series_x_range', 'F3:F4')
        expected_series_y_range = options.get('expected_series_y_range', 'G3:G4')
        expected_chart_type = options.get('chart_type', 'scatterChart')
        smooth_line = options.get('smooth_line', True)
        secondary_axis = options.get('secondary_axis', True)
        tick_mark_type = options.get('tick_mark_type', 'in')
        primary_x_axis_min = options.get('primary_x_axis_min', None)
        
        logger.info(f"Verifying scatter chart with secondary axis internal ticks in file: {result}")
        logger.info(f"Sheet index: {sheet_idx}")
        logger.info(f"Auxiliary data range: {auxiliary_data_range}")
        logger.info(f"Expected series X range: {expected_series_x_range}")
        logger.info(f"Expected series Y range: {expected_series_y_range}")
        logger.info(f"Expected chart type: {expected_chart_type}")
        logger.info(f"Smooth line: {smooth_line}")
        logger.info(f"Secondary axis: {secondary_axis}")
        logger.info(f"Tick mark type: {tick_mark_type}")
        if primary_x_axis_min is not None:
            logger.info(f"Primary X axis minimum value: {primary_x_axis_min}")
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=False)
            sheet_names = wb.sheetnames
            if sheet_idx >= len(sheet_names):
                logger.error(f"Sheet index {sheet_idx} out of range. Available sheets: {sheet_names}")
                return 0.0
            sheet_name = sheet_names[sheet_idx]
            ws = wb[sheet_name]
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return 0.0
        
        # Check auxiliary data in F3:G4
        logger.info(f"Checking auxiliary data in {auxiliary_data_range}...")
        try:
            # Parse range to get cells
            range_parts = auxiliary_data_range.split(':')
            if len(range_parts) == 2:
                start_cell = range_parts[0]
                end_cell = range_parts[1]
                # Extract column and row
                start_col = ''.join(filter(str.isalpha, start_cell))
                start_row = int(''.join(filter(str.isdigit, start_cell)))
                end_col = ''.join(filter(str.isalpha, end_cell))
                end_row = int(''.join(filter(str.isdigit, end_cell)))
                
                # Check if cells have data
                has_data = False
                for row in range(start_row, end_row + 1):
                    for col_letter in [start_col, end_col]:
                        cell = ws[f"{col_letter}{row}"]
                        if cell.value is not None:
                            has_data = True
                            logger.info(f"✓ Found data in {col_letter}{row}: {cell.value}")
                
                if not has_data:
                    logger.warning(f"⚠ No data found in {auxiliary_data_range}")
            else:
                logger.warning(f"Could not parse range {auxiliary_data_range}")
        except Exception as e:
            logger.warning(f"Error checking auxiliary data: {e}")
        
        # Check if charts exist
        charts = ws._charts
        if charts:
            logger.info(f"Found {len(charts)} chart(s) in the worksheet via openpyxl")
        else:
            logger.info("No charts found via openpyxl (this is normal for LibreOffice files, will check XML directly)")
        
        # Use XML parsing to find the chart and verify properties
        try:
            with zipfile.ZipFile(result, 'r') as z_f:
                # Find chart files
                chart_files = [f for f in z_f.namelist() if f.startswith('xl/charts/chart') and f.endswith('.xml')]
                
                # Also check relationships to find chart files
                rel_files = [f for f in z_f.namelist() if 'xl/worksheets/_rels' in f and f.endswith('.rels')]
                for rel_file in rel_files:
                    try:
                        with z_f.open(rel_file) as f:
                            rel_xml = lxml.etree.parse(f)
                            rel_root = rel_xml.getroot()
                            # Find chart relationships
                            for rel in rel_root.xpath('.//Relationship[@Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart"]'):
                                chart_path = rel.get('Target')
                                if chart_path:
                                    # Convert relative path to absolute
                                    if not chart_path.startswith('xl/'):
                                        chart_path = 'xl/' + chart_path.lstrip('/')
                                    if chart_path not in chart_files and chart_path in z_f.namelist():
                                        chart_files.append(chart_path)
                                        logger.info(f"Found chart via relationship: {chart_path}")
                    except Exception as e:
                        logger.debug(f"Error reading relationship file {rel_file}: {e}")
                
                if not chart_files:
                    logger.error("No chart XML files found")
                    return 0.0
                
                logger.info(f"Found {len(chart_files)} chart XML file(s)")
                
                # Namespaces for chart XML
                chart_ns = {
                    'c': 'http://schemas.openxmlformats.org/drawingml/2006/chart',
                    'a': 'http://schemas.openxmlformats.org/drawingml/2006/main',
                    'r': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
                }
                
                chart_found = False
                scatter_chart_found = False
                smooth_line_found = False
                series_found = False
                series_x_range_ok = False
                series_y_range_ok = False
                secondary_axis_found = False
                secondary_x_axis_found = False
                secondary_y_axis_found = False
                tick_mark_x_ok = False
                tick_mark_y_ok = False
                primary_x_axis_min_ok = False
                
                # Check each chart XML file
                for chart_file in chart_files:
                    try:
                        with z_f.open(chart_file) as f:
                            chart_xml = lxml.etree.parse(f)
                            root = chart_xml.getroot()
                            
                            # Find scatter chart
                            scatter_chart_elem = root.xpath('.//c:scatterChart', namespaces=chart_ns)
                            if not scatter_chart_elem:
                                logger.debug("Chart is not a scatter chart, skipping")
                                continue
                            
                            scatter_chart_found = True
                            logger.info("✓ Chart contains scatter chart type")
                            
                            # Check for smooth line
                            if smooth_line:
                                smooth_elem = scatter_chart_elem[0].xpath('.//c:smooth', namespaces=chart_ns)
                                if smooth_elem:
                                    smooth_val = smooth_elem[0].get('val', '0')
                                    if smooth_val == '1' or smooth_val == 'true':
                                        smooth_line_found = True
                                        logger.info("✓ Chart has smooth lines enabled")
                                    else:
                                        logger.warning(f"Smooth line value is {smooth_val}, expected 1 or true")
                                else:
                                    logger.warning("Smooth line element not found")
                            
                            # Find all series in the chart
                            series_elements = root.xpath('.//c:ser', namespaces=chart_ns)
                            logger.info(f"Found {len(series_elements)} series in chart XML")
                            
                            # Get all axes first (needed for secondary axis checking)
                            all_axes = root.xpath('.//c:valAx | .//c:catAx | .//c:dateAx', namespaces=chart_ns)
                            
                            logger.info(f"Found {len(all_axes)} axis elements in chart XML")
                            
                            # Identify primary and secondary axes by examining the chart structure
                            # In scatter charts, secondary axes are typically defined separately
                            primary_axis_ids = set()
                            secondary_axis_ids = set()
                            
                            # Count axes by type
                            val_axes = []  # Y axes
                            cat_axes = []  # X axes
                            axis_info = []  # Store axis information
                            
                            for axis_elem in all_axes:
                                # Try multiple ways to get axis ID
                                axis_id_val = None
                                # Method 1: Try with namespace
                                axis_id_val = axis_elem.get('{http://schemas.openxmlformats.org/drawingml/2006/chart}axId')
                                # Method 2: Try without namespace (for some WPS files)
                                if not axis_id_val:
                                    axis_id_val = axis_elem.get('axId')
                                # Method 3: Try to find axId element
                                if not axis_id_val:
                                    ax_id_elem = axis_elem.xpath('.//c:axId', namespaces=chart_ns)
                                    if ax_id_elem:
                                        axis_id_val = ax_id_elem[0].get('val')
                                
                                if axis_id_val:
                                    # Get axis position to help identify X vs Y axis and primary vs secondary
                                    ax_pos_elem = axis_elem.xpath('.//c:axPos', namespaces=chart_ns)
                                    ax_pos = ax_pos_elem[0].get('val', '') if ax_pos_elem else ''
                                    
                                    # In scatter charts, X and Y axes may both be valAx
                                    # Use position to determine axis type:
                                    # - b (bottom) or t (top) = X axis
                                    # - l (left) or r (right) = Y axis
                                    tag_type = 'valAx' if axis_elem.tag.endswith('valAx') else ('catAx' if axis_elem.tag.endswith('catAx') else 'dateAx')
                                    
                                    # Determine actual axis type based on position
                                    if ax_pos in ['b', 't']:  # bottom or top = X axis
                                        axis_type = 'catAx'  # Treat as category axis (X axis)
                                    elif ax_pos in ['l', 'r']:  # left or right = Y axis
                                        axis_type = 'valAx'  # Value axis (Y axis)
                                    else:
                                        # Fallback to tag type
                                        axis_type = tag_type
                                    
                                    # Get cross axis (the axis this axis crosses)
                                    cross_ax_elem = axis_elem.xpath('.//c:crossAx', namespaces=chart_ns)
                                    cross_ax = cross_ax_elem[0].get('val', '') if cross_ax_elem else ''
                                    
                                    axis_info.append({
                                        'id': axis_id_val,
                                        'type': axis_type,
                                        'tag_type': tag_type,  # Original tag type
                                        'position': ax_pos,
                                        'cross_ax': cross_ax,
                                        'element': axis_elem
                                    })
                                    
                                    try:
                                        axis_id_int = int(axis_id_val)
                                        # In scatter charts with 4 axes, typically:
                                        # - Primary axes: bottom (b) and left (l)
                                        # - Secondary axes: top (t) and right (r)
                                        if ax_pos in ['b', 'l']:
                                            primary_axis_ids.add(axis_id_val)
                                        elif ax_pos in ['t', 'r']:
                                            secondary_axis_ids.add(axis_id_val)
                                            logger.info(f"Found secondary axis with ID: {axis_id_val}, type: {axis_type}, position: {ax_pos}")
                                    except ValueError:
                                        # If ID is not numeric, use position to determine primary/secondary
                                        if ax_pos in ['b', 'l']:
                                            primary_axis_ids.add(axis_id_val)
                                        elif ax_pos in ['t', 'r']:
                                            secondary_axis_ids.add(axis_id_val)
                                    
                                    # Categorize by actual axis type (not tag type)
                                    if axis_type == 'valAx':
                                        val_axes.append(axis_id_val)
                                    elif axis_type in ['catAx', 'dateAx']:
                                        cat_axes.append(axis_id_val)
                                    
                                    logger.info(f"Axis ID: {axis_id_val}, Tag Type: {tag_type}, Actual Type: {axis_type}, Position: {ax_pos}, Cross Axis: {cross_ax}")
                                else:
                                    logger.warning(f"Could not extract axis ID from axis element: {axis_elem.tag}")
                                    # Still try to categorize by type even without ID
                                    axis_type = 'valAx' if axis_elem.tag.endswith('valAx') else ('catAx' if axis_elem.tag.endswith('catAx') else 'dateAx')
                                    logger.warning(f"Axis without ID, Type: {axis_type}")
                            
                            logger.info(f"Primary axis IDs: {primary_axis_ids}")
                            logger.info(f"Secondary axis IDs: {secondary_axis_ids}")
                            logger.info(f"Value axes (Y): {val_axes}")
                            logger.info(f"Category axes (X): {cat_axes}")
                            
                            # If there are multiple X or Y axes, there are secondary axes
                            # In scatter charts with secondary axes, we typically have:
                            # - Primary X axis (catAx/dateAx) with ID 1
                            # - Primary Y axis (valAx) with ID 2
                            # - Secondary X axis (catAx/dateAx) with ID 3 or higher
                            # - Secondary Y axis (valAx) with ID 4 or higher
                            if len(val_axes) > 1 or len(cat_axes) > 1:
                                logger.info(f"Multiple axes detected - secondary axes present")
                                # If we have multiple axes, identify secondary axes
                                if len(val_axes) > 1:
                                    # First valAx is usually primary, rest are secondary
                                    secondary_axis_ids.update(val_axes[1:])
                                    logger.info(f"Secondary Y axes (from val_axes): {val_axes[1:]}")
                                if len(cat_axes) > 1:
                                    # First catAx is usually primary, rest are secondary
                                    secondary_axis_ids.update(cat_axes[1:])
                                    logger.info(f"Secondary X axes (from cat_axes): {cat_axes[1:]}")
                                logger.info(f"Updated secondary axis IDs (based on multiple axes): {secondary_axis_ids}")
                            
                            # Also check if there are exactly 4 axes (typical for scatter with secondary axes)
                            if len(all_axes) == 4:
                                logger.info("Found 4 axes - typical configuration for scatter chart with secondary axes")
                                # If we have 4 axes and can't identify by ID, use position-based logic
                                if not secondary_axis_ids and len(axis_info) == 4:
                                    # Typically: axes 0 and 1 are primary, axes 2 and 3 are secondary
                                    # But we need to check by type: first catAx and first valAx are primary
                                    cat_axis_indices = [i for i, ax in enumerate(axis_info) if ax['type'] in ['catAx', 'dateAx']]
                                    val_axis_indices = [i for i, ax in enumerate(axis_info) if ax['type'] == 'valAx']
                                    
                                    if len(cat_axis_indices) >= 2:
                                        # First catAx is primary, second is secondary
                                        if len(cat_axis_indices) > 1:
                                            secondary_axis_ids.add(axis_info[cat_axis_indices[1]]['id'])
                                            logger.info(f"Identified secondary X axis by position: {axis_info[cat_axis_indices[1]]['id']}")
                                    
                                    if len(val_axis_indices) >= 2:
                                        # First valAx is primary, second is secondary
                                        if len(val_axis_indices) > 1:
                                            secondary_axis_ids.add(axis_info[val_axis_indices[1]]['id'])
                                            logger.info(f"Identified secondary Y axis by position: {axis_info[val_axis_indices[1]]['id']}")
                                
                                # Also try numeric ID check
                                for axis in axis_info:
                                    try:
                                        if int(axis['id']) >= 3:
                                            secondary_axis_ids.add(axis['id'])
                                    except ValueError:
                                        pass
                            
                            # Check primary X axis minimum value if specified
                            if primary_x_axis_min is not None:
                                # Find primary X axis
                                # In scatter charts, primary X axis is typically at bottom (position 'b')
                                primary_x_axis = None
                                
                                # Method 1: Find by position 'b' (bottom) - this is the primary X axis
                                for axis in axis_info:
                                    if axis['position'] == 'b' and axis['type'] in ['catAx', 'dateAx']:
                                        primary_x_axis = axis
                                        logger.info(f"Found primary X axis by position 'b' with ID: {axis['id']}")
                                        break
                                
                                # Method 2: If not found by position, try by primary_axis_ids
                                if primary_x_axis is None and primary_axis_ids:
                                    for axis in axis_info:
                                        if axis['type'] in ['catAx', 'dateAx']:
                                            if axis['id'] in primary_axis_ids:
                                                primary_x_axis = axis
                                                logger.info(f"Found primary X axis with ID: {axis['id']} (from primary_axis_ids)")
                                                break
                                
                                # Method 3: If still not found, use the first catAx/dateAx as primary X axis
                                if primary_x_axis is None:
                                    for axis in axis_info:
                                        if axis['type'] in ['catAx', 'dateAx']:
                                            primary_x_axis = axis
                                            logger.info(f"Using first X axis as primary X axis with ID: {axis['id']}")
                                            break
                                
                                # Method 4: If still not found, check all axes directly by position
                                if primary_x_axis is None:
                                    for axis_elem in all_axes:
                                        ax_pos_elem = axis_elem.xpath('.//c:axPos', namespaces=chart_ns)
                                        ax_pos = ax_pos_elem[0].get('val', '') if ax_pos_elem else ''
                                        if ax_pos == 'b':  # Bottom position = primary X axis
                                            axis_id_temp = axis_elem.get('{http://schemas.openxmlformats.org/drawingml/2006/chart}axId') or axis_elem.get('axId') or 'unknown'
                                            primary_x_axis = {
                                                'id': axis_id_temp,
                                                'type': 'catAx',
                                                'element': axis_elem,
                                                'position': 'b'
                                            }
                                            logger.info(f"Using axis at position 'b' directly as primary X axis")
                                            break
                                
                                if primary_x_axis:
                                    # Check minimum value
                                    scaling_elem = primary_x_axis['element'].xpath('.//c:scaling', namespaces=chart_ns)
                                    if scaling_elem:
                                        min_elem = scaling_elem[0].xpath('.//c:min', namespaces=chart_ns)
                                        if min_elem:
                                            min_val_elem = min_elem[0].xpath('.//c:val', namespaces=chart_ns)
                                            if min_val_elem and min_val_elem[0].text:
                                                try:
                                                    min_val = float(min_val_elem[0].text)
                                                    if abs(min_val - primary_x_axis_min) < 0.01:  # Allow small floating point differences
                                                        primary_x_axis_min_ok = True
                                                        logger.info(f"✓ Primary X axis minimum value is {min_val} (expected {primary_x_axis_min})")
                                                    else:
                                                        logger.warning(f"Primary X axis minimum value is {min_val}, expected {primary_x_axis_min}")
                                                except (ValueError, TypeError):
                                                    logger.warning(f"Could not parse primary X axis minimum value: {min_val_elem[0].text}")
                                            else:
                                                logger.warning("Primary X axis minimum value element (c:val) not found")
                                                # Try to get min value directly from min element
                                                min_val_attr = min_elem[0].get('val')
                                                if min_val_attr:
                                                    try:
                                                        min_val = float(min_val_attr)
                                                        if abs(min_val - primary_x_axis_min) < 0.01:
                                                            primary_x_axis_min_ok = True
                                                            logger.info(f"✓ Primary X axis minimum value is {min_val} (expected {primary_x_axis_min}, from attribute)")
                                                    except (ValueError, TypeError):
                                                        pass
                                        else:
                                            logger.warning("Primary X axis scaling/min element not found")
                                            # Log the scaling element structure for debugging
                                            logger.debug(f"Scaling element: {lxml.etree.tostring(scaling_elem[0], encoding='unicode')[:200]}")
                                    else:
                                        logger.warning("Primary X axis scaling element not found")
                                        # Try to find scaling in different ways
                                        scaling_alt = primary_x_axis['element'].xpath('.//scaling', namespaces=chart_ns)
                                        if scaling_alt:
                                            logger.info("Found scaling element without namespace prefix")
                                else:
                                    logger.warning("Primary X axis not found - checking all axes...")
                                    for i, axis_elem in enumerate(all_axes):
                                        logger.info(f"Axis {i}: tag={axis_elem.tag}, has scaling={len(axis_elem.xpath('.//c:scaling', namespaces=chart_ns)) > 0}")
                            
                            # Check each series for data ranges and secondary axis
                            for ser_elem in series_elements:
                                # Get X values range
                                x_range = None
                                x_num_ref = ser_elem.xpath('.//c:xVal//c:numRef', namespaces=chart_ns)
                                if x_num_ref:
                                    f_elem = x_num_ref[0].xpath('.//c:f', namespaces=chart_ns)
                                    if f_elem and f_elem[0].text:
                                        x_range_raw = f_elem[0].text
                                        # Remove sheet name if present
                                        if '!' in x_range_raw:
                                            x_range = x_range_raw.split('!')[1]
                                        else:
                                            x_range = x_range_raw
                                        x_range = x_range.replace('$', '')
                                
                                # Get Y values range
                                y_range = None
                                y_num_ref = ser_elem.xpath('.//c:yVal//c:numRef', namespaces=chart_ns)
                                if y_num_ref:
                                    f_elem = y_num_ref[0].xpath('.//c:f', namespaces=chart_ns)
                                    if f_elem and f_elem[0].text:
                                        y_range_raw = f_elem[0].text
                                        # Remove sheet name if present
                                        if '!' in y_range_raw:
                                            y_range = y_range_raw.split('!')[1]
                                        else:
                                            y_range = y_range_raw
                                        y_range = y_range.replace('$', '')
                                
                                logger.info(f"Series X range: {x_range}, Y range: {y_range}")
                                
                                # Check if X and Y ranges match expected ranges
                                expected_x_clean = expected_series_x_range.replace('$', '').upper()
                                expected_y_clean = expected_series_y_range.replace('$', '').upper()
                                
                                # Normalize ranges for comparison (remove sheet names, $ signs, convert to uppercase)
                                x_range_normalized = x_range.replace('$', '').upper() if x_range else None
                                y_range_normalized = y_range.replace('$', '').upper() if y_range else None
                                
                                # Check if this series matches the expected ranges
                                this_series_x_ok = False
                                this_series_y_ok = False
                                
                                if x_range_normalized:
                                    # Try exact match first
                                    if x_range_normalized == expected_x_clean:
                                        this_series_x_ok = True
                                        series_x_range_ok = True
                                        logger.info(f"✓ Series X range matches: {x_range} (normalized: {x_range_normalized})")
                                    # Also check if the range contains the expected range (e.g., Sheet1!F3:F4 contains F3:F4)
                                    elif expected_x_clean in x_range_normalized:
                                        this_series_x_ok = True
                                        series_x_range_ok = True
                                        logger.info(f"✓ Series X range contains expected range: {x_range} (contains {expected_x_clean})")
                                    else:
                                        logger.debug(f"Series X range {x_range_normalized} does not match expected {expected_x_clean}")
                                
                                if y_range_normalized:
                                    # Try exact match first
                                    if y_range_normalized == expected_y_clean:
                                        this_series_y_ok = True
                                        series_y_range_ok = True
                                        logger.info(f"✓ Series Y range matches: {y_range} (normalized: {y_range_normalized})")
                                    # Also check if the range contains the expected range
                                    elif expected_y_clean in y_range_normalized:
                                        this_series_y_ok = True
                                        series_y_range_ok = True
                                        logger.info(f"✓ Series Y range contains expected range: {y_range} (contains {expected_y_clean})")
                                    else:
                                        logger.debug(f"Series Y range {y_range_normalized} does not match expected {expected_y_clean}")
                                
                                # If this series matches both X and Y ranges, check secondary axis
                                if this_series_x_ok and this_series_y_ok:
                                    series_found = True
                                    logger.info(f"✓ Series with matching data ranges found: X={x_range}, Y={y_range}")
                                    
                                    # Check if series uses secondary axis
                                    # Method 1: Look for c:axId elements in the series
                                    ax_id_elems = ser_elem.xpath('.//c:axId', namespaces=chart_ns)
                                    ax_ids = []
                                    if ax_id_elems:
                                        ax_ids = [ax.get('val') for ax in ax_id_elems if ax.get('val')]
                                        logger.info(f"Series axis IDs from axId elements: {ax_ids}")
                                    
                                    # Method 2: If no axId elements, check if there are multiple axes
                                    # In some cases, the series might not have explicit axId, but if there are
                                    # multiple axes in the chart and this is the auxiliary series, it likely uses secondary axes
                                    if not ax_ids:
                                        logger.info("Series has no explicit axis ID elements, checking chart structure...")
                                        # If chart has 4 axes (typical for secondary axis setup), and this is the auxiliary series
                                        # it likely uses the secondary axes (IDs 3 and 4)
                                        if len(all_axes) == 4:
                                            logger.info("Chart has 4 axes - auxiliary series likely uses secondary axes")
                                            # Assume this series uses secondary axes (all axes with ID >= 3)
                                            secondary_axis_found = True
                                            ax_ids = []
                                            for ax in axis_info:
                                                try:
                                                    if int(ax['id']) >= 3:
                                                        ax_ids.append(ax['id'])
                                                except ValueError:
                                                    pass
                                            logger.info(f"Assuming series uses secondary axis IDs: {ax_ids}")
                                            # Also check tick marks for all secondary axes
                                            for ax in axis_info:
                                                if ax['id'] in ax_ids:
                                                    if ax['type'] == 'valAx':
                                                        secondary_y_axis_found = True
                                                        logger.info(f"✓ Secondary Y axis found (ID: {ax['id']})")
                                                        
                                                        # Check tick mark type
                                                        major_tick = ax['element'].xpath('.//c:majorTickMark', namespaces=chart_ns)
                                                        if major_tick:
                                                            tick_val = major_tick[0].get('val', '')
                                                            if tick_val == tick_mark_type:
                                                                tick_mark_y_ok = True
                                                                logger.info(f"✓ Secondary Y axis tick mark type is {tick_val} (expected {tick_mark_type})")
                                                            else:
                                                                logger.warning(f"Secondary Y axis tick mark type is {tick_val}, expected {tick_mark_type}")
                                                        else:
                                                            logger.warning("Secondary Y axis major tick mark element not found")
                                                    elif ax['type'] in ['catAx', 'dateAx']:
                                                        secondary_x_axis_found = True
                                                        logger.info(f"✓ Secondary X axis found (ID: {ax['id']})")
                                                        
                                                        # Check tick mark type
                                                        major_tick = ax['element'].xpath('.//c:majorTickMark', namespaces=chart_ns)
                                                        if major_tick:
                                                            tick_val = major_tick[0].get('val', '')
                                                            if tick_val == tick_mark_type:
                                                                tick_mark_x_ok = True
                                                                logger.info(f"✓ Secondary X axis tick mark type is {tick_val} (expected {tick_mark_type})")
                                                            else:
                                                                logger.warning(f"Secondary X axis tick mark type is {tick_val}, expected {tick_mark_type}")
                                                        else:
                                                            logger.warning("Secondary X axis major tick mark element not found")
                                                        
                                            series_uses_secondary = True
                                    
                                    # Check if series uses secondary axes
                                    series_uses_secondary = False
                                    if ax_ids:
                                        for ax_id in ax_ids:
                                            if ax_id in secondary_axis_ids:
                                                series_uses_secondary = True
                                                secondary_axis_found = True
                                                logger.info(f"✓ Series uses secondary axis ID {ax_id}")
                                                
                                                # Determine if it's X or Y axis by checking axis type
                                                for axis in axis_info:
                                                    if axis['id'] == ax_id:
                                                        if axis['type'] == 'valAx':
                                                            secondary_y_axis_found = True
                                                            logger.info(f"✓ Secondary Y axis found (ID: {ax_id})")
                                                            
                                                            # Check tick mark type
                                                            major_tick = axis['element'].xpath('.//c:majorTickMark', namespaces=chart_ns)
                                                            if major_tick:
                                                                tick_val = major_tick[0].get('val', '')
                                                                if tick_val == tick_mark_type:
                                                                    tick_mark_y_ok = True
                                                                    logger.info(f"✓ Secondary Y axis tick mark type is {tick_val} (expected {tick_mark_type})")
                                                                else:
                                                                    logger.warning(f"Secondary Y axis tick mark type is {tick_val}, expected {tick_mark_type}")
                                                            else:
                                                                logger.warning("Secondary Y axis major tick mark element not found")
                                                        elif axis['type'] in ['catAx', 'dateAx']:
                                                            secondary_x_axis_found = True
                                                            logger.info(f"✓ Secondary X axis found (ID: {ax_id})")
                                                            
                                                            # Check tick mark type
                                                            major_tick = axis['element'].xpath('.//c:majorTickMark', namespaces=chart_ns)
                                                            if major_tick:
                                                                tick_val = major_tick[0].get('val', '')
                                                                if tick_val == tick_mark_type:
                                                                    tick_mark_x_ok = True
                                                                    logger.info(f"✓ Secondary X axis tick mark type is {tick_val} (expected {tick_mark_type})")
                                                                else:
                                                                    logger.warning(f"Secondary X axis tick mark type is {tick_val}, expected {tick_mark_type}")
                                                            else:
                                                                logger.warning("Secondary X axis major tick mark element not found")
                                                            
                                        
                                        if not series_uses_secondary:
                                            # If there are multiple axes in the chart, check if series uses different axes than primary
                                            if len(val_axes) > 1 or len(cat_axes) > 1:
                                                # Check if series uses any axis that's not in primary_axis_ids
                                                for ax_id in ax_ids:
                                                    if ax_id not in primary_axis_ids:
                                                        secondary_axis_found = True
                                                        series_uses_secondary = True
                                                        logger.info(f"✓ Series uses axis ID {ax_id} which is not a primary axis (multiple axes detected)")
                                                        
                                                        # Determine axis type and check tick marks
                                                        for axis in axis_info:
                                                            if axis['id'] == ax_id:
                                                                if axis['type'] == 'valAx':
                                                                    secondary_y_axis_found = True
                                                                    logger.info(f"✓ Secondary Y axis found (ID: {ax_id})")
                                                                    
                                                                    # Check tick mark type
                                                                    major_tick = axis['element'].xpath('.//c:majorTickMark', namespaces=chart_ns)
                                                                    if major_tick:
                                                                        tick_val = major_tick[0].get('val', '')
                                                                        if tick_val == tick_mark_type:
                                                                            tick_mark_y_ok = True
                                                                            logger.info(f"✓ Secondary Y axis tick mark type is {tick_val} (expected {tick_mark_type})")
                                                                        else:
                                                                            logger.warning(f"Secondary Y axis tick mark type is {tick_val}, expected {tick_mark_type}")
                                                                    else:
                                                                        logger.warning("Secondary Y axis major tick mark element not found")
                                                                elif axis['type'] in ['catAx', 'dateAx']:
                                                                    secondary_x_axis_found = True
                                                                    logger.info(f"✓ Secondary X axis found (ID: {ax_id})")
                                                                    
                                                                    # Check tick mark type
                                                                    major_tick = axis['element'].xpath('.//c:majorTickMark', namespaces=chart_ns)
                                                                    if major_tick:
                                                                        tick_val = major_tick[0].get('val', '')
                                                                        if tick_val == tick_mark_type:
                                                                            tick_mark_x_ok = True
                                                                            logger.info(f"✓ Secondary X axis tick mark type is {tick_val} (expected {tick_mark_type})")
                                                                        else:
                                                                            logger.warning(f"Secondary X axis tick mark type is {tick_val}, expected {tick_mark_type}")
                                                                    else:
                                                                        logger.warning("Secondary X axis major tick mark element not found")
                                                                    
                                                        break
                                            else:
                                                logger.warning(f"Series axis IDs {ax_ids} do not match secondary axis IDs {secondary_axis_ids}")
                                    elif len(all_axes) == 4:
                                        # If chart has 4 axes and this is the auxiliary series, it uses secondary axes
                                        logger.info("Chart has 4 axes and series has no explicit axis IDs - checking all secondary axes")
                                        # Check all secondary axes for tick marks
                                        for axis in axis_info:
                                            if axis['id'] in secondary_axis_ids:
                                                if axis['type'] == 'valAx':
                                                    secondary_y_axis_found = True
                                                    logger.info(f"✓ Secondary Y axis found (ID: {axis['id']})")
                                                    
                                                    # Check tick mark type
                                                    major_tick = axis['element'].xpath('.//c:majorTickMark', namespaces=chart_ns)
                                                    if major_tick:
                                                        tick_val = major_tick[0].get('val', '')
                                                        if tick_val == tick_mark_type:
                                                            tick_mark_y_ok = True
                                                            logger.info(f"✓ Secondary Y axis tick mark type is {tick_val} (expected {tick_mark_type})")
                                                        else:
                                                            logger.warning(f"Secondary Y axis tick mark type is {tick_val}, expected {tick_mark_type}")
                                                    else:
                                                        logger.warning("Secondary Y axis major tick mark element not found")
                                                elif axis['type'] in ['catAx', 'dateAx']:
                                                    secondary_x_axis_found = True
                                                    logger.info(f"✓ Secondary X axis found (ID: {axis['id']})")
                                                    
                                                    # Check tick mark type
                                                    major_tick = axis['element'].xpath('.//c:majorTickMark', namespaces=chart_ns)
                                                    if major_tick:
                                                        tick_val = major_tick[0].get('val', '')
                                                        if tick_val == tick_mark_type:
                                                            tick_mark_x_ok = True
                                                            logger.info(f"✓ Secondary X axis tick mark type is {tick_val} (expected {tick_mark_type})")
                                                        else:
                                                            logger.warning(f"Secondary X axis tick mark type is {tick_val}, expected {tick_mark_type}")
                                                    else:
                                                        logger.warning("Secondary X axis major tick mark element not found")
                                                    
                            
                            if scatter_chart_found:
                                chart_found = True
                                break
                                
                    except Exception as e:
                        logger.debug(f"Error reading chart file {chart_file}: {e}")
                        import traceback
                        logger.debug(traceback.format_exc())
                        continue
                
                # Final verification
                if not chart_found:
                    logger.error("✗ No chart found")
                    return 0.0
                
                if not scatter_chart_found:
                    logger.error("✗ Chart is not a scatter chart")
                    return 0.0
                
                if smooth_line and not smooth_line_found:
                    logger.warning("⚠ Smooth line not found (may be represented differently)")
                    # Don't fail on this alone as LibreOffice may represent it differently
                
                if not series_found:
                    logger.error("✗ Series with matching data ranges not found")
                    return 0.0
                
                if not series_x_range_ok:
                    logger.error("✗ Series X range does not match expected range")
                    return 0.0
                
                if not series_y_range_ok:
                    logger.error("✗ Series Y range does not match expected range")
                    return 0.0
                
                if secondary_axis and not secondary_axis_found:
                    logger.error("✗ Series does not use secondary axis")
                    return 0.0
                
                if secondary_axis and not secondary_x_axis_found:
                    logger.warning("⚠ Secondary X axis not found (may be represented differently)")
                    # Don't fail on this alone as LibreOffice may represent it differently
                
                if secondary_axis and not secondary_y_axis_found:
                    logger.warning("⚠ Secondary Y axis not found (may be represented differently)")
                    # Don't fail on this alone as LibreOffice may represent it differently
                
                if secondary_axis and not tick_mark_x_ok:
                    logger.warning("⚠ Secondary X axis tick mark type not verified (may be represented differently)")
                    # Don't fail on this alone as LibreOffice may represent it differently
                
                if secondary_axis and not tick_mark_y_ok:
                    logger.warning("⚠ Secondary Y axis tick mark type not verified (may be represented differently)")
                    # Don't fail on this alone as LibreOffice may represent it differently
                
                if primary_x_axis_min is not None and not primary_x_axis_min_ok:
                    logger.error(f"✗ Primary X axis minimum value is not {primary_x_axis_min}")
                    return 0.0
                
                # If core requirements are met, consider it a pass
                # (tick mark checks are lenient due to LibreOffice representation differences)
                if chart_found and scatter_chart_found and series_found and series_x_range_ok and series_y_range_ok:
                    if secondary_axis:
                        if secondary_axis_found:
                            logger.info("=" * 60)
                            logger.info(f"✓ Scatter chart with secondary axis verification passed!")
                            logger.info(f"  - Chart type: Scatter chart")
                            logger.info(f"  - Smooth line: {'Found' if smooth_line_found else 'Warning (may be represented differently)'}")
                            logger.info(f"  - Series data ranges: X={expected_series_x_range}, Y={expected_series_y_range}")
                            logger.info(f"  - Secondary axis: Found")
                            logger.info(f"  - Secondary X axis: {'Found' if secondary_x_axis_found else 'Warning (may be represented differently)'}")
                            logger.info(f"  - Secondary Y axis: {'Found' if secondary_y_axis_found else 'Warning (may be represented differently)'}")
                            logger.info(f"  - Tick mark X: {'Verified' if tick_mark_x_ok else 'Warning (may be represented differently)'}")
                            logger.info(f"  - Tick mark Y: {'Verified' if tick_mark_y_ok else 'Warning (may be represented differently)'}")
                            if primary_x_axis_min is not None:
                                logger.info(f"  - Primary X axis minimum: {'Verified' if primary_x_axis_min_ok else 'Not verified'}")
                            logger.info("=" * 60)
                            return 1.0
                        else:
                            logger.error("✗ Secondary axis verification failed")
                            return 0.0
                    else:
                        logger.info("=" * 60)
                        logger.info(f"✓ Scatter chart verification passed!")
                        logger.info("=" * 60)
                        return 1.0
                else:
                    logger.error("=" * 60)
                    logger.error("✗ Verification failed")
                    logger.error("=" * 60)
                    return 0.0
                    
        except Exception as e:
            logger.error(f"Error accessing chart XML files: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0

def verify_bar_chart_axis_cross_value(result: str, expected: str = None, **options) -> float:
    """
    Verify if a bar chart has the correct axis settings including Y-axis min/max, X-axis cross value, and label position.
    
    This function checks:
    1. Whether at least one chart exists in the worksheet
    2. Whether the chart is a bar chart
    3. Whether the chart uses data from the specified range (A1:B13)
    4. Whether the Y-axis maximum value is set to the expected value (1.5)
    5. Whether the Y-axis minimum value is set to the expected value (0.5)
    6. Whether the X-axis cross value is set to the expected value (1)
    7. Whether the X-axis label position is set to low
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - sheet_idx: Sheet index to check (default: 0)
            - expected_data_range: Expected data range for the chart (default: "A1:B13")
            - chart_type: Expected chart type (default: "barChart")
            - y_axis_max: Expected Y-axis maximum value (default: 1.5)
            - y_axis_min: Expected Y-axis minimum value (default: 0.5)
            - x_axis_cross_value: Expected X-axis cross value (default: 1)
            - x_axis_label_position: Expected X-axis label position (default: "low")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import zipfile
        import lxml.etree
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        sheet_idx = options.get('sheet_idx', 0)
        expected_data_range = options.get('expected_data_range', 'A1:B13')
        expected_chart_type = options.get('chart_type', 'barChart')
        y_axis_max = options.get('y_axis_max', 1.5)
        y_axis_min = options.get('y_axis_min', 0.5)
        x_axis_cross_value = options.get('x_axis_cross_value', 1)
        x_axis_label_position = options.get('x_axis_label_position', 'low')
        
        logger.info(f"Verifying bar chart axis cross value in file: {result}")
        logger.info(f"Sheet index: {sheet_idx}")
        logger.info(f"Expected data range: {expected_data_range}")
        logger.info(f"Expected chart type: {expected_chart_type}")
        logger.info(f"Y-axis max: {y_axis_max}, min: {y_axis_min}")
        logger.info(f"X-axis cross value: {x_axis_cross_value}")
        logger.info(f"X-axis label position: {x_axis_label_position}")
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=False)
            sheet_names = wb.sheetnames
            if sheet_idx >= len(sheet_names):
                logger.error(f"Sheet index {sheet_idx} out of range. Available sheets: {sheet_names}")
                return 0.0
            sheet_name = sheet_names[sheet_idx]
            ws = wb[sheet_name]
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return 0.0
        
        # Use XML parsing to find the chart and verify properties
        try:
            with zipfile.ZipFile(result, 'r') as z_f:
                # Find chart files
                chart_files = [f for f in z_f.namelist() if f.startswith('xl/charts/chart') and f.endswith('.xml')]
                
                # Also check relationships to find chart files
                rel_files = [f for f in z_f.namelist() if 'xl/worksheets/_rels' in f and f.endswith('.rels')]
                for rel_file in rel_files:
                    try:
                        with z_f.open(rel_file) as f:
                            rel_xml = lxml.etree.parse(f)
                            rel_root = rel_xml.getroot()
                            # Find chart relationships
                            for rel in rel_root.xpath('.//Relationship[@Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart"]'):
                                chart_path = rel.get('Target')
                                if chart_path:
                                    # Convert relative path to absolute
                                    if not chart_path.startswith('xl/'):
                                        chart_path = 'xl/' + chart_path.lstrip('/')
                                    if chart_path not in chart_files and chart_path in z_f.namelist():
                                        chart_files.append(chart_path)
                                        logger.info(f"Found chart via relationship: {chart_path}")
                    except Exception as e:
                        logger.debug(f"Error reading relationship file {rel_file}: {e}")
                
                if not chart_files:
                    logger.error("✗ No chart XML files found")
                    return 0.0
                
                logger.info(f"Found {len(chart_files)} chart XML file(s)")
                
                # Namespaces for chart XML
                chart_ns = {
                    'c': 'http://schemas.openxmlformats.org/drawingml/2006/chart',
                    'a': 'http://schemas.openxmlformats.org/drawingml/2006/main',
                    'r': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
                }
                
                chart_found = False
                bar_chart_found = False
                data_range_ok = False
                y_axis_max_ok = False
                y_axis_min_ok = False
                x_axis_cross_value_ok = False
                x_axis_label_position_ok = False
                
                # Check each chart XML file
                for chart_file in chart_files:
                    try:
                        with z_f.open(chart_file) as f:
                            chart_xml = lxml.etree.parse(f)
                            root = chart_xml.getroot()
                            
                            # Find bar chart
                            bar_chart_elem = root.xpath('.//c:barChart', namespaces=chart_ns)
                            if not bar_chart_elem:
                                logger.debug("Chart is not a bar chart, skipping")
                                continue
                            
                            bar_chart_found = True
                            logger.info("✓ Chart contains bar chart type")
                            
                            # Check data range by examining series
                            series_elements = root.xpath('.//c:ser', namespaces=chart_ns)
                            logger.info(f"Found {len(series_elements)} series in chart XML")
                            
                            if not series_elements:
                                logger.error("✗ No series found in chart")
                                continue
                            
                            # Check if any series uses the expected data range
                            expected_range_clean = expected_data_range.replace('$', '').upper()
                            # Parse expected range: A1:B13
                            range_parts = expected_range_clean.split(':')
                            if len(range_parts) == 2:
                                start_cell = range_parts[0]
                                end_cell = range_parts[1]
                                start_col = ''.join(filter(str.isalpha, start_cell))
                                start_row = int(''.join(filter(str.isdigit, start_cell)))
                                end_col = ''.join(filter(str.isalpha, end_cell))
                                end_row = int(''.join(filter(str.isdigit, end_cell)))
                                
                                # Expected category range: A1:A13 (or A2:A13 if header)
                                # Expected value range: B1:B13 (or B2:B13 if header)
                                # We'll check both with and without header
                                expected_cat_ranges = [
                                    f"{start_col}{start_row}:{start_col}{end_row}".upper(),
                                    f"{start_col}{start_row+1}:{start_col}{end_row}".upper() if start_row == 1 else None
                                ]
                                expected_val_ranges = [
                                    f"{end_col}{start_row}:{end_col}{end_row}".upper(),
                                    f"{end_col}{start_row+1}:{end_col}{end_row}".upper() if start_row == 1 else None
                                ]
                                expected_cat_ranges = [r for r in expected_cat_ranges if r]
                                expected_val_ranges = [r for r in expected_val_ranges if r]
                            
                            for ser_elem in series_elements:
                                # Get category range (X-axis)
                                cat_range = None
                                # Try numRef first (for numeric categories)
                                cat_num_ref = ser_elem.xpath('.//c:cat//c:numRef', namespaces=chart_ns)
                                if cat_num_ref:
                                    f_elem = cat_num_ref[0].xpath('.//c:f', namespaces=chart_ns)
                                    if f_elem and f_elem[0].text:
                                        cat_range_raw = f_elem[0].text
                                        if '!' in cat_range_raw:
                                            cat_range = cat_range_raw.split('!')[1]
                                        else:
                                            cat_range = cat_range_raw
                                        cat_range = cat_range.replace('$', '').upper()
                                else:
                                    # Try strRef (for text categories)
                                    cat_str_ref = ser_elem.xpath('.//c:cat//c:strRef', namespaces=chart_ns)
                                    if cat_str_ref:
                                        f_elem = cat_str_ref[0].xpath('.//c:f', namespaces=chart_ns)
                                        if f_elem and f_elem[0].text:
                                            cat_range_raw = f_elem[0].text
                                            if '!' in cat_range_raw:
                                                cat_range = cat_range_raw.split('!')[1]
                                            else:
                                                cat_range = cat_range_raw
                                            cat_range = cat_range.replace('$', '').upper()
                                
                                # Get value range (Y-axis)
                                val_range = None
                                val_num_ref = ser_elem.xpath('.//c:val//c:numRef', namespaces=chart_ns)
                                if val_num_ref:
                                    f_elem = val_num_ref[0].xpath('.//c:f', namespaces=chart_ns)
                                    if f_elem and f_elem[0].text:
                                        val_range_raw = f_elem[0].text
                                        if '!' in val_range_raw:
                                            val_range = val_range_raw.split('!')[1]
                                        else:
                                            val_range = val_range_raw
                                        val_range = val_range.replace('$', '').upper()
                                
                                logger.info(f"Series category range: {cat_range}, value range: {val_range}")
                                
                                # Check if ranges match expected ranges
                                if cat_range and val_range:
                                    cat_match = any(cat_range == exp_cat or exp_cat in cat_range for exp_cat in expected_cat_ranges)
                                    val_match = any(val_range == exp_val or exp_val in val_range for exp_val in expected_val_ranges)
                                    
                                    if cat_match and val_match:
                                        data_range_ok = True
                                        logger.info(f"✓ Chart data range matches: category={cat_range}, value={val_range}")
                                        break
                            
                            if not data_range_ok:
                                logger.error(f"✗ Chart data range does not match expected range {expected_data_range}")
                                continue
                            
                            # Get all axes
                            all_axes = root.xpath('.//c:valAx | .//c:catAx | .//c:dateAx', namespaces=chart_ns)
                            logger.info(f"Found {len(all_axes)} axis elements in chart XML")
                            
                            if not all_axes:
                                logger.error("✗ No axes found in chart")
                                continue
                            
                            # Find Y-axis (value axis) and X-axis (category axis)
                            y_axis = None
                            x_axis = None
                            
                            for axis_elem in all_axes:
                                # Get axis position
                                ax_pos_elem = axis_elem.xpath('.//c:axPos', namespaces=chart_ns)
                                ax_pos = ax_pos_elem[0].get('val', '') if ax_pos_elem else ''
                                
                                # In bar charts:
                                # - valAx (Y-axis) is typically at left (l) or right (r)
                                # - catAx (X-axis) is typically at bottom (b) or top (t)
                                if axis_elem.tag.endswith('valAx'):
                                    # This is a value axis (Y-axis)
                                    if not y_axis or ax_pos == 'l':  # Prefer left position
                                        y_axis = axis_elem
                                        logger.info(f"Found Y-axis (valAx) at position: {ax_pos}")
                                elif axis_elem.tag.endswith('catAx') or axis_elem.tag.endswith('dateAx'):
                                    # This is a category axis (X-axis)
                                    if not x_axis or ax_pos == 'b':  # Prefer bottom position
                                        x_axis = axis_elem
                                        logger.info(f"Found X-axis (catAx/dateAx) at position: {ax_pos}")
                            
                            # If not found by tag, use position-based logic
                            if not y_axis:
                                for axis_elem in all_axes:
                                    ax_pos_elem = axis_elem.xpath('.//c:axPos', namespaces=chart_ns)
                                    ax_pos = ax_pos_elem[0].get('val', '') if ax_pos_elem else ''
                                    if ax_pos in ['l', 'r']:  # Left or right = Y-axis
                                        y_axis = axis_elem
                                        logger.info(f"Found Y-axis by position '{ax_pos}'")
                                        break
                            
                            if not x_axis:
                                for axis_elem in all_axes:
                                    ax_pos_elem = axis_elem.xpath('.//c:axPos', namespaces=chart_ns)
                                    ax_pos = ax_pos_elem[0].get('val', '') if ax_pos_elem else ''
                                    if ax_pos in ['b', 't']:  # Bottom or top = X-axis
                                        x_axis = axis_elem
                                        logger.info(f"Found X-axis by position '{ax_pos}'")
                                        break
                            
                            if y_axis is None:
                                logger.error("✗ Y-axis not found")
                                continue
                            
                            if x_axis is None:
                                logger.error("✗ X-axis not found")
                                continue
                            
                            # Check Y-axis min/max values
                            logger.info("Checking Y-axis scaling...")
                            scaling_elem = y_axis.xpath('.//c:scaling', namespaces=chart_ns)
                            if not scaling_elem:
                                logger.error("✗ Y-axis scaling element not found")
                                continue
                            
                            # Check maximum value
                            max_elem = scaling_elem[0].xpath('.//c:max', namespaces=chart_ns)
                            if not max_elem:
                                logger.error("✗ Y-axis maximum element not found")
                                continue
                            
                            max_val = None
                            max_val_elem = max_elem[0].xpath('.//c:val', namespaces=chart_ns)
                            if max_val_elem and max_val_elem[0].text:
                                try:
                                    max_val = float(max_val_elem[0].text)
                                except (ValueError, TypeError):
                                    pass
                            
                            if max_val is None:
                                # Try to get from attribute
                                max_val_attr = max_elem[0].get('val')
                                if max_val_attr:
                                    try:
                                        max_val = float(max_val_attr)
                                    except (ValueError, TypeError):
                                        pass
                            
                            if max_val is None:
                                logger.error("✗ Could not extract Y-axis maximum value")
                                continue
                            
                            if abs(max_val - y_axis_max) > 0.01:
                                logger.error(f"✗ Y-axis maximum value is {max_val}, expected {y_axis_max}")
                                continue
                            
                            y_axis_max_ok = True
                            logger.info(f"✓ Y-axis maximum value is {max_val} (expected {y_axis_max})")
                            
                            # Check minimum value
                            min_elem = scaling_elem[0].xpath('.//c:min', namespaces=chart_ns)
                            if not min_elem:
                                logger.error("✗ Y-axis minimum element not found")
                                continue
                            
                            min_val = None
                            min_val_elem = min_elem[0].xpath('.//c:val', namespaces=chart_ns)
                            if min_val_elem and min_val_elem[0].text:
                                try:
                                    min_val = float(min_val_elem[0].text)
                                except (ValueError, TypeError):
                                    pass
                            
                            if min_val is None:
                                # Try to get from attribute
                                min_val_attr = min_elem[0].get('val')
                                if min_val_attr:
                                    try:
                                        min_val = float(min_val_attr)
                                    except (ValueError, TypeError):
                                        pass
                            
                            if min_val is None:
                                logger.error("✗ Could not extract Y-axis minimum value")
                                continue
                            
                            if abs(min_val - y_axis_min) > 0.01:
                                logger.error(f"✗ Y-axis minimum value is {min_val}, expected {y_axis_min}")
                                continue
                            
                            y_axis_min_ok = True
                            logger.info(f"✓ Y-axis minimum value is {min_val} (expected {y_axis_min})")
                            
                            # Check cross value - In WPS, it's stored in X-axis crossesAt element
                            # The crossesAt on X-axis means where X-axis crosses Y-axis (the value on Y-axis)
                            logger.info("Checking cross value (where axes cross)...")
                            
                            cross_val = None
                            
                            # Method 1: Check crossesAt on X-axis (WPS uses this)
                            crosses_at_elem = x_axis.xpath('.//c:crossesAt', namespaces=chart_ns)
                            if crosses_at_elem:
                                logger.info("Found crossesAt element on X-axis")
                                cross_val_elem = crosses_at_elem[0].xpath('.//c:val', namespaces=chart_ns)
                                if cross_val_elem and cross_val_elem[0].text:
                                    try:
                                        cross_val = float(cross_val_elem[0].text)
                                        logger.info(f"Extracted cross value from X-axis crossesAt: {cross_val}")
                                    except (ValueError, TypeError):
                                        pass
                                
                                if cross_val is None:
                                    # Try to get from attribute
                                    cross_val_attr = crosses_at_elem[0].get('val')
                                    if cross_val_attr:
                                        try:
                                            cross_val = float(cross_val_attr)
                                            logger.info(f"Extracted cross value from X-axis crossesAt attribute: {cross_val}")
                                        except (ValueError, TypeError):
                                            pass
                            
                            # Method 2: Check crossAt on Y-axis (standard Excel format)
                            if cross_val is None:
                                cross_at_elem = y_axis.xpath('.//c:crossAt', namespaces=chart_ns)
                                if cross_at_elem:
                                    logger.info("Found crossAt element on Y-axis")
                                    cross_val_elem = cross_at_elem[0].xpath('.//c:val', namespaces=chart_ns)
                                    if cross_val_elem and cross_val_elem[0].text:
                                        try:
                                            cross_val = float(cross_val_elem[0].text)
                                            logger.info(f"Extracted cross value from Y-axis crossAt: {cross_val}")
                                        except (ValueError, TypeError):
                                            pass
                                    
                                    if cross_val is None:
                                        # Try to get from attribute
                                        cross_val_attr = cross_at_elem[0].get('val')
                                        if cross_val_attr:
                                            try:
                                                cross_val = float(cross_val_attr)
                                                logger.info(f"Extracted cross value from Y-axis crossAt attribute: {cross_val}")
                                            except (ValueError, TypeError):
                                                pass
                            
                            # Method 3: Check crossAt on X-axis (alternative)
                            if cross_val is None:
                                cross_at_elem = x_axis.xpath('.//c:crossAt', namespaces=chart_ns)
                                if cross_at_elem:
                                    logger.info("Found crossAt element on X-axis")
                                    cross_val_elem = cross_at_elem[0].xpath('.//c:val', namespaces=chart_ns)
                                    if cross_val_elem and cross_val_elem[0].text:
                                        try:
                                            cross_val = float(cross_val_elem[0].text)
                                            logger.info(f"Extracted cross value from X-axis crossAt: {cross_val}")
                                        except (ValueError, TypeError):
                                            pass
                                    
                                    if cross_val is None:
                                        # Try to get from attribute
                                        cross_val_attr = cross_at_elem[0].get('val')
                                        if cross_val_attr:
                                            try:
                                                cross_val = float(cross_val_attr)
                                                logger.info(f"Extracted cross value from X-axis crossAt attribute: {cross_val}")
                                            except (ValueError, TypeError):
                                                pass
                            
                            if cross_val is None:
                                logger.error("✗ Could not find cross value in any expected location (checked crossesAt and crossAt)")
                                continue
                            
                            if abs(cross_val - x_axis_cross_value) > 0.01:
                                logger.error(f"✗ Cross value is {cross_val}, expected {x_axis_cross_value}")
                                continue
                            
                            x_axis_cross_value_ok = True
                            logger.info(f"✓ Cross value is {cross_val} (expected {x_axis_cross_value})")
                            
                            # Check X-axis label position - WPS uses tickLblPos, standard Excel uses lblPos
                            logger.info("Checking X-axis label position...")
                            
                            lbl_pos_val = None
                            
                            # Method 1: Check tickLblPos (WPS format)
                            tick_lbl_pos_elem = x_axis.xpath('.//c:tickLblPos', namespaces=chart_ns)
                            if tick_lbl_pos_elem:
                                lbl_pos_val = tick_lbl_pos_elem[0].get('val', '')
                                if lbl_pos_val:
                                    logger.info(f"Found tickLblPos on X-axis: {lbl_pos_val}")
                            
                            # Method 2: Check lblPos (standard Excel format)
                            if not lbl_pos_val:
                                lbl_pos_elem = x_axis.xpath('.//c:lblPos', namespaces=chart_ns)
                                if lbl_pos_elem:
                                    lbl_pos_val = lbl_pos_elem[0].get('val', '')
                                    if lbl_pos_val:
                                        logger.info(f"Found lblPos on X-axis: {lbl_pos_val}")
                            
                            if not lbl_pos_val:
                                logger.error("✗ X-axis label position element not found (checked tickLblPos and lblPos)")
                                continue
                            
                            # Normalize label position values
                            # "low" might be represented as "low", "l", "bottom", "b", etc.
                            lbl_pos_normalized = lbl_pos_val.lower()
                            expected_normalized = x_axis_label_position.lower()
                            
                            # Map common variations
                            position_map = {
                                'low': ['low', 'l', 'bottom', 'b', 'low'],
                                'high': ['high', 'h', 'top', 't'],
                                'nextTo': ['nextto', 'next', 'n'],
                                'none': ['none', 'n']
                            }
                            
                            # Check if the value matches
                            match = False
                            if lbl_pos_normalized == expected_normalized:
                                match = True
                            else:
                                # Check if both map to the same position
                                for pos_key, variations in position_map.items():
                                    if expected_normalized in variations and lbl_pos_normalized in variations:
                                        match = True
                                        break
                            
                            if not match:
                                logger.error(f"✗ X-axis label position is {lbl_pos_val}, expected {x_axis_label_position}")
                                continue
                            
                            x_axis_label_position_ok = True
                            logger.info(f"✓ X-axis label position is {lbl_pos_val} (expected {x_axis_label_position})")
                            
                            # All checks passed for this chart
                            chart_found = True
                            break
                                
                    except Exception as e:
                        logger.debug(f"Error reading chart file {chart_file}: {e}")
                        import traceback
                        logger.debug(traceback.format_exc())
                        continue
                
                # Final verification - ALL conditions must be met
                if not chart_found:
                    logger.error("✗ No chart found")
                    return 0.0
                
                if not bar_chart_found:
                    logger.error("✗ Chart is not a bar chart")
                    return 0.0
                
                if not data_range_ok:
                    logger.error("✗ Chart data range does not match expected range")
                    return 0.0
                
                if not y_axis_max_ok:
                    logger.error(f"✗ Y-axis maximum value is not {y_axis_max}")
                    return 0.0
                
                if not y_axis_min_ok:
                    logger.error(f"✗ Y-axis minimum value is not {y_axis_min}")
                    return 0.0
                
                if not x_axis_cross_value_ok:
                    logger.error(f"✗ X-axis cross value is not {x_axis_cross_value}")
                    return 0.0
                
                if not x_axis_label_position_ok:
                    logger.error(f"✗ X-axis label position is not {x_axis_label_position}")
                    return 0.0
                
                # All checks passed
                logger.info("=" * 60)
                logger.info(f"✓ Bar chart axis cross value verification passed!")
                logger.info(f"  - Chart type: Bar chart")
                logger.info(f"  - Data range: {expected_data_range}")
                logger.info(f"  - Y-axis max: {y_axis_max}, min: {y_axis_min}")
                logger.info(f"  - X-axis cross value: {x_axis_cross_value}")
                logger.info(f"  - X-axis label position: {x_axis_label_position}")
                logger.info("=" * 60)
                return 1.0
                    
        except Exception as e:
            logger.error(f"Error accessing chart XML files: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_bar_chart_year_over_year_analysis(result: str, expected: str = None, **options) -> float:
    """
    Verify if a bar chart has correct year-over-year analysis with auxiliary columns, secondary axis, and series formatting.
    
    This function checks:
    1. Whether auxiliary column headers (E1:H1) are correct
    2. Whether formulas in E2:H7 are correct
    3. Whether chart is a bar chart with correct data ranges
    4. Whether specified series use secondary axis
    5. Whether secondary axis maximum value is set correctly
    6. Whether series formatting (overlap, gap width, fill, line, data labels, error bars) is correct
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import zipfile
        import lxml.etree
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        sheet_idx = options.get('sheet_idx', 0)
        expected_headers = options.get('expected_headers', {})
        expected_formulas = options.get('expected_formulas', {})
        formula_range = options.get('formula_range', 'E2:H7')
        expected_data_ranges = options.get('expected_data_ranges', [])
        chart_type = options.get('chart_type', 'barChart')
        secondary_axis_series = options.get('secondary_axis_series', [])
        secondary_axis_max = options.get('secondary_axis_max', None)
        series_formatting = options.get('series_formatting', {})
        
        logger.info(f"Verifying bar chart year-over-year analysis in file: {result}")
        logger.info(f"Sheet index: {sheet_idx}")
        logger.info(f"Expected headers: {expected_headers}")
        logger.info(f"Expected formulas: {expected_formulas}")
        logger.info(f"Formula range: {formula_range}")
        logger.info(f"Secondary axis series: {secondary_axis_series}")
        logger.info(f"Secondary axis max: {secondary_axis_max}")
        
        # Load workbook
        wb = openpyxl.load_workbook(result, data_only=False)
        ws = wb[wb.sheetnames[sheet_idx]]
        
        # Check headers
        logger.info("Checking auxiliary column headers...")
        for cell_ref, expected_value in expected_headers.items():
            cell = ws[cell_ref]
            actual_value = str(cell.value) if cell.value is not None else ""
            if actual_value != expected_value:
                logger.error(f"✗ Header {cell_ref} is '{actual_value}', expected '{expected_value}'")
                return 0.0
            logger.info(f"✓ Header {cell_ref}: {actual_value}")
        
        # Check formulas - verify all cells in the range have correct formulas
        logger.info("Checking formulas...")
        range_parts = formula_range.split(':')
        if len(range_parts) == 2:
            start_cell = range_parts[0]
            end_cell = range_parts[1]
            start_col = ''.join(filter(str.isalpha, start_cell))
            start_row = int(''.join(filter(str.isdigit, start_cell)))
            end_col = ''.join(filter(str.isalpha, end_cell))
            end_row = int(''.join(filter(str.isdigit, end_cell)))
            
            # Get column letters
            cols = []
            for c in range(ord(start_col), ord(end_col) + 1):
                cols.append(chr(c))
            
            # Get base formulas from E2:H2
            base_formulas = {}
            for col in cols:
                cell_ref = f"{col}{start_row}"
                if cell_ref in expected_formulas:
                    base_formulas[col] = expected_formulas[cell_ref]
            
            # Check all cells in the range
            for row in range(start_row, end_row + 1):
                for col in cols:
                    cell_ref = f"{col}{row}"
                    cell = ws[cell_ref]
                    
                    if cell.data_type != "f":
                        logger.error(f"✗ Cell {cell_ref} does not contain a formula")
                        return 0.0
                    
                    # Get formula
                    formula = None
                    if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                        formula = cell._value
                    elif hasattr(cell, "formula"):
                        formula = cell.formula
                    
                    if not formula:
                        logger.error(f"✗ Could not extract formula from {cell_ref}")
                        return 0.0
                    
                    # For E2:H2, check exact match
                    if cell_ref in expected_formulas:
                        expected_formula = expected_formulas[cell_ref].upper().replace(' ', '')
                        formula_clean = formula.upper().replace(' ', '')
                        if formula_clean != expected_formula:
                            logger.error(f"✗ Cell {cell_ref} formula is '{formula}', expected '{expected_formulas[cell_ref]}'")
                            return 0.0
                        logger.info(f"✓ Cell {cell_ref} formula: {formula}")
                    else:
                        # For other rows, check if formula is correctly adjusted (relative references)
                        # The formula should be the same structure but with adjusted row numbers
                        if col in base_formulas:
                            base_formula = base_formulas[col]
                            # Check if formula structure matches (functions and structure)
                            # Allow row numbers to be different (relative references)
                            base_funcs = re.findall(r'\\b[A-Z]+\\b', base_formula.upper())
                            formula_funcs = re.findall(r'\\b[A-Z]+\\b', formula.upper())
                            if set(base_funcs) == set(formula_funcs):
                                logger.info(f"✓ Cell {cell_ref} formula structure matches: {formula}")
                            else:
                                logger.error(f"✗ Cell {cell_ref} formula structure doesn't match base formula")
                                return 0.0
        
        # Check chart via XML
        logger.info("Checking chart properties via XML...")
        with zipfile.ZipFile(result, 'r') as z_f:
            chart_files = [f for f in z_f.namelist() if f.startswith('xl/charts/chart') and f.endswith('.xml')]
            if not chart_files:
                logger.error("✗ No chart XML files found")
                return 0.0
            
            chart_ns = {
                'c': 'http://schemas.openxmlformats.org/drawingml/2006/chart',
                'a': 'http://schemas.openxmlformats.org/drawingml/2006/main'
            }
            
            for chart_file in chart_files:
                with z_f.open(chart_file) as f:
                    root = lxml.etree.parse(f).getroot()
                    
                    # Check bar chart
                    if not root.xpath('.//c:barChart', namespaces=chart_ns):
                        continue
                    
                    logger.info("✓ Found bar chart")
                    
                    # Check series and secondary axis
                    series_elements = root.xpath('.//c:ser', namespaces=chart_ns)
                    logger.info(f"Found {len(series_elements)} series")
                    
                    # Get all axes
                    all_axes = root.xpath('.//c:valAx | .//c:catAx', namespaces=chart_ns)
                    logger.info(f"Found {len(all_axes)} axes")
                    
                    # Identify secondary Y axis (usually has higher ID or is the second valAx)
                    secondary_y_axis = None
                    val_axes = [ax for ax in all_axes if ax.tag.endswith('valAx')]
                    if len(val_axes) >= 2:
                        secondary_y_axis = val_axes[1]  # Second valAx is usually secondary
                        logger.info("Found secondary Y axis")
                    
                    # Check secondary axis max
                    if secondary_axis_max and secondary_y_axis:
                        scaling = secondary_y_axis.xpath('.//c:scaling', namespaces=chart_ns)
                        if scaling:
                            max_elem = scaling[0].xpath('.//c:max', namespaces=chart_ns)
                            if max_elem:
                                max_val = None
                                max_val_elem = max_elem[0].xpath('.//c:val', namespaces=chart_ns)
                                if max_val_elem and max_val_elem[0].text:
                                    max_val = float(max_val_elem[0].text)
                                elif max_elem[0].get('val'):
                                    max_val = float(max_elem[0].get('val'))
                                
                                if max_val and abs(max_val - secondary_axis_max) < 0.01:
                                    logger.info(f"✓ Secondary axis max: {max_val}")
                                else:
                                    logger.error(f"✗ Secondary axis max is {max_val}, expected {secondary_axis_max}")
                                    return 0.0
                    
                    # Check series formatting
                    for ser_elem in series_elements:
                        # Get series name
                        ser_name_elem = ser_elem.xpath('.//c:tx//c:v', namespaces=chart_ns)
                        if ser_name_elem and ser_name_elem[0].text:
                            ser_name = ser_name_elem[0].text
                            logger.info(f"Checking series: {ser_name}")
                            
                            if ser_name in series_formatting:
                                fmt = series_formatting[ser_name]
                                logger.info(f"Verifying formatting for series '{ser_name}'")
                                
                                # Check if series uses secondary axis
                                if ser_name in secondary_axis_series:
                                    ax_id_elem = ser_elem.xpath('.//c:axId', namespaces=chart_ns)
                                    if ax_id_elem:
                                        ax_id = ax_id_elem[0].get('val', '')
                                        # Check if this axis ID matches secondary Y axis
                                        if secondary_y_axis:
                                            sec_ax_id_elem = secondary_y_axis.xpath('.//c:axId', namespaces=chart_ns)
                                            if sec_ax_id_elem:
                                                sec_ax_id = sec_ax_id_elem[0].get('val', '')
                                                if ax_id == sec_ax_id:
                                                    logger.info(f"✓ Series '{ser_name}' uses secondary axis")
                                                else:
                                                    logger.error(f"✗ Series '{ser_name}' does not use secondary axis")
                                                    return 0.0
                                
                                # Check overlap and gap width - these are per-series in some formats
                                # First try to find in series-specific elements
                                if 'overlap' in fmt or 'gap_width' in fmt:
                                    # Check if there's a grouping element that applies to this series
                                    # In clustered bar charts, overlap and gapWidth are at chart level
                                    # But we need to check series-specific settings if they exist
                                    bar_chart_elem = root.xpath('.//c:barChart', namespaces=chart_ns)[0]
                                    overlap_elem = bar_chart_elem.xpath('.//c:overlap', namespaces=chart_ns)
                                    gap_width_elem = bar_chart_elem.xpath('.//c:gapWidth', namespaces=chart_ns)
                                    
                                    # For now, we'll check if the values exist (exact matching may need series-specific logic)
                                    if 'overlap' in fmt:
                                        if overlap_elem:
                                            overlap_val = int(overlap_elem[0].get('val', 0))
                                            # Note: In some cases, different series may have different overlaps
                                            # This is a simplified check
                                            logger.info(f"Chart overlap value: {overlap_val} (expected {fmt['overlap']} for series '{ser_name}')")
                                        else:
                                            logger.warning(f"Overlap element not found for series '{ser_name}'")
                                    
                                    if 'gap_width' in fmt:
                                        if gap_width_elem:
                                            gap_val = int(gap_width_elem[0].get('val', 0))
                                            logger.info(f"Chart gap width value: {gap_val} (expected {fmt['gap_width']} for series '{ser_name}')")
                                        else:
                                            logger.warning(f"Gap width element not found for series '{ser_name}'")
                                
                                # Check fill color and transparency
                                if 'fill_color' in fmt or 'transparency' in fmt:
                                    sp_pr = ser_elem.xpath('.//c:spPr', namespaces=chart_ns)
                                    if sp_pr:
                                        fill_elem = sp_pr[0].xpath('.//a:solidFill', namespaces=chart_ns)
                                        if fill_elem:
                                            # Check color
                                            if 'fill_color' in fmt:
                                                color_elem = fill_elem[0].xpath('.//a:srgbCl | .//a:schemeCl', namespaces=chart_ns)
                                                # Color verification would need color mapping
                                                logger.info(f"✓ Series '{ser_name}' has fill color")
                                            
                                            # Check transparency
                                            if 'transparency' in fmt:
                                                alpha_elem = fill_elem[0].xpath('.//a:alpha', namespaces=chart_ns)
                                                if alpha_elem:
                                                    alpha_val = int(alpha_elem[0].get('val', 0))
                                                    # Transparency is usually 0-100000, where 100000 = 100%
                                                    # 90% transparency = 90000
                                                    expected_alpha = (100 - fmt['transparency']) * 1000
                                                    if abs(alpha_val - expected_alpha) < 1000:
                                                        logger.info(f"✓ Series '{ser_name}' transparency: {alpha_val}")
                                                    else:
                                                        logger.warning(f"Series '{ser_name}' transparency is {alpha_val}, expected around {expected_alpha}")
                                
                                # Check line style and color
                                if 'line_style' in fmt or 'line_color' in fmt:
                                    sp_pr = ser_elem.xpath('.//c:spPr', namespaces=chart_ns)
                                    if sp_pr:
                                        ln_elem = sp_pr[0].xpath('.//a:ln', namespaces=chart_ns)
                                        if ln_elem:
                                            if 'line_style' in fmt:
                                                # Check if line is solid
                                                logger.info(f"✓ Series '{ser_name}' has line style")
                                            
                                            if 'line_color' in fmt:
                                                # Check line color
                                                logger.info(f"✓ Series '{ser_name}' has line color")
                                
                                # Check data labels
                                if 'data_labels' in fmt:
                                    dlbls_elem = ser_elem.xpath('.//c:dLbls', namespaces=chart_ns)
                                    if dlbls_elem:
                                        # Check if data labels reference the specified range
                                        logger.info(f"✓ Series '{ser_name}' has data labels")
                                    else:
                                        logger.error(f"✗ Series '{ser_name}' data labels not found")
                                        return 0.0
                                
                                # Check error bars
                                if 'error_bars' in fmt:
                                    err_bars = ser_elem.xpath('.//c:errBars', namespaces=chart_ns)
                                    if err_bars:
                                        logger.info(f"✓ Series '{ser_name}' has error bars")
                                    else:
                                        logger.error(f"✗ Series '{ser_name}' error bars not found")
                                        return 0.0
                    
                    logger.info("=" * 60)
                    logger.info("✓ Bar chart year-over-year analysis verification passed!")
                    logger.info("=" * 60)
                    return 1.0
            
            logger.error("✗ No matching bar chart found")
            return 0.0
                
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_combination_chart_auto_data_labels(result: str, expected: str = None, **options) -> float:
    """
    Verify if a combination chart has data labels that automatically update based on cell references.
    
    This function checks:
    1. Whether E2:F12 contains the formula =IF(B3<>""," ",B2) (with relative references)
    2. Whether a combination chart exists
    3. Whether "供应套数" series has data labels referencing E2:E12
    4. Whether "成交套数" series has data labels referencing F2:F12
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import zipfile
        import lxml.etree
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        sheet_idx = options.get('sheet_idx', 0)
        formula_range = options.get('formula_range', 'E2:F12')
        expected_formula = options.get('expected_formula', '=IF(B3<>""," ",B2)')
        chart_type = options.get('chart_type', 'comboChart')
        series_data_labels = options.get('series_data_labels', {})
        
        logger.info(f"Verifying combination chart auto data labels in file: {result}")
        logger.info(f"Sheet index: {sheet_idx}")
        logger.info(f"Formula range: {formula_range}")
        logger.info(f"Expected formula: {expected_formula}")
        logger.info(f"Series data labels: {series_data_labels}")
        
        # Load workbook
        wb = openpyxl.load_workbook(result, data_only=False)
        ws = wb[wb.sheetnames[sheet_idx]]
        
        # Check formulas in E2:F12
        logger.info(f"Checking formulas in {formula_range}...")
        range_parts = formula_range.split(':')
        if len(range_parts) == 2:
            start_cell = range_parts[0]
            end_cell = range_parts[1]
            start_col = ''.join(filter(str.isalpha, start_cell))
            start_row = int(''.join(filter(str.isdigit, start_cell)))
            end_col = ''.join(filter(str.isalpha, end_cell))
            end_row = int(''.join(filter(str.isdigit, end_cell)))
            
            # Get column letters
            cols = []
            for c in range(ord(start_col), ord(end_col) + 1):
                cols.append(chr(c))
            
            # Parse expected formula to get base pattern
            expected_formula_clean = expected_formula.upper().replace(' ', '')
            # Extract function and structure: IF(B3<>""," ",B2)
            base_funcs = re.findall(r'\b[A-Z]+\b', expected_formula_clean)
            
            for row in range(start_row, end_row + 1):
                for col in cols:
                    cell_ref = f"{col}{row}"
                    cell = ws[cell_ref]
                    
                    if cell.data_type != "f":
                        logger.error(f"✗ Cell {cell_ref} does not contain a formula")
                        return 0.0
                    
                    # Get formula
                    formula = None
                    if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                        formula = cell._value
                    elif hasattr(cell, "formula"):
                        formula = cell.formula
                    
                    if not formula:
                        logger.error(f"✗ Could not extract formula from {cell_ref}")
                        return 0.0
                    
                    # Check formula structure (functions should match)
                    formula_clean = formula.upper().replace(' ', '')
                    formula_funcs = re.findall(r'\b[A-Z]+\b', formula_clean)
                    
                    if set(base_funcs) != set(formula_funcs):
                        logger.error(f"✗ Cell {cell_ref} formula functions don't match: {formula}")
                        return 0.0
                    
                    # For E2, check exact match
                    if cell_ref == "E2":
                        if formula_clean != expected_formula_clean:
                            logger.error(f"✗ Cell E2 formula is '{formula}', expected '{expected_formula}'")
                            return 0.0
                        logger.info(f"✓ Cell E2 formula: {formula}")
                    else:
                        # For other cells, check structure (relative references should be adjusted)
                        logger.info(f"✓ Cell {cell_ref} formula structure matches: {formula}")
        
        # Check chart via XML
        logger.info("Checking chart properties via XML...")
        with zipfile.ZipFile(result, 'r') as z_f:
            chart_files = [f for f in z_f.namelist() if f.startswith('xl/charts/chart') and f.endswith('.xml')]
            if not chart_files:
                logger.error("✗ No chart XML files found")
                return 0.0
            
            chart_ns = {
                'c': 'http://schemas.openxmlformats.org/drawingml/2006/chart',
                'a': 'http://schemas.openxmlformats.org/drawingml/2006/main'
            }
            
            chart_found = False
            combo_chart_found = False
            all_series_labels_ok = True
            
            for chart_file in chart_files:
                with z_f.open(chart_file) as f:
                    root = lxml.etree.parse(f).getroot()
                    
                    # Check combination chart - can be comboChart or a chart with multiple chart types
                    combo_chart_elem = root.xpath('.//c:comboChart', namespaces=chart_ns)
                    if combo_chart_elem:
                        combo_chart_found = True
                        logger.info("✓ Found combination chart (comboChart)")
                    else:
                        # Check if chart has multiple series with different chart types (also a combination chart)
                        # Or check if it's a chart that can have multiple series (line, bar, etc.)
                        # In WPS, combination charts might be represented differently
                        # Check if there are multiple chart types or if it's a chart with multiple series
                        bar_chart_elem = root.xpath('.//c:barChart', namespaces=chart_ns)
                        line_chart_elem = root.xpath('.//c:lineChart', namespaces=chart_ns)
                        area_chart_elem = root.xpath('.//c:areaChart', namespaces=chart_ns)
                        
                        # If there are multiple chart types, it's a combination chart
                        chart_types_count = sum([
                            1 if bar_chart_elem else 0,
                            1 if line_chart_elem else 0,
                            1 if area_chart_elem else 0
                        ])
                        
                        if chart_types_count >= 2:
                            combo_chart_found = True
                            logger.info(f"✓ Found combination chart (multiple chart types: {chart_types_count})")
                        elif bar_chart_elem or line_chart_elem or area_chart_elem:
                            # If there's at least one chart type and multiple series, it might be a combination chart
                            # Or it could be a single chart type with multiple series
                            # For this task, we'll accept any chart with multiple series as it might be a combination
                            series_elements = root.xpath('.//c:ser', namespaces=chart_ns)
                            if len(series_elements) >= 2:
                                combo_chart_found = True
                                logger.info(f"✓ Found chart with multiple series (may be combination chart): {len(series_elements)} series")
                    
                    if not combo_chart_found:
                        logger.debug("Chart is not a combination chart, skipping")
                        continue
                    
                    # Check series and data labels
                    series_elements = root.xpath('.//c:ser', namespaces=chart_ns)
                    logger.info(f"Found {len(series_elements)} series")
                    
                    for ser_elem in series_elements:
                        # Get series name
                        ser_name_elem = ser_elem.xpath('.//c:tx//c:v', namespaces=chart_ns)
                        if not ser_name_elem or not ser_name_elem[0].text:
                            continue
                        
                        ser_name = ser_name_elem[0].text
                        logger.info(f"Checking series: {ser_name}")
                        
                        if ser_name in series_data_labels:
                            expected_range = series_data_labels[ser_name].get('source_range', '')
                            logger.info(f"Verifying data labels for series '{ser_name}', expected range: {expected_range}")
                            
                            # Check data labels
                            dlbls_elem = ser_elem.xpath('.//c:dLbls', namespaces=chart_ns)
                            if not dlbls_elem:
                                logger.error(f"✗ Series '{ser_name}' data labels not found")
                                all_series_labels_ok = False
                                continue
                            
                            # Method: Verify by comparing data label values with cell values
                            # This is more reliable than trying to find cell references in XML
                            # If data labels correctly reference the cell range, their values should match
                            
                            # Check if showDataLabelsRange is enabled (indicates cell range is used)
                            show_data_labels_range = False
                            ext_lst = dlbls_elem[0].xpath('.//c:extLst', namespaces=chart_ns)
                            if ext_lst:
                                ext_elems = ext_lst[0].xpath('.//c:ext', namespaces=chart_ns)
                                for ext_elem in ext_elems:
                                    # Check for showDataLabelsRange element (Microsoft Office 2012 extension)
                                    show_dlbl_range = ext_elem.xpath('.//*[local-name()="showDataLabelsRange"]')
                                    if show_dlbl_range:
                                        val_attr = show_dlbl_range[0].get('val', '0')
                                        if val_attr == '1' or val_attr == 'true':
                                            show_data_labels_range = True
                                            logger.info(f"✓ Series '{ser_name}' has showDataLabelsRange enabled")
                                            break
                            
                            if not show_data_labels_range:
                                logger.warning(f"Series '{ser_name}' showDataLabelsRange not found or not enabled")
                            
                            # Parse expected range to get cell values
                            expected_range_clean = expected_range.replace('$', '').upper()
                            range_parts = expected_range_clean.split(':')
                            if len(range_parts) != 2:
                                logger.error(f"✗ Invalid expected range format: {expected_range}")
                                all_series_labels_ok = False
                                continue
                            
                            start_cell = range_parts[0]
                            end_cell = range_parts[1]
                            start_col = ''.join(filter(str.isalpha, start_cell))
                            start_row = int(''.join(filter(str.isdigit, start_cell)))
                            end_col = ''.join(filter(str.isalpha, end_cell))
                            end_row = int(''.join(filter(str.isdigit, end_cell)))
                            
                            # Read cell values from Excel
                            expected_values = []
                            for row in range(start_row, end_row + 1):
                                cell_ref = f"{start_col}{row}"
                                cell = ws[cell_ref]
                                # Get cell value (formula result)
                                cell_value = cell.value
                                if cell_value is None:
                                    cell_value = ""
                                elif isinstance(cell_value, (int, float)):
                                    cell_value = str(cell_value)
                                else:
                                    cell_value = str(cell_value).strip()
                                expected_values.append(cell_value)
                            
                            logger.debug(f"Expected values from {expected_range}: {expected_values}")
                            
                            # Extract data label values from XML
                            # Data label values might be in dLbl/tx/v (value) or dLbl/tx/strRef/strCache/pt/v
                            dbl_elements = dlbls_elem[0].xpath('.//c:dLbl', namespaces=chart_ns)
                            actual_values = []
                            
                            for dbl_elem in dbl_elements:
                                # Try to get value from tx/v (direct value)
                                tx_v = dbl_elem.xpath('.//c:tx//c:v', namespaces=chart_ns)
                                if tx_v and tx_v[0].text is not None:
                                    actual_values.append(str(tx_v[0].text).strip())
                                    continue
                                
                                # Try to get value from strRef/strCache/pt/v (cached value)
                                str_cache_pt_v = dbl_elem.xpath('.//c:strRef//c:strCache//c:pt//c:v', namespaces=chart_ns)
                                if str_cache_pt_v:
                                    # Get the idx attribute to match with data point
                                    idx_elem = dbl_elem.xpath('.//c:idx', namespaces=chart_ns)
                                    if idx_elem:
                                        idx = int(idx_elem[0].get('val', '0'))
                                        if idx < len(str_cache_pt_v):
                                            actual_values.append(str(str_cache_pt_v[idx].text).strip() if str_cache_pt_v[idx].text else "")
                                            continue
                                
                                # If no value found, try to get from numRef/numCache/pt/v
                                num_cache_pt_v = dbl_elem.xpath('.//c:numRef//c:numCache//c:pt//c:v', namespaces=chart_ns)
                                if num_cache_pt_v:
                                    idx_elem = dbl_elem.xpath('.//c:idx', namespaces=chart_ns)
                                    if idx_elem:
                                        idx = int(idx_elem[0].get('val', '0'))
                                        if idx < len(num_cache_pt_v):
                                            actual_values.append(str(num_cache_pt_v[idx].text).strip() if num_cache_pt_v[idx].text else "")
                                            continue
                            
                            logger.debug(f"Actual data label values: {actual_values}")
                            
                            # Compare values (allow some flexibility for formatting differences)
                            if len(actual_values) == 0:
                                logger.warning(f"Could not extract data label values for series '{ser_name}'")
                                # If showDataLabelsRange is enabled, we'll accept it as valid
                                if show_data_labels_range:
                                    logger.info(f"✓ Series '{ser_name}' data labels configured (showDataLabelsRange enabled)")
                                    continue
                                else:
                                    all_series_labels_ok = False
                                    continue
                            
                            # Match expected and actual values
                            # We need to match them in order, but some data points might not have labels
                            matches = 0
                            min_len = min(len(expected_values), len(actual_values))
                            
                            for i in range(min_len):
                                expected_val = str(expected_values[i]).strip()
                                actual_val = str(actual_values[i]).strip()
                                
                                # Normalize values for comparison (handle empty strings, spaces, etc.)
                                if expected_val == "" or expected_val == " ":
                                    expected_val = ""
                                if actual_val == "" or actual_val == " ":
                                    actual_val = ""
                                
                                # Compare (case-insensitive for text)
                                if expected_val.lower() == actual_val.lower():
                                    matches += 1
                                else:
                                    # Try numeric comparison if both are numbers
                                    try:
                                        if float(expected_val) == float(actual_val):
                                            matches += 1
                                            continue
                                    except (ValueError, TypeError):
                                        pass
                                    
                                    logger.debug(f"Value mismatch at index {i}: expected '{expected_val}', got '{actual_val}'")
                            
                            # Check if at least 80% of values match (allowing for some data points without labels)
                            match_ratio = matches / len(expected_values) if len(expected_values) > 0 else 0
                            if match_ratio >= 0.8:
                                logger.info(f"✓ Series '{ser_name}' data labels match cell values ({matches}/{len(expected_values)} matches, {match_ratio*100:.1f}%)")
                                continue
                            else:
                                logger.warning(f"Series '{ser_name}' data labels do not match cell values ({matches}/{len(expected_values)} matches, {match_ratio*100:.1f}%)")
                                # If showDataLabelsRange is enabled, we'll still accept it
                                if show_data_labels_range:
                                    logger.info(f"✓ Series '{ser_name}' data labels configured (showDataLabelsRange enabled, even though values don't fully match)")
                                    continue
                                else:
                                    all_series_labels_ok = False
                                    continue
                    
                    if combo_chart_found:
                        chart_found = True
                        break
            
            if not chart_found:
                logger.error("✗ No combination chart found")
                return 0.0
            
            if not all_series_labels_ok:
                logger.error("✗ Not all series data labels are correctly configured")
                return 0.0
            
            logger.info("=" * 60)
            logger.info("✓ Combination chart auto data labels verification passed!")
            logger.info("=" * 60)
            return 1.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0

import functools
import itertools
import logging
import os.path

# import operator
from numbers import Number
from typing import Any, Union, cast, Callable, Iterable
from typing import Dict, List, Tuple, Set

import openpyxl
import pandas as pd
from openpyxl import Workbook
from openpyxl.cell.cell import Cell
from openpyxl.utils import get_column_letter
from openpyxl.worksheet.cell_range import MultiCellRange
from openpyxl.worksheet.datavalidation import DataValidation
from openpyxl.worksheet.worksheet import Worksheet
from rapidfuzz import fuzz

from desktop_env.evaluators.metrics.utils import (
    _match_value_to_rule,
    _read_cell_style,
    read_cell_value,
)
from desktop_env.evaluators.metrics.utils import (
    load_charts,
    load_sparklines,
    load_rows_or_cols,
    load_xlsx_styles,
    load_filters,
    load_pivot_tables,
)

# from openpyxl.utils import coordinate_to_tuple

logger = logging.getLogger("desktopenv.metric.table")

BOOK = Union[pd.ExcelFile, Workbook, str]


def _parse_sheet_idx(
    sheet_idx: Union[int, str],
    result: BOOK,
    expected: BOOK,
    result_sheet_names: List[str],
    expected_sheet_names: List[str],
) -> Tuple[BOOK, str]:
    #  function _parse_sheet_idx {{{ #
    if isinstance(sheet_idx, int):
        try:
            if not result_sheet_names or sheet_idx >= len(result_sheet_names):
                logger.error(
                    f"Sheet index {sheet_idx} out of range. Available sheets: {result_sheet_names}"
                )
                index = ""
            else:
                index: str = result_sheet_names[sheet_idx]
                logger.debug(f"Sheet index {sheet_idx} resolved to sheet: {index}")
        except Exception as e:
            logger.error(f"Error resolving sheet index {sheet_idx}: {e}")
            index = ""
        book: BOOK = result
    elif sheet_idx.startswith("RI"):
        try:
            index: str = result_sheet_names[int(sheet_idx[2:])]
        except:
            index = ""
        book: BOOK = result
    elif sheet_idx.startswith("RN"):
        index: str = sheet_idx[2:]
        book: BOOK = result
    elif sheet_idx.startswith("EI"):
        try:
            index: str = expected_sheet_names[int(sheet_idx[2:])]
        except:
            index = ""
        book: BOOK = expected
    elif sheet_idx.startswith("EN"):
        index: str = sheet_idx[2:]
        book: BOOK = expected
    else:
        logger.error("Unrecognized sheet index")
        raise ValueError("Unrecognized sheet index")
    return book, index
    #  }}} function _parse_sheet_idx #


SHEET = Union[pd.DataFrame, Worksheet, List[str]]


def _load_sheet(book: BOOK, index: str) -> SHEET:
    #  function _load_sheet {{{ #
    try:
        if isinstance(book, str):
            book: str = cast(str, book)
            csv_name: str = "{:}-{:}.csv".format(os.path.splitext(book)[0], index)

            try:
                all_lines: List[str] = _safe_read_file(csv_name)
                csv_lines: List[str] = list(
                    itertools.dropwhile(
                        lambda l: len(l) == 0,
                        map(lambda l: l.strip(), reversed(all_lines)),
                    )
                )
                return csv_lines
            except (FileNotFoundError, IOError) as e:
                logger.error(f"Failed to read CSV file {csv_name}: {e}")
                return None
        if isinstance(book, pd.ExcelFile):
            return pd.read_excel(book, index)
        if isinstance(book, Workbook):
            return book[index]
        logger.error("Not supported workbook format")
        raise NotImplementedError("Not supported workbook format")
    except NotImplementedError as e:
        raise e
    except:
        return None
    #  }}} function _load_sheet #


def _safe_read_file(file_path: str) -> List[str]:
    """
    Safely read a file with multiple encoding attempts.

    Args:
        file_path: Path to the file to read

    Returns:
        List of lines from the file

    Raises:
        FileNotFoundError: If file doesn't exist
        IOError: If file cannot be read with any encoding
    """
    # Common encodings to try in order of preference
    encodings = [
        "utf-8",  # Most common modern encoding
        "utf-8-sig",  # UTF-8 with BOM
        "latin-1",  # ISO-8859-1, works with any byte sequence
        "windows-1252",  # Common Windows encoding
        "gbk",  # Chinese encoding
        "cp1251",  # Cyrillic encoding
        "iso-8859-1",  # Alternative latin-1
    ]

    last_error = None

    for encoding in encodings:
        try:
            with open(file_path, "r", encoding=encoding) as f:
                lines = f.read().splitlines()
                logger.debug(
                    f"Successfully read file {file_path} with encoding {encoding}"
                )
                return lines
        except UnicodeDecodeError as e:
            last_error = e
            logger.debug(f"Failed to read {file_path} with encoding {encoding}: {e}")
            continue
        except (FileNotFoundError, IOError) as e:
            # These are non-encoding related errors, re-raise immediately
            raise e

    # If all encodings fail, try with error handling as last resort
    try:
        with open(file_path, "r", encoding="utf-8", errors="replace") as f:
            lines = f.read().splitlines()
            logger.warning(f"Read file {file_path} with UTF-8 and error replacement")
            return lines
    except Exception as e:
        logger.error(
            f"Failed to read file {file_path} with any encoding. Last error: {last_error}"
        )
        raise IOError(
            f"Cannot read file {file_path} with any supported encoding"
        ) from last_error


def compare_csv(result: str, expected: Union[str, List[str]], **options) -> float:
    """
    Compare CSV files. If expected is a list, returns 1.0 if result matches any of the expected files.

    Args:
        result: Path to result CSV file
        expected: Path to expected CSV file or list of paths to expected CSV files
        options: Additional options (strict, ignore_case)

    Returns:
        1.0 if result matches expected (or any file in expected list), 0.0 otherwise
    """
    if result is None:
        return 0.0

    try:
        result_lines: List[str] = _safe_read_file(result)
    except (FileNotFoundError, IOError) as e:
        logger.error(f"Failed to read result file {result}: {e}")
        return 0.0

    # Convert expected to list if it's a single string (for backward compatibility)
    if isinstance(expected, str):
        expected_files = [expected]
    else:
        expected_files = expected

    # Try to match against each expected file
    for expected_file in expected_files:
        try:
            expected_lines: List[str] = _safe_read_file(expected_file)

            # Process lines based on options
            current_result_lines = result_lines
            current_expected_lines = expected_lines

            if not options.get("strict", True):
                current_result_lines = map(str.strip, current_result_lines)
                current_expected_lines = map(str.strip, current_expected_lines)
            if options.get("ignore_case", False):
                current_result_lines = map(str.lower, current_result_lines)
                current_expected_lines = map(str.lower, current_expected_lines)

            # Check if this expected file matches
            if list(current_result_lines) == list(current_expected_lines):
                return 1.0

        except (FileNotFoundError, IOError):
            # If this expected file doesn't exist, continue to next one
            continue

    # No match found
    return 0.0


def compare_table(result: str, expected: str = None, **options) -> float:
    #  function compare_table {{{ #
    """
    Args:
        result (str): path to result xlsx
        expected (str): path to golden xlsx
        rules (List[Dict[str, Any]]): list of dict like
          {
            "type": str,
            <str as parameters>: anything
          }
          as sequential rules

    Returns:
        float: the score
    """

    if result is None:
        logger.error("Result file path is None")
        return 0.0

    # Check if result file exists
    if not os.path.exists(result):
        logger.error(f"Result file not found: {result}")
        return 0.0

    try:
        logger.info(f"Loading result file: {result}")
        xlworkbookr: Workbook = openpyxl.load_workbook(filename=result)
        pdworkbookr = pd.ExcelFile(result)
        logger.info(
            f"Successfully loaded result file with sheets: {pdworkbookr.sheet_names}"
        )
    except Exception as e:
        logger.error(f"Failed to load result file {result}: {e}")
        return 0.0
    worksheetr_names: List[str] = pdworkbookr.sheet_names

    if expected is not None:
        xlworkbooke: Workbook = openpyxl.load_workbook(filename=expected)
        pdworkbooke = pd.ExcelFile(expected)
        worksheete_names: List[str] = pdworkbooke.sheet_names
    else:
        xlworkbooke: Workbook = None
        pdworkbooke = None
        worksheete_names: List[str] = None

    parse_idx: Callable[[Union[str, int], BOOK, BOOK], Tuple[BOOK, str]] = (
        functools.partial(
            _parse_sheet_idx,
            result_sheet_names=worksheetr_names,
            expected_sheet_names=worksheete_names,
        )
    )

    passes = True
    for r in options["rules"]:
        if r["type"] == "sheet_name":
            #  Compare Sheet Names {{{ #
            metric: bool = worksheetr_names == worksheete_names
            logger.debug(
                "Assertion: %s.sheet_names == %s.sheet_names - %s",
                result,
                expected,
                metric,
            )
            #  }}} Compare Sheet Names #

        elif r["type"] == "sheet_data":
            #  Compare Sheet Data by Internal Value {{{ #
            # sheet_idx0: 0 == "RI0" == "RNSheet1" | "EI0" == "ENSheet1"
            # sheet_idx1: as sheet_idx0
            # precision: int as number of decimal digits, default to 4

            error_limit: int = r.get("precision", 4)
            sheet1: pd.DataFrame = _load_sheet(
                *parse_idx(r["sheet_idx0"], pdworkbookr, pdworkbooke)
            )
            if sheet1 is None:
                return 0.0
            sheet2: pd.DataFrame = _load_sheet(
                *parse_idx(r["sheet_idx1"], pdworkbookr, pdworkbooke)
            )

            sheet1 = sheet1.round(error_limit)
            sheet2 = sheet2.round(error_limit)
            metric: bool = sheet1.equals(sheet2)
            logger.debug("Sheet1: \n%s", str(sheet1))
            logger.debug("Sheet2: \n%s", str(sheet2))
            try:
                logger.debug("Sheet1 =v= Sheet2: \n%s", str(sheet1 == sheet2))
            except:
                logger.debug("Sheet1 =/v= Sheet2")
            logger.debug(
                "Assertion: %s =v= %s - %s", r["sheet_idx0"], r["sheet_idx1"], metric
            )
            #  }}} Compare Sheet Data by Internal Value #

        elif r["type"] == "sheet_print":
            #  Compare Sheet Data by Printed Value {{{ #
            # sheet_idx0: 0 == "RI0" == "RNSheet1" | "EI0" == "ENSheet1"
            # sheet_idx1: as sheet_idx0
            # ignore_case: optional, defaults to False

            sheet1: List[str] = _load_sheet(
                *parse_idx(r["sheet_idx0"], result, expected)
            )
            if sheet1 is None:
                return 0.0
            sheet2: List[str] = _load_sheet(
                *parse_idx(r["sheet_idx1"], result, expected)
            )
            if r.get("ignore_case", False):
                sheet1 = [l.lower() for l in sheet1]
                sheet2 = [l.lower() for l in sheet2]
            metric: bool = sheet1 == sheet2
            logger.debug(
                "Assertion: %s =p= %s - %s", r["sheet_idx0"], r["sheet_idx1"], metric
            )
            #  }}} Compare Sheet Data by Printed Value #

        elif r["type"] == "sheet_fuzzy":
            #  Fuzzy Match for Ranges {{{ #
            # sheet_idx0: 0 == "RI0" == "RNSheet1" | "EI0" == "ENSheet1"
            # sheet_idx1: as sheet_idx0
            # rules: list of dict, each dict is like
            #   { "range": ["A1:B6", "C2:E5"],
            #     "type": "includes" | "included_by" | "fuzzy_match" | "exact_match", # 0 includes 1, 0 includes_by 1
            #     "threshold": 85, // for fuzzy match
            #     "ignore_case": true | false,
            #     "ignore_chars": " ()", # filtered out
            #     "trim_leadings": "+ ", # filtered by lstrip
            #     "trim_trailings": "", # filtered by rstrip
            #     "normalization": [["Rd", "Road"]], # filtered by replace
            #   }

            sheet1: Tuple[BOOK, str] = parse_idx(r["sheet_idx0"], result, expected)
            sheet2: Tuple[BOOK, str] = parse_idx(r["sheet_idx1"], result, expected)
            total_metric = True
            for rl in r["rules"]:
                for rng in MultiCellRange(rl["range"]):
                    for cdn in rng.cells:
                        coordinate: str = "{:}{:d}".format(
                            get_column_letter(cdn[1]), cdn[0]
                        )
                        value1: str = str(read_cell_value(*sheet1, coordinate))
                        value2: str = str(read_cell_value(*sheet2, coordinate))
                        logger.debug("%s: %s vs %s", cdn, value1, value2)

                        for rplc in rl.get("normalization", []):
                            value1 = value1.replace(rplc[0], rplc[1])
                            value2 = value2.replace(rplc[0], rplc[1])
                        if "trim_leadings" in rl:
                            value1 = value1.lstrip(rl["trim_leadings"])
                            value2 = value2.lstrip(rl["trim_leadings"])
                        if "trim_trailings" in rl:
                            value1 = value1.rstrip(rl["trim_trailings"])
                            value2 = value2.rstrip(rl["trim_trailings"])
                        if "ignore_chars" in rl:
                            ignore_chars: Set[str] = set(rl["ignore_chars"])
                            value1 = "".join(
                                filter(lambda ch: ch not in ignore_chars, value1)
                            )
                            value2 = "".join(
                                filter(lambda ch: ch not in ignore_chars, value2)
                            )
                        if rl.get("ignore_case", False):
                            value1 = value1.lower()
                            value2 = value2.lower()

                        if rl["type"] == "includes":
                            metric: bool = value2 in value1
                        elif rl["type"] == "included_by":
                            metric: bool = value1 in value2
                        elif rl["type"] == "fuzzy_match":
                            metric: bool = fuzz.ratio(value1, value2) >= rl.get(
                                "threshold", 85.0
                            )
                        elif rl["type"] == "exact_match":
                            metric: bool = value1 == value2
                        total_metric = total_metric and metric

            metric: bool = total_metric
            logger.debug(
                "Assertion: %s =~= %s - %s", r["sheet_idx0"], r["sheet_idx1"], metric
            )
            #  }}} Fuzzy Match for Ranges #

        elif r["type"] == "sparkline":
            #  Compare Sparklines {{{ #
            # sheet_idx0: 0 == "RI0" == "RNSheet1" | "EI0" == "ENSheet1"
            # sheet_idx1: as sheet_idx0

            sparkline1: Dict[str, str] = load_sparklines(
                *parse_idx(r["sheet_idx0"], result, expected)
            )
            sparkline2: Dict[str, str] = load_sparklines(
                *parse_idx(r["sheet_idx1"], result, expected)
            )
            metric: bool = sparkline1 == sparkline2
            logger.debug(
                "Assertion: %s.sp == %.sp - %s",
                r["sheet_idx0"],
                r["sheet_idx1"],
                metric,
            )
            #  }}} Compare Sparklines #

        elif r["type"] == "chart":
            #  Compare Charts {{{ #
            # sheet_idx0: 0 == "RI0" == "RNSheet1" | "EI0" == "ENSheet1"
            # sheet_idx1: as sheet_idx0
            # chart_props: list of str, see utils.load_charts

            charts1: Dict[str, Any] = load_charts(
                *parse_idx(r["sheet_idx0"], xlworkbookr, xlworkbooke), **r
            )
            charts2: Dict[str, Any] = load_charts(
                *parse_idx(r["sheet_idx1"], xlworkbookr, xlworkbooke), **r
            )
            metric: bool = charts1 == charts2
            logger.debug(
                "Assertion: %s[chart] == %s[chart] - %s",
                r["sheet_idx0"],
                r["sheet_idx1"],
                metric,
            )
            #  }}} Compare Charts #

        elif r["type"] == "style":
            #  Compare Style (Also Conditional Formatiing) {{{ #
            # sheet_idx0: 0 == "RI0" == "RNSheet1" | "EI0" == "ENSheet1"
            # sheet_idx1: as sheet_idx0
            # props: list of str indicating concerned styles, see utils._read_cell_style

            sheet_idx1: Tuple[BOOK, str] = parse_idx(
                r["sheet_idx0"], xlworkbookr, xlworkbooke
            )
            book_name1: str = parse_idx(r["sheet_idx0"], result, expected)[0]
            styles1: Dict[str, List[Any]] = load_xlsx_styles(
                *sheet_idx1, book_name1, **r
            )

            sheet_idx2: Tuple[BOOK, str] = parse_idx(
                r["sheet_idx1"], xlworkbookr, xlworkbooke
            )
            book_name2: str = parse_idx(r["sheet_idx1"], result, expected)[0]
            styles2: Dict[str, List[Any]] = load_xlsx_styles(
                *sheet_idx2, book_name2, **r
            )
            # number_formats1: List[str] = [c.number_format.lower() for col in sheet1.iter_cols() for c in col if c.value is not None and c.data_type=="n"]
            # number_formats2: List[str] = [c.number_format.lower() for col in sheet2.iter_cols() for c in col if c.value is not None and c.data_type=="n"]
            metric: bool = styles1 == styles2
            logger.debug(
                "Assertion: %s.style == %s.style - %s",
                r["sheet_idx0"],
                r["sheet_idx1"],
                metric,
            )
            #  }}} Compare Style (Also Conditional Formatiing) #

        elif r["type"] == "freeze":
            #  Compare Freezing {{{ #
            # sheet_idx0: 0 == "RI0" == "RNSheet1" | "EI0" == "ENSheet1"
            # sheet_idx1: as sheet_idx0

            sheet1: Worksheet = _load_sheet(
                *parse_idx(r["sheet_idx0"], xlworkbookr, xlworkbooke)
            )
            if sheet1 is None:
                return 0.0
            sheet2: Worksheet = _load_sheet(
                *parse_idx(r["sheet_idx1"], xlworkbookr, xlworkbooke)
            )
            metric: bool = sheet1.freeze_panes == sheet2.freeze_panes
            logger.debug(
                "Assertion: %s.freeze(%s) == %s.freeze(%s) - %s",
                r["sheet_idx0"],
                sheet1.freeze_panes,
                r["sheet_idx1"],
                sheet2.freeze_panes,
                metric,
            )
            #  }}} Compare Freezing #

        elif r["type"] == "zoom":
            #  Check Zooming {{{ #
            # sheet_idx: 0 == "RI0" == "RNSheet1" | "EI0" == "ENSheet1"
            # method: str
            # ref: value

            sheet: Worksheet = _load_sheet(
                *parse_idx(r["sheet_idx"], xlworkbookr, xlworkbooke)
            )
            if sheet is None:
                return 0.0
            zoom_scale: Number = sheet.sheet_view.zoomScale or 100.0
            metric: bool = _match_value_to_rule(zoom_scale, r)
            logger.debug(
                "Assertion: %s.zoom(%.1f) %s %.1f - %s",
                r["sheet_idx"],
                zoom_scale,
                r["method"],
                r["ref"],
                metric,
            )
            #  }}} Check Zooming #

        elif r["type"] == "data_validation":
            #  Check Data Validation {{{ #
            # sheet_idx: 0 == "RI0" == "RNSheet1" | "EI0" == "ENSheet1"
            # dv_props: list of dict like {attribute: {"method": str, "ref": anything}}
            #   available attributes:
            #     * ranges
            #     * type
            #     * formula1
            #     * formula2
            #     * operator
            #     * allowBlank
            #     * showDropDown
            #     * showInputMessage
            #     * showErrorMessage
            #     * error
            #     * errorTitle
            #     * errorStyle
            #     * prompt
            #     * promptTitle
            #     * imeMode

            sheet: Worksheet = _load_sheet(
                *parse_idx(r["sheet_idx"], xlworkbookr, xlworkbooke)
            )
            if sheet is None:
                return 0.0
            data_validators: List[DataValidation] = (
                sheet.data_validations.dataValidation
            )

            total_metric = len(data_validators) >= len(r["dv_props"])
            for dat_vldt in data_validators:
                metric = False
                for prpt in r["dv_props"]:
                    metric = metric or all(
                        _match_value_to_rule(getattr(dat_vldt, attrbt), mr)
                        for attrbt, mr in prpt.items()
                    )
                    if metric:
                        break
                total_metric = total_metric and metric
                if not total_metric:
                    break

            logger.debug(
                "Assertion: %s.data_validation - %s", r["sheet_idx"], total_metric
            )
            metric: bool = total_metric
            #  }}} Check Data Validation #

        elif r["type"] == "row_props":
            #  Check Row Properties {{{ #
            # sheet_idx0: 0 == "RI0" == "RNSheet1" | "EI0" == "ENSheet1"
            # sheet_idx1: as sheet_idx0
            # props: list of str, see utils.load_rows_or_cols

            rows1: Dict[str, Any] = load_rows_or_cols(
                *parse_idx(r["sheet_idx0"], xlworkbookr, xlworkbooke), obj="row", **r
            )
            rows2: Dict[str, Any] = load_rows_or_cols(
                *parse_idx(r["sheet_idx1"], xlworkbookr, xlworkbooke), obj="row", **r
            )
            logger.debug("Rows1: %s", repr(rows1))
            logger.debug("Rows2: %s", repr(rows2))
            metric: bool = rows1 == rows2
            logger.debug(
                "Assertion: %s[rows] == %s[rows] - %s",
                r["sheet_idx0"],
                r["sheet_idx1"],
                metric,
            )
            #  }}} Check Row Properties #

        elif r["type"] == "col_props":
            #  Check Row Properties {{{ #
            # sheet_idx0: 0 == "RI0" == "RNSheet1" | "EI0" == "ENSheet1"
            # sheet_idx1: as sheet_idx0
            # props: list of str, see utils.load_rows_or_cols

            cols1: Dict[str, Any] = load_rows_or_cols(
                *parse_idx(r["sheet_idx0"], xlworkbookr, xlworkbooke), obj="column", **r
            )
            cols2: Dict[str, Any] = load_rows_or_cols(
                *parse_idx(r["sheet_idx1"], xlworkbookr, xlworkbooke), obj="column", **r
            )
            metric: bool = cols1 == cols2
            logger.debug(
                "Assertion: %s[cols] == %s[cols] - %s",
                r["sheet_idx0"],
                r["sheet_idx1"],
                metric,
            )
            #  }}} Check Row Properties #

        elif r["type"] == "filter":
            #  Compare Filters {{{ #
            # sheet_idx0: 0 == "RI0" == "RNSheet1" | "EI0" == "ENSheet1"
            # sheet_idx1: as sheet_idx0

            filters1: Dict[str, Any] = load_filters(
                *parse_idx(r["sheet_idx0"], xlworkbookr, xlworkbooke), **r
            )
            filters2: Dict[str, Any] = load_filters(
                *parse_idx(r["sheet_idx1"], xlworkbookr, xlworkbooke), **r
            )
            metric: bool = filters1 == filters2
            logger.debug(
                "Assertion: %s[filter] == %s[filter] - %s",
                r["sheet_idx0"],
                r["sheet_idx1"],
                metric,
            )
            #  }}} Compare Filters #

        elif r["type"] == "pivot_table":
            #  Compare Pivot Tables {{{ #
            # sheet_idx0: 0 == "RI0" == "RNSheet1" | "EI0" == "ENSheet1"
            # sheet_idx1: as sheet_idx0
            # pivot_props: list of str, see utils.load_pivot_tables

            pivots1: Dict[str, Any] = load_pivot_tables(
                *parse_idx(r["sheet_idx0"], xlworkbookr, xlworkbooke), **r
            )
            pivots2: Dict[str, Any] = load_pivot_tables(
                *parse_idx(r["sheet_idx1"], xlworkbookr, xlworkbooke), **r
            )
            metric: bool = pivots1 == pivots2
            logger.debug(
                "Assertion: %s[pivot]==%s[pivot] - %s",
                r["sheet_idx0"],
                r["sheet_idx1"],
                metric,
            )
            #  }}} Compare Pivot Tables #

        elif r["type"] == "check_cell":
            #  Check Cell Properties {{{ #
            # sheet_idx: 0 == "RI0" == "RNSheet1" | "EI0" == "ENSheet1"
            # coordinate: str, "E3"
            # props: dict like {attribute: {"method": str, "ref": anything}}
            #   supported attributes: value & those supported by utils._read_cell_style

            try:
                sheet: Worksheet = _load_sheet(
                    *parse_idx(r["sheet_idx"], xlworkbookr, xlworkbooke)
                )
                if sheet is None:
                    logger.error(
                        f"Failed to load sheet for sheet_idx: {r['sheet_idx']}"
                    )
                    return 0.0
                # data_frame: pd.DataFrame = _load_sheet(*parse_idx(r["sheet_idx"], pdworkbookr, pdworkbooke))
                cell: Cell = sheet[r["coordinate"]]
                metric: bool = True
                for prpt, rule in r["props"].items():
                    if prpt == "value":
                        try:
                            parsed_result = parse_idx(r["sheet_idx"], result, expected)
                            logger.debug(f"parse_idx result: {parsed_result}")
                            val = read_cell_value(*parsed_result, r["coordinate"])
                            logger.debug(f"Cell {r['coordinate']} value: {val}")
                        except Exception as e:
                            logger.error(
                                f"Failed to read cell value at {r['coordinate']}: {e}"
                            )
                            val = None
                    elif prpt == "formula":
                        # Support checking cell formula directly
                        try:
                            if cell.data_type == "f":
                                # For formula cells, get the formula text
                                # In openpyxl, formula is stored in cell.value for formula cells
                                # But we need the actual formula text, not the calculated value
                                # Try to get formula from internal representation
                                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                                    val = cell._value
                                elif hasattr(cell, "formula"):
                                    val = cell.formula
                                else:
                                    # Fallback: try to reconstruct from value if it's a formula
                                    val = f"={cell.value}" if cell.value is not None else None
                            else:
                                val = None
                            logger.debug(f"Cell {r['coordinate']} formula: {val}")
                        except Exception as e:
                            logger.error(
                                f"Failed to read cell formula at {r['coordinate']}: {e}"
                            )
                            val = None
                    else:
                        try:
                            val = _read_cell_style(prpt, cell)
                        except Exception as e:
                            logger.error(
                                f"Failed to read cell style {prpt} at {r['coordinate']}: {e}"
                            )
                            val = None

                    metric = metric and _match_value_to_rule(val, rule)
            except Exception as e:
                logger.error(f"Error in check_cell processing: {e}")
                return 0.0

            logger.debug(
                "Assertion: %s[%s] :%s - %s",
                r["sheet_idx"],
                r["coordinate"],
                repr(r["props"]),
                metric,
            )
            #  }}} Check Cell Properties #

        else:
            raise NotImplementedError(
                "Unimplemented sheet check: {:}".format(r["type"])
            )

        passes = passes and metric
        if not passes:
            break

    return float(passes)
    #  }}} function compare_table #


def compare_conference_city_in_order(actual_city_list_path, expected_city):
    expected_city_list = expected_city["expected"]
    wb = openpyxl.load_workbook(actual_city_list_path)
    sheet = wb.active
    actual_city_list = []
    for row in sheet["C2:C22"]:
        for cell in row:
            actual_city_list.append(cell.value)
    # expected_city is the city that we want to compare with the actual city list
    # must in order index
    # debug
    try:
        for i in range(len(actual_city_list)):
            if isinstance(expected_city_list[i], str):
                if expected_city_list[i] not in actual_city_list[i]:
                    logger.debug(
                        f"Expected city {expected_city_list[i]}; Actual city {actual_city_list[i]}"
                    )
                    print(
                        f"Expected city {expected_city_list[i]}; Actual city {actual_city_list[i]}"
                    )
                    return 0.0

            elif isinstance(expected_city_list[i], List):
                if not any(
                    possible_str in actual_city_list[i]
                    for possible_str in expected_city_list[i]
                ):
                    logger.debug(
                        f"Expected city {expected_city_list[i]}; Actual city {actual_city_list[i]}"
                    )
                    print(
                        f"Expected city {expected_city_list[i]}; Actual city {actual_city_list[i]}"
                    )
                    return 0.0

            else:
                raise TypeError("Expected city should be a string or a list of strings")

    except:
        return 0.0

    return 1.0


def verify_second_row_deleted_without_gold(result: str, expected: str = None, **options) -> float:
    """
    验证 Excel 文件的第二行是否被删除（不需要金标准文件）
    
    通过以下方式验证：
    1. 检查结果文件的行数是否比原始文件少1
    2. 检查原始文件的第二行数据是否在结果文件中不存在
    3. 检查其他所有行是否保持不变
    
    Args:
        result (str): 结果文件路径
        expected (str): 未使用（为了兼容框架接口）
        options (dict): 配置选项，应包含：
            - original_file_url: 原始文件的URL（用于下载和比对）
            - result_file_path: 结果文件的路径（可选，默认使用 result 参数）
            - original_file_cache: 原始文件的本地缓存路径（可选）
    
    Returns:
        float: 如果验证通过返回 1.0，否则返回 0.0
    """
    try:
        import tempfile
        import urllib.request
        
        # result 参数已经是从VM获取到宿主机的文件路径
        # 不应该从 options 中覆盖它，因为 options 中可能包含的是VM路径
        result_file_path = result
        original_file_url = options.get('original_file_url', '')
        
        logger.info(f"开始验证删除第二行任务...")
        logger.info(f"结果文件: {result_file_path}")
        logger.info(f"原始文件URL: {original_file_url}")
        
        if not result_file_path or not os.path.exists(result_file_path):
            logger.error(f"结果文件不存在: {result_file_path}")
            return 0.0
        
        # 下载原始文件到临时位置
        with tempfile.NamedTemporaryFile(delete=False, suffix='.xlsx') as tmp_file:
            original_file_temp = tmp_file.name
        
        try:
            logger.info(f"正在下载原始文件到临时位置: {original_file_temp}")
            urllib.request.urlretrieve(original_file_url, original_file_temp)
        except Exception as e:
            logger.warning(f"下载原始文件失败: {e}")
            # 如果下载失败，尝试从本地缓存读取
            cache_path = options.get('original_file_cache', '')
            if cache_path and os.path.exists(cache_path):
                logger.info(f"使用缓存文件: {cache_path}")
                original_file_temp = cache_path
            else:
                logger.error("无法获取原始文件")
                return 0.0
        
        # 加载原始文件
        logger.info("加载原始文件...")
        original_wb = openpyxl.load_workbook(original_file_temp)
        original_ws = original_wb.active
        
        # 获取原始文件的所有行
        original_rows = list(original_ws.iter_rows(values_only=True))
        original_row_count = len(original_rows)
        
        if original_row_count < 2:
            logger.error(f"原始文件行数不足: {original_row_count}（需要至少2行）")
            return 0.0
        
        # 保存第二行的数据（索引为1）
        second_row_data = original_rows[1]
        logger.info(f"原始文件行数: {original_row_count}")
        logger.info(f"原始文件第二行数据: {second_row_data}")
        
        # 加载结果文件
        logger.info(f"加载结果文件...")
        result_wb = openpyxl.load_workbook(result_file_path)
        result_ws = result_wb.active
        
        # 获取结果文件的所有行
        result_rows = list(result_ws.iter_rows(values_only=True))
        result_row_count = len(result_rows)
        
        logger.info(f"结果文件行数: {result_row_count}")
        
        # 验证1: 检查行数是否减少了1
        if result_row_count != original_row_count - 1:
            logger.error(f"行数验证失败: 期望 {original_row_count - 1} 行，实际 {result_row_count} 行")
            return 0.0
        else:
            logger.info(f"✓ 行数验证通过: {original_row_count} → {result_row_count}")
        
        # 验证2: 检查原始第二行是否存在于结果文件中
        second_row_exists = False
        for i, row in enumerate(result_rows):
            if row == second_row_data:
                logger.error(f"原始第二行数据仍存在于结果文件的第 {i+1} 行")
                second_row_exists = True
                break
        
        if second_row_exists:
            return 0.0
        else:
            logger.info(f"✓ 原始第二行数据已从结果文件中删除")
        
        # 验证3: 检查其他行是否保持不变（第一行和第3行之后）
        # 结果文件的第一行应该等于原始文件的第一行
        if result_rows[0] != original_rows[0]:
            logger.error(f"第一行数据不匹配")
            logger.error(f"  原始: {original_rows[0]}")
            logger.error(f"  结果: {result_rows[0]}")
            return 0.0
        
        # 结果文件的第2行及之后应该等于原始文件的第3行及之后
        for i in range(1, result_row_count):
            if result_rows[i] != original_rows[i+1]:
                logger.error(f"第 {i+1} 行数据不匹配")
                logger.error(f"  期望（原始第 {i+2} 行）: {original_rows[i+1]}")
                logger.error(f"  实际: {result_rows[i]}")
                return 0.0
        
        logger.info(f"✓ 其他行数据保持不变")
        
        # 清理临时文件
        if original_file_temp != options.get('original_file_cache', ''):
            try:
                os.unlink(original_file_temp)
            except:
                pass
        
        logger.info("=" * 60)
        logger.info("✓ 所有验证通过！第二行已成功删除")
        logger.info("=" * 60)
        return 1.0
        
    except Exception as e:
        import traceback
        logger.error(f"评估出错: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_regexp_extract(result: str, expected: str = None, **options) -> float:
    """
    Verify if REGEX formulas exist in specified columns (B and C) with correct patterns.
    
    This function checks:
    1. Whether cells in specified columns contain REGEX formulas
    2. Whether formulas reference the corresponding A column cell (B2->A2, B3->A3, etc.)
    3. Whether formulas contain the correct pattern text (牛肉丸 for B column, 牛筋丸 for C column)
    4. Whether formulas have the correct structure with lookbehind and lookahead
    
    The function automatically detects the number of data rows by checking the data column
    (default: A column) for non-empty cells. It stops checking after finding 3 consecutive
    empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_columns: List of columns to check (e.g., ["B", "C"])
            - start_row: Starting row number (default: 2)
            - end_row: Ending row number (optional, will auto-detect if not provided)
            - expected_pattern: Expected function name (default: "REGEX")
            - column_patterns: Dict mapping column letters to expected pattern text
            - data_column: Column to check for data to determine end_row (default: "A")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_columns = options.get('check_columns', ['B', 'C'])
        start_row = options.get('start_row', 2)
        end_row = options.get('end_row', None)  # Optional, will auto-detect if not provided
        expected_pattern = options.get('expected_pattern', 'REGEX')
        column_patterns = options.get('column_patterns', {'B': '牛肉丸', 'C': '牛筋丸'})
        data_column = options.get('data_column', 'A')  # Column to check for data to determine end_row
        
        if not check_columns:
            logger.error("No columns specified in options")
            return 0.0
        
        logger.info(f"Verifying REGEX formulas in file: {result}")
        logger.info(f"Columns to check: {check_columns}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Expected function: {expected_pattern}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        if end_row is None:
            logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
            max_row = ws.max_row
            end_row = start_row  # Start from start_row
            
            # Find the last row with data in the data column
            # Check up to max_row, but stop if we find 3 consecutive empty rows
            empty_count = 0
            for row_num in range(start_row, max_row + 1):
                data_cell = ws[f"{data_column}{row_num}"]
                if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                    empty_count += 1
                    if empty_count >= 3:  # Stop after 3 consecutive empty rows
                        break
                else:
                    empty_count = 0
                    end_row = row_num  # Update end_row to the last row with data
            
            logger.info(f"Auto-detected end row: {end_row}")
        else:
            logger.info(f"Using specified end row: {end_row}")
        
        # Check each column and row
        all_passed = True
        for col_letter in check_columns:
            expected_pattern_text = column_patterns.get(col_letter)
            if not expected_pattern_text:
                logger.warning(f"No pattern text specified for column {col_letter}, skipping")
                continue
            
            logger.info(f"Checking column {col_letter} with pattern '{expected_pattern_text}' (rows {start_row} to {end_row})")
            
            for row_num in range(start_row, end_row + 1):
                cell_coord = f"{col_letter}{row_num}"
                try:
                    cell = ws[cell_coord]
                    logger.debug(f"Checking cell {cell_coord}")
                    
                    # Check if cell contains a formula
                    if cell.data_type != "f":
                        logger.warning(f"Cell {cell_coord} does not contain a formula")
                        all_passed = False
                        continue
                    
                    # Get formula text
                    formula_text = None
                    if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                        formula_text = cell._value
                    elif hasattr(cell, "formula"):
                        formula_text = cell.formula
                    else:
                        # Try to get from value attribute
                        if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                            formula_text = cell.value
                    
                    if formula_text is None:
                        logger.warning(f"Could not extract formula from cell {cell_coord}")
                        all_passed = False
                        continue
                    
                    # Remove leading = if present for comparison
                    formula_clean = formula_text.lstrip("=")
                    logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                    
                    # Check 1: Formula contains REGEX function
                    if expected_pattern.upper() not in formula_text.upper():
                        logger.warning(f"Cell {cell_coord} formula does not contain {expected_pattern}")
                        logger.warning(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 2: Formula contains expected pattern text (牛肉丸 or 牛筋丸)
                    if expected_pattern_text not in formula_text:
                        logger.warning(f"Cell {cell_coord} formula does not contain pattern text '{expected_pattern_text}'")
                        logger.warning(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 3: Formula contains REGEX function call structure
                    regex_match = re.search(r'REGEX\s*\([^)]+\)', formula_text, re.IGNORECASE)
                    if not regex_match:
                        logger.warning(f"Cell {cell_coord} formula does not have correct REGEX structure")
                        logger.warning(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 4: Formula references the corresponding A column cell (A2, A3, etc.)
                    expected_a_cell = f"A{row_num}"
                    # Check if formula contains A column reference with the same row number
                    a_cell_pattern = rf'A{row_num}\b'
                    if not re.search(a_cell_pattern, formula_text, re.IGNORECASE):
                        logger.warning(f"Cell {cell_coord} formula does not reference {expected_a_cell}")
                        logger.warning(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 5: Formula contains lookbehind pattern (?<=...)
                    if "(?<=" not in formula_text:
                        logger.warning(f"Cell {cell_coord} formula does not contain lookbehind pattern (?<=...)")
                        logger.warning(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 6: Formula contains lookahead pattern (?=,)
                    if "(?=," not in formula_text:
                        logger.warning(f"Cell {cell_coord} formula does not contain lookahead pattern (?=,)")
                        logger.warning(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 7: Formula contains \d+ pattern
                    if "\\d+" not in formula_text:
                        # Also check for unescaped version in the pattern
                        if not re.search(r'\\d\+|d\+', formula_text):
                            logger.warning(f"Cell {cell_coord} formula does not contain digit pattern \\d+")
                            logger.warning(f"Formula: {formula_text}")
                            all_passed = False
                            continue
                    
                    # Check 8: Formula pattern should contain 5 dots after pattern text
                    # Pattern should be like: (?<=牛肉丸.....)
                    pattern_with_dots = expected_pattern_text + "....."
                    if pattern_with_dots not in formula_text:
                        logger.warning(f"Cell {cell_coord} formula pattern may not have 5 dots after '{expected_pattern_text}'")
                        logger.debug(f"Formula: {formula_text}")
                        # Don't fail, just warn - the pattern might be correct but formatted differently
                    
                    logger.info(f"✓ Cell {cell_coord} has valid REGEX formula: {formula_text}")
                    
                except Exception as e:
                    logger.error(f"Error checking cell {cell_coord}: {e}")
                    import traceback
                    logger.error(traceback.format_exc())
                    all_passed = False
        
        if all_passed:
            logger.info("=" * 60)
            logger.info(f"✓ All cells in columns {check_columns} contain correct {expected_pattern} formulas")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ {expected_pattern} formula verification failed")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_regexp_order_extract(result: str, expected: str = None, **options) -> float:
    """
    Verify if REGEXP formulas exist in specified column (C) to extract order numbers from addresses.
    
    This function checks:
    1. Whether cells in specified column contain REGEXP formulas
    2. Whether formulas reference the corresponding A column cell (C2->A2, C3->A3, etc.)
    3. Whether formulas contain the correct regex pattern (\\w{10})
    4. Whether formulas have the correct structure
    
    The function automatically detects the number of data rows by checking the data column
    (default: A column) for non-empty cells. It stops checking after finding 3 consecutive
    empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_column: Column to check (e.g., "C")
            - start_row: Starting row number (default: 2)
            - expected_pattern: Expected function name (default: "REGEXP")
            - expected_formula_pattern: Expected formula pattern (e.g., "REGEXP(A")
            - regex_pattern: Expected regex pattern in formula (e.g., "\\w{10}")
            - data_column: Column to check for data to determine end_row (default: "A")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_column = options.get('check_column', 'C')
        start_row = options.get('start_row', 2)
        expected_pattern = options.get('expected_pattern', 'REGEX')
        expected_formula_pattern = options.get('expected_formula_pattern', 'REGEX(A')
        regex_pattern = options.get('regex_pattern', '[a-zA-Z0-9]{10}')
        data_column = options.get('data_column', 'A')
        
        logger.info(f"Verifying REGEXP order extraction in file: {result}")
        logger.info(f"Column to check: {check_column}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Expected function: {expected_pattern}")
        logger.info(f"Expected regex pattern: {regex_pattern}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row  # Start from start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Check each row in the specified column
        all_passed = True
        logger.info(f"Checking column {check_column} (rows {start_row} to {end_row})")
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{check_column}{row_num}"
            try:
                cell = ws[cell_coord]
                logger.debug(f"Checking cell {cell_coord}")
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.warning(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                else:
                    # Try to get from value attribute
                    if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                # Remove leading = if present for comparison
                formula_clean = formula_text.lstrip("=")
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains REGEX function (support both REGEX and LibreOffice internal format)
                # LibreOffice may save as _xlfn.ORG.LIBREOFFICE.REGEX
                formula_upper = formula_text.upper()
                if expected_pattern.upper() not in formula_upper and '_XLFN.ORG.LIBREOFFICE.REGEX' not in formula_upper:
                    logger.warning(f"Cell {cell_coord} formula does not contain {expected_pattern} or LibreOffice REGEX")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 2: Formula contains expected formula pattern (REGEX(A or _xlfn.ORG.LIBREOFFICE.REGEX(A)
                formula_clean_upper = formula_clean.upper()
                if expected_formula_pattern.upper() not in formula_clean_upper and 'REGEX(A' not in formula_clean_upper:
                    logger.warning(f"Cell {cell_coord} formula does not contain pattern '{expected_formula_pattern}'")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: Formula contains REGEX function call structure (support both formats)
                regexp_match = re.search(r'(REGEX|REGEXP|_XLFN\.ORG\.LIBREOFFICE\.REGEX)\s*\([^)]+\)', formula_text, re.IGNORECASE)
                if not regexp_match:
                    logger.warning(f"Cell {cell_coord} formula does not have correct REGEX structure")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: Formula references the corresponding A column cell (A2, A3, etc.)
                expected_a_cell = f"A{row_num}"
                # Check if formula contains A column reference with the same row number
                a_cell_pattern = rf'A{row_num}\b'
                if not re.search(a_cell_pattern, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {cell_coord} formula does not reference {expected_a_cell}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 5: Formula contains the regex pattern ([a-zA-Z0-9]{10})
                # The pattern might be escaped differently in the formula
                # Check for various escape formats
                pattern_variations = [
                    regex_pattern,  # [a-zA-Z0-9]{10}
                    regex_pattern.replace('\\', '\\\\'),  # [a-zA-Z0-9]{10} with double escape
                    regex_pattern.replace('[', '\\[').replace(']', '\\]'),  # Escaped brackets
                    '[a-zA-Z0-9]{10}',  # Original pattern
                    '\\[a-zA-Z0-9\\]{10}',  # Escaped brackets
                    '\\\\[a-zA-Z0-9\\\\]{10}',  # Double escaped
                ]
                found = False
                for pattern_var in pattern_variations:
                    if pattern_var in formula_text:
                        found = True
                        break
                if not found:
                    # Also check for pattern without escaping brackets
                    simple_pattern = 'a-zA-Z0-9]{10}'
                    if simple_pattern not in formula_text:
                        logger.warning(f"Cell {cell_coord} formula does not contain regex pattern '{regex_pattern}'")
                        logger.warning(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                
                logger.info(f"✓ Cell {cell_coord} has valid REGEXP formula: {formula_text}")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        if all_passed:
            logger.info("=" * 60)
            logger.info(f"✓ All cells in column {check_column} contain correct {expected_pattern} formulas")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ {expected_pattern} formula verification failed")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_sumif_formula(result: str, expected: str = None, **options) -> float:
    """
    Verify if SUMIF formulas exist in specified column (F) to calculate totals.
    
    This function checks:
    1. Whether cells in specified column contain SUMIF formulas
    2. Whether formulas reference the correct ranges (auto-detected from data)
    3. Whether formulas reference the corresponding E column cell (F2->E2, F3->E3, etc.)
    4. Whether formulas have the correct structure
    
    The function automatically detects:
    - end_row: by checking the data column (E) for non-empty cells
    - criteria_range: by detecting the range from the first formula or from criteria_column data
    - sum_range: by detecting the range from the first formula or from sum_column data
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_column: Column to check (e.g., "F")
            - start_row: Starting row number (default: 2)
            - expected_function: Expected function name (default: "SUMIF")
            - criteria_column: Column containing criteria (e.g., "B")
            - sum_column: Column containing values to sum (e.g., "C")
            - criteria_column_start: Starting row for criteria column (default: 2)
            - data_column: Column to check for data to determine end_row (default: "E")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_column = options.get('check_column', 'F')
        start_row = options.get('start_row', 2)
        expected_function = options.get('expected_function', 'SUMIF')
        criteria_column = options.get('criteria_column', 'B')
        sum_column = options.get('sum_column', 'C')
        criteria_column_start = options.get('criteria_column_start', 2)
        data_column = options.get('data_column', 'E')
        
        logger.info(f"Verifying SUMIF formulas in file: {result}")
        logger.info(f"Column to check: {check_column}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Expected function: {expected_function}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row  # Start from start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Auto-detect criteria_range and sum_range by checking the first formula
        criteria_range = None
        sum_range = None
        
        # Try to extract ranges from the first formula
        first_cell_coord = f"{check_column}{start_row}"
        try:
            first_cell = ws[first_cell_coord]
            if first_cell.data_type == "f":
                first_formula_text = None
                if hasattr(first_cell, "_value") and isinstance(first_cell._value, str) and first_cell._value.startswith("="):
                    first_formula_text = first_cell._value
                elif hasattr(first_cell, "formula"):
                    first_formula_text = first_cell.formula
                elif first_cell.value is not None and isinstance(first_cell.value, str) and first_cell.value.startswith("="):
                    first_formula_text = first_cell.value
                
                if first_formula_text:
                    # Extract ranges from SUMIF formula: SUMIF(range1, criteria, range2)
                    # Pattern: SUMIF(range1, criteria, range2)
                    sumif_pattern = r'SUMIF\s*\(\s*([^,]+)\s*,\s*[^,]+\s*,\s*([^)]+)\s*\)'
                    match = re.search(sumif_pattern, first_formula_text, re.IGNORECASE)
                    if match:
                        criteria_range = match.group(1).strip()
                        sum_range = match.group(2).strip()
                        logger.info(f"Extracted from first formula: criteria_range={criteria_range}, sum_range={sum_range}")
        except Exception as e:
            logger.debug(f"Could not extract ranges from first formula: {e}")
        
        # If ranges not found in formula, detect from data columns
        if not criteria_range or not sum_range:
            logger.info(f"Auto-detecting ranges from data columns...")
            # Find the last row with data in criteria_column
            criteria_end_row = criteria_column_start
            empty_count = 0
            for row_num in range(criteria_column_start, max_row + 1):
                criteria_cell = ws[f"{criteria_column}{row_num}"]
                if criteria_cell.value is None or (isinstance(criteria_cell.value, str) and criteria_cell.value.strip() == ""):
                    empty_count += 1
                    if empty_count >= 3:
                        break
                else:
                    empty_count = 0
                    criteria_end_row = row_num
            
            # Find the last row with data in sum_column
            sum_end_row = criteria_column_start
            empty_count = 0
            for row_num in range(criteria_column_start, max_row + 1):
                sum_cell = ws[f"{sum_column}{row_num}"]
                if sum_cell.value is None or (isinstance(sum_cell.value, str) and sum_cell.value.strip() == ""):
                    empty_count += 1
                    if empty_count >= 3:
                        break
                else:
                    empty_count = 0
                    sum_end_row = row_num
            
            # Use the maximum end row for both ranges
            max_end_row = max(criteria_end_row, sum_end_row)
            criteria_range = f"{criteria_column}{criteria_column_start}:{criteria_column}{max_end_row}"
            sum_range = f"{sum_column}{criteria_column_start}:{sum_column}{max_end_row}"
            logger.info(f"Auto-detected ranges: criteria_range={criteria_range}, sum_range={sum_range}")
        
        # Check each row in the specified column
        all_passed = True
        logger.info(f"Checking column {check_column} (rows {start_row} to {end_row})")
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{check_column}{row_num}"
            try:
                cell = ws[cell_coord]
                logger.debug(f"Checking cell {cell_coord}")
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.warning(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                else:
                    # Try to get from value attribute
                    if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                # Remove leading = if present for comparison
                formula_clean = formula_text.lstrip("=")
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains SUMIF function
                formula_upper = formula_text.upper()
                if expected_function.upper() not in formula_upper:
                    logger.warning(f"Cell {cell_coord} formula does not contain {expected_function}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 2: Formula contains SUMIF function call structure
                sumif_match = re.search(r'SUMIF\s*\([^)]+\)', formula_text, re.IGNORECASE)
                if not sumif_match:
                    logger.warning(f"Cell {cell_coord} formula does not have correct SUMIF structure")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: Formula contains criteria range
                if criteria_range and criteria_range.upper() not in formula_upper:
                    logger.warning(f"Cell {cell_coord} formula does not contain criteria range '{criteria_range}'")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: Formula contains sum range
                if sum_range and sum_range.upper() not in formula_upper:
                    logger.warning(f"Cell {cell_coord} formula does not contain sum range '{sum_range}'")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 5: Formula references the corresponding E column cell (E2, E3, etc.)
                expected_e_cell = f"E{row_num}"
                # Check if formula contains E column reference with the same row number
                e_cell_pattern = rf'E{row_num}\b'
                if not re.search(e_cell_pattern, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {cell_coord} formula does not reference {expected_e_cell}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                logger.info(f"✓ Cell {cell_coord} has valid SUMIF formula: {formula_text}")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        if all_passed:
            logger.info("=" * 60)
            logger.info(f"✓ All cells in column {check_column} contain correct {expected_function} formulas")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ {expected_function} formula verification failed")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_networkdays_formula(result: str, expected: str = None, **options) -> float:
    """
    Verify if NETWORKDAYS formulas exist in specified column to calculate working days.
    
    This function checks:
    1. Whether cells in specified column contain NETWORKDAYS formulas
    2. Whether formulas reference the corresponding start date column cell (A2, A3, etc.)
    3. Whether formulas reference the corresponding end date column cell (B2, B3, etc.)
    4. Whether formulas have the correct structure
    
    The function automatically detects the number of data rows by checking the data column
    (default: A column) for non-empty cells. It stops checking after finding 3 consecutive
    empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_column: Column to check (e.g., "C")
            - start_row: Starting row number (default: 2)
            - start_date_column: Column containing start dates (e.g., "A")
            - end_date_column: Column containing end dates (e.g., "B")
            - expected_function: Expected function name (default: "NETWORKDAYS")
            - data_column: Column to check for data to determine end_row (default: "A")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_column = options.get('check_column', 'C')
        start_row = options.get('start_row', 2)
        start_date_column = options.get('start_date_column', 'A')
        end_date_column = options.get('end_date_column', 'B')
        expected_function = options.get('expected_function', 'NETWORKDAYS')
        data_column = options.get('data_column', 'A')
        
        logger.info(f"Verifying NETWORKDAYS formulas in file: {result}")
        logger.info(f"Column to check: {check_column}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Start date column: {start_date_column}")
        logger.info(f"End date column: {end_date_column}")
        logger.info(f"Expected function: {expected_function}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row  # Start from start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Check each row in the specified column
        all_passed = True
        logger.info(f"Checking column {check_column} (rows {start_row} to {end_row})")
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{check_column}{row_num}"
            try:
                cell = ws[cell_coord]
                logger.debug(f"Checking cell {cell_coord}")
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.warning(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                else:
                    # Try to get from value attribute
                    if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                # Remove leading = if present for comparison
                formula_clean = formula_text.lstrip("=")
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains NETWORKDAYS function
                formula_upper = formula_text.upper()
                if expected_function.upper() not in formula_upper:
                    logger.warning(f"Cell {cell_coord} formula does not contain {expected_function}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 2: Formula contains NETWORKDAYS function call structure
                # NETWORKDAYS can have 2 or 3 parameters: NETWORKDAYS(start_date, end_date) or NETWORKDAYS(start_date, end_date, holidays)
                networkdays_pattern = r'NETWORKDAYS\s*\([^)]+\)'
                networkdays_match = re.search(networkdays_pattern, formula_text, re.IGNORECASE)
                if not networkdays_match:
                    logger.warning(f"Cell {cell_coord} formula does not have correct NETWORKDAYS structure")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: Formula references the corresponding start date column cell (A2, A3, etc.)
                expected_start_cell = f"{start_date_column}{row_num}"
                start_cell_pattern = rf'{start_date_column}{row_num}\b'
                if not re.search(start_cell_pattern, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {cell_coord} formula does not reference start date cell {expected_start_cell}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: Formula references the corresponding end date column cell (B2, B3, etc.)
                expected_end_cell = f"{end_date_column}{row_num}"
                end_cell_pattern = rf'{end_date_column}{row_num}\b'
                if not re.search(end_cell_pattern, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {cell_coord} formula does not reference end date cell {expected_end_cell}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                logger.info(f"✓ Cell {cell_coord} has valid NETWORKDAYS formula: {formula_text}")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        if all_passed:
            logger.info("=" * 60)
            logger.info(f"✓ All cells in column {check_column} contain correct {expected_function} formulas")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ {expected_function} formula verification failed")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_conditional_formatting_reconciliation(result: str, expected: str = None, **options) -> float:
    """
    Verify if conditional formatting is correctly set up for reconciliation between two tables.
    
    This function checks:
    1. Whether conditional formatting rules exist in the worksheet
    2. Whether the formula matches the expected pattern (e.g., A1<>E1 to compare cells from two tables)
    3. Whether conditional formatting is applied to the correct range
    4. Whether cells with differences are formatted (highlighted)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_range: Range where conditional formatting should be applied (e.g., "A1:C16")
            - compare_range: Range to compare against (e.g., "E1:G16")
            - expected_formula: Expected formula pattern (e.g., "A1<>E1")
            - format_column: Column to check for formatting (optional, e.g., "B")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        from openpyxl.worksheet.cell_range import CellRange
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_range = options.get('check_range', 'A1:C16')
        compare_range = options.get('compare_range', 'E1:G16')
        expected_formula = options.get('expected_formula', 'A1<>E1')
        format_column = options.get('format_column', None)
        
        logger.info(f"Verifying conditional formatting reconciliation in file: {result}")
        logger.info(f"Check range: {check_range}")
        logger.info(f"Compare range: {compare_range}")
        logger.info(f"Expected formula pattern: {expected_formula}")
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=False)
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check if conditional formatting exists
        conditional_formattings = ws.conditional_formatting
        if not conditional_formattings:
            logger.error("No conditional formatting rules found in the worksheet")
            return 0.0
        
        logger.info(f"Found {len(conditional_formattings)} conditional formatting rule(s)")
        
        # Parse expected formula to extract cell references
        # Expected formula like "A1<>E1" means compare A1 with E1
        expected_formula_clean = expected_formula.replace(" ", "").upper()
        
        # Find matching conditional formatting rule
        found_matching_rule = False
        rule_applied_to_correct_range = False
        
        for fmt in conditional_formattings:
            for rule in fmt.rules:
                # Check if rule has formula
                if not rule.formula:
                    continue
                
                # Check formula pattern
                formula_text = rule.formula[0] if rule.formula else ""
                formula_text_clean = formula_text.replace(" ", "").upper()
                
                logger.debug(f"Checking rule with formula: {formula_text}")
                
                # Check if formula matches expected pattern
                # The formula should contain comparison like A1<>E1, A2<>E2, etc.
                # We need to check if the pattern matches (allowing for relative references)
                if "<>" in expected_formula_clean:
                    # Extract cell references from expected formula
                    # Pattern: A1<>E1 means compare A column with E column
                    expected_parts = expected_formula_clean.split("<>")
                    if len(expected_parts) == 2:
                        expected_cell1 = expected_parts[0]  # e.g., "A1"
                        expected_cell2 = expected_parts[1]   # e.g., "E1"
                        
                        # Extract column letters
                        expected_col1 = re.match(r'([A-Z]+)', expected_cell1)
                        expected_col2 = re.match(r'([A-Z]+)', expected_cell2)
                        
                        if expected_col1 and expected_col2:
                            col1 = expected_col1.group(1)
                            col2 = expected_col2.group(1)
                            
                            # Check if formula contains comparison between these columns
                            # Pattern should be like: A1<>E1, A2<>E2, etc. (relative references)
                            pattern1 = rf'{col1}\d+\s*<>\s*{col2}\d+'
                            pattern2 = rf'{col1}\d+\s*!=\s*{col2}\d+'  # Alternative: !=
                            
                            if re.search(pattern1, formula_text_clean, re.IGNORECASE) or \
                               re.search(pattern2, formula_text_clean, re.IGNORECASE):
                                found_matching_rule = True
                                logger.info(f"✓ Found matching formula pattern: {formula_text}")
                                
                                # Check if rule is applied to correct range
                                fmt_ranges = [str(rng) for rng in fmt.cells]
                                check_range_upper = check_range.upper()
                                
                                # Check if check_range is covered by any of the formatting ranges
                                try:
                                    check_cell_range = CellRange(check_range_upper)
                                    for fmt_range_str in fmt_ranges:
                                        fmt_cell_range = CellRange(fmt_range_str)
                                        # Check if check_range is within or overlaps with fmt_range
                                        if (check_cell_range.min_row >= fmt_cell_range.min_row and
                                            check_cell_range.max_row <= fmt_cell_range.max_row and
                                            check_cell_range.min_col >= fmt_cell_range.min_col and
                                            check_cell_range.max_col <= fmt_cell_range.max_col):
                                            rule_applied_to_correct_range = True
                                            logger.info(f"✓ Rule applied to correct range: {fmt_range_str} covers {check_range}")
                                            break
                                except Exception as e:
                                    logger.debug(f"Error parsing ranges: {e}")
                                    # If range parsing fails, check if range string matches
                                    if check_range_upper in fmt_ranges:
                                        rule_applied_to_correct_range = True
                                        logger.info(f"✓ Rule applied to exact range: {check_range}")
                                
                                break
            
            if found_matching_rule:
                break
        
        if not found_matching_rule:
            logger.error("No conditional formatting rule found with expected formula pattern")
            return 0.0
        
        if not rule_applied_to_correct_range:
            logger.warning("Conditional formatting rule found but may not be applied to correct range")
            # Don't fail completely, as the range might be slightly different but still valid
        
        # Optional: Check if cells with differences are actually formatted
        # This is a more advanced check that verifies the formatting is working
        if format_column:
            logger.info(f"Checking formatting in column {format_column}...")
            # Try to find cells in format_column that have conditional formatting applied
            # This is a simplified check - in practice, we'd need to evaluate the formula
            # for each cell to see if it's formatted
            
        logger.info("=" * 60)
        logger.info("✓ Conditional formatting reconciliation verification passed")
        logger.info("=" * 60)
        return 1.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_right_len_find_extract(result: str, expected: str = None, **options) -> float:
    """
    Verify if RIGHT, LEN, and FIND formulas exist in specified column to extract text.
    
    This function checks:
    1. Whether cells in specified column contain RIGHT, LEN, and FIND functions
    2. Whether formulas reference the corresponding source column cell (C2->B2, C3->B3, etc.)
    3. Whether formulas contain the correct pattern (e.g., RIGHT(B2,LEN(B2)-FIND("班",B2)))
    4. Whether formulas have the correct structure with RIGHT, LEN, and FIND functions
    
    The function automatically detects the number of data rows by checking the data column
    (default: B column) for non-empty cells. It stops checking after finding 3 consecutive
    empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_column: Column to check (e.g., "C")
            - start_row: Starting row number (default: 2)
            - expected_functions: List of expected function names (e.g., ["RIGHT", "LEN", "FIND"])
            - expected_formula_pattern: Expected formula pattern (e.g., "RIGHT(B")
            - find_text: Text to find in FIND function (e.g., "班")
            - data_column: Column to check for data to determine end_row (default: "B")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_column = options.get('check_column', 'C')
        start_row = options.get('start_row', 2)
        expected_functions = options.get('expected_functions', ['RIGHT', 'LEN', 'FIND'])
        expected_formula_pattern = options.get('expected_formula_pattern', 'RIGHT(B')
        find_text = options.get('find_text', '班')
        data_column = options.get('data_column', 'B')
        
        logger.info(f"Verifying RIGHT/LEN/FIND extraction formulas in file: {result}")
        logger.info(f"Column to check: {check_column}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Expected functions: {expected_functions}")
        logger.info(f"Expected formula pattern: {expected_formula_pattern}")
        logger.info(f"Find text: {find_text}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row  # Start from start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Check each row in the specified column
        all_passed = True
        logger.info(f"Checking column {check_column} (rows {start_row} to {end_row})")
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{check_column}{row_num}"
            try:
                cell = ws[cell_coord]
                logger.debug(f"Checking cell {cell_coord}")
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.warning(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                else:
                    # Try to get from value attribute
                    if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                # Remove leading = if present for comparison
                formula_clean = formula_text.lstrip("=")
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains all expected functions
                for func_name in expected_functions:
                    if func_name.upper() not in formula_upper:
                        logger.warning(f"Cell {cell_coord} formula does not contain {func_name}")
                        logger.warning(f"Formula: {formula_text}")
                        all_passed = False
                        break
                
                if not all_passed:
                    continue
                
                # Check 2: Formula contains expected formula pattern (e.g., RIGHT(B)
                if expected_formula_pattern.upper() not in formula_upper:
                    logger.warning(f"Cell {cell_coord} formula does not contain pattern '{expected_formula_pattern}'")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: Formula contains RIGHT function call structure
                right_match = re.search(r'RIGHT\s*\([^)]+\)', formula_text, re.IGNORECASE)
                if not right_match:
                    logger.warning(f"Cell {cell_coord} formula does not have correct RIGHT structure")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: Formula contains LEN function
                len_match = re.search(r'LEN\s*\([^)]+\)', formula_text, re.IGNORECASE)
                if not len_match:
                    logger.warning(f"Cell {cell_coord} formula does not have LEN function")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 5: Formula contains FIND function with find_text
                find_pattern = rf'FIND\s*\([^)]*{re.escape(find_text)}[^)]*\)'
                find_match = re.search(find_pattern, formula_text, re.IGNORECASE)
                if not find_match:
                    logger.warning(f"Cell {cell_coord} formula does not contain FIND function with text '{find_text}'")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 6: Formula references the corresponding source column cell (B2, B3, etc.)
                expected_source_cell = f"{data_column}{row_num}"
                source_cell_pattern = rf'{data_column}{row_num}\b'
                if not re.search(source_cell_pattern, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {cell_coord} formula does not reference source cell {expected_source_cell}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 7: Formula structure should be RIGHT(B2, LEN(B2)-FIND("班",B2))
                # Verify that LEN and FIND are used together in the second parameter of RIGHT
                # This is a pattern check - the formula should have LEN(...)-FIND(...) structure
                len_find_pattern = r'LEN\s*\([^)]+\)\s*-\s*FIND\s*\([^)]+\)'
                if not re.search(len_find_pattern, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {cell_coord} formula does not have LEN(...)-FIND(...) structure")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                logger.info(f"✓ Cell {cell_coord} has valid RIGHT/LEN/FIND formula: {formula_text}")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        if all_passed:
            logger.info("=" * 60)
            logger.info(f"✓ All cells in column {check_column} contain correct RIGHT/LEN/FIND formulas")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ RIGHT/LEN/FIND formula verification failed")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_iferror_regex_extract(result: str, expected: str = None, **options) -> float:
    """
    Verify if IFERROR(REGEX(...)) formulas exist in specified column to extract text with error handling.
    
    This function checks:
    1. Whether cells in specified column contain IFERROR function wrapping REGEX
    2. Whether REGEX function uses capture group pattern (e.g., .*水笔(\d+).*)
    3. Whether REGEX function uses replacement pattern (e.g., $1元)
    4. Whether IFERROR has empty string as second parameter
    5. Whether formulas reference the corresponding source column cell
    
    The function automatically detects the number of data rows by checking the data column
    for non-empty cells. It stops checking after finding 3 consecutive empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_column: Column to check (e.g., "C")
            - start_row: Starting row number (default: 2)
            - expected_pattern_text: Expected text pattern in regex (e.g., "水笔")
            - data_column: Column to check for data to determine end_row (default: "B")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_column = options.get('check_column', 'C')
        start_row = options.get('start_row', 2)
        expected_pattern_text = options.get('expected_pattern_text', '水笔')
        data_column = options.get('data_column', 'B')
        
        logger.info(f"Verifying IFERROR(REGEX(...)) formulas in file: {result}")
        logger.info(f"Column to check: {check_column}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Expected pattern text: {expected_pattern_text}")
        logger.info(f"Data column: {data_column}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row  # Start from start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Check each row in the specified column
        all_passed = True
        logger.info(f"Checking column {check_column} (rows {start_row} to {end_row})")
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{check_column}{row_num}"
            try:
                cell = ws[cell_coord]
                logger.debug(f"Checking cell {cell_coord}")
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.warning(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                else:
                    # Try to get from value attribute
                    if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains IFERROR function
                if 'IFERROR' not in formula_upper:
                    logger.warning(f"Cell {cell_coord} formula does not contain IFERROR function")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 2: Formula contains REGEX function (inside IFERROR)
                # Support both REGEX and LibreOffice internal format _xlfn.ORG.LIBREOFFICE.REGEX
                has_regex = 'REGEX' in formula_upper or '_XLFN.ORG.LIBREOFFICE.REGEX' in formula_upper
                if not has_regex:
                    logger.warning(f"Cell {cell_coord} formula does not contain REGEX function")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: IFERROR structure - should have two parameters
                iferror_match = re.search(r'IFERROR\s*\([^)]+\)', formula_text, re.IGNORECASE)
                if not iferror_match:
                    logger.warning(f"Cell {cell_coord} formula does not have correct IFERROR structure")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: IFERROR second parameter should be empty string ""
                # Handle various formats: ,"" or , "" or ,'' or , ''
                # Also handle LibreOffice format with spaces: REGEX(...) ,""
                # Extract IFERROR parameters: IFERROR(param1, param2)
                iferror_params_match = re.search(r'IFERROR\s*\((.*)\)', formula_text, re.IGNORECASE)
                if iferror_params_match:
                    params_str = iferror_params_match.group(1)
                    # Split by comma, but need to handle nested commas in strings
                    # Simple approach: find the last comma (should separate the two parameters)
                    # For IFERROR(REGEX(...), ""), the last comma separates REGEX call from ""
                    last_comma_pos = params_str.rfind(',')
                    if last_comma_pos != -1:
                        second_param = params_str[last_comma_pos + 1:].strip()
                        # Check if second parameter is empty string "" or ''
                        if second_param in ['""', "''", '""', "''"]:
                            has_empty_string = True
                        else:
                            has_empty_string = False
                    else:
                        has_empty_string = False
                else:
                    has_empty_string = False
                
                if not has_empty_string:
                    logger.warning(f"Cell {cell_coord} IFERROR should have empty string as second parameter")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 5: REGEX function call structure
                # Support both REGEX and LibreOffice internal format
                regex_match = re.search(r'(REGEX|_XLFN\.ORG\.LIBREOFFICE\.REGEX)\s*\([^)]+\)', formula_text, re.IGNORECASE)
                if not regex_match:
                    logger.warning(f"Cell {cell_coord} formula does not have correct REGEX structure")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 6: Formula contains expected pattern text (e.g., "水笔")
                if expected_pattern_text not in formula_text:
                    logger.warning(f"Cell {cell_coord} formula does not contain pattern text '{expected_pattern_text}'")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 7: Formula contains capture group pattern (\d+)
                has_capture_group = bool(re.search(r'\(\\d\+\)|\(\\\\d\+\)', formula_text))
                if not has_capture_group:
                    logger.warning(f"Cell {cell_coord} REGEX formula should contain capture group (\\d+)")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 8: Formula contains replacement pattern $1
                has_replacement = '"$1' in formula_text or "'$1" in formula_text
                if not has_replacement:
                    logger.warning(f"Cell {cell_coord} REGEX formula should contain replacement pattern $1")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 9: Formula references the corresponding source column cell
                expected_source_cell = f"{data_column}{row_num}"
                source_cell_pattern = rf'{data_column}{row_num}\b'
                if not re.search(source_cell_pattern, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {cell_coord} formula does not reference source cell {expected_source_cell}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                logger.info(f"✓ Cell {cell_coord} has valid IFERROR(REGEX(...)) formula: {formula_text}")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        if all_passed:
            logger.info("=" * 60)
            logger.info(f"✓ All cells in column {check_column} contain correct IFERROR(REGEX(...)) formulas")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ IFERROR(REGEX(...)) formula verification failed")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_rept_text_progress_bar(result: str, expected: str = None, **options) -> float:
    """
    Verify if REPT and TEXT formulas exist in specified column to create progress bars with percentage.
    
    This function checks:
    1. Whether cells in specified column contain REPT and TEXT functions
    2. Whether REPT function uses the correct character (e.g., "|")
    3. Whether REPT function uses the correct multiplier (e.g., *50)
    4. Whether TEXT function uses percentage format (e.g., "0%")
    5. Whether formulas reference the correct numerator and denominator columns
    6. Whether formulas use & operator to concatenate REPT and TEXT results
    
    The function automatically detects the number of data rows by checking the data column
    for non-empty cells. It stops checking after finding 3 consecutive empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_column: Column to check (e.g., "D")
            - start_row: Starting row number (default: 2)
            - expected_functions: List of expected function names (e.g., ["REPT", "TEXT"])
            - numerator_column: Column containing numerator values (e.g., "C")
            - denominator_column: Column containing denominator values (e.g., "B")
            - rept_char: Character to repeat in REPT function (e.g., "|")
            - rept_multiplier: Multiplier for REPT function (e.g., 50)
            - data_column: Column to check for data to determine end_row (default: "B")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_column = options.get('check_column', 'D')
        start_row = options.get('start_row', 2)
        expected_functions = options.get('expected_functions', ['REPT', 'TEXT'])
        numerator_column = options.get('numerator_column', 'C')
        denominator_column = options.get('denominator_column', 'B')
        rept_char = options.get('rept_char', '|')
        rept_multiplier = options.get('rept_multiplier', 50)
        data_column = options.get('data_column', 'B')
        
        logger.info(f"Verifying REPT/TEXT progress bar formulas in file: {result}")
        logger.info(f"Column to check: {check_column}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Expected functions: {expected_functions}")
        logger.info(f"Numerator column: {numerator_column}")
        logger.info(f"Denominator column: {denominator_column}")
        logger.info(f"REPT character: {rept_char}")
        logger.info(f"REPT multiplier: {rept_multiplier}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row  # Start from start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Check each row in the specified column
        all_passed = True
        logger.info(f"Checking column {check_column} (rows {start_row} to {end_row})")
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{check_column}{row_num}"
            try:
                cell = ws[cell_coord]
                logger.debug(f"Checking cell {cell_coord}")
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.warning(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                else:
                    # Try to get from value attribute
                    if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains all expected functions (REPT and TEXT)
                for func_name in expected_functions:
                    if func_name.upper() not in formula_upper:
                        logger.warning(f"Cell {cell_coord} formula does not contain {func_name}")
                        logger.warning(f"Formula: {formula_text}")
                        all_passed = False
                        break
                
                if not all_passed:
                    continue
                
                # Check 2: Formula contains REPT function call structure
                rept_match = re.search(r'REPT\s*\([^)]+\)', formula_text, re.IGNORECASE)
                if not rept_match:
                    logger.warning(f"Cell {cell_coord} formula does not have correct REPT structure")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: REPT function contains the correct character (e.g., "|")
                # Support both double quotes and single quotes
                rept_char_pattern1 = rf'REPT\s*\(\s*"{re.escape(rept_char)}"'
                rept_char_pattern2 = rf"REPT\s*\(\s*'{re.escape(rept_char)}'"
                if not re.search(rept_char_pattern1, formula_text, re.IGNORECASE) and \
                   not re.search(rept_char_pattern2, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {cell_coord} REPT function should use character '{rept_char}'")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: REPT function contains the multiplier (e.g., *50)
                rept_multiplier_pattern = rf'\*{rept_multiplier}\b'
                if not re.search(rept_multiplier_pattern, formula_text):
                    logger.warning(f"Cell {cell_coord} REPT function should use multiplier *{rept_multiplier}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 5: Formula contains TEXT function call structure
                text_match = re.search(r'TEXT\s*\([^)]+\)', formula_text, re.IGNORECASE)
                if not text_match:
                    logger.warning(f"Cell {cell_coord} formula does not have correct TEXT structure")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 6: TEXT function contains percentage format ("0%" or '0%')
                text_percent_pattern1 = r'TEXT\s*\([^,]+,\s*"0%"'
                text_percent_pattern2 = r"TEXT\s*\([^,]+,\s*'0%'"
                if not re.search(text_percent_pattern1, formula_text, re.IGNORECASE) and \
                   not re.search(text_percent_pattern2, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {cell_coord} TEXT function should use percentage format \"0%\"")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 7: Formula references the correct numerator column (C2, C3, etc.)
                expected_numerator_cell = f"{numerator_column}{row_num}"
                numerator_cell_pattern = rf'{numerator_column}{row_num}\b'
                if not re.search(numerator_cell_pattern, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {cell_coord} formula does not reference numerator cell {expected_numerator_cell}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 8: Formula references the correct denominator column (B2, B3, etc.)
                expected_denominator_cell = f"{denominator_column}{row_num}"
                denominator_cell_pattern = rf'{denominator_column}{row_num}\b'
                if not re.search(denominator_cell_pattern, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {cell_coord} formula does not reference denominator cell {expected_denominator_cell}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 9: Formula contains & operator to concatenate REPT and TEXT
                if '&' not in formula_text:
                    logger.warning(f"Cell {cell_coord} formula should use & operator to concatenate REPT and TEXT")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 10: Formula structure should be REPT(...)&TEXT(...)
                # Verify that REPT comes before TEXT (or at least both are present)
                rept_pos = formula_text.upper().find('REPT')
                text_pos = formula_text.upper().find('TEXT')
                if rept_pos == -1 or text_pos == -1:
                    logger.warning(f"Cell {cell_coord} formula should contain both REPT and TEXT functions")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                logger.info(f"✓ Cell {cell_coord} has valid REPT/TEXT progress bar formula: {formula_text}")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        if all_passed:
            logger.info("=" * 60)
            logger.info(f"✓ All cells in column {check_column} contain correct REPT/TEXT progress bar formulas")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ REPT/TEXT progress bar formula verification failed")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_id_extract_gender_age_birthday(result: str, expected: str = None, **options) -> float:
    """
    Verify if formulas exist to extract gender, age, and birthday from ID numbers.
    
    This function checks:
    1. Gender column (C): IF(MOD(MID(B3,17,1),2),"男","女")
    2. Age column (D): DATEDIF(TEXT(MID(B3,7,8),"0-00-00"),TODAY(),"Y")
    3. Birthday column (E): --TEXT(MID(B3,7,8),"0-00-00")
    
    The function automatically detects the number of data rows by checking the ID column
    for non-empty cells. It stops checking after finding 3 consecutive empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - id_column: Column containing ID numbers (e.g., "B")
            - gender_column: Column for gender formulas (e.g., "C")
            - age_column: Column for age formulas (e.g., "D")
            - birthday_column: Column for birthday formulas (e.g., "E")
            - start_row: Starting row number (default: 3)
            - data_column: Column to check for data to determine end_row (default: "B")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        id_column = options.get('id_column', 'B')
        gender_column = options.get('gender_column', 'C')
        age_column = options.get('age_column', 'D')
        birthday_column = options.get('birthday_column', 'E')
        start_row = options.get('start_row', 3)
        data_column = options.get('data_column', 'B')
        
        logger.info(f"Verifying ID extraction formulas in file: {result}")
        logger.info(f"ID column: {id_column}")
        logger.info(f"Gender column: {gender_column}")
        logger.info(f"Age column: {age_column}")
        logger.info(f"Birthday column: {birthday_column}")
        logger.info(f"Start row: {start_row}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row  # Start from start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Check each row
        all_passed = True
        logger.info(f"Checking rows {start_row} to {end_row}")
        
        for row_num in range(start_row, end_row + 1):
            try:
                # Check gender column (C)
                gender_cell_coord = f"{gender_column}{row_num}"
                gender_cell = ws[gender_cell_coord]
                
                if gender_cell.data_type != "f":
                    logger.warning(f"Cell {gender_cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                gender_formula_text = None
                if hasattr(gender_cell, "_value") and isinstance(gender_cell._value, str) and gender_cell._value.startswith("="):
                    gender_formula_text = gender_cell._value
                elif hasattr(gender_cell, "formula"):
                    gender_formula_text = gender_cell.formula
                elif gender_cell.value is not None and isinstance(gender_cell.value, str) and gender_cell.value.startswith("="):
                    gender_formula_text = gender_cell.value
                
                if gender_formula_text is None:
                    logger.warning(f"Could not extract formula from cell {gender_cell_coord}")
                    all_passed = False
                    continue
                
                gender_formula_upper = gender_formula_text.upper()
                logger.debug(f"Cell {gender_cell_coord} formula: {gender_formula_text}")
                
                # Check gender formula: IF(MOD(MID(B3,17,1),2),"男","女")
                if 'IF' not in gender_formula_upper:
                    logger.warning(f"Cell {gender_cell_coord} formula does not contain IF function")
                    all_passed = False
                    continue
                
                if 'MOD' not in gender_formula_upper:
                    logger.warning(f"Cell {gender_cell_coord} formula does not contain MOD function")
                    all_passed = False
                    continue
                
                if 'MID' not in gender_formula_upper:
                    logger.warning(f"Cell {gender_cell_coord} formula does not contain MID function")
                    all_passed = False
                    continue
                
                # Check MID(B3,17,1) pattern
                mid_pattern = rf'MID\s*\(\s*{id_column}{row_num}\s*,\s*17\s*,\s*1\s*\)'
                if not re.search(mid_pattern, gender_formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {gender_cell_coord} formula should contain MID({id_column}{row_num},17,1)")
                    logger.warning(f"Formula: {gender_formula_text}")
                    all_passed = False
                    continue
                
                # Check for "男" and "女" in formula
                if '"男"' not in gender_formula_text and "'男'" not in gender_formula_text:
                    logger.warning(f"Cell {gender_cell_coord} formula should contain \"男\"")
                    logger.warning(f"Formula: {gender_formula_text}")
                    all_passed = False
                    continue
                
                if '"女"' not in gender_formula_text and "'女'" not in gender_formula_text:
                    logger.warning(f"Cell {gender_cell_coord} formula should contain \"女\"")
                    logger.warning(f"Formula: {gender_formula_text}")
                    all_passed = False
                    continue
                
                logger.info(f"✓ Cell {gender_cell_coord} has valid gender formula: {gender_formula_text}")
                
                # Check age column (D)
                age_cell_coord = f"{age_column}{row_num}"
                age_cell = ws[age_cell_coord]
                
                if age_cell.data_type != "f":
                    logger.warning(f"Cell {age_cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                age_formula_text = None
                if hasattr(age_cell, "_value") and isinstance(age_cell._value, str) and age_cell._value.startswith("="):
                    age_formula_text = age_cell._value
                elif hasattr(age_cell, "formula"):
                    age_formula_text = age_cell.formula
                elif age_cell.value is not None and isinstance(age_cell.value, str) and age_cell.value.startswith("="):
                    age_formula_text = age_cell.value
                
                if age_formula_text is None:
                    logger.warning(f"Could not extract formula from cell {age_cell_coord}")
                    all_passed = False
                    continue
                
                age_formula_upper = age_formula_text.upper()
                logger.debug(f"Cell {age_cell_coord} formula: {age_formula_text}")
                
                # Check age formula: DATEDIF(TEXT(MID(B3,7,8),"0-00-00"),TODAY(),"Y")
                if 'DATEDIF' not in age_formula_upper:
                    logger.warning(f"Cell {age_cell_coord} formula does not contain DATEDIF function")
                    all_passed = False
                    continue
                
                if 'TEXT' not in age_formula_upper:
                    logger.warning(f"Cell {age_cell_coord} formula does not contain TEXT function")
                    all_passed = False
                    continue
                
                if 'TODAY' not in age_formula_upper:
                    logger.warning(f"Cell {age_cell_coord} formula does not contain TODAY function")
                    all_passed = False
                    continue
                
                if 'MID' not in age_formula_upper:
                    logger.warning(f"Cell {age_cell_coord} formula does not contain MID function")
                    all_passed = False
                    continue
                
                # Check MID(B3,7,8) pattern
                mid_pattern_age = rf'MID\s*\(\s*{id_column}{row_num}\s*,\s*7\s*,\s*8\s*\)'
                if not re.search(mid_pattern_age, age_formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {age_cell_coord} formula should contain MID({id_column}{row_num},7,8)")
                    logger.warning(f"Formula: {age_formula_text}")
                    all_passed = False
                    continue
                
                # Check TEXT format "0-00-00"
                # Use pattern that matches until the quote to handle nested functions like MID(B3,7,8)
                text_format_pattern1 = r'TEXT\s*\([^"]+,\s*"0-00-00"'
                text_format_pattern2 = r"TEXT\s*\([^']+,\s*'0-00-00'"
                if not re.search(text_format_pattern1, age_formula_text, re.IGNORECASE) and \
                   not re.search(text_format_pattern2, age_formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {age_cell_coord} TEXT function should use format \"0-00-00\"")
                    logger.warning(f"Formula: {age_formula_text}")
                    all_passed = False
                    continue
                
                # Check DATEDIF third parameter "Y"
                # Use a more flexible pattern that handles nested functions
                # Check if DATEDIF contains "Y" as the third parameter (after two commas)
                # Pattern: DATEDIF(...,...,"Y") or DATEDIF(...,...,'Y')
                # We'll count commas to find the third parameter
                datedif_match = re.search(r'DATEDIF\s*\((.*)\)', age_formula_text, re.IGNORECASE)
                if datedif_match:
                    datedif_params = datedif_match.group(1)
                    # Count commas to find the third parameter
                    # Simple approach: check if the last part before closing paren is "Y" or 'Y'
                    # More robust: find the pattern ,"Y" or ,'Y' before the closing paren
                    if not re.search(r',\s*"Y"\s*\)', age_formula_text, re.IGNORECASE) and \
                       not re.search(r",\s*'Y'\s*\)", age_formula_text, re.IGNORECASE):
                        logger.warning(f"Cell {age_cell_coord} DATEDIF function should use \"Y\" parameter")
                        logger.warning(f"Formula: {age_formula_text}")
                        all_passed = False
                        continue
                else:
                    logger.warning(f"Cell {age_cell_coord} could not parse DATEDIF function")
                    logger.warning(f"Formula: {age_formula_text}")
                    all_passed = False
                    continue
                
                logger.info(f"✓ Cell {age_cell_coord} has valid age formula: {age_formula_text}")
                
                # Check birthday column (E)
                birthday_cell_coord = f"{birthday_column}{row_num}"
                birthday_cell = ws[birthday_cell_coord]
                
                if birthday_cell.data_type != "f":
                    logger.warning(f"Cell {birthday_cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                birthday_formula_text = None
                if hasattr(birthday_cell, "_value") and isinstance(birthday_cell._value, str) and birthday_cell._value.startswith("="):
                    birthday_formula_text = birthday_cell._value
                elif hasattr(birthday_cell, "formula"):
                    birthday_formula_text = birthday_cell.formula
                elif birthday_cell.value is not None and isinstance(birthday_cell.value, str) and birthday_cell.value.startswith("="):
                    birthday_formula_text = birthday_cell.value
                
                if birthday_formula_text is None:
                    logger.warning(f"Could not extract formula from cell {birthday_cell_coord}")
                    all_passed = False
                    continue
                
                birthday_formula_upper = birthday_formula_text.upper()
                logger.debug(f"Cell {birthday_cell_coord} formula: {birthday_formula_text}")
                
                # Check birthday formula: TEXT(MID(B3,7,8),"0-00-00")
                if 'TEXT' not in birthday_formula_upper:
                    logger.warning(f"Cell {birthday_cell_coord} formula does not contain TEXT function")
                    all_passed = False
                    continue
                
                if 'MID' not in birthday_formula_upper:
                    logger.warning(f"Cell {birthday_cell_coord} formula does not contain MID function")
                    all_passed = False
                    continue
                
                # Check MID(B3,7,8) pattern
                mid_pattern_birthday = rf'MID\s*\(\s*{id_column}{row_num}\s*,\s*7\s*,\s*8\s*\)'
                if not re.search(mid_pattern_birthday, birthday_formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {birthday_cell_coord} formula should contain MID({id_column}{row_num},7,8)")
                    logger.warning(f"Formula: {birthday_formula_text}")
                    all_passed = False
                    continue
                
                # Check TEXT format "0-00-00"
                # Use pattern that matches until the quote to handle nested functions like MID(B3,7,8)
                text_format_pattern1 = r'TEXT\s*\([^"]+,\s*"0-00-00"'
                text_format_pattern2 = r"TEXT\s*\([^']+,\s*'0-00-00'"
                if not re.search(text_format_pattern1, birthday_formula_text, re.IGNORECASE) and \
                   not re.search(text_format_pattern2, birthday_formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {birthday_cell_coord} TEXT function should use format \"0-00-00\"")
                    logger.warning(f"Formula: {birthday_formula_text}")
                    all_passed = False
                    continue
                
                logger.info(f"✓ Cell {birthday_cell_coord} has valid birthday formula: {birthday_formula_text}")
                
            except Exception as e:
                logger.error(f"Error checking row {row_num}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        if all_passed:
            logger.info("=" * 60)
            logger.info(f"✓ All rows contain correct ID extraction formulas (gender, age, birthday)")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ ID extraction formula verification failed")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_line_chart(result: str, expected: str = None, **options) -> float:
    """
    Verify if a line chart exists in the Excel file.
    
    This function checks:
    1. Whether at least one chart exists in the worksheet
    2. Whether the chart type is lineChart
    3. Whether the chart has the expected number of series
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - expected_chart_type: Expected chart type (default: "lineChart")
            - min_series_count: Minimum number of series expected (default: 1)
            - data_range: Data range used for chart (optional, for logging)
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        expected_chart_type = options.get('expected_chart_type', 'lineChart')
        min_series_count = options.get('min_series_count', 1)
        data_range = options.get('data_range', '')
        
        logger.info(f"Verifying line chart in file: {result}")
        logger.info(f"Expected chart type: {expected_chart_type}")
        logger.info(f"Minimum series count: {min_series_count}")
        if data_range:
            logger.info(f"Data range: {data_range}")
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result)
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check if charts exist
        charts = ws._charts
        if not charts or len(charts) == 0:
            logger.error("No charts found in the worksheet")
            return 0.0
        
        logger.info(f"Found {len(charts)} chart(s) in the worksheet")
        
        # Check each chart
        for chart_idx, chart in enumerate(charts):
            logger.info(f"Checking chart {chart_idx + 1}...")
            
            # Check chart type
            chart_type = None
            if hasattr(chart, 'tagname'):
                chart_type = chart.tagname
            logger.info(f"Chart type: {chart_type}")
            
            # Check if it's a line chart
            if chart_type and expected_chart_type.lower() in chart_type.lower():
                logger.info(f"✓ Chart {chart_idx + 1} is a line chart")
                
                # Check if it has series
                if not hasattr(chart, 'series') or not chart.series:
                    logger.warning(f"Chart {chart_idx + 1} has no series")
                    continue
                
                series_count = len(chart.series)
                logger.info(f"Chart {chart_idx + 1} has {series_count} series")
                
                # Verify series count
                if series_count >= min_series_count:
                    logger.info("=" * 60)
                    logger.info(f"✓ Line chart verification passed")
                    logger.info(f"  Chart type: {chart_type}")
                    logger.info(f"  Series count: {series_count} (minimum required: {min_series_count})")
                    logger.info("=" * 60)
                    return 1.0
                else:
                    logger.warning(f"Chart {chart_idx + 1} has {series_count} series, but minimum required is {min_series_count}")
            else:
                logger.warning(f"Chart {chart_idx + 1} is not a line chart (type: {chart_type})")
        
        # If we get here, verification failed
        logger.error("=" * 60)
        logger.error(f"✗ Line chart verification failed")
        logger.error(f"  Expected chart type: {expected_chart_type}")
        logger.error(f"  Minimum series count: {min_series_count}")
        logger.error("=" * 60)
        return 0.0
             
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_salary_growth_chart(result: str, expected: str = None, **options) -> float:
    """
    Verify if the salary growth chart matches the expected specifications.
    
    This function checks the chart itself (not the data table):
    1. Whether a chart exists in the specified sheet
    2. Whether the chart title matches "店长工资增长"
    3. Whether the chart has the expected number of series (at least 3)
    4. Whether the chart is a combination chart (bar + line)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - sheet_idx: Sheet index (default: 0)
            - expected_title: Expected chart title (default: "店长工资增长")
            - min_series_count: Minimum number of series (default: 3)
            - chart_type: Expected chart type (default: "combination")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        sheet_idx = options.get('sheet_idx', 0)
        expected_title = options.get('expected_title', '店长工资增长')
        min_series_count = options.get('min_series_count', 3)
        chart_type = options.get('chart_type', 'combination')
        
        logger.info(f"Verifying salary growth chart in file: {result}")
        logger.info(f"Sheet index: {sheet_idx}")
        logger.info(f"Expected title: {expected_title}")
        logger.info(f"Min series count: {min_series_count}")
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result)
            pdworkbook = pd.ExcelFile(result)
            sheet_names = pdworkbook.sheet_names
            
            if sheet_idx >= len(sheet_names):
                logger.error(f"Sheet index {sheet_idx} out of range. Available sheets: {sheet_names}")
                return 0.0
            
            sheet_name = sheet_names[sheet_idx]
            logger.info(f"Checking sheet: {sheet_name}")
            ws = wb[sheet_name]
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return 0.0
        
        # Check if charts exist
        charts = ws._charts
        if not charts:
            logger.error("No charts found in the sheet")
            return 0.0
        
        logger.info(f"Found {len(charts)} chart(s) in the sheet")
        
        # Load chart information
        chart_props = ['title', 'type', 'legend', 'xtitle', 'ytitle']
        chart_info = load_charts(wb, sheet_name, chart_props=chart_props)
        
        if not chart_info:
            logger.error("Could not load chart information")
            return 0.0
        
        # Check each chart
        chart_passed = False
        for chart_key, chart_data in chart_info.items():
            logger.info(f"Checking chart: {chart_key}")
            logger.debug(f"Chart data: {chart_data}")
            
            # Check 1: Chart title
            chart_title = chart_data.get('title')
            if chart_title != expected_title:
                logger.warning(f"Chart title mismatch: expected '{expected_title}', got '{chart_title}'")
                continue
            else:
                logger.info(f"✓ Chart title matches: {chart_title}")
            
            # Check 2: Chart type (for combination charts, we might see multiple types)
            chart_type_actual = chart_data.get('type')
            logger.info(f"Chart type: {chart_type_actual}")
            # Note: Combination charts might be represented differently in openpyxl
            # We'll be lenient here and just check that a chart exists
            
            # Check 3: Number of series
            # Extract series count from chart_key (format: "value_ref1,category_ref1;value_ref2,category_ref2;...")
            series_parts = chart_key.split(';')
            series_count = len(series_parts)
            logger.info(f"Number of series: {series_count}")
            
            if series_count < min_series_count:
                logger.warning(f"Insufficient series count: expected at least {min_series_count}, got {series_count}")
                continue
            else:
                logger.info(f"✓ Series count sufficient: {series_count} >= {min_series_count}")
            
            # If we get here, this chart passed all checks
            chart_passed = True
            logger.info("=" * 60)
            logger.info(f"✓ Chart verification passed!")
            logger.info("=" * 60)
            break
        
        if chart_passed:
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error("✗ Chart verification failed - no chart matched all criteria")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_project_completion_chart(result: str, expected: str = None, **options) -> float:
    """
    Verify if a combination chart exists with the expected title that contains
    both bar chart series (for project values) and line chart series (for completion rates).
    
    This function checks:
    1. Whether at least one chart exists in the worksheet
    2. Whether the chart title matches expected_title
    3. Whether the chart has at least 16 series (8 projects + 8 completion rates)
    4. Whether at least one series name contains "rate" (for completion rates)
    5. Whether the chart has at least project_count * 5 categories (for 5 quarters per project)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - sheet_idx: Sheet index to check (default: 0)
            - expected_title: Expected chart title (default: "项目")
            - min_series_count: Minimum number of series required (default: 16)
            - project_count: Number of projects (default: 8)
            - quarters_per_project: Number of quarters per project (default: 5)
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        sheet_idx = options.get('sheet_idx', 0)
        expected_title = options.get('expected_title', '项目')
        min_series_count = options.get('min_series_count', 16)
        project_count = options.get('project_count', 8)
        quarters_per_project = options.get('quarters_per_project', 5)
        min_categories = project_count * quarters_per_project
        
        logger.info(f"Verifying project completion chart in file: {result}")
        logger.info(f"Sheet index: {sheet_idx}")
        logger.info(f"Expected title: {expected_title}")
        logger.info(f"Minimum series count: {min_series_count}")
        logger.info(f"Project count: {project_count}")
        logger.info(f"Quarters per project: {quarters_per_project}")
        logger.info(f"Minimum categories: {min_categories}")
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result)
            sheet_names = wb.sheetnames
            if sheet_idx >= len(sheet_names):
                logger.error(f"Sheet index {sheet_idx} out of range. Available sheets: {sheet_names}")
                return 0.0
            sheet_name = sheet_names[sheet_idx]
            ws = wb[sheet_name]
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check if charts exist
        charts = ws._charts
        if not charts:
            logger.error("No charts found in the worksheet")
            return 0.0
        
        logger.info(f"Found {len(charts)} chart(s) in the worksheet")
        
        # Check each chart
        chart_found = False
        for chart in charts:
            # Check chart title
            chart_title = None
            try:
                if chart.title and chart.title.tx:
                    if hasattr(chart.title.tx, 'rich') and chart.title.tx.rich:
                        if hasattr(chart.title.tx.rich, 'p') and chart.title.tx.rich.p:
                            if len(chart.title.tx.rich.p) > 0:
                                if hasattr(chart.title.tx.rich.p[0], 'r') and chart.title.tx.rich.p[0].r:
                                    if len(chart.title.tx.rich.p[0].r) > 0:
                                        if hasattr(chart.title.tx.rich.p[0].r[0], 't'):
                                            chart_title = chart.title.tx.rich.p[0].r[0].t
            except Exception as e:
                logger.debug(f"Error reading chart title: {e}")
            
            logger.info(f"Chart title: {chart_title}")
            
            # Check if title matches
            if chart_title == expected_title:
                logger.info(f"✓ Chart title matches: {chart_title}")
                chart_found = True
                
                # Use load_charts to get all series information (includes both bar and line series)
                # This is more reliable for combination charts
                chart_props = ['title']
                chart_info = load_charts(wb, sheet_name, chart_props=chart_props)
                
                # Find the chart that matches our title
                chart_key = None
                for key, info in chart_info.items():
                    if info.get('title') == expected_title:
                        chart_key = key
                        break
                
                # Get all series from the chart object for detailed inspection
                all_series = list(chart.series) if hasattr(chart, 'series') else []
                logger.info(f"Series count from chart.series: {len(all_series)}")
                
                if not chart_key:
                    logger.warning("Could not find chart in load_charts output, using direct series access")
                    # Fallback to direct series access
                    series_count = len(all_series)
                else:
                    # Extract series count from chart_key (format: "value_ref1,category_ref1;value_ref2,category_ref2;...")
                    # This includes ALL series (both bar and line) in combination charts
                    series_parts = chart_key.split(';')
                    series_count_from_load = len(series_parts)
                    logger.info(f"Series count from load_charts: {series_count_from_load}")
                    
                    # For combination charts, load_charts should give us all series
                    # Use the count from load_charts as it's more reliable for combination charts
                    series_count = series_count_from_load
                    
                    # Also check for sub-charts in case series are stored there
                    if hasattr(chart, '_charts') and chart._charts:
                        # Check for sub-charts (for combination charts)
                        for sub_chart in chart._charts:
                            if hasattr(sub_chart, 'series'):
                                sub_series = list(sub_chart.series)
                                all_series.extend(sub_series)
                                logger.info(f"Found {len(sub_series)} additional series in sub-chart")
                    
                    # If load_charts gave us fewer series than direct access, use the larger count
                    # This handles edge cases where load_charts might miss some series
                    if series_count < len(all_series):
                        logger.warning(f"load_charts found {series_count} series but direct access found {len(all_series)}, using larger count")
                        series_count = len(all_series)
                
                logger.info(f"Chart has {series_count} series (including both bar and line series)")
                
                # Debug: Log all series details
                if all_series:
                    logger.info(f"Detailed series information:")
                    for idx, ser in enumerate(all_series):
                        logger.info(f"  Series {idx}: {type(ser).__name__}")
                        try:
                            if hasattr(ser, 'title'):
                                logger.debug(f"    Title: {ser.title}")
                        except:
                            pass
                
                if series_count < min_series_count:
                    logger.error(f"✗ Chart has only {series_count} series, expected at least {min_series_count}")
                    return 0.0
                
                logger.info(f"✓ Chart has {series_count} series (>= {min_series_count})")
                
                # Check series names for "rate" (completion rate series)
                has_rate_series = False
                series_names = []
                for i, ser in enumerate(all_series):
                    series_name = None
                    try:
                        # Try to get series title/name
                        if hasattr(ser, 'title') and ser.title:
                            if hasattr(ser.title, 'tx') and ser.title.tx:
                                if hasattr(ser.title.tx, 'rich') and ser.title.tx.rich:
                                    if hasattr(ser.title.tx.rich, 'p') and ser.title.tx.rich.p:
                                        if len(ser.title.tx.rich.p) > 0:
                                            if hasattr(ser.title.tx.rich.p[0], 'r') and ser.title.tx.rich.p[0].r:
                                                if len(ser.title.tx.rich.p[0].r) > 0:
                                                    if hasattr(ser.title.tx.rich.p[0].r[0], 't'):
                                                        series_name = ser.title.tx.rich.p[0].r[0].t
                        # Alternative: check if title is a string reference
                        if not series_name and hasattr(ser, 'title') and hasattr(ser.title, 'tx') and hasattr(ser.title.tx, 'strRef'):
                            if hasattr(ser.title.tx.strRef, 'f'):
                                series_name = ser.title.tx.strRef.f
                    except Exception as e:
                        logger.debug(f"Error reading series {i} name: {e}")
                    
                    if series_name:
                        series_names.append(series_name)
                        if "rate" in series_name.lower():
                            has_rate_series = True
                            logger.info(f"✓ Found series with 'rate' in name: {series_name}")
                
                if series_names:
                    logger.info(f"Series names found: {series_names[:10]}...")  # Log first 10
                else:
                    logger.warning("Could not extract series names, will skip rate check")
                
                if not has_rate_series and series_names:
                    logger.error(f"✗ No series found with 'rate' in name. Series names: {series_names}")
                    return 0.0
                elif not has_rate_series:
                    logger.warning("⚠ Could not verify 'rate' in series names (series names not extractable)")
                
                # Check category count
                max_categories = 0
                category_ranges = []
                
                def parse_range_count(range_str):
                    """Parse Excel range string and return count of cells"""
                    try:
                        # Remove sheet name if present (e.g., "Sheet1!$A$2:$A$6" -> "$A$2:$A$6")
                        if '!' in range_str:
                            range_str = range_str.split('!')[1]
                        
                        # Remove $ signs
                        range_str = range_str.replace('$', '')
                        
                        if ':' in range_str:
                            start, end = range_str.split(':')
                            # Parse start and end coordinates
                            # Helper function to parse coordinate like "A1" to (column_index, row_number)
                            from openpyxl.utils import column_index_from_string
                            import re
                            
                            def parse_coordinate(coord):
                                """Parse coordinate string like 'A1' to (column_index, row_number)"""
                                match = re.match(r'([A-Z]+)(\d+)', coord.upper())
                                if match:
                                    col_str, row_str = match.groups()
                                    col_idx = column_index_from_string(col_str)
                                    row_num = int(row_str)
                                    return (col_idx, row_num)
                                raise ValueError(f"Invalid coordinate: {coord}")
                            
                            start_col, start_row = parse_coordinate(start)
                            end_col, end_row = parse_coordinate(end)
                            
                            # Calculate count based on range
                            if start_col == end_col:
                                # Same column, count rows
                                return abs(end_row - start_row) + 1
                            elif start_row == end_row:
                                # Same row, count columns
                                return abs(end_col - start_col) + 1
                            else:
                                # 2D range
                                return (abs(end_row - start_row) + 1) * (abs(end_col - start_col) + 1)
                        else:
                            # Single cell
                            return 1
                    except Exception as e:
                        logger.debug(f"Error parsing range {range_str}: {e}")
                        return 0
                
                for i, ser in enumerate(all_series):
                    try:
                        # Try to get category count from category reference
                        if hasattr(ser, 'cat'):
                            cat_range = None
                            # Check if categories are from a range
                            if hasattr(ser.cat, 'numRef') and hasattr(ser.cat.numRef, 'f'):
                                cat_range = ser.cat.numRef.f
                            elif hasattr(ser.cat, 'strRef') and hasattr(ser.cat.strRef, 'f'):
                                cat_range = ser.cat.strRef.f
                            
                            if cat_range:
                                category_ranges.append(cat_range)
                                cat_count = parse_range_count(cat_range)
                                if cat_count > max_categories:
                                    max_categories = cat_count
                                logger.debug(f"Series {i} category range: {cat_range}, count: {cat_count}")
                    except Exception as e:
                        logger.debug(f"Error reading categories for series {i}: {e}")
                
                if max_categories > 0:
                    logger.info(f"Maximum category count found: {max_categories}")
                    if max_categories < min_categories:
                        logger.error(f"✗ Chart has only {max_categories} categories, expected at least {min_categories} (project_count * quarters_per_project)")
                        return 0.0
                    logger.info(f"✓ Chart has {max_categories} categories (>= {min_categories})")
                else:
                    # If we can't determine category count from ranges, use heuristic
                    # For 8 projects with 5 quarters each, we need at least 40 categories
                    # But since we can't verify directly, we'll log a warning
                    logger.warning(f"⚠ Could not determine exact category count from ranges. Expected at least {min_categories} categories.")
                    logger.info(f"Category ranges found: {category_ranges[:5]}...")  # Log first 5
                
                # Check if it's a combination chart
                if series_count >= 2:
                    logger.info("✓ Chart appears to be a combination chart (has multiple series)")
                else:
                    logger.error(f"✗ Chart has only {series_count} series, expected at least 2 for combination chart")
                    return 0.0
                
                break
        
        if chart_found:
            logger.info("=" * 60)
            logger.info("✓ Project completion combination chart verification passed")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ Chart with title '{expected_title}' not found")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_shipping_boxes_calculation(result: str, expected: str = None, **options) -> float:
    """
    Verify if formulas exist to calculate shipping boxes from product specifications and order quantities.
    
    This function checks:
    1. Whether cells in specified column contain formulas (not just values)
    2. Whether formulas contain required functions: INT, VALUE, LEFT, FIND, MOD, IF
    3. Whether formulas reference the specification column (B) and quantity column (C)
    4. Whether formulas contain Chinese characters "支" and "盒"
    5. Whether formulas use string concatenation (&)
    
    The expected formula pattern:
    =INT(C2/VALUE(LEFT(B2,FIND("支",B2)-1)))&"盒"&IF(MOD(C2,VALUE(LEFT(B2,FIND("支",B2)-1)))=0,"","加"&MOD(C2,VALUE(LEFT(B2,FIND("支",B2)-1)))&"支")
    
    The function automatically detects the number of data rows by checking the data column
    for non-empty cells. It stops checking after finding 3 consecutive empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_column: Column to check (e.g., "D")
            - start_row: Starting row number (default: 2)
            - spec_column: Column containing product specifications (e.g., "B")
            - quantity_column: Column containing order quantities (e.g., "C")
            - expected_functions: List of expected function names (e.g., ["INT", "VALUE", "LEFT", "FIND", "MOD", "IF"])
            - data_column: Column to check for data to determine end_row (default: "B")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_column = options.get('check_column', 'D')
        start_row = options.get('start_row', 2)
        spec_column = options.get('spec_column', 'B')
        quantity_column = options.get('quantity_column', 'C')
        expected_functions = options.get('expected_functions', ['INT', 'VALUE', 'LEFT', 'FIND', 'MOD', 'IF'])
        data_column = options.get('data_column', 'B')
        
        logger.info(f"Verifying shipping boxes calculation formulas in file: {result}")
        logger.info(f"Column to check: {check_column}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Specification column: {spec_column}")
        logger.info(f"Quantity column: {quantity_column}")
        logger.info(f"Expected functions: {expected_functions}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row  # Start from start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        if end_row < start_row:
            logger.error(f"No data rows found starting from row {start_row}")
            return 0.0
        
        # Check formulas in each row
        all_checks_passed = True
        rows_checked = 0
        
        for row_num in range(start_row, end_row + 1):
            check_cell = ws[f"{check_column}{row_num}"]
            spec_cell = ws[f"{spec_column}{row_num}"]
            quantity_cell = ws[f"{quantity_column}{row_num}"]
            
            # Skip if spec or quantity cell is empty
            if spec_cell.value is None or quantity_cell.value is None:
                continue
            
            rows_checked += 1
            formula = check_cell.value
            
            # Check 1: Formula exists (not just a value)
            if formula is None or not isinstance(formula, str) or not formula.startswith('='):
                logger.error(f"Cell {check_column}{row_num} should contain a formula, but got: {formula}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Row {row_num} formula: {formula}")
            
            # Check 2: Contains all required functions
            missing_functions = []
            for func in expected_functions:
                # Check for function name (with word boundary to avoid partial matches)
                func_pattern = r'\b' + re.escape(func) + r'\s*\('
                if not re.search(func_pattern, formula_upper, re.IGNORECASE):
                    missing_functions.append(func)
            
            if missing_functions:
                logger.error(f"Cell {check_column}{row_num} formula missing functions: {missing_functions}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: References specification column (B)
            spec_pattern = rf'{spec_column}\d+'
            if not re.search(spec_pattern, formula_upper):
                logger.error(f"Cell {check_column}{row_num} formula should reference {spec_column} column")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: References quantity column (C)
            quantity_pattern = rf'{quantity_column}\d+'
            if not re.search(quantity_pattern, formula_upper):
                logger.error(f"Cell {check_column}{row_num} formula should reference {quantity_column} column")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 5: Contains Chinese character "支" (for extracting pieces per box)
            if '"支"' not in formula and "'支'" not in formula and '支' not in formula:
                logger.error(f"Cell {check_column}{row_num} formula should contain '支' character")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 6: Contains Chinese character "盒" (for box unit)
            if '"盒"' not in formula and "'盒'" not in formula and '盒' not in formula:
                logger.error(f"Cell {check_column}{row_num} formula should contain '盒' character")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 7: Uses string concatenation (&)
            if '&' not in formula:
                logger.error(f"Cell {check_column}{row_num} formula should use & for string concatenation")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 8: Contains INT function (for calculating integer boxes)
            int_pattern = r'\bINT\s*\('
            if not re.search(int_pattern, formula_upper):
                logger.error(f"Cell {check_column}{row_num} formula should contain INT function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 9: Contains MOD function (for calculating remainder)
            mod_pattern = r'\bMOD\s*\('
            if not re.search(mod_pattern, formula_upper):
                logger.error(f"Cell {check_column}{row_num} formula should contain MOD function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 10: Contains IF function (for conditional formatting)
            if_pattern = r'\bIF\s*\('
            if not re.search(if_pattern, formula_upper):
                logger.error(f"Cell {check_column}{row_num} formula should contain IF function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            logger.debug(f"✓ Row {row_num} formula passed all checks")
        
        if rows_checked == 0:
            logger.error("No rows with data found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ Shipping boxes calculation verification passed")
            logger.info(f"  Rows checked: {rows_checked}")
            logger.info(f"  Column: {check_column}")
            logger.info(f"  Functions verified: {', '.join(expected_functions)}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ Shipping boxes calculation verification failed")
            logger.error(f"  Rows checked: {rows_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_split_content_formula(result: str, expected: str = None, **options) -> float:
    """
    Verify if formulas exist to split content with line breaks into multiple rows.
    
    This function checks:
    1. Whether cells in specified column contain formulas (not just values)
    2. Whether formulas contain required functions: TRIM, MID, SUBSTITUTE, CHAR, REPT, ROW
    3. Whether formulas reference the source column (A)
    4. Whether formulas contain CHAR(10) for line break
    5. Whether formulas contain REPT(" ",100) or similar pattern
    6. Whether formulas use ROW function for position calculation
    
    The expected formula pattern:
    =TRIM(MID(SUBSTITUTE(A2,CHAR(10),REPT(" ",100)),(ROW(A1)-1)*100+1,100))
    
    The function automatically detects the number of data rows by checking the data column
    for non-empty cells. It stops checking after finding 3 consecutive empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_column: Column to check (e.g., "B")
            - start_row: Starting row number (default: 2)
            - source_column: Column containing source data (e.g., "A")
            - expected_functions: List of expected function names (e.g., ["TRIM", "MID", "SUBSTITUTE", "CHAR", "REPT", "ROW"])
            - data_column: Column to check for data to determine end_row (default: "A")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_column = options.get('check_column', 'B')
        start_row = options.get('start_row', 2)
        source_column = options.get('source_column', 'A')
        expected_functions = options.get('expected_functions', ['TRIM', 'MID', 'SUBSTITUTE', 'CHAR', 'REPT', 'ROW'])
        data_column = options.get('data_column', 'A')
        
        logger.info(f"Verifying split content formulas in file: {result}")
        logger.info(f"Column to check: {check_column}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Source column: {source_column}")
        logger.info(f"Expected functions: {expected_functions}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row  # Start from start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        if end_row < start_row:
            logger.error(f"No data rows found starting from row {start_row}")
            return 0.0
        
        # Check formulas in each row
        all_checks_passed = True
        rows_checked = 0
        
        for row_num in range(start_row, end_row + 1):
            check_cell = ws[f"{check_column}{row_num}"]
            
            # Skip if source cell is empty
            source_cell = ws[f"{source_column}{row_num}"]
            if source_cell.value is None:
                continue
            
            rows_checked += 1
            formula = check_cell.value
            
            # Check 1: Formula exists (not just a value)
            if formula is None or not isinstance(formula, str) or not formula.startswith('='):
                logger.error(f"Cell {check_column}{row_num} should contain a formula, but got: {formula}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Row {row_num} formula: {formula}")
            
            # Check 2: Contains all required functions
            missing_functions = []
            for func in expected_functions:
                # Check for function name (with word boundary to avoid partial matches)
                func_pattern = r'\b' + re.escape(func) + r'\s*\('
                if not re.search(func_pattern, formula_upper, re.IGNORECASE):
                    missing_functions.append(func)
            
            if missing_functions:
                logger.error(f"Cell {check_column}{row_num} formula missing functions: {missing_functions}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: References source column (A)
            source_pattern = rf'{source_column}\d+'
            if not re.search(source_pattern, formula_upper):
                logger.error(f"Cell {check_column}{row_num} formula should reference {source_column} column")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3.5: SUBSTITUTE function must reference A2 specifically
            # Pattern: SUBSTITUTE(A2,...
            substitute_a2_pattern = rf'SUBSTITUTE\s*\(\s*{source_column}2\s*,'
            if not re.search(substitute_a2_pattern, formula_upper):
                logger.error(f"Cell {check_column}{row_num} formula SUBSTITUTE function must reference {source_column}2 (not {source_column}3, {source_column}4, etc.)")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Contains CHAR(10) for line break
            char_pattern = r'CHAR\s*\(\s*10\s*\)'
            if not re.search(char_pattern, formula_upper):
                logger.error(f"Cell {check_column}{row_num} formula should contain CHAR(10)")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 5: Contains REPT with space and 100
            rept_pattern = r'REPT\s*\(\s*["\']?\s*["\']?\s*,\s*100\s*\)'
            if not re.search(rept_pattern, formula_upper):
                logger.error(f"Cell {check_column}{row_num} formula should contain REPT(\" \",100) or similar")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 6: Contains ROW function
            row_pattern = r'\bROW\s*\('
            if not re.search(row_pattern, formula_upper):
                logger.error(f"Cell {check_column}{row_num} formula should contain ROW function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 7: Contains TRIM function (outermost)
            trim_pattern = r'\bTRIM\s*\('
            if not re.search(trim_pattern, formula_upper):
                logger.error(f"Cell {check_column}{row_num} formula should contain TRIM function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 8: Contains MID function
            mid_pattern = r'\bMID\s*\('
            if not re.search(mid_pattern, formula_upper):
                logger.error(f"Cell {check_column}{row_num} formula should contain MID function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 9: Contains SUBSTITUTE function
            substitute_pattern = r'\bSUBSTITUTE\s*\('
            if not re.search(substitute_pattern, formula_upper):
                logger.error(f"Cell {check_column}{row_num} formula should contain SUBSTITUTE function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            logger.debug(f"✓ Row {row_num} formula passed all checks")
        
        if rows_checked == 0:
            logger.error("No rows with data found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ Split content formula verification passed")
            logger.info(f"  Rows checked: {rows_checked}")
            logger.info(f"  Column: {check_column}")
            logger.info(f"  Functions verified: {', '.join(expected_functions)}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ Split content formula verification failed")
            logger.error(f"  Rows checked: {rows_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_quote_sheet_with_merged_cells(result: str, expected: str = None, **options) -> float:
    """
    Verify if a quote sheet template exists with the expected structure, fields, and merged cells.
    
    This function checks:
    1. Whether the title "报价单" exists in the worksheet
    2. Whether merged cells exist (especially for the title)
    3. Whether required header fields exist
    4. Whether the product table headers exist
    5. Whether summary fields exist
    6. Whether footer fields exist
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - expected_title: Expected title text (default: "报价单")
            - title_merged_range: Expected merged range for title (default: "G15:H15")
            - required_fields: List of required header field labels
            - table_headers: List of table header labels
            - summary_fields: List of summary field labels
            - footer_fields: List of footer field labels
            - min_merged_cells: Minimum number of merged cell ranges expected (default: 1)
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        expected_title = options.get('expected_title', '报价单')
        title_merged_range = options.get('title_merged_range', 'G15:H15')
        required_fields = options.get('required_fields', ['报价单位', '联系人', '联系电话', '客户名称', '报价日期', '邮箱'])
        table_headers = options.get('table_headers', ['序号', '产品名称', '产品类型', '规格', '数量', '单价', '金额', '备注'])
        summary_fields = options.get('summary_fields', ['合计金额(小写)', '合计金额(大写)'])
        footer_fields = options.get('footer_fields', ['报价人', '审批'])
        min_merged_cells = options.get('min_merged_cells', 1)
        
        logger.info(f"Verifying quote sheet template with merged cells in file: {result}")
        logger.info(f"Expected title: {expected_title}")
        logger.info(f"Title merged range: {title_merged_range}")
        logger.info(f"Required fields: {required_fields}")
        logger.info(f"Table headers: {table_headers}")
        logger.info(f"Summary fields: {summary_fields}")
        logger.info(f"Footer fields: {footer_fields}")
        logger.info(f"Minimum merged cells: {min_merged_cells}")
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=True)
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check merged cells
        merged_cells = list(ws.merged_cells.ranges)
        logger.info(f"Found {len(merged_cells)} merged cell range(s)")
        
        if len(merged_cells) < min_merged_cells:
            logger.error(f"✗ Insufficient merged cells: found {len(merged_cells)}, expected at least {min_merged_cells}")
            return 0.0
        
        # Check if title merged range exists
        title_merged_found = False
        for merged_range in merged_cells:
            merged_str = str(merged_range)
            logger.debug(f"Merged range: {merged_str}")
            if merged_str.upper() == title_merged_range.upper():
                title_merged_found = True
                logger.info(f"✓ Found title merged range: {merged_str}")
                break
        
        if not title_merged_found:
            logger.warning(f"⚠ Title merged range '{title_merged_range}' not found, but other merged cells exist")
            logger.info(f"  Available merged ranges: {[str(r) for r in merged_cells]}")
            # Don't fail completely, as the range might be slightly different
        
        # Search through all cells to find required text
        # Also check merged cells specifically
        max_row = ws.max_row
        max_col = ws.max_column
        
        # Convert all cell values to strings for searching
        # Include both individual cells and merged cell ranges
        all_text = []
        cell_text_map = {}  # Map cell coordinates to text for debugging
        
        for row in ws.iter_rows(min_row=1, max_row=max_row, min_col=1, max_col=max_col, values_only=False):
            for cell in row:
                if cell.value is not None:
                    cell_text = str(cell.value).strip()
                    all_text.append(cell_text)
                    cell_coord = cell.coordinate
                    cell_text_map[cell_coord] = cell_text
                    
                    # Also check if cell contains newlines (for merged cells with multiple fields)
                    if '\n' in cell_text or '\r' in cell_text:
                        # Split by newlines and add each line
                        lines = cell_text.replace('\r', '\n').split('\n')
                        for line in lines:
                            line = line.strip()
                            if line:
                                all_text.append(line)
        
        # Check merged cells - get text from the top-left cell of each merged range
        for merged_range in merged_cells:
            try:
                # Get the top-left cell of the merged range
                top_left_cell = ws[merged_range.min_row][merged_range.min_col - 1]
                if top_left_cell.value is not None:
                    merged_text = str(top_left_cell.value).strip()
                    all_text.append(merged_text)
                    # Also split by newlines if present
                    if '\n' in merged_text or '\r' in merged_text:
                        lines = merged_text.replace('\r', '\n').split('\n')
                        for line in lines:
                            line = line.strip()
                            if line:
                                all_text.append(line)
                    logger.debug(f"Merged range {merged_range} contains text: {merged_text[:100]}")
            except Exception as e:
                logger.debug(f"Error reading merged range {merged_range}: {e}")
        
        # Check 1: Title exists
        title_found = False
        for text in all_text:
            if expected_title in text:
                title_found = True
                logger.info(f"✓ Found title: {expected_title}")
                break
        
        if not title_found:
            logger.error(f"✗ Title '{expected_title}' not found")
            return 0.0
        
        # Check 2: Required header fields
        # Since fields may be in merged cells together, we need to check if all fields exist
        # even if they're in the same cell
        found_fields = []
        missing_fields = []
        for field in required_fields:
            field_found = False
            for text in all_text:
                if field in text:
                    field_found = True
                    found_fields.append(field)
                    logger.debug(f"Found field '{field}' in text: {text[:80]}...")
                    break
            if not field_found:
                missing_fields.append(field)
        
        # Log all text for debugging if fields are missing
        if missing_fields:
            logger.warning(f"⚠ Missing required fields: {missing_fields}")
            # Show some sample text that might contain the fields
            logger.debug(f"Sample text from worksheet (showing text with Chinese characters):")
            chinese_text_samples = [t for t in all_text if any('\u4e00' <= c <= '\u9fff' for c in t)][:20]
            for sample in chinese_text_samples:
                logger.debug(f"  {sample[:100]}")
        
        # Since fields may be grouped in merged cells, we're more lenient
        # Check if at least most fields are found
        found_ratio = len(found_fields) / len(required_fields) if required_fields else 1.0
        
        if found_ratio < 0.5:  # Less than 50% found
            logger.error(f"✗ Too many required fields missing: found {len(found_fields)}/{len(required_fields)}")
            logger.error(f"  Missing: {missing_fields}")
            return 0.0
        elif missing_fields:
            logger.warning(f"⚠ Some fields missing: {missing_fields}, but found {len(found_fields)}/{len(required_fields)} fields")
            # Don't fail if most fields are found (fields might be in merged cells together)
        else:
            logger.info(f"✓ Found all required fields: {found_fields}")
        
        # Check 3: Table headers
        found_headers = []
        missing_headers = []
        for header in table_headers:
            header_found = False
            for text in all_text:
                if header in text:
                    header_found = True
                    found_headers.append(header)
                    break
            if not header_found:
                missing_headers.append(header)
        
        if missing_headers:
            logger.error(f"✗ Missing table headers: {missing_headers}")
            return 0.0
        else:
            logger.info(f"✓ Found all table headers: {found_headers}")
        
        # Check 4: Summary fields
        found_summary = []
        missing_summary = []
        for field in summary_fields:
            field_found = False
            for text in all_text:
                if field in text:
                    field_found = True
                    found_summary.append(field)
                    break
            if not field_found:
                missing_summary.append(field)
        
        if missing_summary:
            logger.warning(f"⚠ Missing summary fields: {missing_summary}")
            # Don't fail completely, as these might be optional
        else:
            logger.info(f"✓ Found summary fields: {found_summary}")
        
        # Check 5: Footer fields
        found_footer = []
        missing_footer = []
        for field in footer_fields:
            field_found = False
            for text in all_text:
                if field in text:
                    field_found = True
                    found_footer.append(field)
                    break
            if not field_found:
                missing_footer.append(field)
        
        if missing_footer:
            logger.warning(f"⚠ Missing footer fields: {missing_footer}")
            # Don't fail completely, as these might be optional
        else:
            logger.info(f"✓ Found footer fields: {found_footer}")
        
        # Check 6: Borders on table cells
        # Check if cells in the product table area have borders
        # Typically, table headers and data rows should have borders
        logger.info("Checking borders on table cells...")
        
        # Find the table header row (should contain table headers)
        table_header_row = None
        for row_num in range(1, max_row + 1):
            for col_num in range(1, max_col + 1):
                cell = ws.cell(row=row_num, column=col_num)
                if cell.value is not None:
                    cell_text = str(cell.value).strip()
                    # Check if this row contains table headers
                    if any(header in cell_text for header in table_headers):
                        table_header_row = row_num
                        break
            if table_header_row:
                break
        
        borders_found = False
        cells_with_borders = 0
        total_table_cells_checked = 0
        
        if table_header_row:
            logger.info(f"Table header row found at row {table_header_row}")
            # Check borders in table area (header row and a few data rows)
            # Table typically spans from column C to K (based on headers)
            check_start_col = 3  # Column C
            check_end_col = min(11, max_col)  # Column K or max_col
            check_start_row = table_header_row
            check_end_row = min(table_header_row + 7, max_row)  # Header + 6 data rows
            
            for row_num in range(check_start_row, check_end_row + 1):
                for col_num in range(check_start_col, check_end_col + 1):
                    cell = ws.cell(row=row_num, column=col_num)
                    total_table_cells_checked += 1
                    
                    # Check if cell has any border
                    has_border = False
                    try:
                        border = cell.border
                        # Check if any side has a border style (not None and not empty)
                        if border:
                            if (border.top and border.top.style) or \
                               (border.bottom and border.bottom.style) or \
                               (border.left and border.left.style) or \
                               (border.right and border.right.style):
                                has_border = True
                                cells_with_borders += 1
                    except Exception as e:
                        logger.debug(f"Error checking border for cell {cell.coordinate}: {e}")
                    
                    if has_border:
                        borders_found = True
                        logger.debug(f"Cell {cell.coordinate} has borders")
            
            if total_table_cells_checked > 0:
                border_ratio = cells_with_borders / total_table_cells_checked
                logger.info(f"Borders found: {cells_with_borders}/{total_table_cells_checked} cells ({border_ratio:.1%})")
                
                # Require at least 30% of table cells to have borders
                if border_ratio < 0.3:
                    logger.warning(f"⚠ Low border coverage: only {border_ratio:.1%} of table cells have borders")
                    # Don't fail completely, as borders might be applied differently
                else:
                    logger.info(f"✓ Sufficient borders found in table area")
            else:
                logger.warning("⚠ Could not check borders: no table cells found")
        else:
            logger.warning("⚠ Could not find table header row for border checking")
        
        # If we get here, all critical checks passed
        logger.info("=" * 60)
        logger.info(f"✓ Quote sheet template with merged cells verification passed")
        logger.info(f"  Title: {expected_title}")
        logger.info(f"  Merged cells: {len(merged_cells)} (minimum required: {min_merged_cells})")
        if title_merged_found:
            logger.info(f"  Title merged range: {title_merged_range}")
        logger.info(f"  Required fields: {len(found_fields)}/{len(required_fields)}")
        logger.info(f"  Table headers: {len(found_headers)}/{len(table_headers)}")
        logger.info(f"  Summary fields: {len(found_summary)}/{len(summary_fields)}")
        logger.info(f"  Footer fields: {len(found_footer)}/{len(footer_fields)}")
        if borders_found:
            logger.info(f"  Borders: {cells_with_borders}/{total_table_cells_checked} cells have borders")
        logger.info("=" * 60)
        return 1.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


import functools
import itertools
import logging
import os.path

# import operator
from numbers import Number
from typing import Any, Union, cast, Callable, Iterable
from typing import Dict, List, Tuple, Set

import openpyxl
import pandas as pd
from openpyxl import Workbook
from openpyxl.cell.cell import Cell
from openpyxl.utils import get_column_letter
from openpyxl.worksheet.cell_range import MultiCellRange
from openpyxl.worksheet.datavalidation import DataValidation
from openpyxl.worksheet.worksheet import Worksheet
from rapidfuzz import fuzz

from desktop_env.evaluators.metrics.utils import (
    _match_value_to_rule,
    _read_cell_style,
    read_cell_value,
)
from desktop_env.evaluators.metrics.utils import (
    load_charts,
    load_sparklines,
    load_rows_or_cols,
    load_xlsx_styles,
    load_filters,
    load_pivot_tables,
)

# from openpyxl.utils import coordinate_to_tuple

logger = logging.getLogger("desktopenv.metric.table")

BOOK = Union[pd.ExcelFile, Workbook, str]


def _parse_sheet_idx(
    sheet_idx: Union[int, str],
    result: BOOK,
    expected: BOOK,
    result_sheet_names: List[str],
    expected_sheet_names: List[str],
) -> Tuple[BOOK, str]:
    #  function _parse_sheet_idx {{{ #
    if isinstance(sheet_idx, int):
        try:
            if not result_sheet_names or sheet_idx >= len(result_sheet_names):
                logger.error(
                    f"Sheet index {sheet_idx} out of range. Available sheets: {result_sheet_names}"
                )
                index = ""
            else:
                index: str = result_sheet_names[sheet_idx]
                logger.debug(f"Sheet index {sheet_idx} resolved to sheet: {index}")
        except Exception as e:
            logger.error(f"Error resolving sheet index {sheet_idx}: {e}")
            index = ""
        book: BOOK = result
    elif sheet_idx.startswith("RI"):
        try:
            index: str = result_sheet_names[int(sheet_idx[2:])]
        except:
            index = ""
        book: BOOK = result
    elif sheet_idx.startswith("RN"):
        index: str = sheet_idx[2:]
        book: BOOK = result
    elif sheet_idx.startswith("EI"):
        try:
            index: str = expected_sheet_names[int(sheet_idx[2:])]
        except:
            index = ""
        book: BOOK = expected
    elif sheet_idx.startswith("EN"):
        index: str = sheet_idx[2:]
        book: BOOK = expected
    else:
        logger.error("Unrecognized sheet index")
        raise ValueError("Unrecognized sheet index")
    return book, index
    #  }}} function _parse_sheet_idx #


SHEET = Union[pd.DataFrame, Worksheet, List[str]]


def _load_sheet(book: BOOK, index: str) -> SHEET:
    #  function _load_sheet {{{ #
    try:
        if isinstance(book, str):
            book: str = cast(str, book)
            csv_name: str = "{:}-{:}.csv".format(os.path.splitext(book)[0], index)

            try:
                all_lines: List[str] = _safe_read_file(csv_name)
                csv_lines: List[str] = list(
                    itertools.dropwhile(
                        lambda l: len(l) == 0,
                        map(lambda l: l.strip(), reversed(all_lines)),
                    )
                )
                return csv_lines
            except (FileNotFoundError, IOError) as e:
                logger.error(f"Failed to read CSV file {csv_name}: {e}")
                return None
        if isinstance(book, pd.ExcelFile):
            return pd.read_excel(book, index)
        if isinstance(book, Workbook):
            return book[index]
        logger.error("Not supported workbook format")
        raise NotImplementedError("Not supported workbook format")
    except NotImplementedError as e:
        raise e
    except:
        return None
    #  }}} function _load_sheet #


def _safe_read_file(file_path: str) -> List[str]:
    """
    Safely read a file with multiple encoding attempts.

    Args:
        file_path: Path to the file to read

    Returns:
        List of lines from the file

    Raises:
        FileNotFoundError: If file doesn't exist
        IOError: If file cannot be read with any encoding
    """
    # Common encodings to try in order of preference
    encodings = [
        "utf-8",  # Most common modern encoding
        "utf-8-sig",  # UTF-8 with BOM
        "latin-1",  # ISO-8859-1, works with any byte sequence
        "windows-1252",  # Common Windows encoding
        "gbk",  # Chinese encoding
        "cp1251",  # Cyrillic encoding
        "iso-8859-1",  # Alternative latin-1
    ]

    last_error = None

    for encoding in encodings:
        try:
            with open(file_path, "r", encoding=encoding) as f:
                lines = f.read().splitlines()
                logger.debug(
                    f"Successfully read file {file_path} with encoding {encoding}"
                )
                return lines
        except UnicodeDecodeError as e:
            last_error = e
            logger.debug(f"Failed to read {file_path} with encoding {encoding}: {e}")
            continue
        except (FileNotFoundError, IOError) as e:
            # These are non-encoding related errors, re-raise immediately
            raise e

    # If all encodings fail, try with error handling as last resort
    try:
        with open(file_path, "r", encoding="utf-8", errors="replace") as f:
            lines = f.read().splitlines()
            logger.warning(f"Read file {file_path} with UTF-8 and error replacement")
            return lines
    except Exception as e:
        logger.error(
            f"Failed to read file {file_path} with any encoding. Last error: {last_error}"
        )
        raise IOError(
            f"Cannot read file {file_path} with any supported encoding"
        ) from last_error


def compare_csv(result: str, expected: Union[str, List[str]], **options) -> float:
    """
    Compare CSV files. If expected is a list, returns 1.0 if result matches any of the expected files.

    Args:
        result: Path to result CSV file
        expected: Path to expected CSV file or list of paths to expected CSV files
        options: Additional options (strict, ignore_case)

    Returns:
        1.0 if result matches expected (or any file in expected list), 0.0 otherwise
    """
    if result is None:
        return 0.0

    try:
        result_lines: List[str] = _safe_read_file(result)
    except (FileNotFoundError, IOError) as e:
        logger.error(f"Failed to read result file {result}: {e}")
        return 0.0

    # Convert expected to list if it's a single string (for backward compatibility)
    if isinstance(expected, str):
        expected_files = [expected]
    else:
        expected_files = expected

    # Try to match against each expected file
    for expected_file in expected_files:
        try:
            expected_lines: List[str] = _safe_read_file(expected_file)

            # Process lines based on options
            current_result_lines = result_lines
            current_expected_lines = expected_lines

            if not options.get("strict", True):
                current_result_lines = map(str.strip, current_result_lines)
                current_expected_lines = map(str.strip, current_expected_lines)
            if options.get("ignore_case", False):
                current_result_lines = map(str.lower, current_result_lines)
                current_expected_lines = map(str.lower, current_expected_lines)

            # Check if this expected file matches
            if list(current_result_lines) == list(current_expected_lines):
                return 1.0

        except (FileNotFoundError, IOError):
            # If this expected file doesn't exist, continue to next one
            continue

    # No match found
    return 0.0


def compare_table(result: str, expected: str = None, **options) -> float:
    #  function compare_table {{{ #
    """
    Args:
        result (str): path to result xlsx
        expected (str): path to golden xlsx
        rules (List[Dict[str, Any]]): list of dict like
          {
            "type": str,
            <str as parameters>: anything
          }
          as sequential rules

    Returns:
        float: the score
    """

    if result is None:
        logger.error("Result file path is None")
        return 0.0

    # Check if result file exists
    if not os.path.exists(result):
        logger.error(f"Result file not found: {result}")
        return 0.0

    try:
        logger.info(f"Loading result file: {result}")
        xlworkbookr: Workbook = openpyxl.load_workbook(filename=result)
        pdworkbookr = pd.ExcelFile(result)
        logger.info(
            f"Successfully loaded result file with sheets: {pdworkbookr.sheet_names}"
        )
    except Exception as e:
        logger.error(f"Failed to load result file {result}: {e}")
        return 0.0
    worksheetr_names: List[str] = pdworkbookr.sheet_names

    if expected is not None:
        xlworkbooke: Workbook = openpyxl.load_workbook(filename=expected)
        pdworkbooke = pd.ExcelFile(expected)
        worksheete_names: List[str] = pdworkbooke.sheet_names
    else:
        xlworkbooke: Workbook = None
        pdworkbooke = None
        worksheete_names: List[str] = None

    parse_idx: Callable[[Union[str, int], BOOK, BOOK], Tuple[BOOK, str]] = (
        functools.partial(
            _parse_sheet_idx,
            result_sheet_names=worksheetr_names,
            expected_sheet_names=worksheete_names,
        )
    )

    passes = True
    for r in options["rules"]:
        if r["type"] == "sheet_name":
            #  Compare Sheet Names {{{ #
            metric: bool = worksheetr_names == worksheete_names
            logger.debug(
                "Assertion: %s.sheet_names == %s.sheet_names - %s",
                result,
                expected,
                metric,
            )
            #  }}} Compare Sheet Names #

        elif r["type"] == "sheet_data":
            #  Compare Sheet Data by Internal Value {{{ #
            # sheet_idx0: 0 == "RI0" == "RNSheet1" | "EI0" == "ENSheet1"
            # sheet_idx1: as sheet_idx0
            # precision: int as number of decimal digits, default to 4

            error_limit: int = r.get("precision", 4)
            sheet1: pd.DataFrame = _load_sheet(
                *parse_idx(r["sheet_idx0"], pdworkbookr, pdworkbooke)
            )
            if sheet1 is None:
                return 0.0
            sheet2: pd.DataFrame = _load_sheet(
                *parse_idx(r["sheet_idx1"], pdworkbookr, pdworkbooke)
            )

            sheet1 = sheet1.round(error_limit)
            sheet2 = sheet2.round(error_limit)
            metric: bool = sheet1.equals(sheet2)
            logger.debug("Sheet1: \n%s", str(sheet1))
            logger.debug("Sheet2: \n%s", str(sheet2))
            try:
                logger.debug("Sheet1 =v= Sheet2: \n%s", str(sheet1 == sheet2))
            except:
                logger.debug("Sheet1 =/v= Sheet2")
            logger.debug(
                "Assertion: %s =v= %s - %s", r["sheet_idx0"], r["sheet_idx1"], metric
            )
            #  }}} Compare Sheet Data by Internal Value #

        elif r["type"] == "sheet_print":
            #  Compare Sheet Data by Printed Value {{{ #
            # sheet_idx0: 0 == "RI0" == "RNSheet1" | "EI0" == "ENSheet1"
            # sheet_idx1: as sheet_idx0
            # ignore_case: optional, defaults to False

            sheet1: List[str] = _load_sheet(
                *parse_idx(r["sheet_idx0"], result, expected)
            )
            if sheet1 is None:
                return 0.0
            sheet2: List[str] = _load_sheet(
                *parse_idx(r["sheet_idx1"], result, expected)
            )
            if r.get("ignore_case", False):
                sheet1 = [l.lower() for l in sheet1]
                sheet2 = [l.lower() for l in sheet2]
            metric: bool = sheet1 == sheet2
            logger.debug(
                "Assertion: %s =p= %s - %s", r["sheet_idx0"], r["sheet_idx1"], metric
            )
            #  }}} Compare Sheet Data by Printed Value #

        elif r["type"] == "sheet_fuzzy":
            #  Fuzzy Match for Ranges {{{ #
            # sheet_idx0: 0 == "RI0" == "RNSheet1" | "EI0" == "ENSheet1"
            # sheet_idx1: as sheet_idx0
            # rules: list of dict, each dict is like
            #   { "range": ["A1:B6", "C2:E5"],
            #     "type": "includes" | "included_by" | "fuzzy_match" | "exact_match", # 0 includes 1, 0 includes_by 1
            #     "threshold": 85, // for fuzzy match
            #     "ignore_case": true | false,
            #     "ignore_chars": " ()", # filtered out
            #     "trim_leadings": "+ ", # filtered by lstrip
            #     "trim_trailings": "", # filtered by rstrip
            #     "normalization": [["Rd", "Road"]], # filtered by replace
            #   }

            sheet1: Tuple[BOOK, str] = parse_idx(r["sheet_idx0"], result, expected)
            sheet2: Tuple[BOOK, str] = parse_idx(r["sheet_idx1"], result, expected)
            total_metric = True
            for rl in r["rules"]:
                for rng in MultiCellRange(rl["range"]):
                    for cdn in rng.cells:
                        coordinate: str = "{:}{:d}".format(
                            get_column_letter(cdn[1]), cdn[0]
                        )
                        value1: str = str(read_cell_value(*sheet1, coordinate))
                        value2: str = str(read_cell_value(*sheet2, coordinate))
                        logger.debug("%s: %s vs %s", cdn, value1, value2)

                        for rplc in rl.get("normalization", []):
                            value1 = value1.replace(rplc[0], rplc[1])
                            value2 = value2.replace(rplc[0], rplc[1])
                        if "trim_leadings" in rl:
                            value1 = value1.lstrip(rl["trim_leadings"])
                            value2 = value2.lstrip(rl["trim_leadings"])
                        if "trim_trailings" in rl:
                            value1 = value1.rstrip(rl["trim_trailings"])
                            value2 = value2.rstrip(rl["trim_trailings"])
                        if "ignore_chars" in rl:
                            ignore_chars: Set[str] = set(rl["ignore_chars"])
                            value1 = "".join(
                                filter(lambda ch: ch not in ignore_chars, value1)
                            )
                            value2 = "".join(
                                filter(lambda ch: ch not in ignore_chars, value2)
                            )
                        if rl.get("ignore_case", False):
                            value1 = value1.lower()
                            value2 = value2.lower()

                        if rl["type"] == "includes":
                            metric: bool = value2 in value1
                        elif rl["type"] == "included_by":
                            metric: bool = value1 in value2
                        elif rl["type"] == "fuzzy_match":
                            metric: bool = fuzz.ratio(value1, value2) >= rl.get(
                                "threshold", 85.0
                            )
                        elif rl["type"] == "exact_match":
                            metric: bool = value1 == value2
                        total_metric = total_metric and metric

            metric: bool = total_metric
            logger.debug(
                "Assertion: %s =~= %s - %s", r["sheet_idx0"], r["sheet_idx1"], metric
            )
            #  }}} Fuzzy Match for Ranges #

        elif r["type"] == "sparkline":
            #  Compare Sparklines {{{ #
            # sheet_idx0: 0 == "RI0" == "RNSheet1" | "EI0" == "ENSheet1"
            # sheet_idx1: as sheet_idx0

            sparkline1: Dict[str, str] = load_sparklines(
                *parse_idx(r["sheet_idx0"], result, expected)
            )
            sparkline2: Dict[str, str] = load_sparklines(
                *parse_idx(r["sheet_idx1"], result, expected)
            )
            metric: bool = sparkline1 == sparkline2
            logger.debug(
                "Assertion: %s.sp == %.sp - %s",
                r["sheet_idx0"],
                r["sheet_idx1"],
                metric,
            )
            #  }}} Compare Sparklines #

        elif r["type"] == "chart":
            #  Compare Charts {{{ #
            # sheet_idx0: 0 == "RI0" == "RNSheet1" | "EI0" == "ENSheet1"
            # sheet_idx1: as sheet_idx0
            # chart_props: list of str, see utils.load_charts

            charts1: Dict[str, Any] = load_charts(
                *parse_idx(r["sheet_idx0"], xlworkbookr, xlworkbooke), **r
            )
            charts2: Dict[str, Any] = load_charts(
                *parse_idx(r["sheet_idx1"], xlworkbookr, xlworkbooke), **r
            )
            metric: bool = charts1 == charts2
            logger.debug(
                "Assertion: %s[chart] == %s[chart] - %s",
                r["sheet_idx0"],
                r["sheet_idx1"],
                metric,
            )
            #  }}} Compare Charts #

        elif r["type"] == "style":
            #  Compare Style (Also Conditional Formatiing) {{{ #
            # sheet_idx0: 0 == "RI0" == "RNSheet1" | "EI0" == "ENSheet1"
            # sheet_idx1: as sheet_idx0
            # props: list of str indicating concerned styles, see utils._read_cell_style

            sheet_idx1: Tuple[BOOK, str] = parse_idx(
                r["sheet_idx0"], xlworkbookr, xlworkbooke
            )
            book_name1: str = parse_idx(r["sheet_idx0"], result, expected)[0]
            styles1: Dict[str, List[Any]] = load_xlsx_styles(
                *sheet_idx1, book_name1, **r
            )

            sheet_idx2: Tuple[BOOK, str] = parse_idx(
                r["sheet_idx1"], xlworkbookr, xlworkbooke
            )
            book_name2: str = parse_idx(r["sheet_idx1"], result, expected)[0]
            styles2: Dict[str, List[Any]] = load_xlsx_styles(
                *sheet_idx2, book_name2, **r
            )
            # number_formats1: List[str] = [c.number_format.lower() for col in sheet1.iter_cols() for c in col if c.value is not None and c.data_type=="n"]
            # number_formats2: List[str] = [c.number_format.lower() for col in sheet2.iter_cols() for c in col if c.value is not None and c.data_type=="n"]
            metric: bool = styles1 == styles2
            logger.debug(
                "Assertion: %s.style == %s.style - %s",
                r["sheet_idx0"],
                r["sheet_idx1"],
                metric,
            )
            #  }}} Compare Style (Also Conditional Formatiing) #

        elif r["type"] == "freeze":
            #  Compare Freezing {{{ #
            # sheet_idx0: 0 == "RI0" == "RNSheet1" | "EI0" == "ENSheet1"
            # sheet_idx1: as sheet_idx0

            sheet1: Worksheet = _load_sheet(
                *parse_idx(r["sheet_idx0"], xlworkbookr, xlworkbooke)
            )
            if sheet1 is None:
                return 0.0
            sheet2: Worksheet = _load_sheet(
                *parse_idx(r["sheet_idx1"], xlworkbookr, xlworkbooke)
            )
            metric: bool = sheet1.freeze_panes == sheet2.freeze_panes
            logger.debug(
                "Assertion: %s.freeze(%s) == %s.freeze(%s) - %s",
                r["sheet_idx0"],
                sheet1.freeze_panes,
                r["sheet_idx1"],
                sheet2.freeze_panes,
                metric,
            )
            #  }}} Compare Freezing #

        elif r["type"] == "zoom":
            #  Check Zooming {{{ #
            # sheet_idx: 0 == "RI0" == "RNSheet1" | "EI0" == "ENSheet1"
            # method: str
            # ref: value

            sheet: Worksheet = _load_sheet(
                *parse_idx(r["sheet_idx"], xlworkbookr, xlworkbooke)
            )
            if sheet is None:
                return 0.0
            zoom_scale: Number = sheet.sheet_view.zoomScale or 100.0
            metric: bool = _match_value_to_rule(zoom_scale, r)
            logger.debug(
                "Assertion: %s.zoom(%.1f) %s %.1f - %s",
                r["sheet_idx"],
                zoom_scale,
                r["method"],
                r["ref"],
                metric,
            )
            #  }}} Check Zooming #

        elif r["type"] == "data_validation":
            #  Check Data Validation {{{ #
            # sheet_idx: 0 == "RI0" == "RNSheet1" | "EI0" == "ENSheet1"
            # dv_props: list of dict like {attribute: {"method": str, "ref": anything}}
            #   available attributes:
            #     * ranges
            #     * type
            #     * formula1
            #     * formula2
            #     * operator
            #     * allowBlank
            #     * showDropDown
            #     * showInputMessage
            #     * showErrorMessage
            #     * error
            #     * errorTitle
            #     * errorStyle
            #     * prompt
            #     * promptTitle
            #     * imeMode

            sheet: Worksheet = _load_sheet(
                *parse_idx(r["sheet_idx"], xlworkbookr, xlworkbooke)
            )
            if sheet is None:
                return 0.0
            data_validators: List[DataValidation] = (
                sheet.data_validations.dataValidation
            )

            total_metric = len(data_validators) >= len(r["dv_props"])
            for dat_vldt in data_validators:
                metric = False
                for prpt in r["dv_props"]:
                    metric = metric or all(
                        _match_value_to_rule(getattr(dat_vldt, attrbt), mr)
                        for attrbt, mr in prpt.items()
                    )
                    if metric:
                        break
                total_metric = total_metric and metric
                if not total_metric:
                    break

            logger.debug(
                "Assertion: %s.data_validation - %s", r["sheet_idx"], total_metric
            )
            metric: bool = total_metric
            #  }}} Check Data Validation #

        elif r["type"] == "row_props":
            #  Check Row Properties {{{ #
            # sheet_idx0: 0 == "RI0" == "RNSheet1" | "EI0" == "ENSheet1"
            # sheet_idx1: as sheet_idx0
            # props: list of str, see utils.load_rows_or_cols

            rows1: Dict[str, Any] = load_rows_or_cols(
                *parse_idx(r["sheet_idx0"], xlworkbookr, xlworkbooke), obj="row", **r
            )
            rows2: Dict[str, Any] = load_rows_or_cols(
                *parse_idx(r["sheet_idx1"], xlworkbookr, xlworkbooke), obj="row", **r
            )
            logger.debug("Rows1: %s", repr(rows1))
            logger.debug("Rows2: %s", repr(rows2))
            metric: bool = rows1 == rows2
            logger.debug(
                "Assertion: %s[rows] == %s[rows] - %s",
                r["sheet_idx0"],
                r["sheet_idx1"],
                metric,
            )
            #  }}} Check Row Properties #

        elif r["type"] == "col_props":
            #  Check Row Properties {{{ #
            # sheet_idx0: 0 == "RI0" == "RNSheet1" | "EI0" == "ENSheet1"
            # sheet_idx1: as sheet_idx0
            # props: list of str, see utils.load_rows_or_cols

            cols1: Dict[str, Any] = load_rows_or_cols(
                *parse_idx(r["sheet_idx0"], xlworkbookr, xlworkbooke), obj="column", **r
            )
            cols2: Dict[str, Any] = load_rows_or_cols(
                *parse_idx(r["sheet_idx1"], xlworkbookr, xlworkbooke), obj="column", **r
            )
            metric: bool = cols1 == cols2
            logger.debug(
                "Assertion: %s[cols] == %s[cols] - %s",
                r["sheet_idx0"],
                r["sheet_idx1"],
                metric,
            )
            #  }}} Check Row Properties #

        elif r["type"] == "filter":
            #  Compare Filters {{{ #
            # sheet_idx0: 0 == "RI0" == "RNSheet1" | "EI0" == "ENSheet1"
            # sheet_idx1: as sheet_idx0

            filters1: Dict[str, Any] = load_filters(
                *parse_idx(r["sheet_idx0"], xlworkbookr, xlworkbooke), **r
            )
            filters2: Dict[str, Any] = load_filters(
                *parse_idx(r["sheet_idx1"], xlworkbookr, xlworkbooke), **r
            )
            metric: bool = filters1 == filters2
            logger.debug(
                "Assertion: %s[filter] == %s[filter] - %s",
                r["sheet_idx0"],
                r["sheet_idx1"],
                metric,
            )
            #  }}} Compare Filters #

        elif r["type"] == "pivot_table":
            #  Compare Pivot Tables {{{ #
            # sheet_idx0: 0 == "RI0" == "RNSheet1" | "EI0" == "ENSheet1"
            # sheet_idx1: as sheet_idx0
            # pivot_props: list of str, see utils.load_pivot_tables

            pivots1: Dict[str, Any] = load_pivot_tables(
                *parse_idx(r["sheet_idx0"], xlworkbookr, xlworkbooke), **r
            )
            pivots2: Dict[str, Any] = load_pivot_tables(
                *parse_idx(r["sheet_idx1"], xlworkbookr, xlworkbooke), **r
            )
            metric: bool = pivots1 == pivots2
            logger.debug(
                "Assertion: %s[pivot]==%s[pivot] - %s",
                r["sheet_idx0"],
                r["sheet_idx1"],
                metric,
            )
            #  }}} Compare Pivot Tables #

        elif r["type"] == "check_cell":
            #  Check Cell Properties {{{ #
            # sheet_idx: 0 == "RI0" == "RNSheet1" | "EI0" == "ENSheet1"
            # coordinate: str, "E3"
            # props: dict like {attribute: {"method": str, "ref": anything}}
            #   supported attributes: value & those supported by utils._read_cell_style

            try:
                sheet: Worksheet = _load_sheet(
                    *parse_idx(r["sheet_idx"], xlworkbookr, xlworkbooke)
                )
                if sheet is None:
                    logger.error(
                        f"Failed to load sheet for sheet_idx: {r['sheet_idx']}"
                    )
                    return 0.0
                # data_frame: pd.DataFrame = _load_sheet(*parse_idx(r["sheet_idx"], pdworkbookr, pdworkbooke))
                cell: Cell = sheet[r["coordinate"]]
                metric: bool = True
                for prpt, rule in r["props"].items():
                    if prpt == "value":
                        try:
                            parsed_result = parse_idx(r["sheet_idx"], result, expected)
                            logger.debug(f"parse_idx result: {parsed_result}")
                            val = read_cell_value(*parsed_result, r["coordinate"])
                            logger.debug(f"Cell {r['coordinate']} value: {val}")
                        except Exception as e:
                            logger.error(
                                f"Failed to read cell value at {r['coordinate']}: {e}"
                            )
                            val = None
                    elif prpt == "formula":
                        # Support checking cell formula directly
                        try:
                            if cell.data_type == "f":
                                # For formula cells, get the formula text
                                # In openpyxl, formula is stored in cell.value for formula cells
                                # But we need the actual formula text, not the calculated value
                                # Try to get formula from internal representation
                                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                                    val = cell._value
                                elif hasattr(cell, "formula"):
                                    val = cell.formula
                                else:
                                    # Fallback: try to reconstruct from value if it's a formula
                                    val = f"={cell.value}" if cell.value is not None else None
                            else:
                                val = None
                            logger.debug(f"Cell {r['coordinate']} formula: {val}")
                        except Exception as e:
                            logger.error(
                                f"Failed to read cell formula at {r['coordinate']}: {e}"
                            )
                            val = None
                    else:
                        try:
                            val = _read_cell_style(prpt, cell)
                        except Exception as e:
                            logger.error(
                                f"Failed to read cell style {prpt} at {r['coordinate']}: {e}"
                            )
                            val = None

                    metric = metric and _match_value_to_rule(val, rule)
            except Exception as e:
                logger.error(f"Error in check_cell processing: {e}")
                return 0.0

            logger.debug(
                "Assertion: %s[%s] :%s - %s",
                r["sheet_idx"],
                r["coordinate"],
                repr(r["props"]),
                metric,
            )
            #  }}} Check Cell Properties #

        else:
            raise NotImplementedError(
                "Unimplemented sheet check: {:}".format(r["type"])
            )

        passes = passes and metric
        if not passes:
            break

    return float(passes)
    #  }}} function compare_table #


def compare_conference_city_in_order(actual_city_list_path, expected_city):
    expected_city_list = expected_city["expected"]
    wb = openpyxl.load_workbook(actual_city_list_path)
    sheet = wb.active
    actual_city_list = []
    for row in sheet["C2:C22"]:
        for cell in row:
            actual_city_list.append(cell.value)
    # expected_city is the city that we want to compare with the actual city list
    # must in order index
    # debug
    try:
        for i in range(len(actual_city_list)):
            if isinstance(expected_city_list[i], str):
                if expected_city_list[i] not in actual_city_list[i]:
                    logger.debug(
                        f"Expected city {expected_city_list[i]}; Actual city {actual_city_list[i]}"
                    )
                    print(
                        f"Expected city {expected_city_list[i]}; Actual city {actual_city_list[i]}"
                    )
                    return 0.0

            elif isinstance(expected_city_list[i], List):
                if not any(
                    possible_str in actual_city_list[i]
                    for possible_str in expected_city_list[i]
                ):
                    logger.debug(
                        f"Expected city {expected_city_list[i]}; Actual city {actual_city_list[i]}"
                    )
                    print(
                        f"Expected city {expected_city_list[i]}; Actual city {actual_city_list[i]}"
                    )
                    return 0.0

            else:
                raise TypeError("Expected city should be a string or a list of strings")

    except:
        return 0.0

    return 1.0


def verify_second_row_deleted_without_gold(result: str, expected: str = None, **options) -> float:
    """
    验证 Excel 文件的第二行是否被删除（不需要金标准文件）
    
    通过以下方式验证：
    1. 检查结果文件的行数是否比原始文件少1
    2. 检查原始文件的第二行数据是否在结果文件中不存在
    3. 检查其他所有行是否保持不变
    
    Args:
        result (str): 结果文件路径
        expected (str): 未使用（为了兼容框架接口）
        options (dict): 配置选项，应包含：
            - original_file_url: 原始文件的URL（用于下载和比对）
            - result_file_path: 结果文件的路径（可选，默认使用 result 参数）
            - original_file_cache: 原始文件的本地缓存路径（可选）
    
    Returns:
        float: 如果验证通过返回 1.0，否则返回 0.0
    """
    try:
        import tempfile
        import urllib.request
        
        # result 参数已经是从VM获取到宿主机的文件路径
        # 不应该从 options 中覆盖它，因为 options 中可能包含的是VM路径
        result_file_path = result
        original_file_url = options.get('original_file_url', '')
        
        logger.info(f"开始验证删除第二行任务...")
        logger.info(f"结果文件: {result_file_path}")
        logger.info(f"原始文件URL: {original_file_url}")
        
        if not result_file_path or not os.path.exists(result_file_path):
            logger.error(f"结果文件不存在: {result_file_path}")
            return 0.0
        
        # 下载原始文件到临时位置
        with tempfile.NamedTemporaryFile(delete=False, suffix='.xlsx') as tmp_file:
            original_file_temp = tmp_file.name
        
        try:
            logger.info(f"正在下载原始文件到临时位置: {original_file_temp}")
            urllib.request.urlretrieve(original_file_url, original_file_temp)
        except Exception as e:
            logger.warning(f"下载原始文件失败: {e}")
            # 如果下载失败，尝试从本地缓存读取
            cache_path = options.get('original_file_cache', '')
            if cache_path and os.path.exists(cache_path):
                logger.info(f"使用缓存文件: {cache_path}")
                original_file_temp = cache_path
            else:
                logger.error("无法获取原始文件")
                return 0.0
        
        # 加载原始文件
        logger.info("加载原始文件...")
        original_wb = openpyxl.load_workbook(original_file_temp)
        original_ws = original_wb.active
        
        # 获取原始文件的所有行
        original_rows = list(original_ws.iter_rows(values_only=True))
        original_row_count = len(original_rows)
        
        if original_row_count < 2:
            logger.error(f"原始文件行数不足: {original_row_count}（需要至少2行）")
            return 0.0
        
        # 保存第二行的数据（索引为1）
        second_row_data = original_rows[1]
        logger.info(f"原始文件行数: {original_row_count}")
        logger.info(f"原始文件第二行数据: {second_row_data}")
        
        # 加载结果文件
        logger.info(f"加载结果文件...")
        result_wb = openpyxl.load_workbook(result_file_path)
        result_ws = result_wb.active
        
        # 获取结果文件的所有行
        result_rows = list(result_ws.iter_rows(values_only=True))
        result_row_count = len(result_rows)
        
        logger.info(f"结果文件行数: {result_row_count}")
        
        # 验证1: 检查行数是否减少了1
        if result_row_count != original_row_count - 1:
            logger.error(f"行数验证失败: 期望 {original_row_count - 1} 行，实际 {result_row_count} 行")
            return 0.0
        else:
            logger.info(f"✓ 行数验证通过: {original_row_count} → {result_row_count}")
        
        # 验证2: 检查原始第二行是否存在于结果文件中
        second_row_exists = False
        for i, row in enumerate(result_rows):
            if row == second_row_data:
                logger.error(f"原始第二行数据仍存在于结果文件的第 {i+1} 行")
                second_row_exists = True
                break
        
        if second_row_exists:
            return 0.0
        else:
            logger.info(f"✓ 原始第二行数据已从结果文件中删除")
        
        # 验证3: 检查其他行是否保持不变（第一行和第3行之后）
        # 结果文件的第一行应该等于原始文件的第一行
        if result_rows[0] != original_rows[0]:
            logger.error(f"第一行数据不匹配")
            logger.error(f"  原始: {original_rows[0]}")
            logger.error(f"  结果: {result_rows[0]}")
            return 0.0
        
        # 结果文件的第2行及之后应该等于原始文件的第3行及之后
        for i in range(1, result_row_count):
            if result_rows[i] != original_rows[i+1]:
                logger.error(f"第 {i+1} 行数据不匹配")
                logger.error(f"  期望（原始第 {i+2} 行）: {original_rows[i+1]}")
                logger.error(f"  实际: {result_rows[i]}")
                return 0.0
        
        logger.info(f"✓ 其他行数据保持不变")
        
        # 清理临时文件
        if original_file_temp != options.get('original_file_cache', ''):
            try:
                os.unlink(original_file_temp)
            except:
                pass
        
        logger.info("=" * 60)
        logger.info("✓ 所有验证通过！第二行已成功删除")
        logger.info("=" * 60)
        return 1.0
        
    except Exception as e:
        import traceback
        logger.error(f"评估出错: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_regexp_extract(result: str, expected: str = None, **options) -> float:
    """
    Verify if REGEX formulas exist in specified columns (B and C) with correct patterns.
    
    This function checks:
    1. Whether cells in specified columns contain REGEX formulas
    2. Whether formulas reference the corresponding A column cell (B2->A2, B3->A3, etc.)
    3. Whether formulas contain the correct pattern text (牛肉丸 for B column, 牛筋丸 for C column)
    4. Whether formulas have the correct structure with lookbehind and lookahead
    
    The function automatically detects the number of data rows by checking the data column
    (default: A column) for non-empty cells. It stops checking after finding 3 consecutive
    empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_columns: List of columns to check (e.g., ["B", "C"])
            - start_row: Starting row number (default: 2)
            - end_row: Ending row number (optional, will auto-detect if not provided)
            - expected_pattern: Expected function name (default: "REGEX")
            - column_patterns: Dict mapping column letters to expected pattern text
            - data_column: Column to check for data to determine end_row (default: "A")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_columns = options.get('check_columns', ['B', 'C'])
        start_row = options.get('start_row', 2)
        end_row = options.get('end_row', None)  # Optional, will auto-detect if not provided
        expected_pattern = options.get('expected_pattern', 'REGEX')
        column_patterns = options.get('column_patterns', {'B': '牛肉丸', 'C': '牛筋丸'})
        data_column = options.get('data_column', 'A')  # Column to check for data to determine end_row
        
        if not check_columns:
            logger.error("No columns specified in options")
            return 0.0
        
        logger.info(f"Verifying REGEX formulas in file: {result}")
        logger.info(f"Columns to check: {check_columns}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Expected function: {expected_pattern}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        if end_row is None:
            logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
            max_row = ws.max_row
            end_row = start_row  # Start from start_row
            
            # Find the last row with data in the data column
            # Check up to max_row, but stop if we find 3 consecutive empty rows
            empty_count = 0
            for row_num in range(start_row, max_row + 1):
                data_cell = ws[f"{data_column}{row_num}"]
                if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                    empty_count += 1
                    if empty_count >= 3:  # Stop after 3 consecutive empty rows
                        break
                else:
                    empty_count = 0
                    end_row = row_num  # Update end_row to the last row with data
            
            logger.info(f"Auto-detected end row: {end_row}")
        else:
            logger.info(f"Using specified end row: {end_row}")
        
        # Check each column and row
        all_passed = True
        for col_letter in check_columns:
            expected_pattern_text = column_patterns.get(col_letter)
            if not expected_pattern_text:
                logger.warning(f"No pattern text specified for column {col_letter}, skipping")
                continue
            
            logger.info(f"Checking column {col_letter} with pattern '{expected_pattern_text}' (rows {start_row} to {end_row})")
            
            for row_num in range(start_row, end_row + 1):
                cell_coord = f"{col_letter}{row_num}"
                try:
                    cell = ws[cell_coord]
                    logger.debug(f"Checking cell {cell_coord}")
                    
                    # Check if cell contains a formula
                    if cell.data_type != "f":
                        logger.warning(f"Cell {cell_coord} does not contain a formula")
                        all_passed = False
                        continue
                    
                    # Get formula text
                    formula_text = None
                    if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                        formula_text = cell._value
                    elif hasattr(cell, "formula"):
                        formula_text = cell.formula
                    else:
                        # Try to get from value attribute
                        if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                            formula_text = cell.value
                    
                    if formula_text is None:
                        logger.warning(f"Could not extract formula from cell {cell_coord}")
                        all_passed = False
                        continue
                    
                    # Remove leading = if present for comparison
                    formula_clean = formula_text.lstrip("=")
                    logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                    
                    # Check 1: Formula contains REGEX function
                    if expected_pattern.upper() not in formula_text.upper():
                        logger.warning(f"Cell {cell_coord} formula does not contain {expected_pattern}")
                        logger.warning(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 2: Formula contains expected pattern text (牛肉丸 or 牛筋丸)
                    if expected_pattern_text not in formula_text:
                        logger.warning(f"Cell {cell_coord} formula does not contain pattern text '{expected_pattern_text}'")
                        logger.warning(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 3: Formula contains REGEX function call structure
                    regex_match = re.search(r'REGEX\s*\([^)]+\)', formula_text, re.IGNORECASE)
                    if not regex_match:
                        logger.warning(f"Cell {cell_coord} formula does not have correct REGEX structure")
                        logger.warning(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 4: Formula references the corresponding A column cell (A2, A3, etc.)
                    expected_a_cell = f"A{row_num}"
                    # Check if formula contains A column reference with the same row number
                    a_cell_pattern = rf'A{row_num}\b'
                    if not re.search(a_cell_pattern, formula_text, re.IGNORECASE):
                        logger.warning(f"Cell {cell_coord} formula does not reference {expected_a_cell}")
                        logger.warning(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 5: Formula contains lookbehind pattern (?<=...)
                    if "(?<=" not in formula_text:
                        logger.warning(f"Cell {cell_coord} formula does not contain lookbehind pattern (?<=...)")
                        logger.warning(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 6: Formula contains lookahead pattern (?=,)
                    if "(?=," not in formula_text:
                        logger.warning(f"Cell {cell_coord} formula does not contain lookahead pattern (?=,)")
                        logger.warning(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 7: Formula contains \d+ pattern
                    if "\\d+" not in formula_text:
                        # Also check for unescaped version in the pattern
                        if not re.search(r'\\d\+|d\+', formula_text):
                            logger.warning(f"Cell {cell_coord} formula does not contain digit pattern \\d+")
                            logger.warning(f"Formula: {formula_text}")
                            all_passed = False
                            continue
                    
                    # Check 8: Formula pattern should contain 5 dots after pattern text
                    # Pattern should be like: (?<=牛肉丸.....)
                    pattern_with_dots = expected_pattern_text + "....."
                    if pattern_with_dots not in formula_text:
                        logger.warning(f"Cell {cell_coord} formula pattern may not have 5 dots after '{expected_pattern_text}'")
                        logger.debug(f"Formula: {formula_text}")
                        # Don't fail, just warn - the pattern might be correct but formatted differently
                    
                    logger.info(f"✓ Cell {cell_coord} has valid REGEX formula: {formula_text}")
                    
                except Exception as e:
                    logger.error(f"Error checking cell {cell_coord}: {e}")
                    import traceback
                    logger.error(traceback.format_exc())
                    all_passed = False
        
        if all_passed:
            logger.info("=" * 60)
            logger.info(f"✓ All cells in columns {check_columns} contain correct {expected_pattern} formulas")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ {expected_pattern} formula verification failed")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_regexp_order_extract(result: str, expected: str = None, **options) -> float:
    """
    Verify if REGEXP formulas exist in specified column (C) to extract order numbers from addresses.
    
    This function checks:
    1. Whether cells in specified column contain REGEXP formulas
    2. Whether formulas reference the corresponding A column cell (C2->A2, C3->A3, etc.)
    3. Whether formulas contain the correct regex pattern (\\w{10})
    4. Whether formulas have the correct structure
    
    The function automatically detects the number of data rows by checking the data column
    (default: A column) for non-empty cells. It stops checking after finding 3 consecutive
    empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_column: Column to check (e.g., "C")
            - start_row: Starting row number (default: 2)
            - expected_pattern: Expected function name (default: "REGEXP")
            - expected_formula_pattern: Expected formula pattern (e.g., "REGEXP(A")
            - regex_pattern: Expected regex pattern in formula (e.g., "\\w{10}")
            - data_column: Column to check for data to determine end_row (default: "A")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_column = options.get('check_column', 'C')
        start_row = options.get('start_row', 2)
        expected_pattern = options.get('expected_pattern', 'REGEX')
        expected_formula_pattern = options.get('expected_formula_pattern', 'REGEX(A')
        regex_pattern = options.get('regex_pattern', '[a-zA-Z0-9]{10}')
        data_column = options.get('data_column', 'A')
        
        logger.info(f"Verifying REGEXP order extraction in file: {result}")
        logger.info(f"Column to check: {check_column}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Expected function: {expected_pattern}")
        logger.info(f"Expected regex pattern: {regex_pattern}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row  # Start from start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Check each row in the specified column
        all_passed = True
        logger.info(f"Checking column {check_column} (rows {start_row} to {end_row})")
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{check_column}{row_num}"
            try:
                cell = ws[cell_coord]
                logger.debug(f"Checking cell {cell_coord}")
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.warning(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                else:
                    # Try to get from value attribute
                    if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                # Remove leading = if present for comparison
                formula_clean = formula_text.lstrip("=")
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains REGEX function (support both REGEX and LibreOffice internal format)
                # LibreOffice may save as _xlfn.ORG.LIBREOFFICE.REGEX
                formula_upper = formula_text.upper()
                if expected_pattern.upper() not in formula_upper and '_XLFN.ORG.LIBREOFFICE.REGEX' not in formula_upper:
                    logger.warning(f"Cell {cell_coord} formula does not contain {expected_pattern} or LibreOffice REGEX")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 2: Formula contains expected formula pattern (REGEX(A or _xlfn.ORG.LIBREOFFICE.REGEX(A)
                formula_clean_upper = formula_clean.upper()
                if expected_formula_pattern.upper() not in formula_clean_upper and 'REGEX(A' not in formula_clean_upper:
                    logger.warning(f"Cell {cell_coord} formula does not contain pattern '{expected_formula_pattern}'")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: Formula contains REGEX function call structure (support both formats)
                regexp_match = re.search(r'(REGEX|REGEXP|_XLFN\.ORG\.LIBREOFFICE\.REGEX)\s*\([^)]+\)', formula_text, re.IGNORECASE)
                if not regexp_match:
                    logger.warning(f"Cell {cell_coord} formula does not have correct REGEX structure")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: Formula references the corresponding A column cell (A2, A3, etc.)
                expected_a_cell = f"A{row_num}"
                # Check if formula contains A column reference with the same row number
                a_cell_pattern = rf'A{row_num}\b'
                if not re.search(a_cell_pattern, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {cell_coord} formula does not reference {expected_a_cell}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 5: Formula contains the regex pattern ([a-zA-Z0-9]{10})
                # The pattern might be escaped differently in the formula
                # Check for various escape formats
                pattern_variations = [
                    regex_pattern,  # [a-zA-Z0-9]{10}
                    regex_pattern.replace('\\', '\\\\'),  # [a-zA-Z0-9]{10} with double escape
                    regex_pattern.replace('[', '\\[').replace(']', '\\]'),  # Escaped brackets
                    '[a-zA-Z0-9]{10}',  # Original pattern
                    '\\[a-zA-Z0-9\\]{10}',  # Escaped brackets
                    '\\\\[a-zA-Z0-9\\\\]{10}',  # Double escaped
                ]
                found = False
                for pattern_var in pattern_variations:
                    if pattern_var in formula_text:
                        found = True
                        break
                if not found:
                    # Also check for pattern without escaping brackets
                    simple_pattern = 'a-zA-Z0-9]{10}'
                    if simple_pattern not in formula_text:
                        logger.warning(f"Cell {cell_coord} formula does not contain regex pattern '{regex_pattern}'")
                        logger.warning(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                
                logger.info(f"✓ Cell {cell_coord} has valid REGEXP formula: {formula_text}")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        if all_passed:
            logger.info("=" * 60)
            logger.info(f"✓ All cells in column {check_column} contain correct {expected_pattern} formulas")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ {expected_pattern} formula verification failed")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_sumif_formula(result: str, expected: str = None, **options) -> float:
    """
    Verify if SUMIF formulas exist in specified column (F) to calculate totals.
    
    This function checks:
    1. Whether cells in specified column contain SUMIF formulas
    2. Whether formulas reference the correct ranges (auto-detected from data)
    3. Whether formulas reference the corresponding E column cell (F2->E2, F3->E3, etc.)
    4. Whether formulas have the correct structure
    
    The function automatically detects:
    - end_row: by checking the data column (E) for non-empty cells
    - criteria_range: by detecting the range from the first formula or from criteria_column data
    - sum_range: by detecting the range from the first formula or from sum_column data
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_column: Column to check (e.g., "F")
            - start_row: Starting row number (default: 2)
            - expected_function: Expected function name (default: "SUMIF")
            - criteria_column: Column containing criteria (e.g., "B")
            - sum_column: Column containing values to sum (e.g., "C")
            - criteria_column_start: Starting row for criteria column (default: 2)
            - data_column: Column to check for data to determine end_row (default: "E")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_column = options.get('check_column', 'F')
        start_row = options.get('start_row', 2)
        expected_function = options.get('expected_function', 'SUMIF')
        criteria_column = options.get('criteria_column', 'B')
        sum_column = options.get('sum_column', 'C')
        criteria_column_start = options.get('criteria_column_start', 2)
        data_column = options.get('data_column', 'E')
        
        logger.info(f"Verifying SUMIF formulas in file: {result}")
        logger.info(f"Column to check: {check_column}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Expected function: {expected_function}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row  # Start from start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Auto-detect criteria_range and sum_range by checking the first formula
        criteria_range = None
        sum_range = None
        
        # Try to extract ranges from the first formula
        first_cell_coord = f"{check_column}{start_row}"
        try:
            first_cell = ws[first_cell_coord]
            if first_cell.data_type == "f":
                first_formula_text = None
                if hasattr(first_cell, "_value") and isinstance(first_cell._value, str) and first_cell._value.startswith("="):
                    first_formula_text = first_cell._value
                elif hasattr(first_cell, "formula"):
                    first_formula_text = first_cell.formula
                elif first_cell.value is not None and isinstance(first_cell.value, str) and first_cell.value.startswith("="):
                    first_formula_text = first_cell.value
                
                if first_formula_text:
                    # Extract ranges from SUMIF formula: SUMIF(range1, criteria, range2)
                    # Pattern: SUMIF(range1, criteria, range2)
                    sumif_pattern = r'SUMIF\s*\(\s*([^,]+)\s*,\s*[^,]+\s*,\s*([^)]+)\s*\)'
                    match = re.search(sumif_pattern, first_formula_text, re.IGNORECASE)
                    if match:
                        criteria_range = match.group(1).strip()
                        sum_range = match.group(2).strip()
                        logger.info(f"Extracted from first formula: criteria_range={criteria_range}, sum_range={sum_range}")
        except Exception as e:
            logger.debug(f"Could not extract ranges from first formula: {e}")
        
        # If ranges not found in formula, detect from data columns
        if not criteria_range or not sum_range:
            logger.info(f"Auto-detecting ranges from data columns...")
            # Find the last row with data in criteria_column
            criteria_end_row = criteria_column_start
            empty_count = 0
            for row_num in range(criteria_column_start, max_row + 1):
                criteria_cell = ws[f"{criteria_column}{row_num}"]
                if criteria_cell.value is None or (isinstance(criteria_cell.value, str) and criteria_cell.value.strip() == ""):
                    empty_count += 1
                    if empty_count >= 3:
                        break
                else:
                    empty_count = 0
                    criteria_end_row = row_num
            
            # Find the last row with data in sum_column
            sum_end_row = criteria_column_start
            empty_count = 0
            for row_num in range(criteria_column_start, max_row + 1):
                sum_cell = ws[f"{sum_column}{row_num}"]
                if sum_cell.value is None or (isinstance(sum_cell.value, str) and sum_cell.value.strip() == ""):
                    empty_count += 1
                    if empty_count >= 3:
                        break
                else:
                    empty_count = 0
                    sum_end_row = row_num
            
            # Use the maximum end row for both ranges
            max_end_row = max(criteria_end_row, sum_end_row)
            criteria_range = f"{criteria_column}{criteria_column_start}:{criteria_column}{max_end_row}"
            sum_range = f"{sum_column}{criteria_column_start}:{sum_column}{max_end_row}"
            logger.info(f"Auto-detected ranges: criteria_range={criteria_range}, sum_range={sum_range}")
        
        # Check each row in the specified column
        all_passed = True
        logger.info(f"Checking column {check_column} (rows {start_row} to {end_row})")
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{check_column}{row_num}"
            try:
                cell = ws[cell_coord]
                logger.debug(f"Checking cell {cell_coord}")
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.warning(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                else:
                    # Try to get from value attribute
                    if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                # Remove leading = if present for comparison
                formula_clean = formula_text.lstrip("=")
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains SUMIF function
                formula_upper = formula_text.upper()
                if expected_function.upper() not in formula_upper:
                    logger.warning(f"Cell {cell_coord} formula does not contain {expected_function}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 2: Formula contains SUMIF function call structure
                sumif_match = re.search(r'SUMIF\s*\([^)]+\)', formula_text, re.IGNORECASE)
                if not sumif_match:
                    logger.warning(f"Cell {cell_coord} formula does not have correct SUMIF structure")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: Formula contains criteria range
                if criteria_range and criteria_range.upper() not in formula_upper:
                    logger.warning(f"Cell {cell_coord} formula does not contain criteria range '{criteria_range}'")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: Formula contains sum range
                if sum_range and sum_range.upper() not in formula_upper:
                    logger.warning(f"Cell {cell_coord} formula does not contain sum range '{sum_range}'")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 5: Formula references the corresponding E column cell (E2, E3, etc.)
                expected_e_cell = f"E{row_num}"
                # Check if formula contains E column reference with the same row number
                e_cell_pattern = rf'E{row_num}\b'
                if not re.search(e_cell_pattern, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {cell_coord} formula does not reference {expected_e_cell}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                logger.info(f"✓ Cell {cell_coord} has valid SUMIF formula: {formula_text}")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        if all_passed:
            logger.info("=" * 60)
            logger.info(f"✓ All cells in column {check_column} contain correct {expected_function} formulas")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ {expected_function} formula verification failed")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_networkdays_formula(result: str, expected: str = None, **options) -> float:
    """
    Verify if NETWORKDAYS formulas exist in specified column to calculate working days.
    
    This function checks:
    1. Whether cells in specified column contain NETWORKDAYS formulas
    2. Whether formulas reference the corresponding start date column cell (A2, A3, etc.)
    3. Whether formulas reference the corresponding end date column cell (B2, B3, etc.)
    4. Whether formulas have the correct structure
    
    The function automatically detects the number of data rows by checking the data column
    (default: A column) for non-empty cells. It stops checking after finding 3 consecutive
    empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_column: Column to check (e.g., "C")
            - start_row: Starting row number (default: 2)
            - start_date_column: Column containing start dates (e.g., "A")
            - end_date_column: Column containing end dates (e.g., "B")
            - expected_function: Expected function name (default: "NETWORKDAYS")
            - data_column: Column to check for data to determine end_row (default: "A")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_column = options.get('check_column', 'C')
        start_row = options.get('start_row', 2)
        start_date_column = options.get('start_date_column', 'A')
        end_date_column = options.get('end_date_column', 'B')
        expected_function = options.get('expected_function', 'NETWORKDAYS')
        data_column = options.get('data_column', 'A')
        
        logger.info(f"Verifying NETWORKDAYS formulas in file: {result}")
        logger.info(f"Column to check: {check_column}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Start date column: {start_date_column}")
        logger.info(f"End date column: {end_date_column}")
        logger.info(f"Expected function: {expected_function}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row  # Start from start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Check each row in the specified column
        all_passed = True
        logger.info(f"Checking column {check_column} (rows {start_row} to {end_row})")
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{check_column}{row_num}"
            try:
                cell = ws[cell_coord]
                logger.debug(f"Checking cell {cell_coord}")
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.warning(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                else:
                    # Try to get from value attribute
                    if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                # Remove leading = if present for comparison
                formula_clean = formula_text.lstrip("=")
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains NETWORKDAYS function
                formula_upper = formula_text.upper()
                if expected_function.upper() not in formula_upper:
                    logger.warning(f"Cell {cell_coord} formula does not contain {expected_function}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 2: Formula contains NETWORKDAYS function call structure
                # NETWORKDAYS can have 2 or 3 parameters: NETWORKDAYS(start_date, end_date) or NETWORKDAYS(start_date, end_date, holidays)
                networkdays_pattern = r'NETWORKDAYS\s*\([^)]+\)'
                networkdays_match = re.search(networkdays_pattern, formula_text, re.IGNORECASE)
                if not networkdays_match:
                    logger.warning(f"Cell {cell_coord} formula does not have correct NETWORKDAYS structure")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: Formula references the corresponding start date column cell (A2, A3, etc.)
                expected_start_cell = f"{start_date_column}{row_num}"
                start_cell_pattern = rf'{start_date_column}{row_num}\b'
                if not re.search(start_cell_pattern, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {cell_coord} formula does not reference start date cell {expected_start_cell}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: Formula references the corresponding end date column cell (B2, B3, etc.)
                expected_end_cell = f"{end_date_column}{row_num}"
                end_cell_pattern = rf'{end_date_column}{row_num}\b'
                if not re.search(end_cell_pattern, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {cell_coord} formula does not reference end date cell {expected_end_cell}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                logger.info(f"✓ Cell {cell_coord} has valid NETWORKDAYS formula: {formula_text}")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        if all_passed:
            logger.info("=" * 60)
            logger.info(f"✓ All cells in column {check_column} contain correct {expected_function} formulas")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ {expected_function} formula verification failed")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_conditional_formatting_reconciliation(result: str, expected: str = None, **options) -> float:
    """
    Verify if conditional formatting is correctly set up for reconciliation between two tables.
    
    This function checks:
    1. Whether conditional formatting rules exist in the worksheet
    2. Whether the formula matches the expected pattern (e.g., A1<>E1 to compare cells from two tables)
    3. Whether conditional formatting is applied to the correct range
    4. Whether cells with differences are formatted (highlighted)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_range: Range where conditional formatting should be applied (e.g., "A1:C16")
            - compare_range: Range to compare against (e.g., "E1:G16")
            - expected_formula: Expected formula pattern (e.g., "A1<>E1")
            - format_column: Column to check for formatting (optional, e.g., "B")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        from openpyxl.worksheet.cell_range import CellRange
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_range = options.get('check_range', 'A1:C16')
        compare_range = options.get('compare_range', 'E1:G16')
        expected_formula = options.get('expected_formula', 'A1<>E1')
        format_column = options.get('format_column', None)
        
        logger.info(f"Verifying conditional formatting reconciliation in file: {result}")
        logger.info(f"Check range: {check_range}")
        logger.info(f"Compare range: {compare_range}")
        logger.info(f"Expected formula pattern: {expected_formula}")
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=False)
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check if conditional formatting exists
        conditional_formattings = ws.conditional_formatting
        if not conditional_formattings:
            logger.error("No conditional formatting rules found in the worksheet")
            return 0.0
        
        logger.info(f"Found {len(conditional_formattings)} conditional formatting rule(s)")
        
        # Parse expected formula to extract cell references
        # Expected formula like "A1<>E1" means compare A1 with E1
        expected_formula_clean = expected_formula.replace(" ", "").upper()
        
        # Find matching conditional formatting rule
        found_matching_rule = False
        rule_applied_to_correct_range = False
        
        for fmt in conditional_formattings:
            for rule in fmt.rules:
                # Check if rule has formula
                if not rule.formula:
                    continue
                
                # Check formula pattern
                formula_text = rule.formula[0] if rule.formula else ""
                formula_text_clean = formula_text.replace(" ", "").upper()
                
                logger.debug(f"Checking rule with formula: {formula_text}")
                
                # Check if formula matches expected pattern
                # The formula should contain comparison like A1<>E1, A2<>E2, etc.
                # We need to check if the pattern matches (allowing for relative references)
                if "<>" in expected_formula_clean:
                    # Extract cell references from expected formula
                    # Pattern: A1<>E1 means compare A column with E column
                    expected_parts = expected_formula_clean.split("<>")
                    if len(expected_parts) == 2:
                        expected_cell1 = expected_parts[0]  # e.g., "A1"
                        expected_cell2 = expected_parts[1]   # e.g., "E1"
                        
                        # Extract column letters
                        expected_col1 = re.match(r'([A-Z]+)', expected_cell1)
                        expected_col2 = re.match(r'([A-Z]+)', expected_cell2)
                        
                        if expected_col1 and expected_col2:
                            col1 = expected_col1.group(1)
                            col2 = expected_col2.group(1)
                            
                            # Check if formula contains comparison between these columns
                            # Pattern should be like: A1<>E1, A2<>E2, etc. (relative references)
                            pattern1 = rf'{col1}\d+\s*<>\s*{col2}\d+'
                            pattern2 = rf'{col1}\d+\s*!=\s*{col2}\d+'  # Alternative: !=
                            
                            if re.search(pattern1, formula_text_clean, re.IGNORECASE) or \
                               re.search(pattern2, formula_text_clean, re.IGNORECASE):
                                found_matching_rule = True
                                logger.info(f"✓ Found matching formula pattern: {formula_text}")
                                
                                # Check if rule is applied to correct range
                                fmt_ranges = [str(rng) for rng in fmt.cells]
                                check_range_upper = check_range.upper()
                                
                                # Check if check_range is covered by any of the formatting ranges
                                try:
                                    check_cell_range = CellRange(check_range_upper)
                                    for fmt_range_str in fmt_ranges:
                                        fmt_cell_range = CellRange(fmt_range_str)
                                        # Check if check_range is within or overlaps with fmt_range
                                        if (check_cell_range.min_row >= fmt_cell_range.min_row and
                                            check_cell_range.max_row <= fmt_cell_range.max_row and
                                            check_cell_range.min_col >= fmt_cell_range.min_col and
                                            check_cell_range.max_col <= fmt_cell_range.max_col):
                                            rule_applied_to_correct_range = True
                                            logger.info(f"✓ Rule applied to correct range: {fmt_range_str} covers {check_range}")
                                            break
                                except Exception as e:
                                    logger.debug(f"Error parsing ranges: {e}")
                                    # If range parsing fails, check if range string matches
                                    if check_range_upper in fmt_ranges:
                                        rule_applied_to_correct_range = True
                                        logger.info(f"✓ Rule applied to exact range: {check_range}")
                                
                                break
            
            if found_matching_rule:
                break
        
        if not found_matching_rule:
            logger.error("No conditional formatting rule found with expected formula pattern")
            return 0.0
        
        if not rule_applied_to_correct_range:
            logger.warning("Conditional formatting rule found but may not be applied to correct range")
            # Don't fail completely, as the range might be slightly different but still valid
        
        # Optional: Check if cells with differences are actually formatted
        # This is a more advanced check that verifies the formatting is working
        if format_column:
            logger.info(f"Checking formatting in column {format_column}...")
            # Try to find cells in format_column that have conditional formatting applied
            # This is a simplified check - in practice, we'd need to evaluate the formula
            # for each cell to see if it's formatted
            
        logger.info("=" * 60)
        logger.info("✓ Conditional formatting reconciliation verification passed")
        logger.info("=" * 60)
        return 1.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_right_len_find_extract(result: str, expected: str = None, **options) -> float:
    """
    Verify if RIGHT, LEN, and FIND formulas exist in specified column to extract text.
    
    This function checks:
    1. Whether cells in specified column contain RIGHT, LEN, and FIND functions
    2. Whether formulas reference the corresponding source column cell (C2->B2, C3->B3, etc.)
    3. Whether formulas contain the correct pattern (e.g., RIGHT(B2,LEN(B2)-FIND("班",B2)))
    4. Whether formulas have the correct structure with RIGHT, LEN, and FIND functions
    
    The function automatically detects the number of data rows by checking the data column
    (default: B column) for non-empty cells. It stops checking after finding 3 consecutive
    empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_column: Column to check (e.g., "C")
            - start_row: Starting row number (default: 2)
            - expected_functions: List of expected function names (e.g., ["RIGHT", "LEN", "FIND"])
            - expected_formula_pattern: Expected formula pattern (e.g., "RIGHT(B")
            - find_text: Text to find in FIND function (e.g., "班")
            - data_column: Column to check for data to determine end_row (default: "B")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_column = options.get('check_column', 'C')
        start_row = options.get('start_row', 2)
        expected_functions = options.get('expected_functions', ['RIGHT', 'LEN', 'FIND'])
        expected_formula_pattern = options.get('expected_formula_pattern', 'RIGHT(B')
        find_text = options.get('find_text', '班')
        data_column = options.get('data_column', 'B')
        
        logger.info(f"Verifying RIGHT/LEN/FIND extraction formulas in file: {result}")
        logger.info(f"Column to check: {check_column}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Expected functions: {expected_functions}")
        logger.info(f"Expected formula pattern: {expected_formula_pattern}")
        logger.info(f"Find text: {find_text}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row  # Start from start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Check each row in the specified column
        all_passed = True
        logger.info(f"Checking column {check_column} (rows {start_row} to {end_row})")
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{check_column}{row_num}"
            try:
                cell = ws[cell_coord]
                logger.debug(f"Checking cell {cell_coord}")
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.warning(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                else:
                    # Try to get from value attribute
                    if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                # Remove leading = if present for comparison
                formula_clean = formula_text.lstrip("=")
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains all expected functions
                for func_name in expected_functions:
                    if func_name.upper() not in formula_upper:
                        logger.warning(f"Cell {cell_coord} formula does not contain {func_name}")
                        logger.warning(f"Formula: {formula_text}")
                        all_passed = False
                        break
                
                if not all_passed:
                    continue
                
                # Check 2: Formula contains expected formula pattern (e.g., RIGHT(B)
                if expected_formula_pattern.upper() not in formula_upper:
                    logger.warning(f"Cell {cell_coord} formula does not contain pattern '{expected_formula_pattern}'")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: Formula contains RIGHT function call structure
                right_match = re.search(r'RIGHT\s*\([^)]+\)', formula_text, re.IGNORECASE)
                if not right_match:
                    logger.warning(f"Cell {cell_coord} formula does not have correct RIGHT structure")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: Formula contains LEN function
                len_match = re.search(r'LEN\s*\([^)]+\)', formula_text, re.IGNORECASE)
                if not len_match:
                    logger.warning(f"Cell {cell_coord} formula does not have LEN function")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 5: Formula contains FIND function with find_text
                find_pattern = rf'FIND\s*\([^)]*{re.escape(find_text)}[^)]*\)'
                find_match = re.search(find_pattern, formula_text, re.IGNORECASE)
                if not find_match:
                    logger.warning(f"Cell {cell_coord} formula does not contain FIND function with text '{find_text}'")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 6: Formula references the corresponding source column cell (B2, B3, etc.)
                expected_source_cell = f"{data_column}{row_num}"
                source_cell_pattern = rf'{data_column}{row_num}\b'
                if not re.search(source_cell_pattern, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {cell_coord} formula does not reference source cell {expected_source_cell}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 7: Formula structure should be RIGHT(B2, LEN(B2)-FIND("班",B2))
                # Verify that LEN and FIND are used together in the second parameter of RIGHT
                # This is a pattern check - the formula should have LEN(...)-FIND(...) structure
                len_find_pattern = r'LEN\s*\([^)]+\)\s*-\s*FIND\s*\([^)]+\)'
                if not re.search(len_find_pattern, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {cell_coord} formula does not have LEN(...)-FIND(...) structure")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                logger.info(f"✓ Cell {cell_coord} has valid RIGHT/LEN/FIND formula: {formula_text}")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        if all_passed:
            logger.info("=" * 60)
            logger.info(f"✓ All cells in column {check_column} contain correct RIGHT/LEN/FIND formulas")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ RIGHT/LEN/FIND formula verification failed")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_iferror_regex_extract(result: str, expected: str = None, **options) -> float:
    """
    Verify if IFERROR(REGEX(...)) formulas exist in specified column to extract text with error handling.
    
    This function checks:
    1. Whether cells in specified column contain IFERROR function wrapping REGEX
    2. Whether REGEX function uses capture group pattern (e.g., .*水笔(\d+).*)
    3. Whether REGEX function uses replacement pattern (e.g., $1元)
    4. Whether IFERROR has empty string as second parameter
    5. Whether formulas reference the corresponding source column cell
    
    The function automatically detects the number of data rows by checking the data column
    for non-empty cells. It stops checking after finding 3 consecutive empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_column: Column to check (e.g., "C")
            - start_row: Starting row number (default: 2)
            - expected_pattern_text: Expected text pattern in regex (e.g., "水笔")
            - data_column: Column to check for data to determine end_row (default: "B")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_column = options.get('check_column', 'C')
        start_row = options.get('start_row', 2)
        expected_pattern_text = options.get('expected_pattern_text', '水笔')
        data_column = options.get('data_column', 'B')
        
        logger.info(f"Verifying IFERROR(REGEX(...)) formulas in file: {result}")
        logger.info(f"Column to check: {check_column}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Expected pattern text: {expected_pattern_text}")
        logger.info(f"Data column: {data_column}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row  # Start from start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Check each row in the specified column
        all_passed = True
        logger.info(f"Checking column {check_column} (rows {start_row} to {end_row})")
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{check_column}{row_num}"
            try:
                cell = ws[cell_coord]
                logger.debug(f"Checking cell {cell_coord}")
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.warning(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                else:
                    # Try to get from value attribute
                    if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains IFERROR function
                if 'IFERROR' not in formula_upper:
                    logger.warning(f"Cell {cell_coord} formula does not contain IFERROR function")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 2: Formula contains REGEX function (inside IFERROR)
                # Support both REGEX and LibreOffice internal format _xlfn.ORG.LIBREOFFICE.REGEX
                has_regex = 'REGEX' in formula_upper or '_XLFN.ORG.LIBREOFFICE.REGEX' in formula_upper
                if not has_regex:
                    logger.warning(f"Cell {cell_coord} formula does not contain REGEX function")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: IFERROR structure - should have two parameters
                iferror_match = re.search(r'IFERROR\s*\([^)]+\)', formula_text, re.IGNORECASE)
                if not iferror_match:
                    logger.warning(f"Cell {cell_coord} formula does not have correct IFERROR structure")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: IFERROR second parameter should be empty string ""
                # Handle various formats: ,"" or , "" or ,'' or , ''
                # Also handle LibreOffice format with spaces: REGEX(...) ,""
                # Extract IFERROR parameters: IFERROR(param1, param2)
                iferror_params_match = re.search(r'IFERROR\s*\((.*)\)', formula_text, re.IGNORECASE)
                if iferror_params_match:
                    params_str = iferror_params_match.group(1)
                    # Split by comma, but need to handle nested commas in strings
                    # Simple approach: find the last comma (should separate the two parameters)
                    # For IFERROR(REGEX(...), ""), the last comma separates REGEX call from ""
                    last_comma_pos = params_str.rfind(',')
                    if last_comma_pos != -1:
                        second_param = params_str[last_comma_pos + 1:].strip()
                        # Check if second parameter is empty string "" or ''
                        if second_param in ['""', "''", '""', "''"]:
                            has_empty_string = True
                        else:
                            has_empty_string = False
                    else:
                        has_empty_string = False
                else:
                    has_empty_string = False
                
                if not has_empty_string:
                    logger.warning(f"Cell {cell_coord} IFERROR should have empty string as second parameter")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 5: REGEX function call structure
                # Support both REGEX and LibreOffice internal format
                regex_match = re.search(r'(REGEX|_XLFN\.ORG\.LIBREOFFICE\.REGEX)\s*\([^)]+\)', formula_text, re.IGNORECASE)
                if not regex_match:
                    logger.warning(f"Cell {cell_coord} formula does not have correct REGEX structure")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 6: Formula contains expected pattern text (e.g., "水笔")
                if expected_pattern_text not in formula_text:
                    logger.warning(f"Cell {cell_coord} formula does not contain pattern text '{expected_pattern_text}'")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 7: Formula contains capture group pattern (\d+)
                has_capture_group = bool(re.search(r'\(\\d\+\)|\(\\\\d\+\)', formula_text))
                if not has_capture_group:
                    logger.warning(f"Cell {cell_coord} REGEX formula should contain capture group (\\d+)")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 8: Formula contains replacement pattern $1
                has_replacement = '"$1' in formula_text or "'$1" in formula_text
                if not has_replacement:
                    logger.warning(f"Cell {cell_coord} REGEX formula should contain replacement pattern $1")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 9: Formula references the corresponding source column cell
                expected_source_cell = f"{data_column}{row_num}"
                source_cell_pattern = rf'{data_column}{row_num}\b'
                if not re.search(source_cell_pattern, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {cell_coord} formula does not reference source cell {expected_source_cell}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                logger.info(f"✓ Cell {cell_coord} has valid IFERROR(REGEX(...)) formula: {formula_text}")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        if all_passed:
            logger.info("=" * 60)
            logger.info(f"✓ All cells in column {check_column} contain correct IFERROR(REGEX(...)) formulas")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ IFERROR(REGEX(...)) formula verification failed")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_rept_text_progress_bar(result: str, expected: str = None, **options) -> float:
    """
    Verify if REPT and TEXT formulas exist in specified column to create progress bars with percentage.
    
    This function checks:
    1. Whether cells in specified column contain REPT and TEXT functions
    2. Whether REPT function uses the correct character (e.g., "|")
    3. Whether REPT function uses the correct multiplier (e.g., *50)
    4. Whether TEXT function uses percentage format (e.g., "0%")
    5. Whether formulas reference the correct numerator and denominator columns
    6. Whether formulas use & operator to concatenate REPT and TEXT results
    
    The function automatically detects the number of data rows by checking the data column
    for non-empty cells. It stops checking after finding 3 consecutive empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_column: Column to check (e.g., "D")
            - start_row: Starting row number (default: 2)
            - expected_functions: List of expected function names (e.g., ["REPT", "TEXT"])
            - numerator_column: Column containing numerator values (e.g., "C")
            - denominator_column: Column containing denominator values (e.g., "B")
            - rept_char: Character to repeat in REPT function (e.g., "|")
            - rept_multiplier: Multiplier for REPT function (e.g., 50)
            - data_column: Column to check for data to determine end_row (default: "B")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_column = options.get('check_column', 'D')
        start_row = options.get('start_row', 2)
        expected_functions = options.get('expected_functions', ['REPT', 'TEXT'])
        numerator_column = options.get('numerator_column', 'C')
        denominator_column = options.get('denominator_column', 'B')
        rept_char = options.get('rept_char', '|')
        rept_multiplier = options.get('rept_multiplier', 50)
        data_column = options.get('data_column', 'B')
        
        logger.info(f"Verifying REPT/TEXT progress bar formulas in file: {result}")
        logger.info(f"Column to check: {check_column}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Expected functions: {expected_functions}")
        logger.info(f"Numerator column: {numerator_column}")
        logger.info(f"Denominator column: {denominator_column}")
        logger.info(f"REPT character: {rept_char}")
        logger.info(f"REPT multiplier: {rept_multiplier}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row  # Start from start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Check each row in the specified column
        all_passed = True
        logger.info(f"Checking column {check_column} (rows {start_row} to {end_row})")
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{check_column}{row_num}"
            try:
                cell = ws[cell_coord]
                logger.debug(f"Checking cell {cell_coord}")
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.warning(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                else:
                    # Try to get from value attribute
                    if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains all expected functions (REPT and TEXT)
                for func_name in expected_functions:
                    if func_name.upper() not in formula_upper:
                        logger.warning(f"Cell {cell_coord} formula does not contain {func_name}")
                        logger.warning(f"Formula: {formula_text}")
                        all_passed = False
                        break
                
                if not all_passed:
                    continue
                
                # Check 2: Formula contains REPT function call structure
                rept_match = re.search(r'REPT\s*\([^)]+\)', formula_text, re.IGNORECASE)
                if not rept_match:
                    logger.warning(f"Cell {cell_coord} formula does not have correct REPT structure")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: REPT function contains the correct character (e.g., "|")
                # Support both double quotes and single quotes
                rept_char_pattern1 = rf'REPT\s*\(\s*"{re.escape(rept_char)}"'
                rept_char_pattern2 = rf"REPT\s*\(\s*'{re.escape(rept_char)}'"
                if not re.search(rept_char_pattern1, formula_text, re.IGNORECASE) and \
                   not re.search(rept_char_pattern2, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {cell_coord} REPT function should use character '{rept_char}'")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: REPT function contains the multiplier (e.g., *50)
                rept_multiplier_pattern = rf'\*{rept_multiplier}\b'
                if not re.search(rept_multiplier_pattern, formula_text):
                    logger.warning(f"Cell {cell_coord} REPT function should use multiplier *{rept_multiplier}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 5: Formula contains TEXT function call structure
                text_match = re.search(r'TEXT\s*\([^)]+\)', formula_text, re.IGNORECASE)
                if not text_match:
                    logger.warning(f"Cell {cell_coord} formula does not have correct TEXT structure")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 6: TEXT function contains percentage format ("0%" or '0%')
                text_percent_pattern1 = r'TEXT\s*\([^,]+,\s*"0%"'
                text_percent_pattern2 = r"TEXT\s*\([^,]+,\s*'0%'"
                if not re.search(text_percent_pattern1, formula_text, re.IGNORECASE) and \
                   not re.search(text_percent_pattern2, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {cell_coord} TEXT function should use percentage format \"0%\"")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 7: Formula references the correct numerator column (C2, C3, etc.)
                expected_numerator_cell = f"{numerator_column}{row_num}"
                numerator_cell_pattern = rf'{numerator_column}{row_num}\b'
                if not re.search(numerator_cell_pattern, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {cell_coord} formula does not reference numerator cell {expected_numerator_cell}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 8: Formula references the correct denominator column (B2, B3, etc.)
                expected_denominator_cell = f"{denominator_column}{row_num}"
                denominator_cell_pattern = rf'{denominator_column}{row_num}\b'
                if not re.search(denominator_cell_pattern, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {cell_coord} formula does not reference denominator cell {expected_denominator_cell}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 9: Formula contains & operator to concatenate REPT and TEXT
                if '&' not in formula_text:
                    logger.warning(f"Cell {cell_coord} formula should use & operator to concatenate REPT and TEXT")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 10: Formula structure should be REPT(...)&TEXT(...)
                # Verify that REPT comes before TEXT (or at least both are present)
                rept_pos = formula_text.upper().find('REPT')
                text_pos = formula_text.upper().find('TEXT')
                if rept_pos == -1 or text_pos == -1:
                    logger.warning(f"Cell {cell_coord} formula should contain both REPT and TEXT functions")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                logger.info(f"✓ Cell {cell_coord} has valid REPT/TEXT progress bar formula: {formula_text}")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        if all_passed:
            logger.info("=" * 60)
            logger.info(f"✓ All cells in column {check_column} contain correct REPT/TEXT progress bar formulas")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ REPT/TEXT progress bar formula verification failed")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_id_extract_gender_age_birthday(result: str, expected: str = None, **options) -> float:
    """
    Verify if formulas exist to extract gender, age, and birthday from ID numbers.
    
    This function checks:
    1. Gender column (C): IF(MOD(MID(B3,17,1),2),"男","女")
    2. Age column (D): DATEDIF(TEXT(MID(B3,7,8),"0-00-00"),TODAY(),"Y")
    3. Birthday column (E): --TEXT(MID(B3,7,8),"0-00-00")
    
    The function automatically detects the number of data rows by checking the ID column
    for non-empty cells. It stops checking after finding 3 consecutive empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - id_column: Column containing ID numbers (e.g., "B")
            - gender_column: Column for gender formulas (e.g., "C")
            - age_column: Column for age formulas (e.g., "D")
            - birthday_column: Column for birthday formulas (e.g., "E")
            - start_row: Starting row number (default: 3)
            - data_column: Column to check for data to determine end_row (default: "B")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        id_column = options.get('id_column', 'B')
        gender_column = options.get('gender_column', 'C')
        age_column = options.get('age_column', 'D')
        birthday_column = options.get('birthday_column', 'E')
        start_row = options.get('start_row', 3)
        data_column = options.get('data_column', 'B')
        
        logger.info(f"Verifying ID extraction formulas in file: {result}")
        logger.info(f"ID column: {id_column}")
        logger.info(f"Gender column: {gender_column}")
        logger.info(f"Age column: {age_column}")
        logger.info(f"Birthday column: {birthday_column}")
        logger.info(f"Start row: {start_row}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row  # Start from start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Check each row
        all_passed = True
        logger.info(f"Checking rows {start_row} to {end_row}")
        
        for row_num in range(start_row, end_row + 1):
            try:
                # Check gender column (C)
                gender_cell_coord = f"{gender_column}{row_num}"
                gender_cell = ws[gender_cell_coord]
                
                if gender_cell.data_type != "f":
                    logger.warning(f"Cell {gender_cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                gender_formula_text = None
                if hasattr(gender_cell, "_value") and isinstance(gender_cell._value, str) and gender_cell._value.startswith("="):
                    gender_formula_text = gender_cell._value
                elif hasattr(gender_cell, "formula"):
                    gender_formula_text = gender_cell.formula
                elif gender_cell.value is not None and isinstance(gender_cell.value, str) and gender_cell.value.startswith("="):
                    gender_formula_text = gender_cell.value
                
                if gender_formula_text is None:
                    logger.warning(f"Could not extract formula from cell {gender_cell_coord}")
                    all_passed = False
                    continue
                
                gender_formula_upper = gender_formula_text.upper()
                logger.debug(f"Cell {gender_cell_coord} formula: {gender_formula_text}")
                
                # Check gender formula: IF(MOD(MID(B3,17,1),2),"男","女")
                if 'IF' not in gender_formula_upper:
                    logger.warning(f"Cell {gender_cell_coord} formula does not contain IF function")
                    all_passed = False
                    continue
                
                if 'MOD' not in gender_formula_upper:
                    logger.warning(f"Cell {gender_cell_coord} formula does not contain MOD function")
                    all_passed = False
                    continue
                
                if 'MID' not in gender_formula_upper:
                    logger.warning(f"Cell {gender_cell_coord} formula does not contain MID function")
                    all_passed = False
                    continue
                
                # Check MID(B3,17,1) pattern
                mid_pattern = rf'MID\s*\(\s*{id_column}{row_num}\s*,\s*17\s*,\s*1\s*\)'
                if not re.search(mid_pattern, gender_formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {gender_cell_coord} formula should contain MID({id_column}{row_num},17,1)")
                    logger.warning(f"Formula: {gender_formula_text}")
                    all_passed = False
                    continue
                
                # Check for "男" and "女" in formula
                if '"男"' not in gender_formula_text and "'男'" not in gender_formula_text:
                    logger.warning(f"Cell {gender_cell_coord} formula should contain \"男\"")
                    logger.warning(f"Formula: {gender_formula_text}")
                    all_passed = False
                    continue
                
                if '"女"' not in gender_formula_text and "'女'" not in gender_formula_text:
                    logger.warning(f"Cell {gender_cell_coord} formula should contain \"女\"")
                    logger.warning(f"Formula: {gender_formula_text}")
                    all_passed = False
                    continue
                
                logger.info(f"✓ Cell {gender_cell_coord} has valid gender formula: {gender_formula_text}")
                
                # Check age column (D)
                age_cell_coord = f"{age_column}{row_num}"
                age_cell = ws[age_cell_coord]
                
                if age_cell.data_type != "f":
                    logger.warning(f"Cell {age_cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                age_formula_text = None
                if hasattr(age_cell, "_value") and isinstance(age_cell._value, str) and age_cell._value.startswith("="):
                    age_formula_text = age_cell._value
                elif hasattr(age_cell, "formula"):
                    age_formula_text = age_cell.formula
                elif age_cell.value is not None and isinstance(age_cell.value, str) and age_cell.value.startswith("="):
                    age_formula_text = age_cell.value
                
                if age_formula_text is None:
                    logger.warning(f"Could not extract formula from cell {age_cell_coord}")
                    all_passed = False
                    continue
                
                age_formula_upper = age_formula_text.upper()
                logger.debug(f"Cell {age_cell_coord} formula: {age_formula_text}")
                
                # Check age formula: DATEDIF(TEXT(MID(B3,7,8),"0-00-00"),TODAY(),"Y")
                if 'DATEDIF' not in age_formula_upper:
                    logger.warning(f"Cell {age_cell_coord} formula does not contain DATEDIF function")
                    all_passed = False
                    continue
                
                if 'TEXT' not in age_formula_upper:
                    logger.warning(f"Cell {age_cell_coord} formula does not contain TEXT function")
                    all_passed = False
                    continue
                
                if 'TODAY' not in age_formula_upper:
                    logger.warning(f"Cell {age_cell_coord} formula does not contain TODAY function")
                    all_passed = False
                    continue
                
                if 'MID' not in age_formula_upper:
                    logger.warning(f"Cell {age_cell_coord} formula does not contain MID function")
                    all_passed = False
                    continue
                
                # Check MID(B3,7,8) pattern
                mid_pattern_age = rf'MID\s*\(\s*{id_column}{row_num}\s*,\s*7\s*,\s*8\s*\)'
                if not re.search(mid_pattern_age, age_formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {age_cell_coord} formula should contain MID({id_column}{row_num},7,8)")
                    logger.warning(f"Formula: {age_formula_text}")
                    all_passed = False
                    continue
                
                # Check TEXT format "0-00-00"
                # Use pattern that matches until the quote to handle nested functions like MID(B3,7,8)
                text_format_pattern1 = r'TEXT\s*\([^"]+,\s*"0-00-00"'
                text_format_pattern2 = r"TEXT\s*\([^']+,\s*'0-00-00'"
                if not re.search(text_format_pattern1, age_formula_text, re.IGNORECASE) and \
                   not re.search(text_format_pattern2, age_formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {age_cell_coord} TEXT function should use format \"0-00-00\"")
                    logger.warning(f"Formula: {age_formula_text}")
                    all_passed = False
                    continue
                
                # Check DATEDIF third parameter "Y"
                # Use a more flexible pattern that handles nested functions
                # Check if DATEDIF contains "Y" as the third parameter (after two commas)
                # Pattern: DATEDIF(...,...,"Y") or DATEDIF(...,...,'Y')
                # We'll count commas to find the third parameter
                datedif_match = re.search(r'DATEDIF\s*\((.*)\)', age_formula_text, re.IGNORECASE)
                if datedif_match:
                    datedif_params = datedif_match.group(1)
                    # Count commas to find the third parameter
                    # Simple approach: check if the last part before closing paren is "Y" or 'Y'
                    # More robust: find the pattern ,"Y" or ,'Y' before the closing paren
                    if not re.search(r',\s*"Y"\s*\)', age_formula_text, re.IGNORECASE) and \
                       not re.search(r",\s*'Y'\s*\)", age_formula_text, re.IGNORECASE):
                        logger.warning(f"Cell {age_cell_coord} DATEDIF function should use \"Y\" parameter")
                        logger.warning(f"Formula: {age_formula_text}")
                        all_passed = False
                        continue
                else:
                    logger.warning(f"Cell {age_cell_coord} could not parse DATEDIF function")
                    logger.warning(f"Formula: {age_formula_text}")
                    all_passed = False
                    continue
                
                logger.info(f"✓ Cell {age_cell_coord} has valid age formula: {age_formula_text}")
                
                # Check birthday column (E)
                birthday_cell_coord = f"{birthday_column}{row_num}"
                birthday_cell = ws[birthday_cell_coord]
                
                if birthday_cell.data_type != "f":
                    logger.warning(f"Cell {birthday_cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                birthday_formula_text = None
                if hasattr(birthday_cell, "_value") and isinstance(birthday_cell._value, str) and birthday_cell._value.startswith("="):
                    birthday_formula_text = birthday_cell._value
                elif hasattr(birthday_cell, "formula"):
                    birthday_formula_text = birthday_cell.formula
                elif birthday_cell.value is not None and isinstance(birthday_cell.value, str) and birthday_cell.value.startswith("="):
                    birthday_formula_text = birthday_cell.value
                
                if birthday_formula_text is None:
                    logger.warning(f"Could not extract formula from cell {birthday_cell_coord}")
                    all_passed = False
                    continue
                
                birthday_formula_upper = birthday_formula_text.upper()
                logger.debug(f"Cell {birthday_cell_coord} formula: {birthday_formula_text}")
                
                # Check birthday formula: TEXT(MID(B3,7,8),"0-00-00")
                if 'TEXT' not in birthday_formula_upper:
                    logger.warning(f"Cell {birthday_cell_coord} formula does not contain TEXT function")
                    all_passed = False
                    continue
                
                if 'MID' not in birthday_formula_upper:
                    logger.warning(f"Cell {birthday_cell_coord} formula does not contain MID function")
                    all_passed = False
                    continue
                
                # Check MID(B3,7,8) pattern
                mid_pattern_birthday = rf'MID\s*\(\s*{id_column}{row_num}\s*,\s*7\s*,\s*8\s*\)'
                if not re.search(mid_pattern_birthday, birthday_formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {birthday_cell_coord} formula should contain MID({id_column}{row_num},7,8)")
                    logger.warning(f"Formula: {birthday_formula_text}")
                    all_passed = False
                    continue
                
                # Check TEXT format "0-00-00"
                # Use pattern that matches until the quote to handle nested functions like MID(B3,7,8)
                text_format_pattern1 = r'TEXT\s*\([^"]+,\s*"0-00-00"'
                text_format_pattern2 = r"TEXT\s*\([^']+,\s*'0-00-00'"
                if not re.search(text_format_pattern1, birthday_formula_text, re.IGNORECASE) and \
                   not re.search(text_format_pattern2, birthday_formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {birthday_cell_coord} TEXT function should use format \"0-00-00\"")
                    logger.warning(f"Formula: {birthday_formula_text}")
                    all_passed = False
                    continue
                
                logger.info(f"✓ Cell {birthday_cell_coord} has valid birthday formula: {birthday_formula_text}")
                
            except Exception as e:
                logger.error(f"Error checking row {row_num}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        if all_passed:
            logger.info("=" * 60)
            logger.info(f"✓ All rows contain correct ID extraction formulas (gender, age, birthday)")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ ID extraction formula verification failed")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_line_chart(result: str, expected: str = None, **options) -> float:
    """
    Verify if a line chart exists in the Excel file.
    
    This function checks:
    1. Whether at least one chart exists in the worksheet
    2. Whether the chart type is lineChart
    3. Whether the chart has the expected number of series
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - expected_chart_type: Expected chart type (default: "lineChart")
            - min_series_count: Minimum number of series expected (default: 1)
            - data_range: Data range used for chart (optional, for logging)
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        expected_chart_type = options.get('expected_chart_type', 'lineChart')
        min_series_count = options.get('min_series_count', 1)
        data_range = options.get('data_range', '')
        
        logger.info(f"Verifying line chart in file: {result}")
        logger.info(f"Expected chart type: {expected_chart_type}")
        logger.info(f"Minimum series count: {min_series_count}")
        if data_range:
            logger.info(f"Data range: {data_range}")
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result)
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check if charts exist
        charts = ws._charts
        if not charts or len(charts) == 0:
            logger.error("No charts found in the worksheet")
            return 0.0
        
        logger.info(f"Found {len(charts)} chart(s) in the worksheet")
        
        # Check each chart
        for chart_idx, chart in enumerate(charts):
            logger.info(f"Checking chart {chart_idx + 1}...")
            
            # Check chart type
            chart_type = None
            if hasattr(chart, 'tagname'):
                chart_type = chart.tagname
            logger.info(f"Chart type: {chart_type}")
            
            # Check if it's a line chart
            if chart_type and expected_chart_type.lower() in chart_type.lower():
                logger.info(f"✓ Chart {chart_idx + 1} is a line chart")
                
                # Check if it has series
                if not hasattr(chart, 'series') or not chart.series:
                    logger.warning(f"Chart {chart_idx + 1} has no series")
                    continue
                
                series_count = len(chart.series)
                logger.info(f"Chart {chart_idx + 1} has {series_count} series")
                
                # Verify series count
                if series_count >= min_series_count:
                    logger.info("=" * 60)
                    logger.info(f"✓ Line chart verification passed")
                    logger.info(f"  Chart type: {chart_type}")
                    logger.info(f"  Series count: {series_count} (minimum required: {min_series_count})")
                    logger.info("=" * 60)
                    return 1.0
                else:
                    logger.warning(f"Chart {chart_idx + 1} has {series_count} series, but minimum required is {min_series_count}")
            else:
                logger.warning(f"Chart {chart_idx + 1} is not a line chart (type: {chart_type})")
        
        # If we get here, verification failed
        logger.error("=" * 60)
        logger.error(f"✗ Line chart verification failed")
        logger.error(f"  Expected chart type: {expected_chart_type}")
        logger.error(f"  Minimum series count: {min_series_count}")
        logger.error("=" * 60)
        return 0.0
             
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_salary_growth_chart(result: str, expected: str = None, **options) -> float:
    """
    Verify if the salary growth chart matches the expected specifications.
    
    This function checks the chart itself (not the data table):
    1. Whether a chart exists in the specified sheet
    2. Whether the chart title matches "店长工资增长"
    3. Whether the chart has the expected number of series (at least 3)
    4. Whether the chart is a combination chart (bar + line)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - sheet_idx: Sheet index (default: 0)
            - expected_title: Expected chart title (default: "店长工资增长")
            - min_series_count: Minimum number of series (default: 3)
            - chart_type: Expected chart type (default: "combination")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        sheet_idx = options.get('sheet_idx', 0)
        expected_title = options.get('expected_title', '店长工资增长')
        min_series_count = options.get('min_series_count', 3)
        chart_type = options.get('chart_type', 'combination')
        
        logger.info(f"Verifying salary growth chart in file: {result}")
        logger.info(f"Sheet index: {sheet_idx}")
        logger.info(f"Expected title: {expected_title}")
        logger.info(f"Min series count: {min_series_count}")
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result)
            pdworkbook = pd.ExcelFile(result)
            sheet_names = pdworkbook.sheet_names
            
            if sheet_idx >= len(sheet_names):
                logger.error(f"Sheet index {sheet_idx} out of range. Available sheets: {sheet_names}")
                return 0.0
            
            sheet_name = sheet_names[sheet_idx]
            logger.info(f"Checking sheet: {sheet_name}")
            ws = wb[sheet_name]
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return 0.0
        
        # Check if charts exist
        charts = ws._charts
        if not charts:
            logger.error("No charts found in the sheet")
            return 0.0
        
        logger.info(f"Found {len(charts)} chart(s) in the sheet")
        
        # Load chart information
        chart_props = ['title', 'type', 'legend', 'xtitle', 'ytitle']
        chart_info = load_charts(wb, sheet_name, chart_props=chart_props)
        
        if not chart_info:
            logger.error("Could not load chart information")
            return 0.0
        
        # Check each chart
        chart_passed = False
        for chart_key, chart_data in chart_info.items():
            logger.info(f"Checking chart: {chart_key}")
            logger.debug(f"Chart data: {chart_data}")
            
            # Check 1: Chart title
            chart_title = chart_data.get('title')
            if chart_title != expected_title:
                logger.warning(f"Chart title mismatch: expected '{expected_title}', got '{chart_title}'")
                continue
            else:
                logger.info(f"✓ Chart title matches: {chart_title}")
            
            # Check 2: Chart type (for combination charts, we might see multiple types)
            chart_type_actual = chart_data.get('type')
            logger.info(f"Chart type: {chart_type_actual}")
            # Note: Combination charts might be represented differently in openpyxl
            # We'll be lenient here and just check that a chart exists
            
            # Check 3: Number of series
            # Extract series count from chart_key (format: "value_ref1,category_ref1;value_ref2,category_ref2;...")
            series_parts = chart_key.split(';')
            series_count = len(series_parts)
            logger.info(f"Number of series: {series_count}")
            
            if series_count < min_series_count:
                logger.warning(f"Insufficient series count: expected at least {min_series_count}, got {series_count}")
                continue
            else:
                logger.info(f"✓ Series count sufficient: {series_count} >= {min_series_count}")
            
            # If we get here, this chart passed all checks
            chart_passed = True
            logger.info("=" * 60)
            logger.info(f"✓ Chart verification passed!")
            logger.info("=" * 60)
            break
        
        if chart_passed:
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error("✗ Chart verification failed - no chart matched all criteria")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_project_completion_chart(result: str, expected: str = None, **options) -> float:
    """
    Verify if a combination chart exists with the expected title that contains
    both bar chart series (for project values) and line chart series (for completion rates).
    
    This function checks:
    1. Whether at least one chart exists in the worksheet
    2. Whether the chart title matches expected_title
    3. Whether the chart has at least 16 series (8 projects + 8 completion rates)
    4. Whether at least one series name contains "rate" (for completion rates)
    5. Whether the chart has at least project_count * 5 categories (for 5 quarters per project)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - sheet_idx: Sheet index to check (default: 0)
            - expected_title: Expected chart title (default: "项目")
            - min_series_count: Minimum number of series required (default: 16)
            - project_count: Number of projects (default: 8)
            - quarters_per_project: Number of quarters per project (default: 5)
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        sheet_idx = options.get('sheet_idx', 0)
        expected_title = options.get('expected_title', '项目')
        min_series_count = options.get('min_series_count', 16)
        project_count = options.get('project_count', 8)
        quarters_per_project = options.get('quarters_per_project', 5)
        min_categories = project_count * quarters_per_project
        
        logger.info(f"Verifying project completion chart in file: {result}")
        logger.info(f"Sheet index: {sheet_idx}")
        logger.info(f"Expected title: {expected_title}")
        logger.info(f"Minimum series count: {min_series_count}")
        logger.info(f"Project count: {project_count}")
        logger.info(f"Quarters per project: {quarters_per_project}")
        logger.info(f"Minimum categories: {min_categories}")
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result)
            sheet_names = wb.sheetnames
            if sheet_idx >= len(sheet_names):
                logger.error(f"Sheet index {sheet_idx} out of range. Available sheets: {sheet_names}")
                return 0.0
            sheet_name = sheet_names[sheet_idx]
            ws = wb[sheet_name]
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check if charts exist
        charts = ws._charts
        if not charts:
            logger.error("No charts found in the worksheet")
            return 0.0
        
        logger.info(f"Found {len(charts)} chart(s) in the worksheet")
        
        # Check each chart
        chart_found = False
        for chart in charts:
            # Check chart title
            chart_title = None
            try:
                if chart.title and chart.title.tx:
                    if hasattr(chart.title.tx, 'rich') and chart.title.tx.rich:
                        if hasattr(chart.title.tx.rich, 'p') and chart.title.tx.rich.p:
                            if len(chart.title.tx.rich.p) > 0:
                                if hasattr(chart.title.tx.rich.p[0], 'r') and chart.title.tx.rich.p[0].r:
                                    if len(chart.title.tx.rich.p[0].r) > 0:
                                        if hasattr(chart.title.tx.rich.p[0].r[0], 't'):
                                            chart_title = chart.title.tx.rich.p[0].r[0].t
            except Exception as e:
                logger.debug(f"Error reading chart title: {e}")
            
            logger.info(f"Chart title: {chart_title}")
            
            # Check if title matches
            if chart_title == expected_title:
                logger.info(f"✓ Chart title matches: {chart_title}")
                chart_found = True
                
                # Use load_charts to get all series information (includes both bar and line series)
                # This is more reliable for combination charts
                chart_props = ['title']
                chart_info = load_charts(wb, sheet_name, chart_props=chart_props)
                
                # Find the chart that matches our title
                chart_key = None
                for key, info in chart_info.items():
                    if info.get('title') == expected_title:
                        chart_key = key
                        break
                
                # Get all series from the chart object for detailed inspection
                all_series = list(chart.series) if hasattr(chart, 'series') else []
                logger.info(f"Series count from chart.series: {len(all_series)}")
                
                if not chart_key:
                    logger.warning("Could not find chart in load_charts output, using direct series access")
                    # Fallback to direct series access
                    series_count = len(all_series)
                else:
                    # Extract series count from chart_key (format: "value_ref1,category_ref1;value_ref2,category_ref2;...")
                    # This includes ALL series (both bar and line) in combination charts
                    series_parts = chart_key.split(';')
                    series_count_from_load = len(series_parts)
                    logger.info(f"Series count from load_charts: {series_count_from_load}")
                    
                    # For combination charts, load_charts should give us all series
                    # Use the count from load_charts as it's more reliable for combination charts
                    series_count = series_count_from_load
                    
                    # Also check for sub-charts in case series are stored there
                    if hasattr(chart, '_charts') and chart._charts:
                        # Check for sub-charts (for combination charts)
                        for sub_chart in chart._charts:
                            if hasattr(sub_chart, 'series'):
                                sub_series = list(sub_chart.series)
                                all_series.extend(sub_series)
                                logger.info(f"Found {len(sub_series)} additional series in sub-chart")
                    
                    # If load_charts gave us fewer series than direct access, use the larger count
                    # This handles edge cases where load_charts might miss some series
                    if series_count < len(all_series):
                        logger.warning(f"load_charts found {series_count} series but direct access found {len(all_series)}, using larger count")
                        series_count = len(all_series)
                
                logger.info(f"Chart has {series_count} series (including both bar and line series)")
                
                # Debug: Log all series details
                if all_series:
                    logger.info(f"Detailed series information:")
                    for idx, ser in enumerate(all_series):
                        logger.info(f"  Series {idx}: {type(ser).__name__}")
                        try:
                            if hasattr(ser, 'title'):
                                logger.debug(f"    Title: {ser.title}")
                        except:
                            pass
                
                if series_count < min_series_count:
                    logger.error(f"✗ Chart has only {series_count} series, expected at least {min_series_count}")
                    return 0.0
                
                logger.info(f"✓ Chart has {series_count} series (>= {min_series_count})")
                
                # Check series names for "rate" (completion rate series)
                has_rate_series = False
                series_names = []
                for i, ser in enumerate(all_series):
                    series_name = None
                    try:
                        # Try to get series title/name
                        if hasattr(ser, 'title') and ser.title:
                            if hasattr(ser.title, 'tx') and ser.title.tx:
                                if hasattr(ser.title.tx, 'rich') and ser.title.tx.rich:
                                    if hasattr(ser.title.tx.rich, 'p') and ser.title.tx.rich.p:
                                        if len(ser.title.tx.rich.p) > 0:
                                            if hasattr(ser.title.tx.rich.p[0], 'r') and ser.title.tx.rich.p[0].r:
                                                if len(ser.title.tx.rich.p[0].r) > 0:
                                                    if hasattr(ser.title.tx.rich.p[0].r[0], 't'):
                                                        series_name = ser.title.tx.rich.p[0].r[0].t
                        # Alternative: check if title is a string reference
                        if not series_name and hasattr(ser, 'title') and hasattr(ser.title, 'tx') and hasattr(ser.title.tx, 'strRef'):
                            if hasattr(ser.title.tx.strRef, 'f'):
                                series_name = ser.title.tx.strRef.f
                    except Exception as e:
                        logger.debug(f"Error reading series {i} name: {e}")
                    
                    if series_name:
                        series_names.append(series_name)
                        if "rate" in series_name.lower():
                            has_rate_series = True
                            logger.info(f"✓ Found series with 'rate' in name: {series_name}")
                
                if series_names:
                    logger.info(f"Series names found: {series_names[:10]}...")  # Log first 10
                else:
                    logger.warning("Could not extract series names, will skip rate check")
                
                if not has_rate_series and series_names:
                    logger.error(f"✗ No series found with 'rate' in name. Series names: {series_names}")
                    return 0.0
                elif not has_rate_series:
                    logger.warning("⚠ Could not verify 'rate' in series names (series names not extractable)")
                
                # Check category count
                max_categories = 0
                category_ranges = []
                
                def parse_range_count(range_str):
                    """Parse Excel range string and return count of cells"""
                    try:
                        # Remove sheet name if present (e.g., "Sheet1!$A$2:$A$6" -> "$A$2:$A$6")
                        if '!' in range_str:
                            range_str = range_str.split('!')[1]
                        
                        # Remove $ signs
                        range_str = range_str.replace('$', '')
                        
                        if ':' in range_str:
                            start, end = range_str.split(':')
                            # Parse start and end coordinates
                            start_col, start_row = coordinate_to_tuple(start)
                            end_col, end_row = coordinate_to_tuple(end)
                            
                            # Calculate count based on range
                            if start_col == end_col:
                                # Same column, count rows
                                return abs(end_row - start_row) + 1
                            elif start_row == end_row:
                                # Same row, count columns
                                return abs(end_col - start_col) + 1
                            else:
                                # 2D range
                                return (abs(end_row - start_row) + 1) * (abs(end_col - start_col) + 1)
                        else:
                            # Single cell
                            return 1
                    except Exception as e:
                        logger.debug(f"Error parsing range {range_str}: {e}")
                        return 0
                
                for i, ser in enumerate(all_series):
                    try:
                        # Try to get category count from category reference
                        if hasattr(ser, 'cat'):
                            cat_range = None
                            # Check if categories are from a range
                            if hasattr(ser.cat, 'numRef') and hasattr(ser.cat.numRef, 'f'):
                                cat_range = ser.cat.numRef.f
                            elif hasattr(ser.cat, 'strRef') and hasattr(ser.cat.strRef, 'f'):
                                cat_range = ser.cat.strRef.f
                            
                            if cat_range:
                                category_ranges.append(cat_range)
                                cat_count = parse_range_count(cat_range)
                                if cat_count > max_categories:
                                    max_categories = cat_count
                                logger.debug(f"Series {i} category range: {cat_range}, count: {cat_count}")
                    except Exception as e:
                        logger.debug(f"Error reading categories for series {i}: {e}")
                
                if max_categories > 0:
                    logger.info(f"Maximum category count found: {max_categories}")
                    if max_categories < min_categories:
                        logger.error(f"✗ Chart has only {max_categories} categories, expected at least {min_categories} (project_count * quarters_per_project)")
                        return 0.0
                    logger.info(f"✓ Chart has {max_categories} categories (>= {min_categories})")
                else:
                    # If we can't determine category count from ranges, use heuristic
                    # For 8 projects with 5 quarters each, we need at least 40 categories
                    # But since we can't verify directly, we'll log a warning
                    logger.warning(f"⚠ Could not determine exact category count from ranges. Expected at least {min_categories} categories.")
                    logger.info(f"Category ranges found: {category_ranges[:5]}...")  # Log first 5
                
                # Check if it's a combination chart
                if series_count >= 2:
                    logger.info("✓ Chart appears to be a combination chart (has multiple series)")
                else:
                    logger.error(f"✗ Chart has only {series_count} series, expected at least 2 for combination chart")
                    return 0.0
                
                break
        
        if chart_found:
            logger.info("=" * 60)
            logger.info("✓ Project completion combination chart verification passed")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ Chart with title '{expected_title}' not found")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_shipping_boxes_calculation(result: str, expected: str = None, **options) -> float:
    """
    Verify if formulas exist to calculate shipping boxes from product specifications and order quantities.
    
    This function checks:
    1. Whether cells in specified column contain formulas (not just values)
    2. Whether formulas contain required functions: INT, VALUE, LEFT, FIND, MOD, IF
    3. Whether formulas reference the specification column (B) and quantity column (C)
    4. Whether formulas contain Chinese characters "支" and "盒"
    5. Whether formulas use string concatenation (&)
    
    The expected formula pattern:
    =INT(C2/VALUE(LEFT(B2,FIND("支",B2)-1)))&"盒"&IF(MOD(C2,VALUE(LEFT(B2,FIND("支",B2)-1)))=0,"","加"&MOD(C2,VALUE(LEFT(B2,FIND("支",B2)-1)))&"支")
    
    The function automatically detects the number of data rows by checking the data column
    for non-empty cells. It stops checking after finding 3 consecutive empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_column: Column to check (e.g., "D")
            - start_row: Starting row number (default: 2)
            - spec_column: Column containing product specifications (e.g., "B")
            - quantity_column: Column containing order quantities (e.g., "C")
            - expected_functions: List of expected function names (e.g., ["INT", "VALUE", "LEFT", "FIND", "MOD", "IF"])
            - data_column: Column to check for data to determine end_row (default: "B")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_column = options.get('check_column', 'D')
        start_row = options.get('start_row', 2)
        spec_column = options.get('spec_column', 'B')
        quantity_column = options.get('quantity_column', 'C')
        expected_functions = options.get('expected_functions', ['INT', 'VALUE', 'LEFT', 'FIND', 'MOD', 'IF'])
        data_column = options.get('data_column', 'B')
        
        logger.info(f"Verifying shipping boxes calculation formulas in file: {result}")
        logger.info(f"Column to check: {check_column}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Specification column: {spec_column}")
        logger.info(f"Quantity column: {quantity_column}")
        logger.info(f"Expected functions: {expected_functions}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row  # Start from start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        if end_row < start_row:
            logger.error(f"No data rows found starting from row {start_row}")
            return 0.0
        
        # Check formulas in each row
        all_checks_passed = True
        rows_checked = 0
        
        for row_num in range(start_row, end_row + 1):
            check_cell = ws[f"{check_column}{row_num}"]
            spec_cell = ws[f"{spec_column}{row_num}"]
            quantity_cell = ws[f"{quantity_column}{row_num}"]
            
            # Skip if spec or quantity cell is empty
            if spec_cell.value is None or quantity_cell.value is None:
                continue
            
            rows_checked += 1
            formula = check_cell.value
            
            # Check 1: Formula exists (not just a value)
            if formula is None or not isinstance(formula, str) or not formula.startswith('='):
                logger.error(f"Cell {check_column}{row_num} should contain a formula, but got: {formula}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Row {row_num} formula: {formula}")
            
            # Check 2: Contains all required functions
            missing_functions = []
            for func in expected_functions:
                # Check for function name (with word boundary to avoid partial matches)
                func_pattern = r'\b' + re.escape(func) + r'\s*\('
                if not re.search(func_pattern, formula_upper, re.IGNORECASE):
                    missing_functions.append(func)
            
            if missing_functions:
                logger.error(f"Cell {check_column}{row_num} formula missing functions: {missing_functions}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: References specification column (B)
            spec_pattern = rf'{spec_column}\d+'
            if not re.search(spec_pattern, formula_upper):
                logger.error(f"Cell {check_column}{row_num} formula should reference {spec_column} column")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: References quantity column (C)
            quantity_pattern = rf'{quantity_column}\d+'
            if not re.search(quantity_pattern, formula_upper):
                logger.error(f"Cell {check_column}{row_num} formula should reference {quantity_column} column")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 5: Contains Chinese character "支" (for extracting pieces per box)
            if '"支"' not in formula and "'支'" not in formula and '支' not in formula:
                logger.error(f"Cell {check_column}{row_num} formula should contain '支' character")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 6: Contains Chinese character "盒" (for box unit)
            if '"盒"' not in formula and "'盒'" not in formula and '盒' not in formula:
                logger.error(f"Cell {check_column}{row_num} formula should contain '盒' character")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 7: Uses string concatenation (&)
            if '&' not in formula:
                logger.error(f"Cell {check_column}{row_num} formula should use & for string concatenation")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 8: Contains INT function (for calculating integer boxes)
            int_pattern = r'\bINT\s*\('
            if not re.search(int_pattern, formula_upper):
                logger.error(f"Cell {check_column}{row_num} formula should contain INT function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 9: Contains MOD function (for calculating remainder)
            mod_pattern = r'\bMOD\s*\('
            if not re.search(mod_pattern, formula_upper):
                logger.error(f"Cell {check_column}{row_num} formula should contain MOD function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 10: Contains IF function (for conditional formatting)
            if_pattern = r'\bIF\s*\('
            if not re.search(if_pattern, formula_upper):
                logger.error(f"Cell {check_column}{row_num} formula should contain IF function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            logger.debug(f"✓ Row {row_num} formula passed all checks")
        
        if rows_checked == 0:
            logger.error("No rows with data found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ Shipping boxes calculation verification passed")
            logger.info(f"  Rows checked: {rows_checked}")
            logger.info(f"  Column: {check_column}")
            logger.info(f"  Functions verified: {', '.join(expected_functions)}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ Shipping boxes calculation verification failed")
            logger.error(f"  Rows checked: {rows_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_split_content_formula(result: str, expected: str = None, **options) -> float:
    """
    Verify if formulas exist to split content with line breaks into multiple rows.
    
    This function checks:
    1. Whether cells in specified column contain formulas (not just values)
    2. Whether formulas contain required functions: TRIM, MID, SUBSTITUTE, CHAR, REPT, ROW
    3. Whether formulas reference the source column (A)
    4. Whether formulas contain CHAR(10) for line break
    5. Whether formulas contain REPT(" ",100) or similar pattern
    6. Whether formulas use ROW function for position calculation
    
    The expected formula pattern:
    =TRIM(MID(SUBSTITUTE(A2,CHAR(10),REPT(" ",100)),(ROW(A1)-1)*100+1,100))
    
    The function automatically detects the number of data rows by checking the data column
    for non-empty cells. It stops checking after finding 3 consecutive empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_column: Column to check (e.g., "B")
            - start_row: Starting row number (default: 2)
            - source_column: Column containing source data (e.g., "A")
            - expected_functions: List of expected function names (e.g., ["TRIM", "MID", "SUBSTITUTE", "CHAR", "REPT", "ROW"])
            - data_column: Column to check for data to determine end_row (default: "A")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_column = options.get('check_column', 'B')
        start_row = options.get('start_row', 2)
        source_column = options.get('source_column', 'A')
        expected_functions = options.get('expected_functions', ['TRIM', 'MID', 'SUBSTITUTE', 'CHAR', 'REPT', 'ROW'])
        data_column = options.get('data_column', 'A')
        
        logger.info(f"Verifying split content formulas in file: {result}")
        logger.info(f"Column to check: {check_column}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Source column: {source_column}")
        logger.info(f"Expected functions: {expected_functions}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row  # Start from start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        if end_row < start_row:
            logger.error(f"No data rows found starting from row {start_row}")
            return 0.0
        
        # Check formulas in each row
        all_checks_passed = True
        rows_checked = 0
        
        for row_num in range(start_row, end_row + 1):
            check_cell = ws[f"{check_column}{row_num}"]
            
            # Skip if source cell is empty
            source_cell = ws[f"{source_column}{row_num}"]
            if source_cell.value is None:
                continue
            
            rows_checked += 1
            formula = check_cell.value
            
            # Check 1: Formula exists (not just a value)
            if formula is None or not isinstance(formula, str) or not formula.startswith('='):
                logger.error(f"Cell {check_column}{row_num} should contain a formula, but got: {formula}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Row {row_num} formula: {formula}")
            
            # Check 2: Contains all required functions
            missing_functions = []
            for func in expected_functions:
                # Check for function name (with word boundary to avoid partial matches)
                func_pattern = r'\b' + re.escape(func) + r'\s*\('
                if not re.search(func_pattern, formula_upper, re.IGNORECASE):
                    missing_functions.append(func)
            
            if missing_functions:
                logger.error(f"Cell {check_column}{row_num} formula missing functions: {missing_functions}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: References source column (A)
            source_pattern = rf'{source_column}\d+'
            if not re.search(source_pattern, formula_upper):
                logger.error(f"Cell {check_column}{row_num} formula should reference {source_column} column")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3.5: SUBSTITUTE function must reference A2 specifically
            # Pattern: SUBSTITUTE(A2,...
            substitute_a2_pattern = rf'SUBSTITUTE\s*\(\s*{source_column}2\s*,'
            if not re.search(substitute_a2_pattern, formula_upper):
                logger.error(f"Cell {check_column}{row_num} formula SUBSTITUTE function must reference {source_column}2 (not {source_column}3, {source_column}4, etc.)")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Contains CHAR(10) for line break
            char_pattern = r'CHAR\s*\(\s*10\s*\)'
            if not re.search(char_pattern, formula_upper):
                logger.error(f"Cell {check_column}{row_num} formula should contain CHAR(10)")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 5: Contains REPT with space and 100
            rept_pattern = r'REPT\s*\(\s*["\']?\s*["\']?\s*,\s*100\s*\)'
            if not re.search(rept_pattern, formula_upper):
                logger.error(f"Cell {check_column}{row_num} formula should contain REPT(\" \",100) or similar")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 6: Contains ROW function
            row_pattern = r'\bROW\s*\('
            if not re.search(row_pattern, formula_upper):
                logger.error(f"Cell {check_column}{row_num} formula should contain ROW function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 7: Contains TRIM function (outermost)
            trim_pattern = r'\bTRIM\s*\('
            if not re.search(trim_pattern, formula_upper):
                logger.error(f"Cell {check_column}{row_num} formula should contain TRIM function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 8: Contains MID function
            mid_pattern = r'\bMID\s*\('
            if not re.search(mid_pattern, formula_upper):
                logger.error(f"Cell {check_column}{row_num} formula should contain MID function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 9: Contains SUBSTITUTE function
            substitute_pattern = r'\bSUBSTITUTE\s*\('
            if not re.search(substitute_pattern, formula_upper):
                logger.error(f"Cell {check_column}{row_num} formula should contain SUBSTITUTE function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            logger.debug(f"✓ Row {row_num} formula passed all checks")
        
        if rows_checked == 0:
            logger.error("No rows with data found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ Split content formula verification passed")
            logger.info(f"  Rows checked: {rows_checked}")
            logger.info(f"  Column: {check_column}")
            logger.info(f"  Functions verified: {', '.join(expected_functions)}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ Split content formula verification failed")
            logger.error(f"  Rows checked: {rows_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_quote_sheet_with_merged_cells(result: str, expected: str = None, **options) -> float:
    """
    Verify if a quote sheet template exists with the expected structure, fields, and merged cells.
    
    This function checks:
    1. Whether the title "报价单" exists in the worksheet
    2. Whether merged cells exist (especially for the title)
    3. Whether required header fields exist
    4. Whether the product table headers exist
    5. Whether summary fields exist
    6. Whether footer fields exist
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - expected_title: Expected title text (default: "报价单")
            - title_merged_range: Expected merged range for title (default: "G15:H15")
            - required_fields: List of required header field labels
            - table_headers: List of table header labels
            - summary_fields: List of summary field labels
            - footer_fields: List of footer field labels
            - min_merged_cells: Minimum number of merged cell ranges expected (default: 1)
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        expected_title = options.get('expected_title', '报价单')
        title_merged_range = options.get('title_merged_range', 'G15:H15')
        required_fields = options.get('required_fields', ['报价单位', '联系人', '联系电话', '客户名称', '报价日期', '邮箱'])
        table_headers = options.get('table_headers', ['序号', '产品名称', '产品类型', '规格', '数量', '单价', '金额', '备注'])
        summary_fields = options.get('summary_fields', ['合计金额(小写)', '合计金额(大写)'])
        footer_fields = options.get('footer_fields', ['报价人', '审批'])
        min_merged_cells = options.get('min_merged_cells', 1)
        
        logger.info(f"Verifying quote sheet template with merged cells in file: {result}")
        logger.info(f"Expected title: {expected_title}")
        logger.info(f"Title merged range: {title_merged_range}")
        logger.info(f"Required fields: {required_fields}")
        logger.info(f"Table headers: {table_headers}")
        logger.info(f"Summary fields: {summary_fields}")
        logger.info(f"Footer fields: {footer_fields}")
        logger.info(f"Minimum merged cells: {min_merged_cells}")
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=True)
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check merged cells
        merged_cells = list(ws.merged_cells.ranges)
        logger.info(f"Found {len(merged_cells)} merged cell range(s)")
        
        if len(merged_cells) < min_merged_cells:
            logger.error(f"✗ Insufficient merged cells: found {len(merged_cells)}, expected at least {min_merged_cells}")
            return 0.0
        
        # Check if title merged range exists
        title_merged_found = False
        for merged_range in merged_cells:
            merged_str = str(merged_range)
            logger.debug(f"Merged range: {merged_str}")
            if merged_str.upper() == title_merged_range.upper():
                title_merged_found = True
                logger.info(f"✓ Found title merged range: {merged_str}")
                break
        
        if not title_merged_found:
            logger.warning(f"⚠ Title merged range '{title_merged_range}' not found, but other merged cells exist")
            logger.info(f"  Available merged ranges: {[str(r) for r in merged_cells]}")
            # Don't fail completely, as the range might be slightly different
        
        # Search through all cells to find required text
        # Also check merged cells specifically
        max_row = ws.max_row
        max_col = ws.max_column
        
        # Convert all cell values to strings for searching
        # Include both individual cells and merged cell ranges
        all_text = []
        cell_text_map = {}  # Map cell coordinates to text for debugging
        
        for row in ws.iter_rows(min_row=1, max_row=max_row, min_col=1, max_col=max_col, values_only=False):
            for cell in row:
                if cell.value is not None:
                    cell_text = str(cell.value).strip()
                    all_text.append(cell_text)
                    cell_coord = cell.coordinate
                    cell_text_map[cell_coord] = cell_text
                    
                    # Also check if cell contains newlines (for merged cells with multiple fields)
                    if '\n' in cell_text or '\r' in cell_text:
                        # Split by newlines and add each line
                        lines = cell_text.replace('\r', '\n').split('\n')
                        for line in lines:
                            line = line.strip()
                            if line:
                                all_text.append(line)
        
        # Check merged cells - get text from the top-left cell of each merged range
        for merged_range in merged_cells:
            try:
                # Get the top-left cell of the merged range
                top_left_cell = ws[merged_range.min_row][merged_range.min_col - 1]
                if top_left_cell.value is not None:
                    merged_text = str(top_left_cell.value).strip()
                    all_text.append(merged_text)
                    # Also split by newlines if present
                    if '\n' in merged_text or '\r' in merged_text:
                        lines = merged_text.replace('\r', '\n').split('\n')
                        for line in lines:
                            line = line.strip()
                            if line:
                                all_text.append(line)
                    logger.debug(f"Merged range {merged_range} contains text: {merged_text[:100]}")
            except Exception as e:
                logger.debug(f"Error reading merged range {merged_range}: {e}")
        
        # Check 1: Title exists
        title_found = False
        for text in all_text:
            if expected_title in text:
                title_found = True
                logger.info(f"✓ Found title: {expected_title}")
                break
        
        if not title_found:
            logger.error(f"✗ Title '{expected_title}' not found")
            return 0.0
        
        # Check 2: Required header fields
        # Since fields may be in merged cells together, we need to check if all fields exist
        # even if they're in the same cell
        found_fields = []
        missing_fields = []
        for field in required_fields:
            field_found = False
            for text in all_text:
                if field in text:
                    field_found = True
                    found_fields.append(field)
                    logger.debug(f"Found field '{field}' in text: {text[:80]}...")
                    break
            if not field_found:
                missing_fields.append(field)
        
        # Log all text for debugging if fields are missing
        if missing_fields:
            logger.warning(f"⚠ Missing required fields: {missing_fields}")
            # Show some sample text that might contain the fields
            logger.debug(f"Sample text from worksheet (showing text with Chinese characters):")
            chinese_text_samples = [t for t in all_text if any('\u4e00' <= c <= '\u9fff' for c in t)][:20]
            for sample in chinese_text_samples:
                logger.debug(f"  {sample[:100]}")
        
        # Since fields may be grouped in merged cells, we're more lenient
        # Check if at least most fields are found
        found_ratio = len(found_fields) / len(required_fields) if required_fields else 1.0
        
        if found_ratio < 0.5:  # Less than 50% found
            logger.error(f"✗ Too many required fields missing: found {len(found_fields)}/{len(required_fields)}")
            logger.error(f"  Missing: {missing_fields}")
            return 0.0
        elif missing_fields:
            logger.warning(f"⚠ Some fields missing: {missing_fields}, but found {len(found_fields)}/{len(required_fields)} fields")
            # Don't fail if most fields are found (fields might be in merged cells together)
        else:
            logger.info(f"✓ Found all required fields: {found_fields}")
        
        # Check 3: Table headers
        found_headers = []
        missing_headers = []
        for header in table_headers:
            header_found = False
            for text in all_text:
                if header in text:
                    header_found = True
                    found_headers.append(header)
                    break
            if not header_found:
                missing_headers.append(header)
        
        if missing_headers:
            logger.error(f"✗ Missing table headers: {missing_headers}")
            return 0.0
        else:
            logger.info(f"✓ Found all table headers: {found_headers}")
        
        # Check 4: Summary fields
        found_summary = []
        missing_summary = []
        for field in summary_fields:
            field_found = False
            for text in all_text:
                if field in text:
                    field_found = True
                    found_summary.append(field)
                    break
            if not field_found:
                missing_summary.append(field)
        
        if missing_summary:
            logger.warning(f"⚠ Missing summary fields: {missing_summary}")
            # Don't fail completely, as these might be optional
        else:
            logger.info(f"✓ Found summary fields: {found_summary}")
        
        # Check 5: Footer fields
        found_footer = []
        missing_footer = []
        for field in footer_fields:
            field_found = False
            for text in all_text:
                if field in text:
                    field_found = True
                    found_footer.append(field)
                    break
            if not field_found:
                missing_footer.append(field)
        
        if missing_footer:
            logger.warning(f"⚠ Missing footer fields: {missing_footer}")
            # Don't fail completely, as these might be optional
        else:
            logger.info(f"✓ Found footer fields: {found_footer}")
        
        # Check 6: Borders on table cells
        # Check if cells in the product table area have borders
        # Typically, table headers and data rows should have borders
        logger.info("Checking borders on table cells...")
        
        # Find the table header row (should contain table headers)
        table_header_row = None
        for row_num in range(1, max_row + 1):
            for col_num in range(1, max_col + 1):
                cell = ws.cell(row=row_num, column=col_num)
                if cell.value is not None:
                    cell_text = str(cell.value).strip()
                    # Check if this row contains table headers
                    if any(header in cell_text for header in table_headers):
                        table_header_row = row_num
                        break
            if table_header_row:
                break
        
        borders_found = False
        cells_with_borders = 0
        total_table_cells_checked = 0
        
        if table_header_row:
            logger.info(f"Table header row found at row {table_header_row}")
            # Check borders in table area (header row and a few data rows)
            # Table typically spans from column C to K (based on headers)
            check_start_col = 3  # Column C
            check_end_col = min(11, max_col)  # Column K or max_col
            check_start_row = table_header_row
            check_end_row = min(table_header_row + 7, max_row)  # Header + 6 data rows
            
            for row_num in range(check_start_row, check_end_row + 1):
                for col_num in range(check_start_col, check_end_col + 1):
                    cell = ws.cell(row=row_num, column=col_num)
                    total_table_cells_checked += 1
                    
                    # Check if cell has any border
                    has_border = False
                    try:
                        border = cell.border
                        # Check if any side has a border style (not None and not empty)
                        if border:
                            if (border.top and border.top.style) or \
                               (border.bottom and border.bottom.style) or \
                               (border.left and border.left.style) or \
                               (border.right and border.right.style):
                                has_border = True
                                cells_with_borders += 1
                    except Exception as e:
                        logger.debug(f"Error checking border for cell {cell.coordinate}: {e}")
                    
                    if has_border:
                        borders_found = True
                        logger.debug(f"Cell {cell.coordinate} has borders")
            
            if total_table_cells_checked > 0:
                border_ratio = cells_with_borders / total_table_cells_checked
                logger.info(f"Borders found: {cells_with_borders}/{total_table_cells_checked} cells ({border_ratio:.1%})")
                
                # Require at least 30% of table cells to have borders
                if border_ratio < 0.3:
                    logger.warning(f"⚠ Low border coverage: only {border_ratio:.1%} of table cells have borders")
                    # Don't fail completely, as borders might be applied differently
                else:
                    logger.info(f"✓ Sufficient borders found in table area")
            else:
                logger.warning("⚠ Could not check borders: no table cells found")
        else:
            logger.warning("⚠ Could not find table header row for border checking")
        
        # If we get here, all critical checks passed
        logger.info("=" * 60)
        logger.info(f"✓ Quote sheet template with merged cells verification passed")
        logger.info(f"  Title: {expected_title}")
        logger.info(f"  Merged cells: {len(merged_cells)} (minimum required: {min_merged_cells})")
        if title_merged_found:
            logger.info(f"  Title merged range: {title_merged_range}")
        logger.info(f"  Required fields: {len(found_fields)}/{len(required_fields)}")
        logger.info(f"  Table headers: {len(found_headers)}/{len(table_headers)}")
        logger.info(f"  Summary fields: {len(found_summary)}/{len(summary_fields)}")
        logger.info(f"  Footer fields: {len(found_footer)}/{len(footer_fields)}")
        if borders_found:
            logger.info(f"  Borders: {cells_with_borders}/{total_table_cells_checked} cells have borders")
        logger.info("=" * 60)
        return 1.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_nested_regex_price_extract(result: str, expected: str = None, **options) -> float:
    """
    Verify if nested REGEX(REGEX(SUBSTITUTE(...))) formulas exist to extract prices from inconsistently formatted text.
    
    This function checks:
    1. Whether cells in specified column contain nested REGEX functions
    2. Whether formulas contain SUBSTITUTE function to remove spaces
    3. Whether inner REGEX function uses pattern to replace Chinese punctuation with dots
    4. Whether outer REGEX function extracts numeric values with pattern [\d.]+
    5. Whether formulas reference the corresponding source column cell (A1, A2, A3, etc.)
    
    Expected formula pattern: =REGEX(REGEX(SUBSTITUTE(A1," ",),"[-，。]",2,"."),"[\d.]+")
    
    The function automatically detects the number of data rows by checking the data column
    for non-empty cells. It stops checking after finding 3 consecutive empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_column: Column to check (e.g., "B")
            - start_row: Starting row number (default: 1)
            - source_column: Column containing source data (e.g., "A")
            - expected_functions: List of expected function names (default: ["REGEX", "SUBSTITUTE"])
            - data_column: Column to check for data to determine end_row (default: "A")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_column = options.get('check_column', 'B')
        start_row = options.get('start_row', 1)
        source_column = options.get('source_column', 'A')
        expected_functions = options.get('expected_functions', ['REGEX', 'SUBSTITUTE'])
        data_column = options.get('data_column', 'A')
        
        logger.info(f"Verifying nested REGEX price extraction formulas in file: {result}")
        logger.info(f"Column to check: {check_column}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Source column: {source_column}")
        logger.info(f"Expected functions: {expected_functions}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Check each row
        all_checks_passed = True
        rows_checked = 0
        
        for row_num in range(start_row, end_row + 1):
            check_cell = ws[f"{check_column}{row_num}"]
            source_cell = ws[f"{source_column}{row_num}"]
            
            # Skip if source cell is empty
            if source_cell.value is None:
                continue
            
            rows_checked += 1
            formula = check_cell.value
            
            # Check 1: Formula exists (not just a value)
            if formula is None or not isinstance(formula, str) or not formula.startswith('='):
                logger.error(f"Cell {check_column}{row_num} should contain a formula, but got: {formula}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Row {row_num} formula: {formula}")
            
            # Check 2: Contains all required functions
            missing_functions = []
            for func in expected_functions:
                # Check for function name (with word boundary to avoid partial matches)
                func_pattern = r'\b' + re.escape(func) + r'\s*\('
                if not re.search(func_pattern, formula_upper, re.IGNORECASE):
                    missing_functions.append(func)
            
            if missing_functions:
                logger.error(f"Cell {check_column}{row_num} formula missing functions: {missing_functions}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains nested REGEX functions (at least 2 REGEX calls)
            regex_count = len(re.findall(r'\bREGEX\s*\(', formula_upper, re.IGNORECASE))
            if regex_count < 2:
                logger.error(f"Cell {check_column}{row_num} formula should contain at least 2 nested REGEX functions")
                logger.error(f"  Formula: {formula}")
                logger.error(f"  Found {regex_count} REGEX function(s)")
                all_checks_passed = False
                continue
            
            # Check 4: Contains SUBSTITUTE function
            substitute_pattern = r'\bSUBSTITUTE\s*\('
            if not re.search(substitute_pattern, formula_upper, re.IGNORECASE):
                logger.error(f"Cell {check_column}{row_num} formula should contain SUBSTITUTE function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 5: SUBSTITUTE function references source column and removes spaces
            # Pattern: SUBSTITUTE(A1," ",) or SUBSTITUTE(A1," ","")
            substitute_pattern = rf'SUBSTITUTE\s*\(\s*{source_column}{row_num}\s*,\s*["\']?\s*["\']?\s*,'
            if not re.search(substitute_pattern, formula_upper, re.IGNORECASE):
                logger.error(f"Cell {check_column}{row_num} SUBSTITUTE should reference {source_column}{row_num} and remove spaces")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 6: Inner REGEX function contains pattern to replace Chinese punctuation
            # Pattern should contain something like "[-，。]" or similar Chinese punctuation
            # and replacement pattern like "2,"." or "2,\"."
            inner_regex_pattern = r'REGEX\s*\([^)]*["\']?[-，。，。、]["\']?\s*,\s*\d+\s*,\s*["\']?\.["\']?'
            if not re.search(inner_regex_pattern, formula_upper, re.IGNORECASE):
                logger.warning(f"Cell {check_column}{row_num} inner REGEX may not have correct pattern for replacing Chinese punctuation")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the pattern might be correct but formatted differently
            
            # Check 7: Outer REGEX function contains pattern to extract numbers
            # Pattern should contain [\d.]+ or similar
            outer_regex_pattern = r'REGEX\s*\([^)]*["\']?\[\\?d\.\]\+["\']?'
            if not re.search(outer_regex_pattern, formula_upper, re.IGNORECASE):
                # Also check for unescaped version
                if not re.search(r'REGEX\s*\([^)]*\[.*d.*\.?.*\]', formula_upper, re.IGNORECASE):
                    logger.warning(f"Cell {check_column}{row_num} outer REGEX may not have correct pattern [\\d.]+")
                    logger.debug(f"  Formula: {formula}")
                    # Don't fail, just warn
            
            # Check 8: Formula references the corresponding source column cell
            source_pattern = rf'{source_column}{row_num}\b'
            if not re.search(source_pattern, formula_upper):
                logger.error(f"Cell {check_column}{row_num} formula should reference {source_column}{row_num}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            logger.debug(f"✓ Row {row_num} formula passed all checks")
        
        if rows_checked == 0:
            logger.error("No rows with data found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ Nested REGEX price extraction verification passed")
            logger.info(f"  Rows checked: {rows_checked}")
            logger.info(f"  Column: {check_column}")
            logger.info(f"  Functions verified: {', '.join(expected_functions)}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ Nested REGEX price extraction verification failed")
            logger.error(f"  Rows checked: {rows_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_text_datetime_format(result: str, expected: str = None, **options) -> float:
    """
    Verify if TEXT formulas exist to convert numbers to datetime format.
    
    This function checks:
    1. Whether cells in specified column contain TEXT formulas
    2. Whether formulas use TEXT function with datetime format pattern "0-00-00 00:00:00"
    3. Whether formulas reference the corresponding source column cell (A2, A3, etc.)
    
    Expected formula pattern: =TEXT(A2,"0-00-00 00:00:00")
    
    The function automatically detects the number of data rows by checking the data column
    for non-empty cells. It stops checking after finding 3 consecutive empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_column: Column to check (e.g., "C")
            - start_row: Starting row number (default: 2)
            - source_column: Column containing source data (e.g., "A")
            - expected_functions: List of expected function names (default: ["TEXT"])
            - expected_format: Expected TEXT format pattern (default: "0-00-00 00:00:00")
            - data_column: Column to check for data to determine end_row (default: "A")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_column = options.get('check_column', 'C')
        start_row = options.get('start_row', 2)
        source_column = options.get('source_column', 'A')
        expected_functions = options.get('expected_functions', ['TEXT'])
        expected_format = options.get('expected_format', '0-00-00 00:00:00')
        data_column = options.get('data_column', 'A')
        
        logger.info(f"Verifying TEXT datetime format formulas in file: {result}")
        logger.info(f"Column to check: {check_column}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Source column: {source_column}")
        logger.info(f"Expected functions: {expected_functions}")
        logger.info(f"Expected format: {expected_format}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Check each row
        all_checks_passed = True
        rows_checked = 0
        
        for row_num in range(start_row, end_row + 1):
            check_cell = ws[f"{check_column}{row_num}"]
            source_cell = ws[f"{source_column}{row_num}"]
            
            # Skip if source cell is empty
            if source_cell.value is None:
                continue
            
            rows_checked += 1
            
            # Check 1: Cell contains a formula
            if check_cell.data_type != "f":
                logger.error(f"Cell {check_column}{row_num} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(check_cell, "_value") and isinstance(check_cell._value, str) and check_cell._value.startswith("="):
                formula = check_cell._value
            elif hasattr(check_cell, "formula"):
                formula = check_cell.formula
            else:
                # Try to get from value attribute
                if check_cell.value is not None and isinstance(check_cell.value, str) and check_cell.value.startswith("="):
                    formula = check_cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {check_column}{row_num}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Row {row_num} formula: {formula}")
            
            # Check 2: Contains TEXT function
            if 'TEXT' not in formula_upper:
                logger.error(f"Cell {check_column}{row_num} formula should contain TEXT function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: TEXT function contains the expected format pattern
            # Pattern: TEXT(A2,"0-00-00 00:00:00") or TEXT(A2,'0-00-00 00:00:00')
            # Escape special characters in format pattern for regex
            format_escaped = re.escape(expected_format)
            text_format_pattern1 = rf'TEXT\s*\([^,]+,\s*"{format_escaped}"'
            text_format_pattern2 = rf"TEXT\s*\([^,]+,\s*'{format_escaped}'"
            if not re.search(text_format_pattern1, formula, re.IGNORECASE) and \
               not re.search(text_format_pattern2, formula, re.IGNORECASE):
                logger.error(f"Cell {check_column}{row_num} TEXT function should use format \"{expected_format}\"")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Formula references the corresponding source column cell
            source_pattern = rf'{source_column}{row_num}\b'
            if not re.search(source_pattern, formula_upper):
                logger.error(f"Cell {check_column}{row_num} formula should reference {source_column}{row_num}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            logger.debug(f"✓ Row {row_num} formula passed all checks")
        
        if rows_checked == 0:
            logger.error("No rows with data found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ TEXT datetime format verification passed")
            logger.info(f"  Rows checked: {rows_checked}")
            logger.info(f"  Column: {check_column}")
            logger.info(f"  Format: {expected_format}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ TEXT datetime format verification failed")
            logger.error(f"  Rows checked: {rows_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_if_counta_payment_receipt_numbering(result: str, expected: str = None, **options) -> float:
    """
    Verify if IF(COUNTA(...)) formulas exist to auto-generate payment/receipt numbering.
    
    This function checks:
    1. Whether cells in specified column contain IF formulas
    2. Whether formulas contain required functions: IF, COUNTA
    3. Whether formulas check if payment column (C) is empty
    4. Whether formulas use COUNTA to count receipt column (C) or payment column (D)
    5. Whether formulas generate "收" or "付" prefixed numbers
    6. Whether formulas reference the correct ranges ($C$2:C2 and $D$2:D2)
    
    Expected formula pattern: =IF(C2="","付"&COUNTA($D$2:D2),"收"&COUNTA($C$2:C2))
    
    The function automatically detects the number of data rows by checking the data column
    for non-empty cells. It stops checking after finding 3 consecutive empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_column: Column to check (e.g., "A")
            - start_row: Starting row number (default: 2)
            - receipt_column: Column containing receipt amounts (e.g., "C")
            - payment_column: Column containing payment amounts (e.g., "D")
            - expected_functions: List of expected function names (default: ["IF", "COUNTA"])
            - receipt_prefix: Prefix for receipt numbers (default: "收")
            - payment_prefix: Prefix for payment numbers (default: "付")
            - data_column: Column to check for data to determine end_row (default: "A")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_column = options.get('check_column', 'A')
        start_row = options.get('start_row', 2)
        receipt_column = options.get('receipt_column', 'C')
        payment_column = options.get('payment_column', 'D')
        expected_functions = options.get('expected_functions', ['IF', 'COUNTA'])
        receipt_prefix = options.get('receipt_prefix', '收')
        payment_prefix = options.get('payment_prefix', '付')
        data_column = options.get('data_column', 'A')
        
        logger.info(f"Verifying IF/COUNTA payment/receipt numbering formulas in file: {result}")
        logger.info(f"Column to check: {check_column}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Receipt column: {receipt_column}")
        logger.info(f"Payment column: {payment_column}")
        logger.info(f"Expected functions: {expected_functions}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Check each row
        all_checks_passed = True
        rows_checked = 0
        
        for row_num in range(start_row, end_row + 1):
            check_cell = ws[f"{check_column}{row_num}"]
            
            # Skip if cell is empty
            if check_cell.value is None:
                continue
            
            rows_checked += 1
            
            # Check if cell contains a formula
            if check_cell.data_type != "f":
                logger.error(f"Cell {check_column}{row_num} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(check_cell, "_value") and isinstance(check_cell._value, str) and check_cell._value.startswith("="):
                formula = check_cell._value
            elif hasattr(check_cell, "formula"):
                formula = check_cell.formula
            else:
                # Try to get from value attribute
                if check_cell.value is not None and isinstance(check_cell.value, str) and check_cell.value.startswith("="):
                    formula = check_cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {check_column}{row_num}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Row {row_num} formula: {formula}")
            
            # Check 1: Contains all required functions
            missing_functions = []
            for func in expected_functions:
                # Check for function name (with word boundary to avoid partial matches)
                func_pattern = r'\b' + re.escape(func) + r'\s*\('
                if not re.search(func_pattern, formula_upper, re.IGNORECASE):
                    missing_functions.append(func)
            
            if missing_functions:
                logger.error(f"Cell {check_column}{row_num} formula missing functions: {missing_functions}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: Formula structure - IF(...)
            if_pattern = r'IF\s*\('
            if not re.search(if_pattern, formula_upper, re.IGNORECASE):
                logger.error(f"Cell {check_column}{row_num} formula should contain IF function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: IF condition checks if receipt column is empty (C2="")
            # Pattern: IF(C2="",... or IF(C2="",...
            if_condition_pattern = rf'IF\s*\(\s*{receipt_column}{row_num}\s*=\s*["\']?\s*["\']?'
            if not re.search(if_condition_pattern, formula_upper, re.IGNORECASE):
                logger.error(f"Cell {check_column}{row_num} IF should check if {receipt_column}{row_num} is empty")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Formula contains COUNTA with payment column range ($D$2:D2)
            # Pattern: COUNTA($D$2:D2) or COUNTA($D$2:D{row_num})
            payment_counta_pattern = rf'COUNTA\s*\(\s*\${payment_column}\$\d+:\s*{payment_column}{row_num}\s*\)'
            if not re.search(payment_counta_pattern, formula_upper, re.IGNORECASE):
                logger.error(f"Cell {check_column}{row_num} should contain COUNTA(${payment_column}$2:{payment_column}{row_num})")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 5: Formula contains COUNTA with receipt column range ($C$2:C2)
            # Pattern: COUNTA($C$2:C2) or COUNTA($C$2:C{row_num})
            receipt_counta_pattern = rf'COUNTA\s*\(\s*\${receipt_column}\$\d+:\s*{receipt_column}{row_num}\s*\)'
            if not re.search(receipt_counta_pattern, formula_upper, re.IGNORECASE):
                logger.error(f"Cell {check_column}{row_num} should contain COUNTA(${receipt_column}$2:{receipt_column}{row_num})")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 6: Formula contains payment prefix (付)
            if payment_prefix not in formula:
                logger.error(f"Cell {check_column}{row_num} formula should contain payment prefix '{payment_prefix}'")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 7: Formula contains receipt prefix (收)
            if receipt_prefix not in formula:
                logger.error(f"Cell {check_column}{row_num} formula should contain receipt prefix '{receipt_prefix}'")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            logger.debug(f"✓ Row {row_num} formula passed all checks")
        
        if rows_checked == 0:
            logger.error("No rows with data found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ IF/COUNTA payment/receipt numbering formula verification passed")
            logger.info(f"  Rows checked: {rows_checked}")
            logger.info(f"  Column: {check_column}")
            logger.info(f"  Functions verified: {', '.join(expected_functions)}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ IF/COUNTA payment/receipt numbering formula verification failed")
            logger.error(f"  Rows checked: {rows_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_if_or_row_check(result: str, expected: str = None, **options) -> float:
    """
    Verify if IF(COUNTIF(...)) formulas exist to check if a row contains a specific character.
    
    This function checks:
    1. Whether cells in specified column contain IF formulas
    2. Whether formulas contain required functions: IF, COUNTIF
    3. Whether formulas use COUNTIF to count occurrences (e.g., COUNTIF(A2:Z2, "连")>0)
    4. Whether formulas return "连" if found, "断" if not found
    5. Whether formulas reference the correct row range
    
    Expected formula pattern: =IF(COUNTIF(A2:Z2, "连")>0, "连", "断")
    
    The function automatically detects the number of data rows by checking the data column
    for non-empty cells. It stops checking after finding 3 consecutive empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_column: Column to check (e.g., "T")
            - start_row: Starting row number (default: 2)
            - check_range_start: Start column of range to check (e.g., "A")
            - check_range_end: End column of range to check (e.g., "Z")
            - search_text: Text to search for (default: "连")
            - found_text: Text to return if found (default: "连")
            - not_found_text: Text to return if not found (default: "断")
            - expected_functions: List of expected function names (default: ["IF", "OR"])
            - data_column: Column to check for data to determine end_row (default: "T")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_column = options.get('check_column', 'T')
        start_row = options.get('start_row', 2)
        check_range_start = options.get('check_range_start', 'A')
        check_range_end = options.get('check_range_end', 'Z')
        search_text = options.get('search_text', '连')
        found_text = options.get('found_text', '连')
        not_found_text = options.get('not_found_text', '断')
        expected_functions = options.get('expected_functions', ['IF', 'COUNTIF'])
        data_column = options.get('data_column', 'T')
        
        logger.info(f"Verifying IF/COUNTIF row check formulas in file: {result}")
        logger.info(f"Column to check: {check_column}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Check range: {check_range_start} to {check_range_end}")
        logger.info(f"Search text: {search_text}")
        logger.info(f"Expected functions: {expected_functions}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Check each row
        all_checks_passed = True
        rows_checked = 0
        
        for row_num in range(start_row, end_row + 1):
            check_cell = ws[f"{check_column}{row_num}"]
            
            # Skip if cell is empty
            if check_cell.value is None:
                continue
            
            rows_checked += 1
            
            # Check if cell contains a formula
            if check_cell.data_type != "f":
                logger.error(f"Cell {check_column}{row_num} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(check_cell, "_value") and isinstance(check_cell._value, str) and check_cell._value.startswith("="):
                formula = check_cell._value
            elif hasattr(check_cell, "formula"):
                formula = check_cell.formula
            else:
                # Try to get from value attribute
                if check_cell.value is not None and isinstance(check_cell.value, str) and check_cell.value.startswith("="):
                    formula = check_cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {check_column}{row_num}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Row {row_num} formula: {formula}")
            
            # Check 1: Contains all required functions
            missing_functions = []
            for func in expected_functions:
                # Check for function name (with word boundary to avoid partial matches)
                func_pattern = r'\b' + re.escape(func) + r'\s*\('
                if not re.search(func_pattern, formula_upper, re.IGNORECASE):
                    missing_functions.append(func)
            
            if missing_functions:
                logger.error(f"Cell {check_column}{row_num} formula missing functions: {missing_functions}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: Formula structure - IF(COUNTIF(...))
            if_countif_pattern = r'IF\s*\(\s*COUNTIF\s*\('
            if not re.search(if_countif_pattern, formula_upper, re.IGNORECASE):
                logger.error(f"Cell {check_column}{row_num} formula should have structure IF(COUNTIF(...))")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: COUNTIF contains row range
            # Pattern: COUNTIF(A2:Z2, ...)
            row_range_pattern = rf'{check_range_start}{row_num}:{check_range_end}{row_num}'
            if row_range_pattern.upper() not in formula_upper:
                logger.error(f"Cell {check_column}{row_num} COUNTIF should contain range {row_range_pattern}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: COUNTIF contains search text
            # Pattern: COUNTIF(A2:Z2, "连") or COUNTIF(A2:Z2, '连')
            countif_search_pattern1 = rf'COUNTIF\s*\(\s*{row_range_pattern}\s*,\s*["\']?{re.escape(search_text)}["\']?'
            countif_search_pattern2 = rf'COUNTIF\s*\(\s*{row_range_pattern}\s*,\s*["\']?{re.escape(search_text)}["\']?'
            if not re.search(countif_search_pattern1, formula, re.IGNORECASE) and \
               not re.search(countif_search_pattern2, formula, re.IGNORECASE):
                logger.error(f"Cell {check_column}{row_num} COUNTIF should search for '{search_text}'")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 5: COUNTIF result is compared with >0
            # Pattern: COUNTIF(...)>0
            countif_gt_pattern = r'COUNTIF\s*\([^)]+\)\s*>\s*0'
            if not re.search(countif_gt_pattern, formula_upper, re.IGNORECASE):
                logger.error(f"Cell {check_column}{row_num} COUNTIF result should be compared with >0")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 5: IF contains found_text ("连")
            if found_text not in formula:
                logger.error(f"Cell {check_column}{row_num} IF should return '{found_text}' if found")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 6: IF contains not_found_text ("断")
            if not_found_text not in formula:
                logger.error(f"Cell {check_column}{row_num} IF should return '{not_found_text}' if not found")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            logger.debug(f"✓ Row {row_num} formula passed all checks")
        
        if rows_checked == 0:
            logger.error("No rows with data found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ IF/COUNTIF row check formula verification passed")
            logger.info(f"  Rows checked: {rows_checked}")
            logger.info(f"  Column: {check_column}")
            logger.info(f"  Functions verified: {', '.join(expected_functions)}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ IF/COUNTIF row check formula verification failed")
            logger.error(f"  Rows checked: {rows_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_counta_sort_amount(result: str, expected: str = None, **options) -> float:
    """
    Verify if COUNTA helper column exists and data is sorted by amount in descending order.
    
    This function checks:
    1. Whether helper column (E) contains COUNTA formulas starting from E3
    2. Whether COUNTA formulas reference the correct range (e.g., $B$2:B3)
    3. Whether data is sorted by amount column (D) in descending order
    4. Whether the sorting maintains data integrity (all rows are present)
    
    Expected helper formula: =COUNTA($B$2:B3) in E3, then copied down
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - helper_column: Helper column with COUNTA formula (e.g., "E")
            - helper_start_row: Starting row for helper formula (default: 3)
            - count_range_column: Column to count in COUNTA (e.g., "B")
            - amount_column: Column containing amounts to sort (e.g., "D")
            - data_start_row: Starting row of data (default: 2)
            - data_end_row: Ending row of data (default: 14)
            - sort_order: Expected sort order "descending" or "ascending" (default: "descending")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        helper_column = options.get('helper_column', 'E')
        helper_start_row = options.get('helper_start_row', 3)
        count_range_column = options.get('count_range_column', 'B')
        amount_column = options.get('amount_column', 'D')
        data_start_row = options.get('data_start_row', 2)
        data_end_row = options.get('data_end_row', 14)
        sort_order = options.get('sort_order', 'descending')
        
        logger.info(f"Verifying COUNTA helper column and amount sorting in file: {result}")
        logger.info(f"Helper column: {helper_column}")
        logger.info(f"Helper start row: {helper_start_row}")
        logger.info(f"Amount column: {amount_column}")
        logger.info(f"Data range: {data_start_row} to {data_end_row}")
        logger.info(f"Sort order: {sort_order}")
        
        # Load workbook to get formulas and values
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check 1: Verify COUNTA formulas in helper column
        logger.info(f"Checking COUNTA formulas in column {helper_column}...")
        helper_formulas_ok = True
        
        for row_num in range(helper_start_row, data_end_row + 1):
            helper_cell = ws[f"{helper_column}{row_num}"]
            
            # Check if cell contains a formula
            if helper_cell.data_type != "f":
                logger.error(f"Cell {helper_column}{row_num} does not contain a formula")
                helper_formulas_ok = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(helper_cell, "_value") and isinstance(helper_cell._value, str) and helper_cell._value.startswith("="):
                formula = helper_cell._value
            elif hasattr(helper_cell, "formula"):
                formula = helper_cell.formula
            else:
                if helper_cell.value is not None and isinstance(helper_cell.value, str) and helper_cell.value.startswith("="):
                    formula = helper_cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {helper_column}{row_num}")
                helper_formulas_ok = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Row {row_num} formula: {formula}")
            
            # Check if formula contains COUNTA
            if 'COUNTA' not in formula_upper:
                logger.error(f"Cell {helper_column}{row_num} formula should contain COUNTA function")
                logger.error(f"  Formula: {formula}")
                helper_formulas_ok = False
                continue
            
            # Check if COUNTA references the correct range
            # Pattern: COUNTA($B$2:B3) or COUNTA($B$2:B{row_num})
            counta_pattern = rf'COUNTA\s*\(\s*\${count_range_column}\$\d+:\s*{count_range_column}{row_num}\s*\)'
            if not re.search(counta_pattern, formula_upper, re.IGNORECASE):
                logger.error(f"Cell {helper_column}{row_num} COUNTA should reference ${count_range_column}$2:{count_range_column}{row_num}")
                logger.error(f"  Formula: {formula}")
                helper_formulas_ok = False
                continue
        
        if not helper_formulas_ok:
            logger.error("COUNTA helper column verification failed")
            return 0.0
        
        logger.info("✓ COUNTA helper column verification passed")
        
        # Check 2: Verify data is sorted by amount column within each group (grouped by helper column)
        # The sorting is done by grouping rows with the same E column value, then sorting D column within each group
        logger.info(f"Checking if data is sorted by column {amount_column} within groups (grouped by {helper_column} column)...")
        
        # Collect data: (row_num, helper_value, amount_value)
        # We need to read calculated values, so load workbook again with data_only=True for values
        try:
            wb_values = openpyxl.load_workbook(result, data_only=True)
            ws_values = wb_values.active
        except Exception as e:
            logger.warning(f"Failed to load workbook with data_only=True, using formula values: {e}")
            ws_values = ws  # Fallback to formula worksheet
        
        data_rows = []
        # Start from helper_start_row to skip header row
        actual_start_row = max(data_start_row, helper_start_row)
        logger.debug(f"Collecting data from row {actual_start_row} to {data_end_row}")
        
        for row_num in range(actual_start_row, data_end_row + 1):
            helper_cell = ws_values[f"{helper_column}{row_num}"]
            amount_cell = ws_values[f"{amount_column}{row_num}"]
            
            helper_value = helper_cell.value
            amount_value = amount_cell.value
            
            logger.debug(f"Row {row_num}: {helper_column}={helper_value}, {amount_column}={amount_value}")
            
            # Skip if helper or amount is None or empty
            if helper_value is None or amount_value is None:
                logger.debug(f"Row {row_num}: Skipping due to None values")
                continue
            
            # Try to convert helper value to number
            try:
                if isinstance(helper_value, str):
                    helper_value = float(helper_value.replace(',', ''))
                else:
                    helper_value = float(helper_value)
            except (ValueError, TypeError) as e:
                logger.debug(f"Cell {helper_column}{row_num} contains non-numeric value: {helper_value} (type: {type(helper_value)}), skipping: {e}")
                continue
            
            # Try to convert amount to number
            try:
                if isinstance(amount_value, str):
                    # Skip if it's a header text (contains Chinese characters that might be headers)
                    if any('\u4e00' <= char <= '\u9fff' for char in amount_value):
                        logger.debug(f"Skipping header text in cell {amount_column}{row_num}: {amount_value}")
                        continue
                    amount_value = float(amount_value.replace(',', ''))
                else:
                    amount_value = float(amount_value)
                data_rows.append((row_num, helper_value, amount_value))
                logger.debug(f"Row {row_num}: Added to data_rows - helper={helper_value}, amount={amount_value}")
            except (ValueError, TypeError) as e:
                logger.debug(f"Cell {amount_column}{row_num} contains non-numeric value: {amount_value} (type: {type(amount_value)}), skipping: {e}")
                continue
        
        logger.info(f"Collected {len(data_rows)} data rows for sorting verification")
        
        if len(data_rows) < 2:
            logger.error(f"Not enough data rows to verify sorting: only {len(data_rows)} rows collected")
            logger.error(f"  Expected data from row {actual_start_row} to {data_end_row}")
            return 0.0
        
        # Group data by helper column value
        from collections import defaultdict
        groups = defaultdict(list)
        for row_num, helper_val, amount_val in data_rows:
            groups[helper_val].append((row_num, amount_val))
        
        logger.info(f"Found {len(groups)} groups based on {helper_column} column values")
        
        # Check if amounts are sorted within each group
        all_groups_sorted = True
        for group_key in sorted(groups.keys()):
            group_data = groups[group_key]
            if len(group_data) < 2:
                # Single row groups are always sorted
                continue
            
            # Check if amounts in this group are sorted
            group_sorted = True
            for i in range(len(group_data) - 1):
                current_amount = group_data[i][1]
                next_amount = group_data[i + 1][1]
                
                if sort_order == "descending":
                    if current_amount < next_amount:
                        logger.error(f"Group {group_key}: row {group_data[i][0]} ({current_amount}) < row {group_data[i+1][0]} ({next_amount}) - not descending")
                        group_sorted = False
                        break
                else:  # ascending
                    if current_amount > next_amount:
                        logger.error(f"Group {group_key}: row {group_data[i][0]} ({current_amount}) > row {group_data[i+1][0]} ({next_amount}) - not ascending")
                        group_sorted = False
                        break
            
            if not group_sorted:
                all_groups_sorted = False
                logger.error(f"Group {group_key} is not sorted in {sort_order} order")
            else:
                logger.debug(f"Group {group_key} is sorted correctly")
        
        if not all_groups_sorted:
            logger.error("Sorting verification failed: not all groups are sorted correctly")
            return 0.0
        
        logger.info("✓ Amount sorting verification passed: all groups are sorted correctly")
        
        logger.info("=" * 60)
        logger.info(f"✓ COUNTA helper column and amount sorting verification passed")
        logger.info(f"  Helper column: {helper_column}")
        logger.info(f"  Amount column: {amount_column}")
        logger.info(f"  Sort order: {sort_order}")
        logger.info("=" * 60)
        return 1.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_if_iferror_find_text_search(result: str, expected: str = None, **options) -> float:
    """
    Verify if IF(IFERROR(FIND(...))) formulas exist to search for text within a row range.
    
    This function checks:
    1. Whether cells in specified column contain IF formulas
    2. Whether formulas contain required functions: IF, IFERROR, FIND
    3. Whether FIND function searches for the specified text (e.g., "AB")
    4. Whether FIND function searches in concatenated text from multiple columns (e.g., A2&B2)
    5. Whether IF function returns 1 if found, empty string if not found
    
    Expected formula pattern: =IF(IFERROR(FIND("AB",A2&B2),)>0,1,)
    
    The function automatically detects the number of data rows by checking the data column
    for non-empty cells. It stops checking after finding 3 consecutive empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_column: Column to check (e.g., "C")
            - start_row: Starting row number (default: 2)
            - search_columns: List of columns to concatenate and search (e.g., ["A", "B"])
            - search_text: Text to search for (e.g., "AB")
            - return_value: Value to return if found (default: "1")
            - expected_functions: List of expected function names (default: ["IF", "IFERROR", "FIND"])
            - data_column: Column to check for data to determine end_row (default: "A")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_column = options.get('check_column', 'C')
        start_row = options.get('start_row', 2)
        search_columns = options.get('search_columns', ['A', 'B'])
        search_text = options.get('search_text', 'AB')
        return_value = options.get('return_value', '1')
        expected_functions = options.get('expected_functions', ['IF', 'IFERROR', 'FIND'])
        data_column = options.get('data_column', 'A')
        
        logger.info(f"Verifying IF/IFERROR/FIND text search formulas in file: {result}")
        logger.info(f"Column to check: {check_column}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Search columns: {search_columns}")
        logger.info(f"Search text: {search_text}")
        logger.info(f"Return value: {return_value}")
        logger.info(f"Expected functions: {expected_functions}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Check each row
        all_checks_passed = True
        rows_checked = 0
        
        for row_num in range(start_row, end_row + 1):
            check_cell = ws[f"{check_column}{row_num}"]
            
            # Skip if cell is empty
            if check_cell.value is None:
                continue
            
            rows_checked += 1
            
            # Check if cell contains a formula
            if check_cell.data_type != "f":
                logger.error(f"Cell {check_column}{row_num} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(check_cell, "_value") and isinstance(check_cell._value, str) and check_cell._value.startswith("="):
                formula = check_cell._value
            elif hasattr(check_cell, "formula"):
                formula = check_cell.formula
            else:
                # Try to get from value attribute
                if check_cell.value is not None and isinstance(check_cell.value, str) and check_cell.value.startswith("="):
                    formula = check_cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {check_column}{row_num}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Row {row_num} formula: {formula}")
            
            # Check 1: Contains all required functions
            missing_functions = []
            for func in expected_functions:
                # Check for function name (with word boundary to avoid partial matches)
                func_pattern = r'\b' + re.escape(func) + r'\s*\('
                if not re.search(func_pattern, formula_upper, re.IGNORECASE):
                    missing_functions.append(func)
            
            if missing_functions:
                logger.error(f"Cell {check_column}{row_num} formula missing functions: {missing_functions}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: Formula structure - IF(IFERROR(FIND(...)))
            if_iferror_pattern = r'IF\s*\(\s*IFERROR\s*\('
            if not re.search(if_iferror_pattern, formula_upper, re.IGNORECASE):
                logger.error(f"Cell {check_column}{row_num} formula should have structure IF(IFERROR(...))")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: IFERROR contains FIND
            iferror_find_pattern = r'IFERROR\s*\(\s*FIND\s*\('
            if not re.search(iferror_find_pattern, formula_upper, re.IGNORECASE):
                logger.error(f"Cell {check_column}{row_num} IFERROR should contain FIND function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: FIND contains search text
            # Pattern: FIND("AB",...) or FIND('AB',...)
            find_search_pattern1 = rf'FIND\s*\(\s*["\']?{re.escape(search_text)}["\']?\s*,'
            find_search_pattern2 = rf'FIND\s*\(\s*["\']?{re.escape(search_text)}["\']?\s*,'
            if not re.search(find_search_pattern1, formula, re.IGNORECASE) and \
               not re.search(find_search_pattern2, formula, re.IGNORECASE):
                logger.error(f"Cell {check_column}{row_num} FIND should search for '{search_text}'")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 5: FIND searches in concatenated columns (e.g., A2&B2)
            # Build pattern for concatenated columns: A2&B2 or A{row_num}&B{row_num}
            concat_pattern_parts = []
            for col in search_columns:
                concat_pattern_parts.append(rf'{col}{row_num}')
            concat_pattern = r'&'.join(concat_pattern_parts)
            if concat_pattern.upper() not in formula_upper:
                logger.error(f"Cell {check_column}{row_num} FIND should search in concatenated columns {concat_pattern}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 6: IFERROR has empty second parameter or no second parameter
            # Pattern: IFERROR(...,) or IFERROR(...,"")
            iferror_empty_pattern = r'IFERROR\s*\([^,]+,\s*\)|IFERROR\s*\([^,]+,\s*["\']?\s*["\']?'
            if not re.search(iferror_empty_pattern, formula_upper, re.IGNORECASE):
                logger.warning(f"Cell {check_column}{row_num} IFERROR may not have empty second parameter")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn
            
            # Check 7: IF condition checks if result > 0
            # Pattern: IFERROR(...)>0
            # Since IFERROR may have nested parentheses, we'll check more flexibly:
            # 1. Check that IFERROR exists
            # 2. Check that >0 exists after IFERROR
            # 3. Check that there's a closing parenthesis before >0
            iferror_pos = formula_upper.find('IFERROR')
            gt_zero_pos = formula_upper.find('>0')
            
            if iferror_pos == -1 or gt_zero_pos == -1:
                logger.error(f"Cell {check_column}{row_num} formula should contain IFERROR and >0")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check that >0 comes after IFERROR
            if gt_zero_pos <= iferror_pos:
                logger.error(f"Cell {check_column}{row_num} >0 should come after IFERROR")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check that there's a closing parenthesis for IFERROR before >0
            # Find the position of IFERROR's opening parenthesis
            iferror_open = formula_upper.find('(', iferror_pos)
            if iferror_open == -1:
                logger.error(f"Cell {check_column}{row_num} IFERROR should have opening parenthesis")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Count parentheses to find IFERROR's closing parenthesis
            paren_count = 0
            iferror_close = -1
            for i in range(iferror_open, min(gt_zero_pos, len(formula_upper))):
                if formula_upper[i] == '(':
                    paren_count += 1
                elif formula_upper[i] == ')':
                    paren_count -= 1
                    if paren_count == 0:
                        iferror_close = i
                        break
            
            if iferror_close == -1 or iferror_close >= gt_zero_pos:
                logger.error(f"Cell {check_column}{row_num} IFERROR should be closed before >0")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 8: IF returns return_value if found
            # Pattern: IF(...,1,) or IF(...,"1",)
            # Since IF condition may contain commas (e.g., IFERROR(...)), we need to find the second parameter
            # Find the position of IF's opening parenthesis and the comma before return_value
            if_pos = formula_upper.find('IF(')
            if if_pos == -1:
                if_pos = formula_upper.find('IF (')
            
            if if_pos != -1:
                # Find the opening parenthesis of IF
                if_open = formula_upper.find('(', if_pos)
                if if_open != -1:
                    # Count parentheses to find the comma that separates condition from return_value
                    paren_count = 0
                    comma_pos = -1
                    for i in range(if_open + 1, len(formula_upper)):
                        if formula_upper[i] == '(':
                            paren_count += 1
                        elif formula_upper[i] == ')':
                            paren_count -= 1
                            if paren_count < 0:
                                break
                        elif formula_upper[i] == ',' and paren_count == 0:
                            comma_pos = i
                            break
                    
                    if comma_pos != -1:
                        # Check if return_value appears after this comma
                        after_comma = formula_upper[comma_pos + 1:].strip()
                        # Check for return_value (with or without quotes)
                        return_pattern1 = rf'^{re.escape(return_value)}\s*,'
                        return_pattern2 = rf'^["\']?{re.escape(return_value)}["\']?\s*,'
                        if not re.match(return_pattern1, after_comma, re.IGNORECASE) and \
                           not re.match(return_pattern2, after_comma, re.IGNORECASE):
                            logger.error(f"Cell {check_column}{row_num} IF should return '{return_value}' if found")
                            logger.error(f"  Formula: {formula}")
                            logger.error(f"  After comma: {after_comma[:20]}")
                            all_checks_passed = False
                            continue
                    else:
                        logger.error(f"Cell {check_column}{row_num} Could not find comma separating IF condition from return value")
                        logger.error(f"  Formula: {formula}")
                        all_checks_passed = False
                        continue
                else:
                    logger.error(f"Cell {check_column}{row_num} IF should have opening parenthesis")
                    logger.error(f"  Formula: {formula}")
                    all_checks_passed = False
                    continue
            else:
                logger.error(f"Cell {check_column}{row_num} Formula should contain IF function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 9: IF has empty third parameter (else case)
            # Pattern: IF(...,1,) or IF(...,"1","")
            if_empty_else_pattern = r'IF\s*\([^,]+,\s*[^,]+,\s*\)|IF\s*\([^,]+,\s*[^,]+,\s*["\']?\s*["\']?'
            if not re.search(if_empty_else_pattern, formula_upper, re.IGNORECASE):
                logger.warning(f"Cell {check_column}{row_num} IF may not have empty else parameter")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn
            
            logger.debug(f"✓ Row {row_num} formula passed all checks")
        
        if rows_checked == 0:
            logger.error("No rows with data found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ IF/IFERROR/FIND text search formula verification passed")
            logger.info(f"  Rows checked: {rows_checked}")
            logger.info(f"  Column: {check_column}")
            logger.info(f"  Search text: {search_text}")
            logger.info(f"  Functions verified: {', '.join(expected_functions)}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ IF/IFERROR/FIND text search formula verification failed")
            logger.error(f"  Rows checked: {rows_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_countif_if_household_sort(result: str, expected: str = None, **options) -> float:
    """
    Verify if COUNTIF and IF formulas exist in helper column for household sorting, and verify sorting.
    
    This function checks:
    1. Whether helper column contains COUNTIF and IF formulas
    2. Whether COUNTIF counts "户主" (household head) from start to current row
    3. Whether IF function assigns values: 1 for "户主", 2 for "夫妻", 3 for others
    4. Whether data is sorted by helper column (ascending) and birth date (ascending)
    
    Expected formula pattern: =COUNTIF($E$1:E1,"户主")*10+IF(E1="户主",1,IF(E1="夫妻",2,3))
    
    The function automatically detects the number of data rows by checking the data column
    for non-empty cells. It stops checking after finding 3 consecutive empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - helper_column: Helper column with formula (e.g., "F")
            - start_row: Starting row for formula (default: 1)
            - relationship_column: Column containing relationships (e.g., "E")
            - birth_date_column: Column containing birth dates (e.g., "D")
            - expected_functions: List of expected function names (default: ["COUNTIF", "IF"])
            - household_head_text: Text for household head (default: "户主")
            - spouse_text: Text for spouse (default: "夫妻")
            - data_column: Column to check for data to determine end_row (default: "E")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        helper_column = options.get('helper_column', 'F')
        start_row = options.get('start_row', 1)
        relationship_column = options.get('relationship_column', 'E')
        birth_date_column = options.get('birth_date_column', 'D')
        expected_functions = options.get('expected_functions', ['COUNTIF', 'IF'])
        household_head_text = options.get('household_head_text', '户主')
        spouse_text = options.get('spouse_text', '夫妻')
        data_column = options.get('data_column', 'E')
        
        logger.info(f"Verifying COUNTIF/IF household sorting formulas in file: {result}")
        logger.info(f"Helper column: {helper_column}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Relationship column: {relationship_column}")
        logger.info(f"Birth date column: {birth_date_column}")
        logger.info(f"Expected functions: {expected_functions}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Check 1: Verify formulas in helper column
        logger.info(f"Checking formulas in column {helper_column}...")
        helper_formulas_ok = True
        
        for row_num in range(start_row, end_row + 1):
            helper_cell = ws[f"{helper_column}{row_num}"]
            
            # Skip if cell is empty
            if helper_cell.value is None:
                continue
            
            # Check if cell contains a formula
            if helper_cell.data_type != "f":
                logger.error(f"Cell {helper_column}{row_num} does not contain a formula")
                helper_formulas_ok = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(helper_cell, "_value") and isinstance(helper_cell._value, str) and helper_cell._value.startswith("="):
                formula = helper_cell._value
            elif hasattr(helper_cell, "formula"):
                formula = helper_cell.formula
            else:
                if helper_cell.value is not None and isinstance(helper_cell.value, str) and helper_cell.value.startswith("="):
                    formula = helper_cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {helper_column}{row_num}")
                helper_formulas_ok = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Row {row_num} formula: {formula}")
            
            # Check if formula contains required functions
            missing_functions = []
            for func in expected_functions:
                func_pattern = r'\b' + re.escape(func) + r'\s*\('
                if not re.search(func_pattern, formula_upper, re.IGNORECASE):
                    missing_functions.append(func)
            
            if missing_functions:
                logger.error(f"Cell {helper_column}{row_num} formula missing functions: {missing_functions}")
                logger.error(f"  Formula: {formula}")
                helper_formulas_ok = False
                continue
            
            # Check if COUNTIF references relationship column with "户主"
            countif_pattern = rf'COUNTIF\s*\(\s*\${relationship_column}\$\d+:\s*{relationship_column}{row_num}\s*,\s*["\']?{re.escape(household_head_text)}["\']?'
            if not re.search(countif_pattern, formula_upper, re.IGNORECASE):
                logger.error(f"Cell {helper_column}{row_num} COUNTIF should count '{household_head_text}' in {relationship_column} column")
                logger.error(f"  Formula: {formula}")
                helper_formulas_ok = False
                continue
            
            # Check if COUNTIF result is multiplied by 10
            countif_multiply_pattern = rf'COUNTIF\s*\([^)]+\)\s*\*\s*10'
            if not re.search(countif_multiply_pattern, formula_upper, re.IGNORECASE):
                logger.error(f"Cell {helper_column}{row_num} COUNTIF result should be multiplied by 10")
                logger.error(f"  Formula: {formula}")
                helper_formulas_ok = False
                continue
            
            # Check if IF function checks for "户主" and assigns 1
            if_household_head_pattern = rf'IF\s*\(\s*{relationship_column}{row_num}\s*=\s*["\']?{re.escape(household_head_text)}["\']?\s*,\s*1'
            if not re.search(if_household_head_pattern, formula_upper, re.IGNORECASE):
                logger.error(f"Cell {helper_column}{row_num} IF should check for '{household_head_text}' and return 1")
                logger.error(f"  Formula: {formula}")
                helper_formulas_ok = False
                continue
            
            # Check if nested IF checks for "夫妻" and assigns 2
            if_spouse_pattern = rf'IF\s*\(\s*{relationship_column}{row_num}\s*=\s*["\']?{re.escape(spouse_text)}["\']?\s*,\s*2'
            if not re.search(if_spouse_pattern, formula_upper, re.IGNORECASE):
                logger.error(f"Cell {helper_column}{row_num} IF should check for '{spouse_text}' and return 2")
                logger.error(f"  Formula: {formula}")
                helper_formulas_ok = False
                continue
            
            # Check if nested IF has else value 3
            if_else_3_pattern = r'IF\s*\([^,]+,\s*[^,]+,\s*3\s*\)'
            if not re.search(if_else_3_pattern, formula_upper, re.IGNORECASE):
                logger.warning(f"Cell {helper_column}{row_num} IF else value may not be 3")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn
        
        if not helper_formulas_ok:
            logger.error("Helper column formula verification failed")
            return 0.0
        
        logger.info("✓ Helper column formula verification passed")
        
        # Check 2: Verify sorting by helper column and birth date
        logger.info(f"Checking if data is sorted by {helper_column} column (ascending) and {birth_date_column} column (ascending)...")
        
        # Load workbook with calculated values for sorting check
        try:
            wb_values = openpyxl.load_workbook(result, data_only=True)
            ws_values = wb_values.active
        except Exception as e:
            logger.warning(f"Failed to load workbook with data_only=True, using formula values: {e}")
            ws_values = ws
        
        # Collect data: (row_num, helper_value, birth_date_value, relationship)
        data_rows = []
        for row_num in range(start_row, end_row + 1):
            helper_cell = ws_values[f"{helper_column}{row_num}"]
            birth_date_cell = ws_values[f"{birth_date_column}{row_num}"]
            relationship_cell = ws_values[f"{relationship_column}{row_num}"]
            
            helper_value = helper_cell.value
            birth_date_value = birth_date_cell.value
            relationship_value = relationship_cell.value
            
            # Skip if essential data is missing
            if helper_value is None or relationship_value is None:
                continue
            
            # Try to convert helper value to number
            try:
                if isinstance(helper_value, str):
                    helper_value = float(helper_value.replace(',', ''))
                else:
                    helper_value = float(helper_value)
            except (ValueError, TypeError):
                logger.debug(f"Cell {helper_column}{row_num} contains non-numeric value: {helper_value}, skipping")
                continue
            
            # Try to convert birth date to comparable value
            birth_date_comparable = None
            if birth_date_value is not None:
                try:
                    if isinstance(birth_date_value, (int, float)):
                        birth_date_comparable = float(birth_date_value)
                    elif isinstance(birth_date_value, str):
                        # Try to parse date string
                        from datetime import datetime
                        try:
                            dt = datetime.strptime(birth_date_value, '%Y-%m-%d')
                            birth_date_comparable = dt.timestamp()
                        except:
                            try:
                                dt = datetime.strptime(birth_date_value, '%Y/%m/%d')
                                birth_date_comparable = dt.timestamp()
                            except:
                                birth_date_comparable = None
                    else:
                        birth_date_comparable = float(birth_date_value)
                except (ValueError, TypeError):
                    logger.debug(f"Cell {birth_date_column}{row_num} contains non-comparable date: {birth_date_value}")
            
            data_rows.append((row_num, helper_value, birth_date_comparable, relationship_value))
        
        if len(data_rows) < 2:
            logger.warning("Not enough data rows to verify sorting")
            logger.info("✓ Sorting verification passed (minimal data, helper column formula verified)")
            return 1.0
        
        # Check sorting: first by helper column (ascending), then by birth date (ascending)
        is_sorted = True
        for i in range(len(data_rows) - 1):
            current_helper = data_rows[i][1]
            next_helper = data_rows[i + 1][1]
            current_birth = data_rows[i][2]
            next_birth = data_rows[i + 1][2]
            
            # First sort key: helper column (ascending)
            if current_helper > next_helper:
                logger.error(f"Data not sorted by helper column: row {data_rows[i][0]} ({current_helper}) > row {data_rows[i+1][0]} ({next_helper})")
                is_sorted = False
                break
            elif current_helper == next_helper:
                # Second sort key: birth date (ascending) - only if both have dates
                if current_birth is not None and next_birth is not None:
                    if current_birth > next_birth:
                        logger.error(f"Data not sorted by birth date within same helper value: row {data_rows[i][0]} ({current_birth}) > row {data_rows[i+1][0]} ({next_birth})")
                        is_sorted = False
                        break
        
        if not is_sorted:
            logger.error("Sorting verification failed")
            return 0.0
        
        logger.info("✓ Sorting verification passed")
        
        logger.info("=" * 60)
        logger.info(f"✓ COUNTIF/IF household sorting verification passed")
        logger.info(f"  Helper column: {helper_column}")
        logger.info(f"  Relationship column: {relationship_column}")
        logger.info(f"  Birth date column: {birth_date_column}")
        logger.info("=" * 60)
        return 1.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_regex_airport_extract(result: str, expected: str = None, **options) -> float:
    """
    Verify if REGEX formulas exist in specified columns (E and F) to extract airport names.
    
    This function checks:
    1. Whether cells in E and F columns contain REGEX formulas
    2. Whether E column formulas reference B column (departure location)
    3. Whether F column formulas reference C column (arrival location)
    4. Whether formulas contain the pattern "\\p{Han}{2,4}" to extract 2-4 Chinese characters
    
    Expected formula patterns:
    - E column: =REGEX(B2,"\\p{Han}{2,4}")
    - F column: =REGEX(C2,"\\p{Han}{2,4}")
    
    The function automatically detects the number of data rows by checking the data column
    for non-empty cells. It stops checking after finding 3 consecutive empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - departure_extract_column: Column with departure airport extraction formulas (e.g., "E")
            - arrival_extract_column: Column with arrival airport extraction formulas (e.g., "F")
            - departure_source_column: Column containing departure location data (e.g., "B")
            - arrival_source_column: Column containing arrival location data (e.g., "C")
            - start_row: Starting row number (default: 2)
            - expected_pattern: Expected regex pattern (default: "\\p{Han}{2,4}")
            - data_column: Column to check for data to determine end_row (default: "B")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        departure_extract_column = options.get('departure_extract_column', 'E')
        arrival_extract_column = options.get('arrival_extract_column', 'F')
        departure_source_column = options.get('departure_source_column', 'B')
        arrival_source_column = options.get('arrival_source_column', 'C')
        start_row = options.get('start_row', 2)
        expected_pattern = options.get('expected_pattern', '\\p{Han}{2,4}')
        data_column = options.get('data_column', 'B')
        
        logger.info(f"Verifying REGEX airport extraction formulas in file: {result}")
        logger.info(f"Departure extract column: {departure_extract_column}")
        logger.info(f"Arrival extract column: {arrival_extract_column}")
        logger.info(f"Departure source column: {departure_source_column}")
        logger.info(f"Arrival source column: {arrival_source_column}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Expected pattern: {expected_pattern}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Check formulas in both columns
        all_checks_passed = True
        rows_checked = 0
        
        for row_num in range(start_row, end_row + 1):
            # Check departure column (E)
            departure_cell = ws[f"{departure_extract_column}{row_num}"]
            departure_source_cell = ws[f"{departure_source_column}{row_num}"]
            
            # Check arrival column (F)
            arrival_cell = ws[f"{arrival_extract_column}{row_num}"]
            arrival_source_cell = ws[f"{arrival_source_column}{row_num}"]
            
            # Skip if source cells are empty
            if departure_source_cell.value is None and arrival_source_cell.value is None:
                continue
            
            rows_checked += 1
            
            # Check departure column formula
            if departure_source_cell.value is not None:
                if departure_cell.data_type != "f":
                    logger.error(f"Cell {departure_extract_column}{row_num} does not contain a formula")
                    all_checks_passed = False
                    continue
                
                # Get formula text
                formula = None
                if hasattr(departure_cell, "_value") and isinstance(departure_cell._value, str) and departure_cell._value.startswith("="):
                    formula = departure_cell._value
                elif hasattr(departure_cell, "formula"):
                    formula = departure_cell.formula
                else:
                    if departure_cell.value is not None and isinstance(departure_cell.value, str) and departure_cell.value.startswith("="):
                        formula = departure_cell.value
                
                if formula is None:
                    logger.error(f"Could not extract formula from cell {departure_extract_column}{row_num}")
                    all_checks_passed = False
                    continue
                
                formula_upper = formula.upper()
                logger.debug(f"Row {row_num} departure formula: {formula}")
                
                # Check 1: Contains REGEX function
                if 'REGEX' not in formula_upper:
                    logger.error(f"Cell {departure_extract_column}{row_num} formula should contain REGEX function")
                    logger.error(f"  Formula: {formula}")
                    all_checks_passed = False
                    continue
                
                # Check 2: References departure source column
                source_pattern = rf'{departure_source_column}{row_num}\b'
                if not re.search(source_pattern, formula_upper):
                    logger.error(f"Cell {departure_extract_column}{row_num} formula should reference {departure_source_column}{row_num}")
                    logger.error(f"  Formula: {formula}")
                    all_checks_passed = False
                    continue
                
                # Check 3: Contains expected pattern
                # Pattern in formula might be: "\\p{Han}{2,4}" or '\\p{Han}{2,4}' or "\p{Han}{2,4}"
                # We need to check for the pattern with proper escaping
                # The pattern might appear as: \p{Han}{2,4} (with backslash) or \\p{Han}{2,4} (with double backslash)
                pattern_variants = [
                    re.escape(expected_pattern),  # Exact match with escaping
                    expected_pattern.replace('\\', '\\\\'),  # Double backslash version
                    expected_pattern.replace('\\\\', '\\'),  # Single backslash version
                ]
                pattern_found = False
                for variant in pattern_variants:
                    # Check for pattern in quotes (single or double)
                    pattern_check = rf'["\']{re.escape(variant)}["\']'
                    if re.search(pattern_check, formula):
                        pattern_found = True
                        break
                    # Also check without quotes (less common but possible)
                    pattern_check2 = rf'\b{re.escape(variant)}\b'
                    if re.search(pattern_check2, formula):
                        pattern_found = True
                        break
                
                if not pattern_found:
                    logger.error(f"Cell {departure_extract_column}{row_num} formula should contain pattern '{expected_pattern}'")
                    logger.error(f"  Formula: {formula}")
                    all_checks_passed = False
                    continue
            
            # Check arrival column formula
            if arrival_source_cell.value is not None:
                if arrival_cell.data_type != "f":
                    logger.error(f"Cell {arrival_extract_column}{row_num} does not contain a formula")
                    all_checks_passed = False
                    continue
                
                # Get formula text
                formula = None
                if hasattr(arrival_cell, "_value") and isinstance(arrival_cell._value, str) and arrival_cell._value.startswith("="):
                    formula = arrival_cell._value
                elif hasattr(arrival_cell, "formula"):
                    formula = arrival_cell.formula
                else:
                    if arrival_cell.value is not None and isinstance(arrival_cell.value, str) and arrival_cell.value.startswith("="):
                        formula = arrival_cell.value
                
                if formula is None:
                    logger.error(f"Could not extract formula from cell {arrival_extract_column}{row_num}")
                    all_checks_passed = False
                    continue
                
                formula_upper = formula.upper()
                logger.debug(f"Row {row_num} arrival formula: {formula}")
                
                # Check 1: Contains REGEX function
                if 'REGEX' not in formula_upper:
                    logger.error(f"Cell {arrival_extract_column}{row_num} formula should contain REGEX function")
                    logger.error(f"  Formula: {formula}")
                    all_checks_passed = False
                    continue
                
                # Check 2: References arrival source column
                source_pattern = rf'{arrival_source_column}{row_num}\b'
                if not re.search(source_pattern, formula_upper):
                    logger.error(f"Cell {arrival_extract_column}{row_num} formula should reference {arrival_source_column}{row_num}")
                    logger.error(f"  Formula: {formula}")
                    all_checks_passed = False
                    continue
                
                # Check 3: Contains expected pattern
                # Pattern in formula might be: "\\p{Han}{2,4}" or '\\p{Han}{2,4}' or "\p{Han}{2,4}"
                # We need to check for the pattern with proper escaping
                # The pattern might appear as: \p{Han}{2,4} (with backslash) or \\p{Han}{2,4} (with double backslash)
                pattern_variants = [
                    re.escape(expected_pattern),  # Exact match with escaping
                    expected_pattern.replace('\\', '\\\\'),  # Double backslash version
                    expected_pattern.replace('\\\\', '\\'),  # Single backslash version
                ]
                pattern_found = False
                for variant in pattern_variants:
                    # Check for pattern in quotes (single or double)
                    pattern_check = rf'["\']{re.escape(variant)}["\']'
                    if re.search(pattern_check, formula):
                        pattern_found = True
                        break
                    # Also check without quotes (less common but possible)
                    pattern_check2 = rf'\b{re.escape(variant)}\b'
                    if re.search(pattern_check2, formula):
                        pattern_found = True
                        break
                
                if not pattern_found:
                    logger.error(f"Cell {arrival_extract_column}{row_num} formula should contain pattern '{expected_pattern}'")
                    logger.error(f"  Formula: {formula}")
                    all_checks_passed = False
                    continue
            
            logger.debug(f"✓ Row {row_num} formulas passed all checks")
        
        if rows_checked == 0:
            logger.error("No rows with data found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ REGEX airport extraction verification passed")
            logger.info(f"  Rows checked: {rows_checked}")
            logger.info(f"  Departure column: {departure_extract_column} (from {departure_source_column})")
            logger.info(f"  Arrival column: {arrival_extract_column} (from {arrival_source_column})")
            logger.info(f"  Pattern: {expected_pattern}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ REGEX airport extraction verification failed")
            logger.error(f"  Rows checked: {rows_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_sumproduct_cross_sheet_lookup(result: str, expected: str = None, **options) -> float:
    """
    Verify if SUMPRODUCT formulas exist in target sheet to lookup data from source sheet.
    
    This function checks:
    1. Whether cells in target column contain SUMPRODUCT formulas
    2. Whether formulas reference source sheet with correct sheet name
    3. Whether formulas match two conditions: source column A equals target column A, source column B equals target column B
    4. Whether formulas return values from source column C
    
    Expected formula pattern: =SUMPRODUCT((source_sheet.$A$2:$A$19=A2)*(source_sheet.$B$2:$B$19=B2),source_sheet.$C$2:$C$19)
    
    The function automatically detects the number of data rows by checking the data column
    for non-empty cells. It stops checking after finding 3 consecutive empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - target_sheet: Target sheet name (e.g., "本周销售")
            - source_sheet: Source sheet name (e.g., "上周销售")
            - target_column: Column with formulas (e.g., "D")
            - source_column_a: Source column for first condition (e.g., "A")
            - source_column_b: Source column for second condition (e.g., "B")
            - source_column_c: Source column for return values (e.g., "C")
            - target_column_a: Target column for first condition (e.g., "A")
            - target_column_b: Target column for second condition (e.g., "B")
            - start_row: Starting row number (default: 2)
            - data_range_start: Source data range start row (default: 2)
            - data_range_end: Source data range end row (default: 19)
            - data_column: Column to check for data to determine end_row (default: "A")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        target_sheet = options.get('target_sheet', '本周销售')
        source_sheet = options.get('source_sheet', '上周销售')
        target_column = options.get('target_column', 'D')
        source_column_a = options.get('source_column_a', 'A')
        source_column_b = options.get('source_column_b', 'B')
        source_column_c = options.get('source_column_c', 'C')
        target_column_a = options.get('target_column_a', 'A')
        target_column_b = options.get('target_column_b', 'B')
        start_row = options.get('start_row', 2)
        data_range_start = options.get('data_range_start', 2)
        data_range_end = options.get('data_range_end', 19)
        data_column = options.get('data_column', 'A')
        
        logger.info(f"Verifying SUMPRODUCT cross-sheet lookup formulas in file: {result}")
        logger.info(f"Target sheet: {target_sheet}")
        logger.info(f"Source sheet: {source_sheet}")
        logger.info(f"Target column: {target_column}")
        logger.info(f"Source columns: {source_column_a}, {source_column_b}, {source_column_c}")
        logger.info(f"Target columns: {target_column_a}, {target_column_b}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Data range: {data_range_start} to {data_range_end}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            if target_sheet not in wb.sheetnames:
                logger.error(f"Target sheet '{target_sheet}' not found in workbook")
                return 0.0
            ws_target = wb[target_sheet]
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws_target.max_row
        end_row = start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws_target[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Check formulas in target column
        all_checks_passed = True
        rows_checked = 0
        
        for row_num in range(start_row, end_row + 1):
            target_cell = ws_target[f"{target_column}{row_num}"]
            target_cell_a = ws_target[f"{target_column_a}{row_num}"]
            
            # Skip if target column A is empty
            if target_cell_a.value is None:
                continue
            
            rows_checked += 1
            
            # Check if cell contains a formula
            if target_cell.data_type != "f":
                logger.error(f"Cell {target_column}{row_num} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(target_cell, "_value") and isinstance(target_cell._value, str) and target_cell._value.startswith("="):
                formula = target_cell._value
            elif hasattr(target_cell, "formula"):
                formula = target_cell.formula
            else:
                if target_cell.value is not None and isinstance(target_cell.value, str) and target_cell.value.startswith("="):
                    formula = target_cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {target_column}{row_num}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Row {row_num} formula: {formula}")
            
            # Check 1: Contains SUMPRODUCT function
            if 'SUMPRODUCT' not in formula_upper:
                logger.error(f"Cell {target_column}{row_num} formula should contain SUMPRODUCT function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References source sheet
            # Sheet name might be quoted or unquoted, and might have spaces
            # Excel/LibreOffice uses ! (exclamation mark) for sheet references
            source_sheet_pattern = rf'["\']?{re.escape(source_sheet)}["\']?[!\.]'
            if not re.search(source_sheet_pattern, formula, re.IGNORECASE):
                logger.error(f"Cell {target_column}{row_num} formula should reference source sheet '{source_sheet}'")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: First condition - source column A equals target column A
            # Pattern: source_sheet!$A$2:$A$19=A2 (or similar row references)
            # Note: Excel/LibreOffice uses ! (exclamation mark) not . (dot) for sheet references
            condition1_pattern = rf'{re.escape(source_sheet)}[!\.][\$]?{source_column_a}[\$]?\d+:\$?{source_column_a}[\$]?\d+\s*=\s*{target_column_a}{row_num}'
            if not re.search(condition1_pattern, formula_upper):
                logger.error(f"Cell {target_column}{row_num} formula should have condition: {source_sheet}!{source_column_a}...={target_column_a}{row_num}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Second condition - source column B equals target column B
            # Pattern: source_sheet!$B$2:$B$19=B2 (or similar row references)
            condition2_pattern = rf'{re.escape(source_sheet)}[!\.][\$]?{source_column_b}[\$]?\d+:\$?{source_column_b}[\$]?\d+\s*=\s*{target_column_b}{row_num}'
            if not re.search(condition2_pattern, formula_upper):
                logger.error(f"Cell {target_column}{row_num} formula should have condition: {source_sheet}!{source_column_b}...={target_column_b}{row_num}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 5: Returns values from source column C
            # Pattern: source_sheet!$C$2:$C$19 (or similar row references)
            return_pattern = rf'{re.escape(source_sheet)}[!\.][\$]?{source_column_c}[\$]?\d+:\$?{source_column_c}[\$]?\d+'
            if not re.search(return_pattern, formula_upper):
                logger.error(f"Cell {target_column}{row_num} formula should return values from {source_sheet}!{source_column_c}...")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 6: Data range should match expected range
            range_pattern = rf'{re.escape(source_sheet)}[!\.][\$]?{source_column_a}[\$]?{data_range_start}:\$?{source_column_a}[\$]?{data_range_end}'
            if not re.search(range_pattern, formula_upper):
                logger.warning(f"Cell {target_column}{row_num} formula may not use expected data range {data_range_start}:{data_range_end}")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn
            
            logger.debug(f"✓ Row {row_num} formula passed all checks")
        
        if rows_checked == 0:
            logger.error("No rows with data found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ SUMPRODUCT cross-sheet lookup verification passed")
            logger.info(f"  Rows checked: {rows_checked}")
            logger.info(f"  Target sheet: {target_sheet}, Column: {target_column}")
            logger.info(f"  Source sheet: {source_sheet}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ SUMPRODUCT cross-sheet lookup verification failed")
            logger.error(f"  Rows checked: {rows_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_substitute_remove_spaces(result: str, expected: str = None, **options) -> float:
    """
    Verify if SUBSTITUTE formulas exist in specified columns to remove spaces.
    
    This function checks:
    1. Whether cells in specified columns contain SUBSTITUTE formulas
    2. Whether formulas reference the corresponding source column cells
    3. Whether formulas use SUBSTITUTE to replace space with empty string
    
    Expected formula pattern: =SUBSTITUTE(A2," ",) or =SUBSTITUTE(A2," ","")
    
    The function automatically detects the number of data rows by checking the data column
    for non-empty cells. It stops checking after finding 3 consecutive empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_columns: List of columns to check (e.g., ["C", "D"])
            - source_columns: List of corresponding source columns (e.g., ["A", "B"])
            - start_row: Starting row number (default: 2)
            - expected_functions: List of expected function names (default: ["SUBSTITUTE"])
            - data_column: Column to check for data to determine end_row (default: "A")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_columns = options.get('check_columns', ['C', 'D'])
        source_columns = options.get('source_columns', ['A', 'B'])
        start_row = options.get('start_row', 2)
        expected_functions = options.get('expected_functions', ['SUBSTITUTE'])
        data_column = options.get('data_column', 'A')
        
        if len(check_columns) != len(source_columns):
            logger.error("check_columns and source_columns must have the same length")
            return 0.0
        
        logger.info(f"Verifying SUBSTITUTE remove spaces formulas in file: {result}")
        logger.info(f"Check columns: {check_columns}")
        logger.info(f"Source columns: {source_columns}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Expected functions: {expected_functions}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Check formulas in each column
        all_checks_passed = True
        rows_checked = 0
        
        for col_idx, check_column in enumerate(check_columns):
            source_column = source_columns[col_idx]
            logger.info(f"Checking column {check_column} (from {source_column})...")
            
            for row_num in range(start_row, end_row + 1):
                check_cell = ws[f"{check_column}{row_num}"]
                source_cell = ws[f"{source_column}{row_num}"]
                
                # Skip if source cell is empty
                if source_cell.value is None:
                    continue
                
                rows_checked += 1
                
                # Check if cell contains a formula
                if check_cell.data_type != "f":
                    logger.error(f"Cell {check_column}{row_num} does not contain a formula")
                    all_checks_passed = False
                    continue
                
                # Get formula text
                formula = None
                if hasattr(check_cell, "_value") and isinstance(check_cell._value, str) and check_cell._value.startswith("="):
                    formula = check_cell._value
                elif hasattr(check_cell, "formula"):
                    formula = check_cell.formula
                else:
                    if check_cell.value is not None and isinstance(check_cell.value, str) and check_cell.value.startswith("="):
                        formula = check_cell.value
                
                if formula is None:
                    logger.error(f"Could not extract formula from cell {check_column}{row_num}")
                    all_checks_passed = False
                    continue
                
                formula_upper = formula.upper()
                logger.debug(f"Row {row_num} {check_column} formula: {formula}")
                
                # Check 1: Contains SUBSTITUTE function
                if 'SUBSTITUTE' not in formula_upper:
                    logger.error(f"Cell {check_column}{row_num} formula should contain SUBSTITUTE function")
                    logger.error(f"  Formula: {formula}")
                    all_checks_passed = False
                    continue
                
                # Check 2: References source column cell
                source_pattern = rf'{source_column}{row_num}\b'
                if not re.search(source_pattern, formula_upper):
                    logger.error(f"Cell {check_column}{row_num} formula should reference {source_column}{row_num}")
                    logger.error(f"  Formula: {formula}")
                    all_checks_passed = False
                    continue
                
                # Check 3: SUBSTITUTE replaces space with empty string
                # Pattern: SUBSTITUTE(...," ",) or SUBSTITUTE(...," ","")
                # The space might be in single or double quotes
                substitute_pattern1 = r'SUBSTITUTE\s*\([^,]+,\s*["\']?\s+["\']?\s*,\s*\)'  # SUBSTITUTE(...," ",)
                substitute_pattern2 = r'SUBSTITUTE\s*\([^,]+,\s*["\']?\s+["\']?\s*,\s*["\']?\s*["\']?\s*\)'  # SUBSTITUTE(...," ","")
                if not re.search(substitute_pattern1, formula_upper) and not re.search(substitute_pattern2, formula_upper):
                    logger.error(f"Cell {check_column}{row_num} SUBSTITUTE should replace space with empty string")
                    logger.error(f"  Formula: {formula}")
                    all_checks_passed = False
                    continue
                
                logger.debug(f"✓ Row {row_num} {check_column} formula passed all checks")
        
        if rows_checked == 0:
            logger.error("No rows with data found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ SUBSTITUTE remove spaces verification passed")
            logger.info(f"  Rows checked: {rows_checked}")
            logger.info(f"  Check columns: {check_columns}")
            logger.info(f"  Source columns: {source_columns}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ SUBSTITUTE remove spaces verification failed")
            logger.error(f"  Rows checked: {rows_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_substitute_remove_spaces(result: str, expected: str = None, **options) -> float:
    """
    Verify if SUBSTITUTE formulas exist in specified columns to remove spaces.
    
    This function checks:
    1. Whether cells in specified columns contain SUBSTITUTE formulas
    2. Whether formulas reference the corresponding source column cells
    3. Whether formulas use SUBSTITUTE to replace space with empty string
    
    Expected formula pattern: =SUBSTITUTE(A2," ",) or =SUBSTITUTE(A2," ","")
    
    The function automatically detects the number of data rows by checking the data column
    for non-empty cells. It stops checking after finding 3 consecutive empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_columns: List of columns to check (e.g., ["C", "D"])
            - source_columns: List of corresponding source columns (e.g., ["A", "B"])
            - start_row: Starting row number (default: 2)
            - expected_functions: List of expected function names (default: ["SUBSTITUTE"])
            - data_column: Column to check for data to determine end_row (default: "A")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_columns = options.get('check_columns', ['C', 'D'])
        source_columns = options.get('source_columns', ['A', 'B'])
        start_row = options.get('start_row', 2)
        expected_functions = options.get('expected_functions', ['SUBSTITUTE'])
        data_column = options.get('data_column', 'A')
        
        if len(check_columns) != len(source_columns):
            logger.error("check_columns and source_columns must have the same length")
            return 0.0
        
        logger.info(f"Verifying SUBSTITUTE remove spaces formulas in file: {result}")
        logger.info(f"Check columns: {check_columns}")
        logger.info(f"Source columns: {source_columns}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Expected functions: {expected_functions}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Check formulas in each column
        all_checks_passed = True
        rows_checked = 0
        
        for col_idx, check_column in enumerate(check_columns):
            source_column = source_columns[col_idx]
            logger.info(f"Checking column {check_column} (from {source_column})...")
            
            for row_num in range(start_row, end_row + 1):
                check_cell = ws[f"{check_column}{row_num}"]
                source_cell = ws[f"{source_column}{row_num}"]
                
                # Skip if source cell is empty
                if source_cell.value is None:
                    continue
                
                rows_checked += 1
                
                # Check if cell contains a formula
                if check_cell.data_type != "f":
                    logger.error(f"Cell {check_column}{row_num} does not contain a formula")
                    all_checks_passed = False
                    continue
                
                # Get formula text
                formula = None
                if hasattr(check_cell, "_value") and isinstance(check_cell._value, str) and check_cell._value.startswith("="):
                    formula = check_cell._value
                elif hasattr(check_cell, "formula"):
                    formula = check_cell.formula
                else:
                    if check_cell.value is not None and isinstance(check_cell.value, str) and check_cell.value.startswith("="):
                        formula = check_cell.value
                
                if formula is None:
                    logger.error(f"Could not extract formula from cell {check_column}{row_num}")
                    all_checks_passed = False
                    continue
                
                formula_upper = formula.upper()
                logger.debug(f"Row {row_num} {check_column} formula: {formula}")
                
                # Check 1: Contains SUBSTITUTE function
                if 'SUBSTITUTE' not in formula_upper:
                    logger.error(f"Cell {check_column}{row_num} formula should contain SUBSTITUTE function")
                    logger.error(f"  Formula: {formula}")
                    all_checks_passed = False
                    continue
                
                # Check 2: References source column cell
                source_pattern = rf'{source_column}{row_num}\b'
                if not re.search(source_pattern, formula_upper):
                    logger.error(f"Cell {check_column}{row_num} formula should reference {source_column}{row_num}")
                    logger.error(f"  Formula: {formula}")
                    all_checks_passed = False
                    continue
                
                # Check 3: SUBSTITUTE replaces space with empty string
                # Pattern: SUBSTITUTE(...," ",) or SUBSTITUTE(...," ","")
                # The space might be in single or double quotes
                substitute_pattern1 = r'SUBSTITUTE\s*\([^,]+,\s*["\']?\s+["\']?\s*,\s*\)'  # SUBSTITUTE(...," ",)
                substitute_pattern2 = r'SUBSTITUTE\s*\([^,]+,\s*["\']?\s+["\']?\s*,\s*["\']?\s*["\']?\s*\)'  # SUBSTITUTE(...," ","")
                if not re.search(substitute_pattern1, formula_upper) and not re.search(substitute_pattern2, formula_upper):
                    logger.error(f"Cell {check_column}{row_num} SUBSTITUTE should replace space with empty string")
                    logger.error(f"  Formula: {formula}")
                    all_checks_passed = False
                    continue
                
                logger.debug(f"✓ Row {row_num} {check_column} formula passed all checks")
        
        if rows_checked == 0:
            logger.error("No rows with data found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ SUBSTITUTE remove spaces verification passed")
            logger.info(f"  Rows checked: {rows_checked}")
            logger.info(f"  Check columns: {check_columns}")
            logger.info(f"  Source columns: {source_columns}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ SUBSTITUTE remove spaces verification failed")
            logger.error(f"  Rows checked: {rows_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_maxifs_minifs_conditional(result: str, expected: str = None, **options) -> float:
    """
    Verify if MAXIFS and MINIFS formulas exist in specified cells to find max/min of positive/negative numbers.
    
    This function checks:
    1. Whether specified cells contain MAXIFS or MINIFS formulas
    2. Whether formulas reference the correct data range
    3. Whether formulas use correct conditions (<0 for negative, >0 for positive)
    
    Expected formula patterns:
    - F3: =MAXIFS(B2:B4771,B2:B4771,"<0") (max of negative numbers)
    - G3: =MAXIFS(B2:B4771,B2:B4771,">0") (max of positive numbers)
    - F4: =MINIFS(B2:B4771,B2:B4771,"<0") (min of negative numbers)
    - G4: =MINIFS(B2:B4771,B2:B4771,">0") (min of positive numbers)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "F3": {"function": "MAXIFS", "condition": "<0", "range": "B2:B4771"},
                  "G3": {"function": "MAXIFS", "condition": ">0", "range": "B2:B4771"},
                  "F4": {"function": "MINIFS", "condition": "<0", "range": "B2:B4771"},
                  "G4": {"function": "MINIFS", "condition": ">0", "range": "B2:B4771"}
              }
            - data_range: Data range to check (e.g., "B2:B4771")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        data_range = options.get('data_range', 'B2:B4771')
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying MAXIFS/MINIFS conditional formulas in file: {result}")
        logger.info(f"Data range: {data_range}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            expected_function = formula_info.get('function', '').upper()
            expected_condition = formula_info.get('condition', '')
            expected_range = formula_info.get('range', data_range)
            
            logger.info(f"Checking cell {cell_coord}: {expected_function} with condition {expected_condition}")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains expected function (MAXIFS or MINIFS)
            if expected_function not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain {expected_function} function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References expected data range
            # Escape the range pattern (e.g., B2:B4771)
            range_escaped = re.escape(expected_range)
            range_pattern = rf'{range_escaped}'
            if not re.search(range_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should reference range {expected_range}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains expected condition
            # Condition might be in quotes: "<0" or '>0'
            condition_escaped = re.escape(expected_condition)
            condition_pattern1 = rf'["\']?{condition_escaped}["\']?'
            if not re.search(condition_pattern1, formula_upper):
                logger.error(f"Cell {cell_coord} formula should have condition {expected_condition}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: Function structure - MAXIFS/MINIFS(range, range, condition)
            # Pattern: MAXIFS(B2:B4771,B2:B4771,"<0")
            function_pattern = rf'{expected_function}\s*\(\s*{range_escaped}\s*,\s*{range_escaped}\s*,\s*["\']?{condition_escaped}["\']?\s*\)'
            if not re.search(function_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula may not have correct {expected_function} structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the structure might vary slightly
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MAXIFS/MINIFS conditional verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info(f"  Data range: {data_range}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MAXIFS/MINIFS conditional verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_concatenate_columns_with_separator(result: str, expected: str = None, **options) -> float:
    """
    Verify if columns are concatenated with a separator using the & operator.
    
    This function checks:
    1. Whether the target column contains formulas that concatenate source columns
    2. Whether the formula uses the & operator for concatenation
    3. Whether the formula includes the specified separator
    4. Whether the formula is applied to all data rows
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - target_column: Column where concatenated results should appear (e.g., "C")
            - source_columns: List of source columns to concatenate (e.g., ["A", "B"])
            - separator: Separator string between columns (e.g., " ")
            - start_row: First data row (default: 1)
            - header_row: Header row number (default: 1)
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        target_column = options.get('target_column', 'C')
        source_columns = options.get('source_columns', ['A', 'B'])
        separator = options.get('separator', ' ')
        start_row = options.get('start_row', 1)
        header_row = options.get('header_row', 1)
        
        # Load workbook to get formulas
        wb = openpyxl.load_workbook(result, data_only=False)
        ws = wb.active
        
        # Auto-detect data rows by checking for consecutive empty rows
        max_check_row = 1000
        data_end_row = start_row
        consecutive_empty = 0
        
        for row_idx in range(start_row, max_check_row):
            # Check if source columns are empty
            all_empty = True
            for col in source_columns:
                cell_value = ws[f"{col}{row_idx}"].value
                if cell_value is not None and str(cell_value).strip() != "":
                    all_empty = False
                    break
            
            if all_empty:
                consecutive_empty += 1
                if consecutive_empty >= 3:  # 3 consecutive empty rows means end of data
                    break
            else:
                consecutive_empty = 0
                data_end_row = row_idx
        
        logger.info(f"Detected data rows from {start_row} to {data_end_row}")
        
        if data_end_row < start_row:
            logger.error(f"No data rows found starting from row {start_row}")
            return 0.0
        
        # Check formulas in target column
        formula_count = 0
        valid_formula_count = 0
        
        for row_idx in range(start_row, data_end_row + 1):
            target_cell = ws[f"{target_column}{row_idx}"]
            
            # Get formula text
            formula_text = None
            if hasattr(target_cell, "_value") and isinstance(target_cell._value, str) and target_cell._value.startswith("="):
                formula_text = target_cell._value
            elif hasattr(target_cell, "formula"):
                formula_text = target_cell.formula
            elif target_cell.value is not None and isinstance(target_cell.value, str) and target_cell.value.startswith("="):
                formula_text = target_cell.value
            
            if formula_text is None:
                # Check if cell has a value (might be calculated)
                if target_cell.value is not None and str(target_cell.value).strip() != "":
                    # Check if the value matches expected concatenation
                    source_values = []
                    for col in source_columns:
                        val = ws[f"{col}{row_idx}"].value
                        if val is not None:
                            source_values.append(str(val))
                    
                    expected_value = separator.join(source_values)
                    actual_value = str(target_cell.value).strip()
                    
                    if actual_value == expected_value:
                        valid_formula_count += 1
                continue
            
            formula_count += 1
            
            # Remove leading = sign
            formula_clean = formula_text[1:] if formula_text.startswith("=") else formula_text
            formula_upper = formula_clean.upper()
            
            # Check 1: Formula contains & operator
            if "&" not in formula_clean:
                logger.warning(f"Row {row_idx}: Formula does not contain & operator")
                continue
            
            # Check 2: Formula references source columns
            all_columns_referenced = True
            for col in source_columns:
                # Check for column reference (e.g., A1, A2, etc.)
                col_pattern = rf'\b{col}{row_idx}\b'
                if not re.search(col_pattern, formula_upper):
                    logger.warning(f"Row {row_idx}: Formula does not reference column {col}")
                    all_columns_referenced = False
                    break
            
            if not all_columns_referenced:
                continue
            
            # Check 3: Formula contains separator (if not empty)
            if separator:
                # Escape special regex characters in separator
                escaped_sep = re.escape(separator)
                # Check for separator in quotes
                sep_pattern = rf'["\'].*{escaped_sep}.*["\']'
                if not re.search(sep_pattern, formula_clean):
                    logger.warning(f"Row {row_idx}: Formula does not contain separator '{separator}'")
                    continue
            
            valid_formula_count += 1
        
        # Calculate success rate
        total_rows = data_end_row - start_row + 1
        success_rate = valid_formula_count / total_rows if total_rows > 0 else 0.0
        
        logger.info(f"Valid formulas: {valid_formula_count}/{total_rows} (success rate: {success_rate:.2%})")
        
        # Require at least 90% of rows to have valid formulas
        if success_rate >= 0.9:
            logger.info(f"✓ Column concatenation verification passed")
            return 1.0
        else:
            logger.error(f"Column concatenation verification failed: only {success_rate:.2%} of rows have valid formulas")
            return 0.0
    
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_tocol_torow_merge(result: str, expected: str = None, **options) -> float:
    """
    Verify if formulas exist to merge two columns using TOCOL/TOROW or INDEX/ROUNDUP/ROW/MOD/ROWS.
    
    This function checks:
    1. Whether the result column contains appropriate formulas
    2. Whether formulas reference the correct source columns
    3. Whether formulas use concatenation operator (&) to merge the columns
    
    Expected formula patterns:
    - Pattern 1: =TOCOL(C1:C20&","&TOROW(G1:G6))
    - Pattern 2: =INDEX($C$1:$C$20,ROUNDUP(ROW(A1)/ROWS($G$1:$G$6),0))&","&INDEX($G$1:$G$6,MOD(ROW(A1)-1,ROWS($G$1:$G$6))+1)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - result_column: Column with merged results (e.g., "H")
            - result_cell: Starting cell for the formula (e.g., "H1")
            - source_column1: First source column (e.g., "C")
            - source_range1: First source range (e.g., "C1:C20")
            - source_column2: Second source column (e.g., "G")
            - source_range2: Second source range (e.g., "G1:G6")
            - separator: Separator used in concatenation (e.g., ",")
            - expected_functions: List of expected function names (default: ["TOCOL", "TOROW"] or ["INDEX", "ROUNDUP", "ROW", "MOD", "ROWS"])
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        result_column = options.get('result_column', 'H')
        result_cell = options.get('result_cell', 'H1')
        source_column1 = options.get('source_column1', 'C')
        source_range1 = options.get('source_range1', 'C1:C20')
        source_column2 = options.get('source_column2', 'G')
        source_range2 = options.get('source_range2', 'G1:G6')
        separator = options.get('separator', ',')
        expected_functions = options.get('expected_functions', ['TOCOL', 'TOROW'])
        
        logger.info(f"Verifying TOCOL/TOROW merge formulas in file: {result}")
        logger.info(f"Result cell: {result_cell}")
        logger.info(f"Source range 1: {source_range1}")
        logger.info(f"Source range 2: {source_range2}")
        logger.info(f"Separator: {separator}")
        logger.info(f"Expected functions: {expected_functions}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check the result cell and nearby cells (in case formula starts from H2, H3, etc.)
        # For INDEX/ROUNDUP/ROW/MOD/ROWS pattern, formula should be in multiple rows
        formula = None
        checked_cell = None
        
        # Try to find formula in result_cell and nearby rows (up to 10 rows)
        result_col = result_column
        result_row = int(re.search(r'\d+', result_cell).group()) if re.search(r'\d+', result_cell) else 1
        
        for row_offset in range(10):  # Check up to 10 rows
            try:
                check_row = result_row + row_offset
                check_cell_coord = f"{result_col}{check_row}"
                cell = ws[check_cell_coord]
                
                # Check if cell contains a formula
                if cell.data_type == "f":
                    # Get formula text
                    if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                        formula = cell._value
                        checked_cell = check_cell_coord
                        break
                    elif hasattr(cell, "formula"):
                        formula = cell.formula
                        checked_cell = check_cell_coord
                        break
                    elif cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula = cell.value
                        checked_cell = check_cell_coord
                        break
            except Exception:
                continue
        
        if formula is None:
            logger.error(f"Could not find formula in {result_column} column (checked rows {result_row} to {result_row + 9})")
            return 0.0
        
        logger.info(f"Found formula in cell {checked_cell}")
        
        formula_upper = formula.upper()
        logger.debug(f"Cell {checked_cell} formula: {formula}")
        
        # Check which pattern is used
        has_tocol = 'TOCOL' in formula_upper
        has_torow = 'TOROW' in formula_upper
        has_index = 'INDEX' in formula_upper
        has_roundup = 'ROUNDUP' in formula_upper
        has_row = 'ROW' in formula_upper
        has_mod = 'MOD' in formula_upper
        has_rows = 'ROWS' in formula_upper
        
        # Pattern 1: TOCOL/TOROW pattern
        if has_tocol and has_torow:
            logger.info("Detected TOCOL/TOROW pattern")
            
            # Check 1: References first source range
            range1_escaped = re.escape(source_range1)
            if not re.search(range1_escaped, formula_upper):
                logger.error(f"Cell {result_cell} formula should reference range {source_range1}")
                logger.error(f"  Formula: {formula}")
                return 0.0
            
            # Check 2: References second source range (within TOROW)
            range2_escaped = re.escape(source_range2)
            torow_pattern = rf'TOROW\s*\(\s*{range2_escaped}\s*\)'
            if not re.search(torow_pattern, formula_upper):
                logger.error(f"Cell {result_cell} TOROW function should reference range {source_range2}")
                logger.error(f"  Formula: {formula}")
                return 0.0
            
            # Check 3: Contains concatenation operator (&)
            if '&' not in formula:
                logger.error(f"Cell {result_cell} formula should use concatenation operator (&)")
                logger.error(f"  Formula: {formula}")
                return 0.0
        
        # Pattern 2: INDEX/ROUNDUP/ROW/MOD/ROWS pattern
        elif has_index and has_roundup and has_row and has_mod and has_rows:
            logger.info("Detected INDEX/ROUNDUP/ROW/MOD/ROWS pattern")
            
            # Check 1: References first source range (in INDEX)
            # The range might use absolute references like $C$1:$C$20
            range1_escaped = re.escape(source_range1)
            range1_abs_escaped = re.escape(source_range1.replace('C', '\\$?C').replace(':', '\\$?:'))
            index1_pattern = rf'INDEX\s*\(\s*[\$]?{source_column1}[\$]?\d+:\$?{source_column1}[\$]?\d+'
            if not re.search(index1_pattern, formula_upper):
                logger.error(f"Cell {checked_cell} first INDEX should reference range {source_range1}")
                logger.error(f"  Formula: {formula}")
                return 0.0
            
            # Check 2: References second source range (in second INDEX)
            range2_escaped = re.escape(source_range2)
            index2_pattern = rf'INDEX\s*\(\s*[\$]?{source_column2}[\$]?\d+:\$?{source_column2}[\$]?\d+'
            if not re.search(index2_pattern, formula_upper):
                logger.error(f"Cell {checked_cell} second INDEX should reference range {source_range2}")
                logger.error(f"  Formula: {formula}")
                return 0.0
            
            # Check 3: Contains ROUNDUP with ROW and ROWS
            # ROWS might reference the second range with absolute references
            rows_pattern = rf'ROWS\s*\(\s*[\$]?{source_column2}[\$]?\d+:\$?{source_column2}[\$]?\d+\s*\)'
            roundup_pattern = rf'ROUNDUP\s*\(\s*ROW\s*\([^)]+\)\s*/\s*{rows_pattern}'
            if not re.search(roundup_pattern, formula_upper):
                logger.warning(f"Cell {checked_cell} ROUNDUP may not have correct structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn
            
            # Check 4: Contains MOD with ROW and ROWS
            mod_pattern = rf'MOD\s*\(\s*ROW\s*\([^)]+\)\s*-\s*\d+\s*,\s*{rows_pattern}'
            if not re.search(mod_pattern, formula_upper):
                logger.warning(f"Cell {checked_cell} MOD may not have correct structure")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn
            
            # Check 5: Contains concatenation operator (&)
            if '&' not in formula:
                logger.error(f"Cell {checked_cell} formula should use concatenation operator (&)")
                logger.error(f"  Formula: {formula}")
                return 0.0
        
        else:
            # Check if at least some expected functions are present
            missing_functions = []
            for func in expected_functions:
                if func.upper() not in formula_upper:
                    missing_functions.append(func)
            
            if missing_functions:
                logger.error(f"Cell {checked_cell} formula missing functions: {missing_functions}")
                logger.error(f"  Formula: {formula}")
                logger.error(f"  Expected pattern: TOCOL/TOROW or INDEX/ROUNDUP/ROW/MOD/ROWS")
                return 0.0
        
        # Common check: Contains separator in concatenation
        separator_escaped = re.escape(separator)
        separator_pattern = rf'&\s*["\']?{separator_escaped}["\']?\s*&'
        if not re.search(separator_pattern, formula_upper):
            logger.warning(f"Cell {checked_cell} formula may not use separator '{separator}' correctly")
            logger.debug(f"  Formula: {formula}")
            # Don't fail, just warn - separator might be in quotes or formatted differently
        
        logger.info("=" * 60)
        logger.info(f"✓ TOCOL/TOROW merge verification passed")
        logger.info(f"  Result cell: {checked_cell}")
        logger.info(f"  Source range 1: {source_range1}")
        logger.info(f"  Source range 2: {source_range2}")
        logger.info(f"  Formula: {formula}")
        logger.info("=" * 60)
        return 1.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_text_prefix_format(result: str, expected: str = None, **options) -> float:
    """
    Verify if formulas exist to add text prefix (like apostrophe) to values.
    
    This function checks:
    1. Whether cells in result column contain formulas
    2. Whether formulas use concatenation operator (&) to add prefix
    3. Whether formulas reference the corresponding source column cells
    
    Expected formula pattern: ="'"&A3
    
    The function automatically detects the number of data rows by checking the source column
    for non-empty cells. It stops checking after finding 3 consecutive empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - result_column: Column with formulas (e.g., "F")
            - source_column: Source column (e.g., "A")
            - start_row: Starting row number (default: 2)
            - prefix: Prefix text to add (e.g., "'")
            - data_column: Column to check for data to determine end_row (default: source_column)
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        result_column = options.get('result_column', 'F')
        source_column = options.get('source_column', 'A')
        start_row = options.get('start_row', 2)
        prefix = options.get('prefix', "'")
        data_column = options.get('data_column', source_column)
        
        logger.info(f"Verifying text prefix format formulas in file: {result}")
        logger.info(f"Result column: {result_column}")
        logger.info(f"Source column: {source_column}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Prefix: {prefix}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Check formulas in result column
        all_checks_passed = True
        rows_checked = 0
        
        for row_num in range(start_row, end_row + 1):
            result_cell = ws[f"{result_column}{row_num}"]
            source_cell = ws[f"{source_column}{row_num}"]
            
            # Skip if source cell is empty
            if source_cell.value is None:
                continue
            
            rows_checked += 1
            
            # Check if cell contains a formula
            if result_cell.data_type != "f":
                logger.error(f"Cell {result_column}{row_num} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(result_cell, "_value") and isinstance(result_cell._value, str) and result_cell._value.startswith("="):
                formula = result_cell._value
            elif hasattr(result_cell, "formula"):
                formula = result_cell.formula
            else:
                if result_cell.value is not None and isinstance(result_cell.value, str) and result_cell.value.startswith("="):
                    formula = result_cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {result_column}{row_num}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Row {row_num} formula: {formula}")
            
            # Check 1: Contains concatenation operator (&)
            if '&' not in formula:
                logger.error(f"Cell {result_column}{row_num} formula should use concatenation operator (&)")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: References source column cell
            source_pattern = rf'{source_column}{row_num}\b'
            if not re.search(source_pattern, formula_upper):
                logger.error(f"Cell {result_column}{row_num} formula should reference {source_column}{row_num}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: Contains prefix in formula
            # Prefix might be in quotes: "'" or '"' or just '
            prefix_escaped = re.escape(prefix)
            # Pattern: ="'"&A3 or ='"'&A3 or ='&A3
            prefix_pattern1 = rf'=\s*["\']{prefix_escaped}["\']\s*&'
            prefix_pattern2 = rf'=\s*{prefix_escaped}\s*&'
            if not re.search(prefix_pattern1, formula) and not re.search(prefix_pattern2, formula):
                logger.error(f"Cell {result_column}{row_num} formula should contain prefix '{prefix}'")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            logger.debug(f"✓ Row {row_num} formula passed all checks")
        
        if rows_checked == 0:
            logger.error("No rows with data found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ Text prefix format verification passed")
            logger.info(f"  Rows checked: {rows_checked}")
            logger.info(f"  Result column: {result_column}")
            logger.info(f"  Source column: {source_column}")
            logger.info(f"  Prefix: {prefix}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ Text prefix format verification failed")
            logger.error(f"  Rows checked: {rows_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_match_percentile_filter(result: str, expected: str = None, **options) -> float:
    """
    Verify if MATCH and PERCENTILE formulas exist to filter top 10% and bottom 10% data.
    
    This function checks:
    1. Whether cells in result column contain MATCH and PERCENTILE formulas
    2. Whether formulas reference the correct source column
    3. Whether PERCENTILE uses correct percentiles array {0,10,90}%
    
    Expected formula pattern: =MATCH(A2,PERCENTILE(A:A,{0,10,90}%))
    
    The function automatically detects the number of data rows by checking the source column
    for non-empty cells. It stops checking after finding 3 consecutive empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - result_column: Column with formulas (e.g., "D")
            - source_column: Source column (e.g., "A")
            - start_row: Starting row number (default: 1)
            - expected_functions: List of expected function names (default: ["MATCH", "PERCENTILE"])
            - expected_percentiles: Expected percentiles array (default: "{0,10,90}%")
            - data_column: Column to check for data to determine end_row (default: source_column)
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        result_column = options.get('result_column', 'D')
        source_column = options.get('source_column', 'A')
        start_row = options.get('start_row', 1)
        expected_functions = options.get('expected_functions', ['MATCH', 'PERCENTILE'])
        expected_percentiles = options.get('expected_percentiles', '{0,10,90}%')
        data_column = options.get('data_column', source_column)
        
        logger.info(f"Verifying MATCH/PERCENTILE filter formulas in file: {result}")
        logger.info(f"Result column: {result_column}")
        logger.info(f"Source column: {source_column}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Expected functions: {expected_functions}")
        logger.info(f"Expected percentiles: {expected_percentiles}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Check formulas in result column
        all_checks_passed = True
        rows_checked = 0
        
        for row_num in range(start_row, end_row + 1):
            result_cell = ws[f"{result_column}{row_num}"]
            source_cell = ws[f"{source_column}{row_num}"]
            
            # Skip if source cell is empty
            if source_cell.value is None:
                continue
            
            rows_checked += 1
            
            # Check if cell contains a formula
            if result_cell.data_type != "f":
                logger.error(f"Cell {result_column}{row_num} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(result_cell, "_value") and isinstance(result_cell._value, str) and result_cell._value.startswith("="):
                formula = result_cell._value
            elif hasattr(result_cell, "formula"):
                formula = result_cell.formula
            else:
                if result_cell.value is not None and isinstance(result_cell.value, str) and result_cell.value.startswith("="):
                    formula = result_cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {result_column}{row_num}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Row {row_num} formula: {formula}")
            
            # Check 1: Contains MATCH function
            if 'MATCH' not in formula_upper:
                logger.error(f"Cell {result_column}{row_num} formula should contain MATCH function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: Contains PERCENTILE function
            if 'PERCENTILE' not in formula_upper:
                logger.error(f"Cell {result_column}{row_num} formula should contain PERCENTILE function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: MATCH references source column cell
            source_pattern = rf'{source_column}{row_num}\b'
            if not re.search(source_pattern, formula_upper):
                logger.error(f"Cell {result_column}{row_num} MATCH should reference {source_column}{row_num}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: PERCENTILE references source column range
            percentile_range_pattern = rf'PERCENTILE\s*\(\s*{source_column}\s*:\s*{source_column}'
            if not re.search(percentile_range_pattern, formula_upper):
                logger.error(f"Cell {result_column}{row_num} PERCENTILE should reference {source_column}:{source_column}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 5: PERCENTILE contains expected percentiles array
            # Pattern: {0,10,90}% or {0, 10, 90}% (with or without spaces)
            percentiles_pattern = r'\{[^}]*0[^}]*,[^}]*10[^}]*,[^}]*90[^}]*\}'
            if not re.search(percentiles_pattern, formula_upper):
                logger.warning(f"Cell {result_column}{row_num} PERCENTILE may not have correct percentiles array")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn - the array format might vary
            
            # Check 6: PERCENTILE percentiles array ends with %
            percent_pattern = r'\{[^}]*\}\s*%'
            if not re.search(percent_pattern, formula_upper):
                logger.warning(f"Cell {result_column}{row_num} PERCENTILE percentiles array should end with %")
                logger.debug(f"  Formula: {formula}")
                # Don't fail, just warn
            
            logger.debug(f"✓ Row {row_num} formula passed all checks")
        
        if rows_checked == 0:
            logger.error("No rows with data found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ MATCH/PERCENTILE filter verification passed")
            logger.info(f"  Rows checked: {rows_checked}")
            logger.info(f"  Result column: {result_column}")
            logger.info(f"  Source column: {source_column}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ MATCH/PERCENTILE filter verification failed")
            logger.error(f"  Rows checked: {rows_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_sumproduct_month_customer_count(result: str, expected: str = None, **options) -> float:
    """
    Verify if SUMPRODUCT formulas exist to count contracts and sum amounts for a specific month and customer.
    
    This function checks:
    1. Whether specified cells contain SUMPRODUCT formulas
    2. Whether formulas use MONTH function to check month
    3. Whether formulas use double negation (--) to convert boolean to number
    4. Whether formulas check customer name match
    
    Expected formula patterns:
    - B28: =SUMPRODUCT(--(MONTH(A2:A24)=6),--(B2:B24=A28)) (count contracts)
    - C28: =SUMPRODUCT(--(MONTH(A2:A24)=6),--(B2:B24=A28),C2:C24) (sum amounts)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formulas: Dict mapping cell coordinates to expected formula info, e.g.:
              {
                  "B28": {"type": "count", "date_range": "A2:A24", "customer_range": "B2:B24", "customer_cell": "A28", "month": 6},
                  "C28": {"type": "sum", "date_range": "A2:A24", "customer_range": "B2:B24", "customer_cell": "A28", "amount_range": "C2:C24", "month": 6}
              }
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formulas_config = options.get('formulas', {})
        
        if not formulas_config:
            logger.error("No formulas specified in options")
            return 0.0
        
        logger.info(f"Verifying SUMPRODUCT month/customer count formulas in file: {result}")
        logger.info(f"Formulas to check: {list(formulas_config.keys())}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each formula
        all_checks_passed = True
        cells_checked = 0
        
        for cell_coord, formula_info in formulas_config.items():
            formula_type = formula_info.get('type', '')  # 'count' or 'sum'
            date_range = formula_info.get('date_range', 'A2:A24')
            customer_range = formula_info.get('customer_range', 'B2:B24')
            customer_cell = formula_info.get('customer_cell', 'A28')
            month = formula_info.get('month', 6)
            amount_range = formula_info.get('amount_range', 'C2:C24')
            
            logger.info(f"Checking cell {cell_coord}: {formula_type} formula")
            
            try:
                cell = ws[cell_coord]
            except Exception as e:
                logger.error(f"Could not access cell {cell_coord}: {e}")
                all_checks_passed = False
                continue
            
            cells_checked += 1
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.error(f"Cell {cell_coord} does not contain a formula")
                all_checks_passed = False
                continue
            
            # Get formula text
            formula = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula = cell._value
            elif hasattr(cell, "formula"):
                formula = cell.formula
            else:
                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula = cell.value
            
            if formula is None:
                logger.error(f"Could not extract formula from cell {cell_coord}")
                all_checks_passed = False
                continue
            
            formula_upper = formula.upper()
            logger.debug(f"Cell {cell_coord} formula: {formula}")
            
            # Check 1: Contains SUMPRODUCT function
            if 'SUMPRODUCT' not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain SUMPRODUCT function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 2: Contains MONTH function
            if 'MONTH' not in formula_upper:
                logger.error(f"Cell {cell_coord} formula should contain MONTH function")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 3: MONTH references date range (support both absolute and relative references)
            # Pattern: MONTH($A$2:$A$24) or MONTH(A2:A24)
            date_col_start = date_range.split(':')[0]  # e.g., "A2" or "$A$2"
            date_col_end = date_range.split(':')[1] if ':' in date_range else date_range  # e.g., "A24" or "$A$24"
            # Extract column letter and row numbers
            date_col_match = re.match(r'[\$]?([A-Z]+)[\$]?(\d+)', date_col_start)
            if date_col_match:
                date_col = date_col_match.group(1)
                date_start_row = date_col_match.group(2)
            else:
                date_col = 'A'
                date_start_row = '2'
            
            date_end_match = re.match(r'[\$]?([A-Z]+)[\$]?(\d+)', date_col_end)
            if date_end_match:
                date_end_row = date_end_match.group(2)
            else:
                date_end_row = '24'
            
            # Pattern: MONTH($A$2:$A$24) or MONTH(A2:A24) - support both absolute and relative
            month_pattern = rf'MONTH\s*\(\s*[\$]?{date_col}[\$]?\d+:\$?{date_col}[\$]?\d+\s*\)'
            if not re.search(month_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} MONTH should reference range like {date_range} (absolute or relative)")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 4: MONTH equals specified month
            month_check_pattern = rf'MONTH\s*\(\s*[\$]?{date_col}[\$]?\d+:\$?{date_col}[\$]?\d+\s*\)\s*=\s*{month}'
            if not re.search(month_check_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} MONTH should equal {month}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 5: Contains double negation (--)
            if '--' not in formula:
                logger.error(f"Cell {cell_coord} formula should use double negation (--) to convert boolean to number")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 6: Customer range equals customer cell (support both absolute and relative references)
            # Pattern: $B$2:$B$24=A28 or B2:B24=A28
            customer_col_start = customer_range.split(':')[0] if ':' in customer_range else customer_range
            customer_col_match = re.match(r'[\$]?([A-Z]+)[\$]?(\d+)', customer_col_start)
            if customer_col_match:
                customer_col = customer_col_match.group(1)
            else:
                customer_col = 'B'
            
            customer_cell_match = re.match(r'[\$]?([A-Z]+)[\$]?(\d+)', customer_cell)
            if customer_cell_match:
                customer_cell_col = customer_cell_match.group(1)
                customer_cell_row = customer_cell_match.group(2)
            else:
                customer_cell_col = 'A'
                customer_cell_row = '28'
            
            # Pattern: $B$2:$B$24=A28 or B2:B24=A28
            customer_pattern = rf'[\$]?{customer_col}[\$]?\d+:\$?{customer_col}[\$]?\d+\s*=\s*{customer_cell_col}{customer_cell_row}'
            if not re.search(customer_pattern, formula_upper):
                logger.error(f"Cell {cell_coord} formula should check {customer_range}={customer_cell}")
                logger.error(f"  Formula: {formula}")
                all_checks_passed = False
                continue
            
            # Check 7: For sum type, should reference amount range (support both absolute and relative)
            if formula_type == 'sum':
                amount_col_start = amount_range.split(':')[0] if ':' in amount_range else amount_range
                amount_col_match = re.match(r'[\$]?([A-Z]+)[\$]?(\d+)', amount_col_start)
                if amount_col_match:
                    amount_col = amount_col_match.group(1)
                else:
                    amount_col = 'C'
                
                # Pattern: $C$2:$C$24 or C2:C24
                amount_pattern = rf'[\$]?{amount_col}[\$]?\d+:\$?{amount_col}[\$]?\d+'
                if not re.search(amount_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} sum formula should reference amount range {amount_range} (absolute or relative)")
                    logger.error(f"  Formula: {formula}")
                    all_checks_passed = False
                    continue
            
            logger.debug(f"✓ Cell {cell_coord} formula passed all checks")
        
        if cells_checked == 0:
            logger.error("No cells found to check")
            return 0.0
        
        if all_checks_passed:
            logger.info("=" * 60)
            logger.info(f"✓ SUMPRODUCT month/customer count verification passed")
            logger.info(f"  Cells checked: {cells_checked}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ SUMPRODUCT month/customer count verification failed")
            logger.error(f"  Cells checked: {cells_checked}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_sum_value_text_conversion(result: str, expected: str = None, **options) -> float:
    """
    Verify if SUM(VALUE(...), ...) formulas exist in specified column to sum text and number values.
    
    This function checks:
    1. Whether specified cells contain SUM formulas
    2. Whether formulas contain VALUE function to convert text to number
    3. Whether formulas reference the correct text column and number column cells
    4. Whether formulas have the correct structure: SUM(VALUE(text_cell), number_cell)
    
    Expected formula pattern:
    - D2: =SUM(VALUE(B2), C2) (sum of text value in B2 converted to number and number value in C2)
    - D3: =SUM(VALUE(B3), C3) (and so on for other rows)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_column: Column to check (e.g., "D")
            - start_row: Starting row number (e.g., 2)
            - text_column: Column containing text values (e.g., "B")
            - number_column: Column containing number values (e.g., "C")
            - expected_functions: List of expected function names (default: ["SUM", "VALUE"])
            - data_column: Column to use for auto-detecting end row (e.g., "B")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_column = options.get('check_column', 'D')
        start_row = options.get('start_row', 2)
        text_column = options.get('text_column', 'B')
        number_column = options.get('number_column', 'C')
        expected_functions = options.get('expected_functions', ['SUM', 'VALUE'])
        data_column = options.get('data_column', 'B')
        
        logger.info(f"Verifying SUM(VALUE) text conversion formulas in file: {result}")
        logger.info(f"Column to check: {check_column}")
        logger.info(f"Start row: {start_row}")
        logger.info(f"Text column: {text_column}")
        logger.info(f"Number column: {number_column}")
        logger.info(f"Expected functions: {expected_functions}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end_row by checking data_column for non-empty cells
        logger.info(f"Auto-detecting end row by checking column {data_column} for data...")
        max_row = ws.max_row
        end_row = start_row  # Start from start_row
        
        # Find the last row with data in the data column
        # Check up to max_row, but stop if we find 3 consecutive empty rows
        empty_count = 0
        for row_num in range(start_row, max_row + 1):
            data_cell = ws[f"{data_column}{row_num}"]
            if data_cell.value is None or (isinstance(data_cell.value, str) and data_cell.value.strip() == ""):
                empty_count += 1
                if empty_count >= 3:  # Stop after 3 consecutive empty rows
                    break
            else:
                empty_count = 0
                end_row = row_num  # Update end_row to the last row with data
        
        logger.info(f"Auto-detected end row: {end_row}")
        
        # Check each row in the specified column
        all_passed = True
        logger.info(f"Checking column {check_column} (rows {start_row} to {end_row})")
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{check_column}{row_num}"
            try:
                cell = ws[cell_coord]
                logger.debug(f"Checking cell {cell_coord}")
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.warning(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                else:
                    # Try to get from value attribute
                    if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains SUM function
                sum_pattern = r'\bSUM\s*\('
                if not re.search(sum_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not contain SUM function")
                    logger.warning(f"  Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 2: Formula contains VALUE function
                value_pattern = r'\bVALUE\s*\('
                if not re.search(value_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not contain VALUE function")
                    logger.warning(f"  Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: Formula structure is SUM(VALUE(...), ...)
                # Check that VALUE is inside SUM
                sum_value_pattern = r'SUM\s*\(\s*VALUE\s*\('
                if not re.search(sum_value_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not have correct SUM(VALUE(...)) structure")
                    logger.warning(f"  Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: VALUE function references the text column cell (e.g., B2, B3, etc.)
                expected_text_cell = f"{text_column}{row_num}"
                text_cell_pattern = rf'{text_column}{row_num}\b'
                if not re.search(text_cell_pattern, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {cell_coord} formula does not reference text column cell {expected_text_cell}")
                    logger.warning(f"  Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 5: Formula references the number column cell (e.g., C2, C3, etc.)
                expected_number_cell = f"{number_column}{row_num}"
                number_cell_pattern = rf'{number_column}{row_num}\b'
                if not re.search(number_cell_pattern, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {cell_coord} formula does not reference number column cell {expected_number_cell}")
                    logger.warning(f"  Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 6: Formula closes parentheses correctly
                open_count = formula_text.count('(')
                close_count = formula_text.count(')')
                if open_count != close_count:
                    logger.warning(f"Cell {cell_coord} formula has mismatched parentheses")
                    logger.warning(f"  Formula: {formula_text}")
                    all_passed = False
                    continue
                
                logger.info(f"✓ Cell {cell_coord} has valid SUM(VALUE) formula: {formula_text}")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        if all_passed:
            logger.info("=" * 60)
            logger.info(f"✓ All cells in column {check_column} contain correct SUM(VALUE) formulas")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ SUM(VALUE) formula verification failed")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0

def verify_sumif_offset_match(result: str, expected: str = None, **options) -> float:
    """
    Verify if SUMIF(OFFSET(MATCH(...))) formulas exist in specified range with correct structure.
    
    This function checks:
    1. Whether cells in specified range contain formulas
    2. Whether formulas contain SUMIF, OFFSET, and MATCH functions
    3. Whether SUMIF references the correct range (e.g., $A:$A)
    4. Whether SUMIF criteria references the correct column (e.g., $Q2)
    5. Whether OFFSET base is correct (e.g., $A$1)
    6. Whether MATCH lookup value references the correct row (e.g., R$1)
    7. Whether MATCH lookup array is correct (e.g., $B$1:$N$1)
    8. Whether formula structure is correct: SUMIF(range, criteria, OFFSET(base, , MATCH(...)))
    
    The function automatically detects the number of data rows by checking for non-empty cells
    in the specified range. It stops checking after finding 3 consecutive empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_range: Range to check (e.g., "R2:Y16")
            - expected_functions: List of expected function names (default: ["SUMIF", "OFFSET", "MATCH"])
            - sumif_range: SUMIF range reference (default: "$A:$A")
            - sumif_criteria_col: Column letter for SUMIF criteria (default: "Q")
            - offset_base: OFFSET base cell (default: "$A$1")
            - match_lookup_value_row: Row number for MATCH lookup value (default: 1)
            - match_lookup_array: MATCH lookup array range (default: "$B$1:$N$1")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_range = options.get('check_range', 'R2:Y16')
        expected_functions = options.get('expected_functions', ['SUMIF', 'OFFSET', 'MATCH'])
        sumif_range = options.get('sumif_range', '$A:$A')
        sumif_criteria_col = options.get('sumif_criteria_col', 'Q')
        offset_base = options.get('offset_base', '$A$1')
        match_lookup_value_row = options.get('match_lookup_value_row', 1)
        match_lookup_array = options.get('match_lookup_array', '$B$1:$N$1')
        
        logger.info(f"Verifying SUMIF(OFFSET(MATCH)) formulas in file: {result}")
        logger.info(f"Range to check: {check_range}")
        logger.info(f"Expected functions: {expected_functions}")
        
        # Parse the range manually
        try:
            # Remove $ signs and split by :
            range_clean = check_range.replace('$', '')
            if ':' in range_clean:
                start_cell, end_cell = range_clean.split(':')
                # Parse start cell
                start_col_letter = ''.join([c for c in start_cell if c.isalpha()])
                start_row = int(''.join([c for c in start_cell if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                # Parse end cell
                end_col_letter = ''.join([c for c in end_cell if c.isalpha()])
                end_row = int(''.join([c for c in end_cell if c.isdigit()]))
                end_col = column_index_from_string(end_col_letter)
            else:
                # Single cell
                start_col_letter = ''.join([c for c in range_clean if c.isalpha()])
                start_row = int(''.join([c for c in range_clean if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                end_col_letter = start_col_letter
                end_row = start_row
                end_col = start_col
        except Exception as e:
            logger.error(f"Failed to parse range {check_range}: {e}")
            return 0.0
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end row by checking for consecutive empty rows
        logger.info(f"Auto-detecting end row in range {check_range}...")
        detected_end_row = start_row
        empty_count = 0
        
        for row_num in range(start_row, end_row + 1):
            has_data = False
            for col_num in range(start_col, end_col + 1):
                col_letter = get_column_letter(col_num)
                cell = ws[f"{col_letter}{row_num}"]
                if cell.value is not None or (cell.data_type == "f"):
                    has_data = True
                    break
            
            if has_data:
                empty_count = 0
                detected_end_row = row_num
            else:
                empty_count += 1
                if empty_count >= 3:
                    break
        
        logger.info(f"Auto-detected end row: {detected_end_row}")
        actual_end_row = min(detected_end_row, end_row)
        
        # Check each cell in the range
        all_passed = True
        checked_count = 0
        passed_count = 0
        
        for row_num in range(start_row, actual_end_row + 1):
            for col_num in range(start_col, end_col + 1):
                col_letter = get_column_letter(col_num)
                cell_coord = f"{col_letter}{row_num}"
                
                try:
                    cell = ws[cell_coord]
                    checked_count += 1
                    
                    # Check if cell contains a formula
                    if cell.data_type != "f":
                        logger.warning(f"Cell {cell_coord} does not contain a formula")
                        all_passed = False
                        continue
                    
                    # Get formula text
                    formula_text = None
                    if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                        formula_text = cell._value
                    elif hasattr(cell, "formula"):
                        formula_text = cell.formula
                    else:
                        if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                            formula_text = cell.value
                    
                    if formula_text is None:
                        logger.warning(f"Could not extract formula from cell {cell_coord}")
                        all_passed = False
                        continue
                    
                    formula_upper = formula_text.upper()
                    logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                    
                    # Check 1: Formula contains all expected functions
                    for func_name in expected_functions:
                        func_pattern = rf'\b{func_name}\s*\('
                        if not re.search(func_pattern, formula_upper):
                            logger.warning(f"Cell {cell_coord} formula does not contain {func_name} function")
                            logger.warning(f"Formula: {formula_text}")
                            all_passed = False
                            break
                    else:
                        # Continue if all functions found
                        pass
                    
                    if not all_passed:
                        continue
                    
                    # Check 2: Formula contains SUMIF function
                    sumif_pattern = r'\bSUMIF\s*\('
                    if not re.search(sumif_pattern, formula_upper):
                        logger.warning(f"Cell {cell_coord} formula does not contain SUMIF function")
                        all_passed = False
                        continue
                    
                    # Check 3: Formula contains OFFSET function
                    offset_pattern = r'\bOFFSET\s*\('
                    if not re.search(offset_pattern, formula_upper):
                        logger.warning(f"Cell {cell_coord} formula does not contain OFFSET function")
                        all_passed = False
                        continue
                    
                    # Check 4: Formula contains MATCH function
                    match_pattern = r'\bMATCH\s*\('
                    if not re.search(match_pattern, formula_upper):
                        logger.warning(f"Cell {cell_coord} formula does not contain MATCH function")
                        all_passed = False
                        continue
                    
                    # Check 5: SUMIF references the correct range (e.g., $A:$A)
                    # Allow for variations in spacing
                    sumif_range_pattern = re.escape(sumif_range).replace('\\$', '\\$?')
                    if not re.search(sumif_range_pattern, formula_text, re.IGNORECASE):
                        logger.warning(f"Cell {cell_coord} formula SUMIF does not reference range {sumif_range}")
                        logger.debug(f"Formula: {formula_text}")
                        # Don't fail, just warn - the range might be correct but formatted differently
                    
                    # Check 6: SUMIF criteria references the correct column (e.g., $Q2, Q2)
                    # The criteria should reference the same row as the current cell
                    criteria_pattern = rf'\${sumif_criteria_col}{row_num}\b|{sumif_criteria_col}{row_num}\b'
                    if not re.search(criteria_pattern, formula_text, re.IGNORECASE):
                        logger.warning(f"Cell {cell_coord} formula SUMIF criteria may not reference {sumif_criteria_col}{row_num}")
                        logger.debug(f"Formula: {formula_text}")
                        # Don't fail, just warn - the criteria might be correct but formatted differently
                    
                    # Check 7: OFFSET base is correct (e.g., $A$1)
                    offset_base_pattern = re.escape(offset_base).replace('\\$', '\\$?')
                    if not re.search(offset_base_pattern, formula_text, re.IGNORECASE):
                        logger.warning(f"Cell {cell_coord} formula OFFSET base may not be {offset_base}")
                        logger.debug(f"Formula: {formula_text}")
                        # Don't fail, just warn
                    
                    # Check 8: MATCH lookup value references the correct row (e.g., R$1, $R$1)
                    # The lookup value should reference the same column as the current cell, row 1
                    match_lookup_pattern = rf'\${col_letter}\${match_lookup_value_row}\b|{col_letter}\${match_lookup_value_row}\b'
                    if not re.search(match_lookup_pattern, formula_text, re.IGNORECASE):
                        logger.warning(f"Cell {cell_coord} formula MATCH lookup value may not reference {col_letter}${match_lookup_value_row}")
                        logger.debug(f"Formula: {formula_text}")
                        # Don't fail, just warn
                    
                    # Check 9: MATCH lookup array is correct (e.g., $B$1:$N$1)
                    match_array_pattern = re.escape(match_lookup_array).replace('\\$', '\\$?')
                    if not re.search(match_array_pattern, formula_text, re.IGNORECASE):
                        logger.warning(f"Cell {cell_coord} formula MATCH lookup array may not be {match_lookup_array}")
                        logger.debug(f"Formula: {formula_text}")
                        # Don't fail, just warn
                    
                    # Check 10: Formula structure is SUMIF(..., ..., OFFSET(..., MATCH(...)))
                    # Check that OFFSET is inside SUMIF
                    sumif_offset_pattern = r'SUMIF\s*\([^,]+,\s*[^,]+,\s*OFFSET\s*\('
                    if not re.search(sumif_offset_pattern, formula_upper):
                        logger.warning(f"Cell {cell_coord} formula does not have correct SUMIF(..., ..., OFFSET(...)) structure")
                        logger.debug(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 11: MATCH is inside OFFSET
                    offset_match_pattern = r'OFFSET\s*\([^,]+,\s*,\s*MATCH\s*\('
                    if not re.search(offset_match_pattern, formula_upper):
                        logger.warning(f"Cell {cell_coord} formula does not have correct OFFSET(..., , MATCH(...)) structure")
                        logger.debug(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 12: Formula closes parentheses correctly
                    open_count = formula_text.count('(')
                    close_count = formula_text.count(')')
                    if open_count != close_count:
                        logger.warning(f"Cell {cell_coord} formula has mismatched parentheses (open: {open_count}, close: {close_count})")
                        all_passed = False
                        continue
                    
                    passed_count += 1
                    logger.debug(f"✓ Cell {cell_coord} has valid SUMIF(OFFSET(MATCH)) formula")
                    
                except Exception as e:
                    logger.error(f"Error checking cell {cell_coord}: {e}")
                    import traceback
                    logger.error(traceback.format_exc())
                    all_passed = False
        
        # Require at least 90% of checked cells to pass
        if checked_count > 0:
            pass_rate = passed_count / checked_count
            logger.info(f"Pass rate: {passed_count}/{checked_count} ({pass_rate*100:.1f}%)")
            
            if pass_rate >= 0.9 and all_passed:
                logger.info("=" * 60)
                logger.info(f"✓ All cells in range {check_range} contain correct SUMIF(OFFSET(MATCH)) formulas")
                logger.info("=" * 60)
                return 1.0
            elif pass_rate >= 0.9:
                logger.warning("=" * 60)
                logger.warning(f"⚠ {pass_rate*100:.1f}% of cells passed, but some checks had warnings")
                logger.warning("=" * 60)
                return 1.0  # Still pass if 90%+ cells are correct
            else:
                logger.error("=" * 60)
                logger.error(f"✗ Only {pass_rate*100:.1f}% of cells passed verification")
                logger.error("=" * 60)
                return 0.0
        else:
            logger.error("=" * 60)
            logger.error("✗ No cells were checked")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_merge_center_cells(result: str, expected: str = None, **options) -> float:
    """
    Verify if specified cell range is merged and horizontally centered.
    
    This function checks:
    1. Whether the specified cell range (e.g., A2:F2) is merged into a single cell
    2. Whether the merged cell has horizontal center alignment
    3. Whether the merge range exactly matches the expected range (not larger, not smaller)
       For example, if checking A2:F2, a merged range of A2:G2 will NOT pass verification.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_range: Cell range to check (e.g., "A2:F2")
            - expected_horizontal: Expected horizontal alignment (default: "center")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        from openpyxl.utils import get_column_letter, column_index_from_string
        from openpyxl.cell.cell import MergedCell
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_range = options.get('check_range', 'A2:F2')
        expected_horizontal = options.get('expected_horizontal', 'center')
        
        logger.info(f"Verifying merged and centered cells in file: {result}")
        logger.info(f"Range to check: {check_range}")
        logger.info(f"Expected horizontal alignment: {expected_horizontal}")
        
        # Parse the range
        try:
            range_clean = check_range.replace('$', '')
            if ':' in range_clean:
                start_cell, end_cell = range_clean.split(':')
                # Parse start cell
                start_col_letter = ''.join([c for c in start_cell if c.isalpha()])
                start_row = int(''.join([c for c in start_cell if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                # Parse end cell
                end_col_letter = ''.join([c for c in end_cell if c.isalpha()])
                end_row = int(''.join([c for c in end_cell if c.isdigit()]))
                end_col = column_index_from_string(end_col_letter)
            else:
                logger.error(f"Invalid range format: {check_range}. Expected format like 'A2:F2'")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse range {check_range}: {e}")
            return 0.0
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=False)
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check if the range is merged
        # Get the top-left cell of the range
        top_left_cell = ws[f"{start_col_letter}{start_row}"]
        
        # Check merged cells
        merged_ranges = list(ws.merged_cells.ranges)
        found_merge = False
        matching_range = None
        
        for merged_range in merged_ranges:
            # Check if the merged range exactly matches the expected range
            merged_start_col = merged_range.min_col
            merged_start_row = merged_range.min_row
            merged_end_col = merged_range.max_col
            merged_end_row = merged_range.max_row
            
            # Check if the merged range exactly matches the expected range (not larger, not smaller)
            if (merged_start_col == start_col and merged_start_row == start_row and
                merged_end_col == end_col and merged_end_row == end_row):
                found_merge = True
                matching_range = merged_range
                logger.info(f"Found exact matching merged range: {merged_range}")
                break
        
        if not found_merge:
            logger.error(f"Range {check_range} is not merged")
            return 0.0
        
        # Check horizontal alignment
        # Get alignment from the top-left cell (the actual cell in merged range)
        cell_alignment = top_left_cell.alignment
        
        if cell_alignment is None:
            logger.error(f"Cell {start_col_letter}{start_row} has no alignment information")
            return 0.0
        
        horizontal_alignment = cell_alignment.horizontal
        
        # Normalize alignment values
        # openpyxl uses constants like 'center', 'centerContinuous', 'left', 'right', etc.
        expected_horizontal_lower = expected_horizontal.lower()
        
        # Check alignment
        if horizontal_alignment is None:
            logger.warning(f"Cell {start_col_letter}{start_row} has no horizontal alignment set (defaults to left)")
            # In Excel/LibreOffice, default alignment is left, so None means left
            if expected_horizontal_lower == 'left':
                pass  # This is acceptable
            else:
                logger.error(f"Expected horizontal alignment '{expected_horizontal}', but got None (default left)")
                return 0.0
        else:
            horizontal_alignment_lower = str(horizontal_alignment).lower()
            
            # Handle different alignment representations
            alignment_map = {
                'center': ['center', 'centre', 'centercontinuous'],
                'left': ['left', 'general'],
                'right': ['right'],
                'justify': ['justify', 'justified'],
                'distributed': ['distributed']
            }
            
            # Check if alignment matches
            alignment_matched = False
            for key, values in alignment_map.items():
                if expected_horizontal_lower == key:
                    if any(horizontal_alignment_lower.startswith(v) for v in values):
                        alignment_matched = True
                        break
            
            if not alignment_matched:
                # Direct string comparison as fallback
                if expected_horizontal_lower not in horizontal_alignment_lower and horizontal_alignment_lower not in expected_horizontal_lower:
                    logger.error(f"Expected horizontal alignment '{expected_horizontal}', but got '{horizontal_alignment}'")
                    return 0.0
                else:
                    alignment_matched = True
        
        logger.info(f"✓ Merged range {check_range} verification passed")
        logger.info(f"  - Merged range: {matching_range}")
        logger.info(f"  - Horizontal alignment: {horizontal_alignment}")
        return 1.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_countif_conditional_formatting(result: str, expected: str = None, **options) -> float:
    """
    Verify if conditional formatting with COUNTIF formula exists in specified range and fills cells with yellow.
    
    This function checks:
    1. Whether the specified range (e.g., F2:O29) has conditional formatting
    2. Whether the conditional formatting formula matches the expected pattern: COUNTIF($A2:$D2,F2)>0
    3. Whether the formatting fills cells with yellow color
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_range: Range to check (e.g., "F2:O29")
            - expected_formula_pattern: Expected formula pattern (default: "COUNTIF($A2:$D2,F2)>0")
            - expected_color: Expected fill color in aRGB format (default: yellow, "FFFFFF00" or "FFFF00")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        from openpyxl.worksheet.cell_range import CellRange
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_range = options.get('check_range', 'F2:O29')
        expected_formula_pattern = options.get('expected_formula_pattern', 'COUNTIF($A2:$D2,F2)>0')
        expected_color = options.get('expected_color', 'yellow')  # Can be "yellow" or aRGB like "FFFFFF00"
        
        logger.info(f"Verifying conditional formatting in file: {result}")
        logger.info(f"Range to check: {check_range}")
        logger.info(f"Expected formula pattern: {expected_formula_pattern}")
        logger.info(f"Expected color: {expected_color}")
        
        # Parse the range
        try:
            range_clean = check_range.replace('$', '')
            if ':' in range_clean:
                start_cell, end_cell = range_clean.split(':')
                # Parse start cell
                start_col_letter = ''.join([c for c in start_cell if c.isalpha()])
                start_row = int(''.join([c for c in start_cell if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                # Parse end cell
                end_col_letter = ''.join([c for c in end_cell if c.isalpha()])
                end_row = int(''.join([c for c in end_cell if c.isdigit()]))
                end_col = column_index_from_string(end_col_letter)
            else:
                logger.error(f"Invalid range format: {check_range}. Expected format like 'F2:O29'")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse range {check_range}: {e}")
            return 0.0
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=False)
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check conditional formatting
        conditional_formattings = ws.conditional_formatting
        
        if not conditional_formattings:
            logger.error("No conditional formatting found in worksheet")
            return 0.0
        
        found_matching_cf = False
        matching_formula = None
        matching_color = None
        matching_range_cells = None
        
        # Check each conditional formatting rule
        for fmt in conditional_formattings:
            # Check if this formatting applies to any cell in our target range
            fmt_applies_to_range = False
            for rge in fmt.cells:
                # Check if this range overlaps with our target range
                cf_start_col = rge.min_col
                cf_start_row = rge.min_row
                cf_end_col = rge.max_col
                cf_end_row = rge.max_row
                
                # Check if ranges overlap
                if not (cf_end_col < start_col or cf_start_col > end_col or 
                        cf_end_row < start_row or cf_start_row > end_row):
                    fmt_applies_to_range = True
                    matching_range_cells = rge
                    break
            
            if not fmt_applies_to_range:
                continue
            
            # Check each rule in this formatting
            for r in fmt.rules:
                # Check formula
                if not r.formula:
                    continue
                
                formula_text = r.formula[0] if isinstance(r.formula, list) else str(r.formula)
                formula_upper = formula_text.upper()
                
                logger.debug(f"Found conditional formatting formula: {formula_text}")
                
                # Check if formula contains COUNTIF
                countif_pattern = r'\bCOUNTIF\s*\('
                if not re.search(countif_pattern, formula_upper):
                    logger.debug(f"Formula does not contain COUNTIF: {formula_text}")
                    continue
                
                # Check if formula matches the expected pattern
                # Expected: COUNTIF($A2:$D2,F2)>0
                # Allow for variations in spacing and case
                expected_pattern_upper = expected_formula_pattern.upper()
                
                # Normalize both formulas for comparison (remove extra spaces, handle case)
                def normalize_formula(fml):
                    # Remove extra spaces around operators and parentheses
                    fml = re.sub(r'\s+', '', fml.upper())
                    return fml
                
                normalized_expected = normalize_formula(expected_formula_pattern)
                normalized_actual = normalize_formula(formula_text)
                
                # Check if the pattern matches (allowing for row variations in the pattern)
                # The pattern should have COUNTIF($A2:$D2,F2)>0 structure
                # We'll check for COUNTIF, the range pattern, and >0
                countif_match = re.search(r'COUNTIF\s*\(\s*\$?A\$?\d+\s*:\s*\$?D\$?\d+\s*,\s*\$?F\$?\d+\s*\)\s*>\s*0', formula_upper)
                
                if not countif_match:
                    logger.debug(f"Formula does not match COUNTIF pattern: {formula_text}")
                    continue
                
                # Check fill color
                fill_color = None
                if r.dxf and r.dxf.fill:
                    try:
                        if r.dxf.fill.bgColor:
                            fill_color = r.dxf.fill.bgColor.rgb
                        elif r.dxf.fill.fgColor:
                            fill_color = r.dxf.fill.fgColor.rgb
                    except:
                        pass
                
                if fill_color is None:
                    logger.warning(f"Conditional formatting rule has no fill color")
                    continue
                
                logger.debug(f"Found fill color: {fill_color}")
                
                # Check if color is yellow
                # Yellow can be represented as FFFF00, FFFFFF00, or similar
                is_yellow = False
                if isinstance(expected_color, str) and expected_color.lower() == 'yellow':
                    # Check if color is yellow (high red and green, low blue)
                    if fill_color:
                        # Convert aRGB to RGB values
                        # aRGB format: AARRGGBB (e.g., FFFFFF00 for yellow)
                        color_str = str(fill_color).upper()
                        if len(color_str) >= 6:
                            # Extract RGB values (last 6 characters, or handle 8-char format)
                            if len(color_str) == 8:
                                r_val = int(color_str[2:4], 16)
                                g_val = int(color_str[4:6], 16)
                                b_val = int(color_str[6:8], 16)
                            elif len(color_str) == 6:
                                r_val = int(color_str[0:2], 16)
                                g_val = int(color_str[2:4], 16)
                                b_val = int(color_str[4:6], 16)
                            else:
                                logger.warning(f"Unexpected color format: {color_str}")
                                continue
                            
                            # Yellow: high red and green (close to 255), low blue (close to 0)
                            # Allow some tolerance
                            if r_val > 200 and g_val > 200 and b_val < 100:
                                is_yellow = True
                                logger.info(f"Color is yellow: RGB({r_val}, {g_val}, {b_val})")
                else:
                    # Direct color comparison
                    if fill_color and str(fill_color).upper() == str(expected_color).upper():
                        is_yellow = True
                
                if not is_yellow:
                    logger.warning(f"Fill color is not yellow: {fill_color}")
                    continue
                
                # All checks passed
                found_matching_cf = True
                matching_formula = formula_text
                matching_color = fill_color
                logger.info(f"✓ Found matching conditional formatting")
                logger.info(f"  - Formula: {formula_text}")
                logger.info(f"  - Color: {fill_color}")
                logger.info(f"  - Range: {matching_range_cells}")
                break
            
            if found_matching_cf:
                break
        
        if not found_matching_cf:
            logger.error("=" * 60)
            logger.error("✗ No matching conditional formatting found")
            logger.error("=" * 60)
            return 0.0
        
        # Strictly verify that the conditional formatting applies to EXACTLY the expected range
        # Must be 100% coverage, no missing cells allowed
        if not matching_range_cells:
            logger.error("=" * 60)
            logger.error("✗ Conditional formatting range not found")
            logger.error("=" * 60)
            return 0.0
        
        # Check if the conditional formatting range exactly matches the target range
        cf_start_col = matching_range_cells.min_col
        cf_start_row = matching_range_cells.min_row
        cf_end_col = matching_range_cells.max_col
        cf_end_row = matching_range_cells.max_row
        
        # The conditional formatting range must exactly match the target range
        # Allow the CF range to be larger (it can include more cells), but it must include ALL target cells
        if cf_start_col > start_col or cf_end_col < end_col or \
           cf_start_row > start_row or cf_end_row < end_row:
            logger.error("=" * 60)
            logger.error("✗ Conditional formatting range does not fully cover target range")
            logger.error(f"  Target range: {check_range} (cols {start_col}-{end_col}, rows {start_row}-{end_row})")
            logger.error(f"  CF range: cols {cf_start_col}-{cf_end_col}, rows {cf_start_row}-{cf_end_row}")
            logger.error("=" * 60)
            return 0.0
        
        # Verify that ALL cells in the target range have the conditional formatting
        # We need to check each cell individually to ensure it's covered
        total_target_cells = (end_row - start_row + 1) * (end_col - start_col + 1)
        cells_with_cf = set()
        
        # Collect all cells covered by the matching conditional formatting
        for fmt in conditional_formattings:
            for rge in fmt.cells:
                # Check if this range overlaps with our target range
                if not (rge.max_col < start_col or rge.min_col > end_col or 
                        rge.max_row < start_row or rge.min_row > end_row):
                    # This range overlaps, check if it has the matching rule
                    for r in fmt.rules:
                        if not r.formula:
                            continue
                        formula_text = r.formula[0] if isinstance(r.formula, list) else str(r.formula)
                        formula_upper = formula_text.upper()
                        
                        # Check if this is the matching rule
                        countif_pattern = r'\bCOUNTIF\s*\('
                        if not re.search(countif_pattern, formula_upper):
                            continue
                        
                        countif_match = re.search(r'COUNTIF\s*\(\s*\$?A\$?\d+\s*:\s*\$?D\$?\d+\s*,\s*\$?F\$?\d+\s*\)\s*>\s*0', formula_upper)
                        if not countif_match:
                            continue
                        
                        # Check color
                        fill_color = None
                        if r.dxf and r.dxf.fill:
                            try:
                                if r.dxf.fill.bgColor:
                                    fill_color = r.dxf.fill.bgColor.rgb
                                elif r.dxf.fill.fgColor:
                                    fill_color = r.dxf.fill.fgColor.rgb
                            except:
                                pass
                        
                        if fill_color is None:
                            continue
                        
                        # Check if color is yellow
                        is_yellow = False
                        if isinstance(expected_color, str) and expected_color.lower() == 'yellow':
                            if fill_color:
                                color_str = str(fill_color).upper()
                                if len(color_str) >= 6:
                                    if len(color_str) == 8:
                                        r_val = int(color_str[2:4], 16)
                                        g_val = int(color_str[4:6], 16)
                                        b_val = int(color_str[6:8], 16)
                                    elif len(color_str) == 6:
                                        r_val = int(color_str[0:2], 16)
                                        g_val = int(color_str[2:4], 16)
                                        b_val = int(color_str[4:6], 16)
                                    else:
                                        continue
                                    
                                    if r_val > 200 and g_val > 200 and b_val < 100:
                                        is_yellow = True
                        else:
                            if fill_color and str(fill_color).upper() == str(expected_color).upper():
                                is_yellow = True
                        
                        if not is_yellow:
                            continue
                        
                        # This is a matching rule, add all cells in the range to the set
                        for row in range(max(start_row, rge.min_row), min(end_row, rge.max_row) + 1):
                            for col in range(max(start_col, rge.min_col), min(end_col, rge.max_col) + 1):
                                cells_with_cf.add((row, col))
                        break
        
        # Check if all target cells are covered
        missing_cells = []
        for row in range(start_row, end_row + 1):
            for col in range(start_col, end_col + 1):
                if (row, col) not in cells_with_cf:
                    col_letter = get_column_letter(col)
                    missing_cells.append(f"{col_letter}{row}")
        
        if missing_cells:
            logger.error("=" * 60)
            logger.error(f"✗ {len(missing_cells)} cells in target range do not have conditional formatting")
            logger.error(f"  Missing cells (first 20): {', '.join(missing_cells[:20])}")
            if len(missing_cells) > 20:
                logger.error(f"  ... and {len(missing_cells) - 20} more cells")
            logger.error(f"  Total target cells: {total_target_cells}")
            logger.error(f"  Cells with CF: {len(cells_with_cf)}")
            logger.error("=" * 60)
            return 0.0
        
        if len(cells_with_cf) < total_target_cells:
            logger.error("=" * 60)
            logger.error(f"✗ Not all target cells have conditional formatting")
            logger.error(f"  Expected: {total_target_cells} cells")
            logger.error(f"  Found: {len(cells_with_cf)} cells")
            logger.error("=" * 60)
            return 0.0
        
        logger.info("=" * 60)
        logger.info(f"✓ Conditional formatting verification passed")
        logger.info(f"  - Formula: {matching_formula}")
        logger.info(f"  - Color: {matching_color}")
        logger.info(f"  - Range: {check_range} (all {total_target_cells} cells verified)")
        logger.info("=" * 60)
        return 1.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_student_grade_sum_average(result: str, expected: str = None, **options) -> float:
    """
    Verify if SUM and AVERAGE formulas exist in specified ranges for calculating student grades.
    
    This function STRICTLY checks ALL cells in the specified ranges - no tolerance, no auto-detection.
    Every single cell in the specified ranges must contain the correct formula.
    
    This function checks:
    1. Whether ALL cells in the SUM range (e.g., H2:H13) contain SUM formulas
    2. Whether ALL cells in the AVERAGE range (e.g., I2:I13) contain AVERAGE formulas
    3. Whether SUM formulas reference the correct source range (e.g., B2:G2, B3:G3, etc.)
    4. Whether AVERAGE formulas reference the correct source range (e.g., B2:G2, B3:G3, etc.)
    5. Whether formulas use relative references correctly (each row references its own data)
    
    IMPORTANT: This function checks ALL cells in the specified ranges, regardless of whether they
    appear to be empty. If any cell in the specified range is missing a formula, verification fails.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - sum_range: Range containing SUM formulas (e.g., "H2:H13") - ALL cells must have formulas
            - average_range: Range containing AVERAGE formulas (e.g., "I2:I13") - ALL cells must have formulas
            - source_range_start: Starting cell of source range (e.g., "B2")
            - source_range_end: Ending cell of source range (e.g., "G2")
            - start_row: Starting row number (default: 2, but will use range from sum_range/average_range)
            - end_row: Ending row number (default: 13, but will use range from sum_range/average_range)
    
    Returns:
        float: 1.0 if ALL cells in specified ranges contain correct formulas, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        sum_range = options.get('sum_range', 'H2:H13')
        average_range = options.get('average_range', 'I2:I13')
        source_range_start = options.get('source_range_start', 'B2')
        source_range_end = options.get('source_range_end', 'G2')
        start_row = options.get('start_row', 2)
        end_row = options.get('end_row', 13)
        
        logger.info(f"Verifying student grade SUM and AVERAGE formulas in file: {result}")
        logger.info(f"SUM range: {sum_range}, AVERAGE range: {average_range}")
        logger.info(f"Source range: {source_range_start}:{source_range_end}")
        
        # Parse SUM range - strictly use the specified range
        try:
            sum_range_clean = sum_range.replace('$', '')
            if ':' in sum_range_clean:
                sum_start_cell, sum_end_cell = sum_range_clean.split(':')
                sum_start_col_letter = ''.join([c for c in sum_start_cell if c.isalpha()])
                sum_start_row = int(''.join([c for c in sum_start_cell if c.isdigit()]))
                sum_start_col = column_index_from_string(sum_start_col_letter)
                sum_end_col_letter = ''.join([c for c in sum_end_cell if c.isalpha()])
                sum_end_row = int(''.join([c for c in sum_end_cell if c.isdigit()]))
                sum_end_col = column_index_from_string(sum_end_col_letter)
            else:
                logger.error(f"Invalid SUM range format: {sum_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse SUM range {sum_range}: {e}")
            return 0.0
        
        # Parse AVERAGE range - strictly use the specified range
        try:
            avg_range_clean = average_range.replace('$', '')
            if ':' in avg_range_clean:
                avg_start_cell, avg_end_cell = avg_range_clean.split(':')
                avg_start_col_letter = ''.join([c for c in avg_start_cell if c.isalpha()])
                avg_start_row = int(''.join([c for c in avg_start_cell if c.isdigit()]))
                avg_start_col = column_index_from_string(avg_start_col_letter)
                avg_end_col_letter = ''.join([c for c in avg_end_cell if c.isalpha()])
                avg_end_row = int(''.join([c for c in avg_end_cell if c.isdigit()]))
                avg_end_col = column_index_from_string(avg_end_col_letter)
            else:
                logger.error(f"Invalid AVERAGE range format: {average_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse AVERAGE range {average_range}: {e}")
            return 0.0
        
        # Parse source range
        try:
            source_start_col_letter = ''.join([c for c in source_range_start if c.isalpha()])
            source_start_row = int(''.join([c for c in source_range_start if c.isdigit()]))
            source_start_col = column_index_from_string(source_start_col_letter)
            source_end_col_letter = ''.join([c for c in source_range_end if c.isalpha()])
            source_end_row = int(''.join([c for c in source_range_end if c.isdigit()]))
            source_end_col = column_index_from_string(source_end_col_letter)
        except Exception as e:
            logger.error(f"Failed to parse source range: {e}")
            return 0.0
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Strictly check ALL cells in the specified ranges - no auto-detection
        logger.info(f"Checking all cells in SUM range {sum_range} (rows {sum_start_row} to {sum_end_row})")
        logger.info(f"Checking all cells in AVERAGE range {average_range} (rows {avg_start_row} to {avg_end_row})")
        
        # Verify that ranges match expected rows
        if sum_start_row != avg_start_row or sum_end_row != avg_end_row:
            logger.warning(f"SUM and AVERAGE ranges have different row ranges, but will check both")
        
        # Check SUM formulas - check ALL rows in the specified range
        all_passed = True
        checked_count = 0
        passed_count = 0
        
        for row_num in range(sum_start_row, sum_end_row + 1):
            sum_cell_coord = f"{sum_start_col_letter}{row_num}"
            
            try:
                sum_cell = ws[sum_cell_coord]
                checked_count += 1
                
                # Check if cell contains a formula
                if sum_cell.data_type != "f":
                    logger.warning(f"Cell {sum_cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(sum_cell, "_value") and isinstance(sum_cell._value, str) and sum_cell._value.startswith("="):
                    formula_text = sum_cell._value
                elif hasattr(sum_cell, "formula"):
                    formula_text = sum_cell.formula
                else:
                    if sum_cell.value is not None and isinstance(sum_cell.value, str) and sum_cell.value.startswith("="):
                        formula_text = sum_cell.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {sum_cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {sum_cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains SUM function
                sum_pattern = r'\bSUM\s*\('
                if not re.search(sum_pattern, formula_upper):
                    logger.warning(f"Cell {sum_cell_coord} formula does not contain SUM function")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 2: Formula references the correct source range for this row
                # Expected: SUM(B{row_num}:G{row_num}) or similar
                expected_source_start = f"{source_start_col_letter}{row_num}"
                expected_source_end = f"{source_end_col_letter}{row_num}"
                expected_range_pattern = rf'{re.escape(expected_source_start)}\s*:\s*{re.escape(expected_source_end)}'
                
                if not re.search(expected_range_pattern, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {sum_cell_coord} formula does not reference correct range {expected_source_start}:{expected_source_end}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: Formula closes parentheses correctly
                open_count = formula_text.count('(')
                close_count = formula_text.count(')')
                if open_count != close_count:
                    logger.warning(f"Cell {sum_cell_coord} formula has mismatched parentheses")
                    all_passed = False
                    continue
                
                passed_count += 1
                logger.debug(f"✓ Cell {sum_cell_coord} has valid SUM formula")
                
            except Exception as e:
                logger.error(f"Error checking SUM cell {sum_cell_coord}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        # Check AVERAGE formulas - check ALL rows in the specified range
        for row_num in range(avg_start_row, avg_end_row + 1):
            avg_cell_coord = f"{avg_start_col_letter}{row_num}"
            
            try:
                avg_cell = ws[avg_cell_coord]
                checked_count += 1
                
                # Check if cell contains a formula
                if avg_cell.data_type != "f":
                    logger.warning(f"Cell {avg_cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(avg_cell, "_value") and isinstance(avg_cell._value, str) and avg_cell._value.startswith("="):
                    formula_text = avg_cell._value
                elif hasattr(avg_cell, "formula"):
                    formula_text = avg_cell.formula
                else:
                    if avg_cell.value is not None and isinstance(avg_cell.value, str) and avg_cell.value.startswith("="):
                        formula_text = avg_cell.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {avg_cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {avg_cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains AVERAGE function
                avg_pattern = r'\bAVERAGE\s*\('
                if not re.search(avg_pattern, formula_upper):
                    logger.warning(f"Cell {avg_cell_coord} formula does not contain AVERAGE function")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 2: Formula references the correct source range for this row
                # Expected: AVERAGE(B{row_num}:G{row_num}) or similar
                expected_source_start = f"{source_start_col_letter}{row_num}"
                expected_source_end = f"{source_end_col_letter}{row_num}"
                expected_range_pattern = rf'{re.escape(expected_source_start)}\s*:\s*{re.escape(expected_source_end)}'
                
                if not re.search(expected_range_pattern, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {avg_cell_coord} formula does not reference correct range {expected_source_start}:{expected_source_end}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: Formula closes parentheses correctly
                open_count = formula_text.count('(')
                close_count = formula_text.count(')')
                if open_count != close_count:
                    logger.warning(f"Cell {avg_cell_coord} formula has mismatched parentheses")
                    all_passed = False
                    continue
                
                passed_count += 1
                logger.debug(f"✓ Cell {avg_cell_coord} has valid AVERAGE formula")
                
            except Exception as e:
                logger.error(f"Error checking AVERAGE cell {avg_cell_coord}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        # Require all specified cells to have correct formulas (no tolerance)
        if checked_count > 0:
            if all_passed and passed_count == checked_count:
                logger.info("=" * 60)
                logger.info(f"✓ All {checked_count} cells contain correct SUM and AVERAGE formulas")
                logger.info("=" * 60)
                return 1.0
            else:
                logger.error("=" * 60)
                logger.error(f"✗ Verification failed: {passed_count}/{checked_count} cells passed")
                logger.error(f"  All specified cells must contain correct formulas")
                logger.error("=" * 60)
                return 0.0
        else:
            logger.error("=" * 60)
            logger.error("✗ No cells were checked")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_student_grade_sum(result: str, expected: str = None, **options) -> float:
    """
    Verify if SUM formulas exist in specified range for calculating student grade totals.
    
    This function STRICTLY checks ALL cells in the specified range - no tolerance, no auto-detection.
    Every single cell in the specified range must contain the correct SUM formula.
    
    This function checks:
    1. Whether ALL cells in the SUM range (e.g., E2:E10) contain SUM formulas
    2. Whether SUM formulas reference the correct source range (e.g., B2:D2, B3:D3, etc.)
    3. Whether formulas use relative references correctly (each row references its own data)
    
    IMPORTANT: This function checks ALL cells in the specified range, regardless of whether they
    appear to be empty. If any cell in the specified range is missing a formula, verification fails.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - sum_range: Range containing SUM formulas (e.g., "E2:E10") - ALL cells must have formulas
            - source_range_start: Starting cell of source range (e.g., "B2")
            - source_range_end: Ending cell of source range (e.g., "D2")
            - start_row: Starting row number (default: 2, but will use range from sum_range)
            - end_row: Ending row number (default: 10, but will use range from sum_range)
    
    Returns:
        float: 1.0 if ALL cells in specified range contain correct SUM formulas, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        sum_range = options.get('sum_range', 'E2:E10')
        source_range_start = options.get('source_range_start', 'B2')
        source_range_end = options.get('source_range_end', 'D2')
        start_row = options.get('start_row', 2)
        end_row = options.get('end_row', 10)
        
        logger.info(f"Verifying student grade SUM formulas in file: {result}")
        logger.info(f"SUM range: {sum_range}")
        logger.info(f"Source range: {source_range_start}:{source_range_end}")
        
        # Parse SUM range - strictly use the specified range
        try:
            sum_range_clean = sum_range.replace('$', '')
            if ':' in sum_range_clean:
                sum_start_cell, sum_end_cell = sum_range_clean.split(':')
                sum_start_col_letter = ''.join([c for c in sum_start_cell if c.isalpha()])
                sum_start_row = int(''.join([c for c in sum_start_cell if c.isdigit()]))
                sum_start_col = column_index_from_string(sum_start_col_letter)
                sum_end_col_letter = ''.join([c for c in sum_end_cell if c.isalpha()])
                sum_end_row = int(''.join([c for c in sum_end_cell if c.isdigit()]))
                sum_end_col = column_index_from_string(sum_end_col_letter)
            else:
                logger.error(f"Invalid SUM range format: {sum_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse SUM range {sum_range}: {e}")
            return 0.0
        
        # Parse source range
        try:
            source_start_col_letter = ''.join([c for c in source_range_start if c.isalpha()])
            source_start_row = int(''.join([c for c in source_range_start if c.isdigit()]))
            source_start_col = column_index_from_string(source_start_col_letter)
            source_end_col_letter = ''.join([c for c in source_range_end if c.isalpha()])
            source_end_row = int(''.join([c for c in source_range_end if c.isdigit()]))
            source_end_col = column_index_from_string(source_end_col_letter)
        except Exception as e:
            logger.error(f"Failed to parse source range: {e}")
            return 0.0
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Strictly check ALL cells in the specified range - no auto-detection
        logger.info(f"Checking all cells in SUM range {sum_range} (rows {sum_start_row} to {sum_end_row})")
        
        # Check SUM formulas - check ALL rows in the specified range
        all_passed = True
        checked_count = 0
        passed_count = 0
        
        for row_num in range(sum_start_row, sum_end_row + 1):
            sum_cell_coord = f"{sum_start_col_letter}{row_num}"
            
            try:
                sum_cell = ws[sum_cell_coord]
                checked_count += 1
                
                # Check if cell contains a formula
                if sum_cell.data_type != "f":
                    logger.warning(f"Cell {sum_cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(sum_cell, "_value") and isinstance(sum_cell._value, str) and sum_cell._value.startswith("="):
                    formula_text = sum_cell._value
                elif hasattr(sum_cell, "formula"):
                    formula_text = sum_cell.formula
                else:
                    if sum_cell.value is not None and isinstance(sum_cell.value, str) and sum_cell.value.startswith("="):
                        formula_text = sum_cell.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {sum_cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {sum_cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains SUM function
                sum_pattern = r'\bSUM\s*\('
                if not re.search(sum_pattern, formula_upper):
                    logger.warning(f"Cell {sum_cell_coord} formula does not contain SUM function")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 2: Formula references the correct source range for this row
                # Expected: SUM(B{row_num}:D{row_num}) or similar
                expected_source_start = f"{source_start_col_letter}{row_num}"
                expected_source_end = f"{source_end_col_letter}{row_num}"
                expected_range_pattern = rf'{re.escape(expected_source_start)}\s*:\s*{re.escape(expected_source_end)}'
                
                if not re.search(expected_range_pattern, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {sum_cell_coord} formula does not reference correct range {expected_source_start}:{expected_source_end}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: Formula closes parentheses correctly
                open_count = formula_text.count('(')
                close_count = formula_text.count(')')
                if open_count != close_count:
                    logger.warning(f"Cell {sum_cell_coord} formula has mismatched parentheses")
                    all_passed = False
                    continue
                
                passed_count += 1
                logger.debug(f"✓ Cell {sum_cell_coord} has valid SUM formula")
                
            except Exception as e:
                logger.error(f"Error checking SUM cell {sum_cell_coord}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        # Require all specified cells to have correct formulas (no tolerance)
        if checked_count > 0:
            if all_passed and passed_count == checked_count:
                logger.info("=" * 60)
                logger.info(f"✓ All {checked_count} cells contain correct SUM formulas")
                logger.info("=" * 60)
                return 1.0
            else:
                logger.error("=" * 60)
                logger.error(f"✗ Verification failed: {passed_count}/{checked_count} cells passed")
                logger.error(f"  All specified cells must contain correct formulas")
                logger.error("=" * 60)
                return 0.0
        else:
            logger.error("=" * 60)
            logger.error("✗ No cells were checked")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_regexp_replace(result: str, expected: str = None, **options) -> float:
    """
    Verify if REGEX formulas exist in specified range with correct pattern and replacement.
    
    This function STRICTLY checks ALL cells in the specified range - no tolerance, no auto-detection.
    Every single cell in the specified range must contain the correct REGEX formula.
    
    This function checks:
    1. Whether ALL cells in the specified range (e.g., D1:D17) contain REGEX formulas
    2. Whether formulas reference the corresponding source column cell (D1->C1, D2->C2, etc.)
    3. Whether formulas contain the correct REGEX function
    4. Whether formulas contain the correct pattern (e.g., "(\\d+)(\\D+)")
    5. Whether formulas contain the correct replace pattern (e.g., "$2$1")
    
    IMPORTANT: This function checks ALL cells in the specified range, regardless of whether they
    appear to be empty. If any cell in the specified range is missing a formula, verification fails.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_range: Range containing REGEX formulas (e.g., "D1:D17") - ALL cells must have formulas
            - source_column: Source column letter (e.g., "C")
            - expected_function: Expected function name (default: "REGEX")
            - expected_pattern: Expected regex pattern (e.g., "(\\d+)(\\D+)")
            - expected_replace_pattern: Expected replace pattern (e.g., "$2$1")
    
    Returns:
        float: 1.0 if ALL cells in specified range contain correct REGEX formulas, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_range = options.get('check_range', 'D1:D17')
        source_column = options.get('source_column', 'C')
        expected_function = options.get('expected_function', 'REGEX')
        expected_pattern = options.get('expected_pattern', '(\\d+)(\\D+)')
        expected_replace_pattern = options.get('expected_replace_pattern', '$2$1')
        
        logger.info(f"Verifying REGEX formulas in file: {result}")
        logger.info(f"Check range: {check_range}")
        logger.info(f"Source column: {source_column}")
        logger.info(f"Expected function: {expected_function}")
        logger.info(f"Expected pattern: {expected_pattern}")
        logger.info(f"Expected replace pattern: {expected_replace_pattern}")
        
        # Parse check range - strictly use the specified range
        try:
            check_range_clean = check_range.replace('$', '')
            if ':' in check_range_clean:
                check_start_cell, check_end_cell = check_range_clean.split(':')
                check_start_col_letter = ''.join([c for c in check_start_cell if c.isalpha()])
                check_start_row = int(''.join([c for c in check_start_cell if c.isdigit()]))
                check_start_col = column_index_from_string(check_start_col_letter)
                check_end_col_letter = ''.join([c for c in check_end_cell if c.isalpha()])
                check_end_row = int(''.join([c for c in check_end_cell if c.isdigit()]))
                check_end_col = column_index_from_string(check_end_col_letter)
            else:
                logger.error(f"Invalid check range format: {check_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse check range {check_range}: {e}")
            return 0.0
        
        # Verify that range is a single column
        if check_start_col != check_end_col:
            logger.error(f"Check range must be a single column, got: {check_range}")
            return 0.0
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Strictly check ALL cells in the specified range - no auto-detection
        logger.info(f"Checking all cells in range {check_range} (rows {check_start_row} to {check_end_row})")
        
        # Check REGEX formulas - check ALL rows in the specified range
        all_passed = True
        checked_count = 0
        passed_count = 0
        
        for row_num in range(check_start_row, check_end_row + 1):
            cell_coord = f"{check_start_col_letter}{row_num}"
            expected_source_cell = f"{source_column}{row_num}"
            
            try:
                cell = ws[cell_coord]
                checked_count += 1
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.warning(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                else:
                    if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains REGEXP function
                regexp_pattern = rf'\b{re.escape(expected_function)}\s*\('
                if not re.search(regexp_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not contain {expected_function} function")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 2: Formula references the corresponding source column cell (C1, C2, etc.)
                source_cell_pattern = rf'\b{re.escape(expected_source_cell)}\b'
                if not re.search(source_cell_pattern, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {cell_coord} formula does not reference {expected_source_cell}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: Formula contains the expected pattern
                # The pattern might be escaped differently in the formula, so we check for key parts
                # Pattern: (\\d+)(\\D+)
                # We check for: (\\d+), (\\D+), and the overall structure
                pattern_escaped = re.escape(expected_pattern)
                # Allow for different escaping (single backslash vs double backslash)
                pattern_variations = [
                    expected_pattern,  # Original
                    expected_pattern.replace('\\', '\\\\'),  # Double escaped
                    expected_pattern.replace('\\\\', '\\'),  # Single escaped
                ]
                
                pattern_found = False
                for pattern_var in pattern_variations:
                    if pattern_var in formula_text:
                        pattern_found = True
                        break
                
                # Also check for key components: (\\d+) and (\\D+)
                if not pattern_found:
                    # Check for digit pattern and non-digit pattern
                    has_digit_pattern = re.search(r'\(\\?d\+\)|\(\\?\\?d\+\)', formula_text)
                    has_nondigit_pattern = re.search(r'\(\\?D\+\)|\(\\?\\?D\+\)', formula_text)
                    if has_digit_pattern and has_nondigit_pattern:
                        pattern_found = True
                
                if not pattern_found:
                    logger.warning(f"Cell {cell_coord} formula does not contain expected pattern '{expected_pattern}'")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: Formula contains the expected replace pattern
                # Replace pattern: $2$1 (REGEX uses $ for backreferences)
                # We check for variations: $2$1, "$2$1", etc.
                replace_pattern_variations = [
                    expected_replace_pattern,  # Original: $2$1
                    f'"{expected_replace_pattern}"',  # Quoted: "$2$1"
                    f"'{expected_replace_pattern}'",  # Single quoted: '$2$1'
                ]
                
                replace_pattern_found = False
                for replace_var in replace_pattern_variations:
                    if replace_var in formula_text:
                        replace_pattern_found = True
                        break
                
                # Also check for backreference patterns with $ symbol
                if not replace_pattern_found:
                    # Check for backreference pattern: $2 followed by $1
                    backref_pattern = re.search(r'\$2\$1', formula_text)
                    if backref_pattern:
                        replace_pattern_found = True
                
                if not replace_pattern_found:
                    logger.warning(f"Cell {cell_coord} formula does not contain expected replace pattern '{expected_replace_pattern}'")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 5: Formula closes parentheses correctly
                open_count = formula_text.count('(')
                close_count = formula_text.count(')')
                if open_count != close_count:
                    logger.warning(f"Cell {cell_coord} formula has mismatched parentheses")
                    all_passed = False
                    continue
                
                passed_count += 1
                logger.debug(f"✓ Cell {cell_coord} has valid REGEX formula")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
                # Require all specified cells to have correct formulas (no tolerance)
        if checked_count > 0:
            if all_passed and passed_count == checked_count:
                logger.info("=" * 60)
                logger.info(f"✓ All {checked_count} cells contain correct REGEX formulas")
                logger.info("=" * 60)
                return 1.0
            else:
                logger.error("=" * 60)
                logger.error(f"✗ Verification failed: {passed_count}/{checked_count} cells passed")
                logger.error(f"  All specified cells must contain correct REGEX formulas")
                logger.error("=" * 60)
                return 0.0
        else:
            logger.error("=" * 60)
            logger.error("✗ No cells were checked")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_regex_extract_brackets(result: str, expected: str = None, **options) -> float:
    """
    Verify if REGEX formulas exist in specified range to extract text from 《》 brackets.
    
    This function STRICTLY checks ALL cells in the specified range - no tolerance, no auto-detection.
    Every single cell in the specified range must contain the correct REGEX formula.
    
    This function checks:
    1. Whether ALL cells in the specified range (e.g., B1:B3) contain REGEX formulas
    2. Whether formulas reference the corresponding source column cell (B1->A1, B2->A2, etc.)
    3. Whether formulas contain the correct REGEX function
    4. Whether formulas contain the correct pattern (e.g., "[^《》]{5,}")
    
    IMPORTANT: This function checks ALL cells in the specified range, regardless of whether they
    appear to be empty. If any cell in the specified range is missing a formula, verification fails.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_range: Range containing REGEX formulas (e.g., "B1:B3") - ALL cells must have formulas
            - source_column: Source column letter (e.g., "A")
            - expected_function: Expected function name (default: "REGEX")
            - expected_pattern: Expected regex pattern (e.g., "[^《》]{5,}")
    
    Returns:
        float: 1.0 if ALL cells in specified range contain correct REGEX formulas, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_range = options.get('check_range', 'B1:B3')
        source_column = options.get('source_column', 'A')
        expected_function = options.get('expected_function', 'REGEX')
        expected_pattern = options.get('expected_pattern', '[^《》]{5,}')
        
        logger.info(f"Verifying REGEX formulas in file: {result}")
        logger.info(f"Check range: {check_range}")
        logger.info(f"Source column: {source_column}")
        logger.info(f"Expected function: {expected_function}")
        logger.info(f"Expected pattern: {expected_pattern}")
        
        # Parse check range - strictly use the specified range
        try:
            check_range_clean = check_range.replace('$', '')
            if ':' in check_range_clean:
                check_start_cell, check_end_cell = check_range_clean.split(':')
                check_start_col_letter = ''.join([c for c in check_start_cell if c.isalpha()])
                check_start_row = int(''.join([c for c in check_start_cell if c.isdigit()]))
                check_start_col = column_index_from_string(check_start_col_letter)
                check_end_col_letter = ''.join([c for c in check_end_cell if c.isalpha()])
                check_end_row = int(''.join([c for c in check_end_cell if c.isdigit()]))
                check_end_col = column_index_from_string(check_end_col_letter)
            else:
                logger.error(f"Invalid check range format: {check_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse check range {check_range}: {e}")
            return 0.0
        
        # Verify that range is a single column
        if check_start_col != check_end_col:
            logger.error(f"Check range must be a single column, got: {check_range}")
            return 0.0
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Strictly check ALL cells in the specified range - no auto-detection
        logger.info(f"Checking all cells in range {check_range} (rows {check_start_row} to {check_end_row})")
        
        # Check REGEX formulas - check ALL rows in the specified range
        all_passed = True
        checked_count = 0
        passed_count = 0
        
        for row_num in range(check_start_row, check_end_row + 1):
            cell_coord = f"{check_start_col_letter}{row_num}"
            expected_source_cell = f"{source_column}{row_num}"
            
            try:
                cell = ws[cell_coord]
                checked_count += 1
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.warning(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                else:
                    if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains REGEX function
                regexp_pattern = rf'\b{re.escape(expected_function)}\s*\('
                if not re.search(regexp_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not contain {expected_function} function")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 2: Formula references the corresponding source column cell (A1, A2, etc.)
                source_cell_pattern = rf'\b{re.escape(expected_source_cell)}\b'
                if not re.search(source_cell_pattern, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {cell_coord} formula does not reference {expected_source_cell}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: Formula contains the expected pattern
                # The pattern might be escaped differently in the formula, so we check for key parts
                # Pattern: [^《》]{5,}
                # We check for variations with different escaping
                pattern_variations = [
                    expected_pattern,  # Original: [^《》]{5,}
                    expected_pattern.replace('\\', '\\\\'),  # Double escaped
                    expected_pattern.replace('\\\\', '\\'),  # Single escaped
                    '[^《》]{5,}',  # Direct pattern
                    '\\[\\^《》\\]\\{5,\\}',  # Fully escaped
                ]
                
                pattern_found = False
                for pattern_var in pattern_variations:
                    if pattern_var in formula_text:
                        pattern_found = True
                        break
                
                # Also check for key components: [^《》] and {5,}
                if not pattern_found:
                    # Check for bracket pattern [^《》] and quantifier {5,}
                    has_bracket_pattern = re.search(r'\[\^《》\]|\[\\\^《》\\\]', formula_text)
                    has_quantifier = re.search(r'\{5,\}|\{5,', formula_text)
                    if has_bracket_pattern and has_quantifier:
                        pattern_found = True
                
                if not pattern_found:
                    logger.warning(f"Cell {cell_coord} formula does not contain expected pattern '{expected_pattern}'")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: Formula closes parentheses correctly
                open_count = formula_text.count('(')
                close_count = formula_text.count(')')
                if open_count != close_count:
                    logger.warning(f"Cell {cell_coord} formula has mismatched parentheses")
                    all_passed = False
                    continue
                
                passed_count += 1
                logger.debug(f"✓ Cell {cell_coord} has valid REGEX formula")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        # Require all specified cells to have correct formulas (no tolerance)
        if checked_count > 0:
            if all_passed and passed_count == checked_count:
                logger.info("=" * 60)
                logger.info(f"✓ All {checked_count} cells contain correct REGEX formulas")
                logger.info("=" * 60)
                return 1.0
            else:
                logger.error("=" * 60)
                logger.error(f"✗ Verification failed: {passed_count}/{checked_count} cells passed")
                logger.error(f"  All specified cells must contain correct REGEX formulas")
                logger.error("=" * 60)
                return 0.0
        else:
            logger.error("=" * 60)
            logger.error("✗ No cells were checked")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_contract_expiry_reminder(result: str, expected: str = None, **options) -> float:
    """
    Verify if nested IF formulas with TODAY function exist in specified range for contract expiry reminders.
    
    This function checks:
    1. Whether cells in specified range contain formulas
    2. Whether formulas contain IF and TODAY functions
    3. Whether formulas have nested IF structure
    4. Whether formulas contain date comparison conditions (>=30, <=0)
    5. Whether formulas contain expected text patterns (还有, 天到期, 已过期, 天后到期)
    6. Whether formulas reference the correct source column with relative references
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_range: Range to check (e.g., "C1:C3")
            - source_column: Source column letter for date reference (default: "B")
            - expected_functions: List of expected function names (default: ["IF", "TODAY"])
            - expected_conditions: List of expected conditions (default: [">=30", "<=0"])
            - expected_text_patterns: List of expected text patterns (default: ["还有", "天到期", "已过期", "天后到期"])
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_range = options.get('check_range', 'C1:C3')
        source_column = options.get('source_column', 'B')
        expected_functions = options.get('expected_functions', ['IF', 'TODAY'])
        expected_conditions = options.get('expected_conditions', ['>=30', '<=0'])
        expected_text_patterns = options.get('expected_text_patterns', ['还有', '天到期', '已过期', '天后到期'])
        
        logger.info(f"Verifying contract expiry reminder formulas in file: {result}")
        logger.info(f"Range to check: {check_range}")
        logger.info(f"Expected functions: {expected_functions}")
        
        # Parse the range
        try:
            range_clean = check_range.replace('$', '')
            if ':' in range_clean:
                start_cell, end_cell = range_clean.split(':')
                start_col_letter = ''.join([c for c in start_cell if c.isalpha()])
                start_row = int(''.join([c for c in start_cell if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                end_col_letter = ''.join([c for c in end_cell if c.isalpha()])
                end_row = int(''.join([c for c in end_cell if c.isdigit()]))
                end_col = column_index_from_string(end_col_letter)
            else:
                start_col_letter = ''.join([c for c in range_clean if c.isalpha()])
                start_row = int(''.join([c for c in range_clean if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                end_col_letter = start_col_letter
                end_row = start_row
                end_col = start_col
        except Exception as e:
            logger.error(f"Failed to parse range {check_range}: {e}")
            return 0.0
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check each cell in the range
        all_passed = True
        checked_count = 0
        passed_count = 0
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{start_col_letter}{row_num}"
            expected_source_cell = f"{source_column}{row_num}"
            
            try:
                cell = ws[cell_coord]
                checked_count += 1
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.warning(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                else:
                    if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains IF function
                if_pattern = r'\bIF\s*\('
                if_count = len(re.findall(if_pattern, formula_upper))
                if if_count < 2:
                    logger.warning(f"Cell {cell_coord} formula does not contain nested IF functions (found {if_count})")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 2: Formula contains TODAY function
                today_pattern = r'\bTODAY\s*\('
                if not re.search(today_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not contain TODAY function")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: Formula references the correct source column cell (B1, B2, B3, etc.)
                # Allow for variations: B1, $B1, B$1, $B$1
                escaped_source_cell = re.escape(expected_source_cell)
                escaped_source_col = re.escape(source_column)
                source_cell_patterns = [
                    rf'\b{escaped_source_cell}\b',  # B1
                    rf'\${escaped_source_col}{row_num}\b',  # $B1
                    rf'\b{escaped_source_col}\${row_num}\b',  # B$1
                    rf'\${escaped_source_col}\${row_num}\b',  # $B$1
                ]
                
                source_cell_found = False
                for pattern in source_cell_patterns:
                    if re.search(pattern, formula_text, re.IGNORECASE):
                        source_cell_found = True
                        break
                
                if not source_cell_found:
                    logger.warning(f"Cell {cell_coord} formula does not reference source cell {expected_source_cell}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: Formula contains date comparison conditions
                # Check for >=30 pattern (allowing for spacing variations)
                escaped_source_col = re.escape(source_column)
                condition1_pattern = rf'{escaped_source_col}\d+\s*-\s*TODAY\s*\(\s*\)\s*>=\s*30'
                condition1_found = re.search(condition1_pattern, formula_upper)
                
                # Check for <=0 pattern
                condition2_pattern = rf'{escaped_source_col}\d+\s*-\s*TODAY\s*\(\s*\)\s*<=\s*0'
                condition2_found = re.search(condition2_pattern, formula_upper)
                
                if not condition1_found or not condition2_found:
                    logger.warning(f"Cell {cell_coord} formula does not contain expected date comparison conditions")
                    logger.warning(f"Formula: {formula_text}")
                    logger.warning(f"Expected: >=30 and <=0 conditions")
                    all_passed = False
                    continue
                
                # Check 5: Formula contains expected text patterns
                # Check for Chinese text patterns in the formula
                text_patterns_found = 0
                for pattern in expected_text_patterns:
                    if pattern in formula_text:
                        text_patterns_found += 1
                
                # Require at least 3 out of 4 text patterns to be present (for flexibility)
                if text_patterns_found < 3:
                    logger.warning(f"Cell {cell_coord} formula does not contain enough expected text patterns (found {text_patterns_found}/4)")
                    logger.warning(f"Formula: {formula_text}")
                    logger.warning(f"Expected patterns: {expected_text_patterns}")
                    all_passed = False
                    continue
                
                # Check 6: Formula contains string concatenation operator (&)
                if '&' not in formula_text:
                    logger.warning(f"Cell {cell_coord} formula does not contain string concatenation operator (&)")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 7: Formula has balanced parentheses
                open_count = formula_text.count('(')
                close_count = formula_text.count(')')
                if open_count != close_count:
                    logger.warning(f"Cell {cell_coord} formula has mismatched parentheses (open: {open_count}, close: {close_count})")
                    all_passed = False
                    continue
                
                passed_count += 1
                logger.debug(f"✓ Cell {cell_coord} has valid contract expiry reminder formula")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        # Require all specified cells to have correct formulas (no tolerance)
        if checked_count > 0:
            if all_passed and passed_count == checked_count:
                logger.info("=" * 60)
                logger.info(f"✓ All {checked_count} cells contain correct contract expiry reminder formulas")
                logger.info("=" * 60)
                return 1.0
            else:
                logger.error("=" * 60)
                logger.error(f"✗ Verification failed: {passed_count}/{checked_count} cells passed")
                logger.error(f"  All specified cells must contain correct formulas")
                logger.error("=" * 60)
                return 0.0
        else:
            logger.error("=" * 60)
            logger.error("✗ No cells were checked")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_if_sumif_pass_fail(result: str, expected: str = None, **options) -> float:
    """
    Verify if IF(SUMIF(...)) formulas exist in specified range for checking if scores meet threshold.
    
    This function STRICTLY checks ALL cells in the specified range - no tolerance, no auto-detection.
    Every single cell in the specified range must contain the correct formula.
    
    This function checks:
    1. Whether ALL cells in the specified range (e.g., F3:F5) contain formulas
    2. Whether formulas contain IF and SUMIF functions
    3. Whether SUMIF references the correct range (e.g., A:A)
    4. Whether SUMIF criteria references the correct column with relative row (e.g., E3, E4, E5)
    5. Whether SUMIF sum_range references the correct range (e.g., C:C)
    6. Whether IF condition checks threshold (>=280)
    7. Whether IF true value is "录取"
    8. Whether IF false value contains string concatenation with "相差" and "分"
    9. Whether formula structure is correct: IF(SUMIF(range, criteria, sum_range)>=threshold, "录取", "相差"&...&"分")
    
    IMPORTANT: This function checks ALL cells in the specified ranges, regardless of whether they
    appear to be empty. If any cell in the specified range is missing a formula, verification fails.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_range: Range to check (e.g., "F3:F5") - ALL cells must have formulas
            - expected_functions: List of expected function names (default: ["IF", "SUMIF"])
            - sumif_range: SUMIF range reference (default: "A:A")
            - sumif_criteria_col: Column letter for SUMIF criteria (default: "E")
            - sumif_sum_range: SUMIF sum_range reference (default: "C:C")
            - threshold: Threshold value for comparison (default: 280)
            - pass_text: Text to display when condition is met (default: "录取")
            - fail_text_pattern: Pattern for fail text (default: "相差.*分")
    
    Returns:
        float: 1.0 if ALL cells in specified range contain correct formulas, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_range = options.get('check_range', 'F3:F5')
        expected_functions = options.get('expected_functions', ['IF', 'SUMIF'])
        sumif_range = options.get('sumif_range', 'A:A')
        sumif_criteria_col = options.get('sumif_criteria_col', 'E')
        sumif_sum_range = options.get('sumif_sum_range', 'C:C')
        threshold = options.get('threshold', 280)
        pass_text = options.get('pass_text', '录取')
        fail_text_pattern = options.get('fail_text_pattern', '相差.*分')
        
        logger.info(f"Verifying IF(SUMIF) pass/fail formulas in file: {result}")
        logger.info(f"Range to check: {check_range}")
        logger.info(f"Expected functions: {expected_functions}")
        logger.info(f"Threshold: {threshold}")
        
        # Parse the range - strictly use the specified range
        try:
            range_clean = check_range.replace('$', '')
            if ':' in range_clean:
                start_cell, end_cell = range_clean.split(':')
                start_col_letter = ''.join([c for c in start_cell if c.isalpha()])
                start_row = int(''.join([c for c in start_cell if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                end_col_letter = ''.join([c for c in end_cell if c.isalpha()])
                end_row = int(''.join([c for c in end_cell if c.isdigit()]))
                end_col = column_index_from_string(end_col_letter)
            else:
                logger.error(f"Invalid range format: {check_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse range {check_range}: {e}")
            return 0.0
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Strictly check ALL cells in the specified range - no auto-detection
        logger.info(f"Checking all cells in range {check_range} (rows {start_row} to {end_row})")
        
        all_passed = True
        checked_count = 0
        passed_count = 0
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{start_col_letter}{row_num}"
            expected_criteria_cell = f"{sumif_criteria_col}{row_num}"
            
            try:
                cell = ws[cell_coord]
                checked_count += 1
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.warning(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                else:
                    if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains IF function
                if_pattern = r'\bIF\s*\('
                if not re.search(if_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not contain IF function")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 2: Formula contains SUMIF function
                sumif_pattern = r'\bSUMIF\s*\('
                if not re.search(sumif_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not contain SUMIF function")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: SUMIF references the correct range (A:A)
                # Allow variations: A:A, $A:$A
                sumif_range_patterns = [
                    rf'\b{re.escape(sumif_range)}\b',
                    rf'\${re.escape(sumif_range.replace(":", ":$"))}\b',
                ]
                sumif_range_found = False
                for pattern in sumif_range_patterns:
                    if re.search(pattern, formula_text, re.IGNORECASE):
                        sumif_range_found = True
                        break
                if not sumif_range_found:
                    logger.warning(f"Cell {cell_coord} formula does not reference SUMIF range {sumif_range}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: SUMIF criteria references the correct column with relative row (E3, E4, E5, etc.)
                # Allow variations: E3, $E3, E$3, $E$3
                escaped_criteria_cell = re.escape(expected_criteria_cell)
                escaped_criteria_col = re.escape(sumif_criteria_col)
                criteria_cell_patterns = [
                    rf'\b{escaped_criteria_cell}\b',  # E3
                    rf'\${escaped_criteria_col}{row_num}\b',  # $E3
                    rf'\b{escaped_criteria_col}\${row_num}\b',  # E$3
                    rf'\${escaped_criteria_col}\${row_num}\b',  # $E$3
                ]
                
                criteria_cell_found = False
                for pattern in criteria_cell_patterns:
                    if re.search(pattern, formula_text, re.IGNORECASE):
                        criteria_cell_found = True
                        break
                
                if not criteria_cell_found:
                    logger.warning(f"Cell {cell_coord} formula does not reference criteria cell {expected_criteria_cell}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 5: SUMIF sum_range references the correct range (C:C)
                # Allow variations: C:C, $C:$C
                sumif_sum_range_patterns = [
                    rf'\b{re.escape(sumif_sum_range)}\b',
                    rf'\${re.escape(sumif_sum_range.replace(":", ":$"))}\b',
                ]
                sumif_sum_range_found = False
                for pattern in sumif_sum_range_patterns:
                    if re.search(pattern, formula_text, re.IGNORECASE):
                        sumif_sum_range_found = True
                        break
                if not sumif_sum_range_found:
                    logger.warning(f"Cell {cell_coord} formula does not reference SUMIF sum_range {sumif_sum_range}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 6: IF condition checks threshold (>=280)
                threshold_pattern = rf'>=\s*{re.escape(str(threshold))}'
                if not re.search(threshold_pattern, formula_text):
                    logger.warning(f"Cell {cell_coord} formula does not contain threshold check >= {threshold}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 7: IF true value contains "录取"
                if pass_text not in formula_text:
                    logger.warning(f"Cell {cell_coord} formula does not contain pass text '{pass_text}'")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 8: IF false value contains string concatenation pattern
                if not re.search(fail_text_pattern, formula_text):
                    logger.warning(f"Cell {cell_coord} formula does not contain fail text pattern '{fail_text_pattern}'")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 9: Formula contains string concatenation operator (&)
                if '&' not in formula_text:
                    logger.warning(f"Cell {cell_coord} formula does not contain string concatenation operator (&)")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 10: Formula closes parentheses correctly
                open_count = formula_text.count('(')
                close_count = formula_text.count(')')
                if open_count != close_count:
                    logger.warning(f"Cell {cell_coord} formula has mismatched parentheses")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                passed_count += 1
                logger.debug(f"✓ Cell {cell_coord} has valid IF(SUMIF) formula")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        # Require ALL cells to pass (strict check)
        if checked_count > 0:
            if all_passed and passed_count == checked_count:
                logger.info("=" * 60)
                logger.info(f"✓ All cells in range {check_range} contain correct IF(SUMIF) formulas")
                logger.info(f"Passed: {passed_count}/{checked_count}")
                logger.info("=" * 60)
                return 1.0
            else:
                logger.error("=" * 60)
                logger.error(f"✗ Not all cells in range {check_range} contain correct formulas")
                logger.error(f"Passed: {passed_count}/{checked_count}")
                logger.error("=" * 60)
                return 0.0
        else:
            logger.error("=" * 60)
            logger.error("✗ No cells were checked")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0

def verify_if_countif_match_duplicate_names(result: str, expected: str = None, **options) -> float:
    """
    Verify if IF(COUNTIF(...), IF(ISERROR(MATCH(...)), ...)) formulas exist in ALL cells of specified range to extract duplicate names.
    
    This function checks:
    1. Whether ALL cells in the specified range (e.g., C2:C31) contain formulas
    2. Whether formulas contain IF, COUNTIF, ISERROR, and MATCH functions
    3. Whether COUNTIF references the correct range with mixed references (e.g., B$2:B2)
    4. Whether COUNTIF condition is > 1
    5. Whether MATCH references the correct range with mixed references (e.g., C$1:C1)
    6. Whether MATCH third parameter is 0
    7. Whether formula structure is correct: IF(COUNTIF(B$2:B2, B2) > 1, IF(ISERROR(MATCH(B2, C$1:C1, 0)), B2, ""), "")
    
    IMPORTANT: This function checks ALL cells in the specified range. If any cell is missing a formula, verification fails.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_range: Range to check (e.g., "C2:C31") - ALL cells must have formulas
            - source_column: Source column for COUNTIF (default: "B")
            - expected_functions: List of expected function names (default: ["IF", "COUNTIF", "ISERROR", "MATCH"])
    
    Returns:
        float: 1.0 if ALL cells in specified range contain correct formulas, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_range = options.get("check_range", "C2:C31")
        source_column = options.get("source_column", "B")
        expected_functions = options.get("expected_functions", ["IF", "COUNTIF", "ISERROR", "MATCH"])
        
        logger.info(f"Verifying IF(COUNTIF, IF(ISERROR(MATCH))) duplicate names formulas in file: {result}")
        logger.info(f"Range to check: {check_range}")
        logger.info(f"Source column: {source_column}")
        logger.info(f"Expected functions: {expected_functions}")
        
        # Parse the range
        try:
            range_clean = check_range.replace("$", "")
            if ":" in range_clean:
                start_cell, end_cell = range_clean.split(":")
                start_col_letter = "".join([c for c in start_cell if c.isalpha()])
                start_row = int("".join([c for c in start_cell if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                end_col_letter = "".join([c for c in end_cell if c.isalpha()])
                end_row = int("".join([c for c in end_cell if c.isdigit()]))
                end_col = column_index_from_string(end_col_letter)
            else:
                logger.error(f"Invalid range format: {check_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse range {check_range}: {e}")
            return 0.0
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check ALL cells in the specified range
        logger.info(f"Checking all cells in range {check_range} (rows {start_row} to {end_row})")
        
        all_passed = True
        checked_count = 0
        passed_count = 0
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{start_col_letter}{row_num}"
            expected_source_cell = f"{source_column}{row_num}"
            
            try:
                cell = ws[cell_coord]
                checked_count += 1
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.warning(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                elif cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula_text = cell.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains IF function (should have 2 IF functions)
                if_pattern = r"\bIF\s*\("
                if_matches = re.findall(if_pattern, formula_upper)
                if len(if_matches) < 2:
                    logger.warning(f"Cell {cell_coord} formula does not contain nested IF functions (found {len(if_matches)})")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 2: Formula contains COUNTIF function
                countif_pattern = r"\bCOUNTIF\s*\("
                if not re.search(countif_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not contain COUNTIF function")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: Formula contains ISERROR function
                iserror_pattern = r"\bISERROR\s*\("
                if not re.search(iserror_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not contain ISERROR function")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: Formula contains MATCH function
                match_pattern = r"\bMATCH\s*\("
                if not re.search(match_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not contain MATCH function")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 5: COUNTIF references the correct range with mixed references
                # Expected pattern: COUNTIF(B$2:B2, B2) or COUNTIF(B$2:B2,B2)
                # Allow variations in spacing
                countif_range_pattern = rf"COUNTIF\s*\(\s*{re.escape(source_column)}\$\d+\s*:\s*{re.escape(source_column)}\d+\s*,\s*{re.escape(source_column)}\d+\s*\)"
                if not re.search(countif_range_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not have correct COUNTIF range pattern")
                    logger.warning(f"Expected pattern: COUNTIF({source_column}$2:{source_column}2, {source_column}2)")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 6: COUNTIF condition is > 1
                countif_condition_pattern = rf"COUNTIF\s*\([^)]+\)\s*>\s*1"
                if not re.search(countif_condition_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not have COUNTIF condition > 1")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 7: MATCH references the correct range with mixed references
                # Expected pattern: MATCH(B2, C$1:C1, 0) or MATCH(B2,C$1:C1,0)
                # Allow variations in spacing
                match_pattern_full = rf"MATCH\s*\(\s*{re.escape(source_column)}\d+\s*,\s*{re.escape(start_col_letter)}\$\d+\s*:\s*{re.escape(start_col_letter)}\d+\s*,\s*0\s*\)"
                if not re.search(match_pattern_full, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not have correct MATCH pattern")
                    logger.warning(f"Expected pattern: MATCH({source_column}2, {start_col_letter}$1:{start_col_letter}1, 0)")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 8: Formula structure is IF(COUNTIF(...)>1, IF(ISERROR(MATCH(...)), B2, ""), "")
                # Check that outer IF wraps COUNTIF condition
                outer_if_pattern = rf"IF\s*\(\s*COUNTIF\s*\([^)]+\)\s*>\s*1\s*,"
                if not re.search(outer_if_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not have correct outer IF structure")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 9: Inner IF wraps ISERROR(MATCH(...))
                inner_if_pattern = rf"IF\s*\(\s*ISERROR\s*\(\s*MATCH\s*\([^)]+\)\s*\)\s*,"
                if not re.search(inner_if_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not have correct inner IF structure")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 10: Formula contains empty string literals ("")
                if '""' not in formula_text and '""' not in formula_text.replace(' ', ''):
                    # Check for variations like "" or ''
                    if not ('""' in formula_text or "''" in formula_text or '""' in formula_text.replace(' ', '')):
                        logger.warning(f"Cell {cell_coord} formula does not contain empty string literals")
                        logger.warning(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                
                # Check 11: Formula closes parentheses correctly
                open_count = formula_text.count("(")
                close_count = formula_text.count(")")
                if open_count != close_count:
                    logger.warning(f"Cell {cell_coord} formula has mismatched parentheses")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                passed_count += 1
                logger.debug(f"✓ Cell {cell_coord} has valid IF(COUNTIF, IF(ISERROR(MATCH))) formula")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        # Require ALL cells to pass (strict check)
        if checked_count > 0:
            if all_passed and passed_count == checked_count:
                logger.info("=" * 60)
                logger.info(f"✓ All cells in range {check_range} contain correct IF(COUNTIF, IF(ISERROR(MATCH))) formulas")
                logger.info(f"Passed: {passed_count}/{checked_count}")
                logger.info("=" * 60)
                return 1.0
            else:
                logger.error("=" * 60)
                logger.error(f"✗ Not all cells in range {check_range} contain correct formulas")
                logger.error(f"Passed: {passed_count}/{checked_count}")
                logger.error("=" * 60)
                return 0.0
        else:
            logger.error("=" * 60)
            logger.error("✗ No cells were checked")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0



def verify_department_merge(result: str, expected: str = None, **options) -> float:
    """
    Verify if departments in specified range are merged correctly and personnel data matches.
    
    This function checks:
    1. Whether departments in A2:A9 are merged correctly (each department merged into appropriate number of cells)
    2. Whether department names are correct (数据部, 市场部, 技术部, 人事部)
    3. Whether B column personnel data correctly corresponds to each department
    4. Department order can be arbitrary, personnel order within same department can be arbitrary
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_range: Range to check (e.g., "A2:A9")
            - personnel_column: Column letter for personnel data (default: "B")
            - expected_departments: Dict mapping department names to their config:
                {
                    "数据部": {"merge_count": 3, "personnel": ["张三", "李四", "王五"]},
                    "市场部": {"merge_count": 1, "personnel": ["吴十"]},
                    "技术部": {"merge_count": 2, "personnel": ["赵六", "钱七"]},
                    "人事部": {"merge_count": 2, "personnel": ["孙八", "周九"]}
                }
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        from openpyxl.utils import get_column_letter, column_index_from_string
        from openpyxl.cell.cell import MergedCell
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_range = options.get('check_range', 'A2:A9')
        personnel_column = options.get('personnel_column', 'B')
        expected_departments = options.get('expected_departments', {})
        
        logger.info(f"Verifying department merge in file: {result}")
        logger.info(f"Range to check: {check_range}")
        logger.info(f"Personnel column: {personnel_column}")
        logger.info(f"Expected departments: {list(expected_departments.keys())}")
        
        # Parse the range
        try:
            range_clean = check_range.replace('$', '')
            if ':' in range_clean:
                start_cell, end_cell = range_clean.split(':')
                start_col_letter = ''.join([c for c in start_cell if c.isalpha()])
                start_row = int(''.join([c for c in start_cell if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                end_col_letter = ''.join([c for c in end_cell if c.isalpha()])
                end_row = int(''.join([c for c in end_cell if c.isdigit()]))
                end_col = column_index_from_string(end_col_letter)
            else:
                logger.error(f"Invalid range format: {check_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse range {check_range}: {e}")
            return 0.0
        
        # Verify that range is a single column
        if start_col != end_col:
            logger.error(f"Check range must be a single column, got: {check_range}")
            return 0.0
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=True)  # data_only=True to get values
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Get all merged ranges in the worksheet
        merged_ranges = list(ws.merged_cells.ranges)
        
        # Track which rows are covered by merged cells
        merged_row_map = {}  # row -> (start_row, end_row, department_name)
        unmerged_rows = set(range(start_row, end_row + 1))
        
        # Process merged ranges that intersect with our check range
        for merged_range in merged_ranges:
            merged_start_col = merged_range.min_col
            merged_start_row = merged_range.min_row
            merged_end_col = merged_range.max_col
            merged_end_row = merged_range.max_row
            
            # Check if this merged range is in column A (our check column)
            if merged_start_col == start_col and merged_end_col == start_col:
                # Check if it intersects with our range
                if not (merged_end_row < start_row or merged_start_row > end_row):
                    # Get the department name from the top-left cell
                    top_left_cell = ws[f"{start_col_letter}{merged_start_row}"]
                    dept_name = str(top_left_cell.value).strip() if top_left_cell.value else ""
                    
                    # Mark all rows in this merged range
                    for row in range(merged_start_row, merged_end_row + 1):
                        if row in unmerged_rows:
                            unmerged_rows.remove(row)
                        merged_row_map[row] = (merged_start_row, merged_end_row, dept_name)
        
        # Process unmerged rows (single cell departments)
        for row in unmerged_rows:
            cell = ws[f"{start_col_letter}{row}"]
            dept_name = str(cell.value).strip() if cell.value else ""
            merged_row_map[row] = (row, row, dept_name)  # Single cell, start_row == end_row
        
        # Group rows by department
        department_groups = {}  # dept_name -> list of (start_row, end_row, row_count)
        for row in range(start_row, end_row + 1):
            if row in merged_row_map:
                start_r, end_r, dept_name = merged_row_map[row]
                if dept_name not in department_groups:
                    department_groups[dept_name] = []
                # Only add if this is the start row of a merged range (avoid duplicates)
                if row == start_r:
                    row_count = end_r - start_r + 1
                    department_groups[dept_name].append((start_r, end_r, row_count))
        
        logger.info(f"Found departments: {list(department_groups.keys())}")
        
        # Verify each expected department
        found_departments = set(department_groups.keys())
        expected_dept_names = set(expected_departments.keys())
        
        # Check if all expected departments are found
        if found_departments != expected_dept_names:
            logger.error(f"Department mismatch. Expected: {expected_dept_names}, Found: {found_departments}")
            return 0.0
        
        # Verify each department's merge count and personnel
        for dept_name, dept_config in expected_departments.items():
            expected_merge_count = dept_config.get('merge_count', 1)
            expected_personnel = set(dept_config.get('personnel', []))
            
            if dept_name not in department_groups:
                logger.error(f"Department '{dept_name}' not found")
                return 0.0
            
            dept_ranges = department_groups[dept_name]
            
            # Check merge count - should have exactly one merged range with correct count
            if len(dept_ranges) != 1:
                logger.error(f"Department '{dept_name}' should have exactly one merged range, found {len(dept_ranges)}")
                return 0.0
            
            start_r, end_r, actual_merge_count = dept_ranges[0]
            
            if actual_merge_count != expected_merge_count:
                logger.error(f"Department '{dept_name}' should merge {expected_merge_count} cells, but merged {actual_merge_count} cells")
                return 0.0
            
            # Verify personnel data in B column
            actual_personnel = []
            for row in range(start_r, end_r + 1):
                personnel_cell = ws[f"{personnel_column}{row}"]
                personnel_value = str(personnel_cell.value).strip() if personnel_cell.value else ""
                if personnel_value:
                    actual_personnel.append(personnel_value)
            
            actual_personnel_set = set(actual_personnel)
            
            if actual_personnel_set != expected_personnel:
                logger.error(f"Department '{dept_name}' personnel mismatch. Expected: {expected_personnel}, Found: {actual_personnel_set}")
                return 0.0
            
            logger.info(f"✓ Department '{dept_name}': merged {actual_merge_count} cells, personnel: {actual_personnel}")
        
        logger.info("=" * 60)
        logger.info("✓ All departments merged correctly with matching personnel data")
        logger.info("=" * 60)
        return 1.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_filter_non_letter_end(result: str, expected: str = None, **options) -> float:
    """
    Verify if formula cells in specified range and filter condition are correctly applied.
    
    This function STRICTLY checks ALL cells in the specified range - no tolerance, no auto-detection.
    Every single cell in the specified range must contain the correct formula.
    
    This function checks:
    1. Whether ALL cells in the specified formula range (e.g., B1:B10) contain formulas
    2. Whether formulas contain N, ISERROR, INDIRECT, and RIGHT functions
    3. Whether formulas reference the correct A column cell with relative row (e.g., $A2, $A3, etc.)
    4. Whether formulas have the correct structure: =N(ISERROR(N(INDIRECT(RIGHT($A2)&4^8))))
    5. Whether auto filter is enabled on the worksheet
    6. Whether filter is applied to the specified filter column (default: column B)
    7. Whether filter condition matches expected value (default: "1")
    
    The formula =N(ISERROR(N(INDIRECT(RIGHT($A2)&4^8)))) works as follows:
    - RIGHT($A2) gets the last character of A2
    - INDIRECT(RIGHT($A2)&4^8) tries to create a cell reference by concatenating the last character with "4^8" (65536)
    - If the last character is a letter, INDIRECT fails (invalid cell reference), ISERROR returns TRUE, N converts to 1
    - If the last character is a number, INDIRECT succeeds, ISERROR returns FALSE, N converts to 0
    - So the formula returns 1 for rows ending with letters (filter out) and 0 for rows ending with numbers (keep)
    
    IMPORTANT: This function checks ALL cells in the specified formula range. If any cell is missing a formula, verification fails.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formula_range: Range containing formulas (e.g., "B1:B10") - ALL cells must have formulas
            - source_column: Source column for RIGHT function (default: "A")
            - filter_column: Column to filter (default: "B")
            - filter_value: Expected filter value (default: "1")
            - expected_formula: Expected filter formula pattern (default: "=N(ISERROR(N(INDIRECT(RIGHT($A2)&4^8))))")
            - expected_functions: List of expected function names (default: ["N", "ISERROR", "INDIRECT", "RIGHT"])
    
    Returns:
        float: 1.0 if ALL cells in specified range contain correct formulas AND filter is correctly applied, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formula_range = options.get('formula_range', 'B1:B10')
        source_column = options.get('source_column', 'A')
        filter_column = options.get('filter_column', 'B')
        filter_value = options.get('filter_value', '1')
        expected_functions = options.get('expected_functions', ['N', 'ISERROR', 'INDIRECT', 'RIGHT'])
        
        logger.info(f"Verifying filter for non-letter ending rows in file: {result}")
        logger.info(f"Formula range: {formula_range}")
        logger.info(f"Source column: {source_column}")
        logger.info(f"Filter column: {filter_column}")
        logger.info(f"Filter value: {filter_value}")
        
        # Parse the formula range
        try:
            range_clean = formula_range.replace("$", "")
            if ":" in range_clean:
                start_cell, end_cell = range_clean.split(":")
                start_col_letter = "".join([c for c in start_cell if c.isalpha()])
                start_row = int("".join([c for c in start_cell if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                end_col_letter = "".join([c for c in end_cell if c.isalpha()])
                end_row = int("".join([c for c in end_cell if c.isdigit()]))
                end_col = column_index_from_string(end_col_letter)
            else:
                logger.error(f"Invalid range format: {formula_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse range {formula_range}: {e}")
            return 0.0
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=False)
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check 1: Verify ALL cells in formula range contain formulas
        logger.info(f"Checking all cells in range {formula_range} (rows {start_row} to {end_row})")
        
        all_passed = True
        checked_count = 0
        passed_count = 0
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{start_col_letter}{row_num}"
            expected_source_cell = f"${source_column}{row_num}"
            
            try:
                cell = ws[cell_coord]
                checked_count += 1
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.error(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                elif cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula_text = cell.value
                
                if formula_text is None:
                    logger.error(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains all expected functions
                for func_name in expected_functions:
                    func_pattern = rf'\b{re.escape(func_name.upper())}\s*\('
                    if not re.search(func_pattern, formula_upper):
                        logger.error(f"Cell {cell_coord} formula does not contain {func_name} function")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        break
                
                if not all_passed:
                    continue
                
                # Check 2: Formula contains N function
                n_pattern = r'\bN\s*\('
                if not re.search(n_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain N function")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: Formula contains ISERROR function
                iserror_pattern = r'\bISERROR\s*\('
                if not re.search(iserror_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain ISERROR function")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: Formula contains INDIRECT function
                indirect_pattern = r'\bINDIRECT\s*\('
                if not re.search(indirect_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain INDIRECT function")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 5: Formula contains RIGHT function
                right_pattern = r'\bRIGHT\s*\('
                if not re.search(right_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain RIGHT function")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 6: Formula references the correct source column with correct row
                source_cell_pattern = rf'\$\s*{re.escape(source_column.upper())}\s*{row_num}\b'
                if not re.search(source_cell_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not reference {expected_source_cell}")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 7: Formula contains the pattern "4^8" or "4^ 8" (with possible spaces)
                power_pattern = r'4\s*\^\s*8'
                if not re.search(power_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain '4^8' pattern")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 8: Formula structure is N(ISERROR(N(INDIRECT(RIGHT(...)&4^8))))
                # Check nested structure
                nested_pattern = r'N\s*\(\s*ISERROR\s*\(\s*N\s*\(\s*INDIRECT\s*\('
                if not re.search(nested_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not have correct nested structure N(ISERROR(N(INDIRECT(...))))")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                passed_count += 1
                logger.info(f"✓ Cell {cell_coord} has valid formula: {formula_text}")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                all_passed = False
        
        if not all_passed:
            logger.error(f"✗ Formula verification failed: {passed_count}/{checked_count} cells passed")
            return 0.0
        
        if checked_count == 0:
            logger.error(f"No cells found in range {formula_range}")
            return 0.0
        
        logger.info(f"✓ All {checked_count} cells in range {formula_range} contain correct formulas")
        
        # Check 2: Verify filter is applied (either AutoFilter or Standard Filter)
        # Standard Filter in LibreOffice Calc may not create AutoFilter, but hides rows instead
        filter_col_id = column_index_from_string(filter_column) - 1  # 0-based index
        filter_found = False
        filter_condition_met = False
        
        # Try to check AutoFilter first (for AutoFilter mode)
        if ws.auto_filter is not None and ws.auto_filter.ref is not None:
            logger.info(f"✓ AutoFilter is enabled, range: {ws.auto_filter.ref}")
            
            # Debug: Log all filter columns
            logger.info(f"Checking filter columns (total: {len(ws.auto_filter.filterColumn)})")
            for idx, flt_clm in enumerate(ws.auto_filter.filterColumn):
                logger.info(f"  Filter column {idx}: colId={flt_clm.colId}, hiddenButton={flt_clm.hiddenButton}, showButton={flt_clm.showButton}")
                if flt_clm.filters is not None:
                    logger.info(f"    filters.filter count: {len(flt_clm.filters.filter)}")
                    for flt in flt_clm.filters.filter:
                        # Handle both object with .val attribute and string values
                        if isinstance(flt, str):
                            logger.info(f"      Filter value: {flt} (type: str)")
                        elif hasattr(flt, 'val'):
                            logger.info(f"      Filter value: {flt.val} (type: {type(flt.val)})")
                        else:
                            logger.info(f"      Filter value: {flt} (type: {type(flt)})")
                if flt_clm.customFilters is not None:
                    logger.info(f"    customFilters count: {len(flt_clm.customFilters.customFilter)}")
                    for flt in flt_clm.customFilters.customFilter:
                        if isinstance(flt, str):
                            logger.info(f"      Custom filter: {flt} (type: str)")
                        elif hasattr(flt, 'operator') and hasattr(flt, 'val'):
                            logger.info(f"      Custom filter: operator={flt.operator}, val={flt.val} (type: {type(flt.val)})")
                        else:
                            logger.info(f"      Custom filter: {flt} (type: {type(flt)})")
            
            for flt_clm in ws.auto_filter.filterColumn:
                if flt_clm.colId == filter_col_id:
                    filter_found = True
                    logger.info(f"✓ Filter found on column {filter_column} (colId: {filter_col_id})")
                    
                    # Check if filters exist (standard filter)
                    if flt_clm.filters is not None:
                        logger.info(f"  filters object exists, filter count: {len(flt_clm.filters.filter) if hasattr(flt_clm.filters, 'filter') else 0}")
                        if hasattr(flt_clm.filters, 'filter') and len(flt_clm.filters.filter) > 0:
                            for flt in flt_clm.filters.filter:
                                # Handle both object with .val attribute and string values
                                if isinstance(flt, str):
                                    filter_val_str = flt
                                    logger.info(f"  Filter value (string): {filter_val_str}")
                                    if str(flt) == str(filter_value):
                                        filter_condition_met = True
                                        logger.info(f"✓ Filter condition matches: {filter_column} = {filter_value}")
                                elif hasattr(flt, 'val'):
                                    filter_val_str = str(flt.val)
                                    logger.info(f"  Filter value (object): {filter_val_str} (type: {type(flt.val)})")
                                    if str(flt.val) == str(filter_value) or flt.val == filter_value:
                                        filter_condition_met = True
                                        logger.info(f"✓ Filter condition matches: {filter_column} = {filter_value}")
                                else:
                                    filter_val_str = str(flt)
                                    logger.info(f"  Filter value (other): {filter_val_str} (type: {type(flt)})")
                                    if str(flt) == str(filter_value):
                                        filter_condition_met = True
                                        logger.info(f"✓ Filter condition matches: {filter_column} = {filter_value}")
                        else:
                            logger.warning(f"  filters.filter is empty or doesn't exist")
                    
                    # Check if custom filters exist
                    if flt_clm.customFilters is not None:
                        logger.info(f"✓ Custom filter exists on column {filter_column}")
                        for flt in flt_clm.customFilters.customFilter:
                            # Handle different filter object types
                            if isinstance(flt, str):
                                logger.info(f"  Custom filter (string): {flt}")
                                if str(flt) == str(filter_value):
                                    filter_condition_met = True
                                    logger.info(f"✓ Custom filter condition matches: {filter_column} = {filter_value}")
                            elif hasattr(flt, 'operator') and hasattr(flt, 'val'):
                                filter_val_str = str(flt.val)
                                logger.info(f"  Custom filter: operator={flt.operator}, val={filter_val_str}")
                                # Check for equal operator
                                operator_match = flt.operator in ['equal', '=', 'eq']
                                if operator_match:
                                    if str(flt.val) == str(filter_value) or flt.val == filter_value:
                                        filter_condition_met = True
                                        logger.info(f"✓ Custom filter condition matches: {filter_column} = {filter_value}")
                            else:
                                filter_val_str = str(flt)
                                logger.info(f"  Custom filter (other): {filter_val_str} (type: {type(flt)})")
                                if str(flt) == str(filter_value):
                                    filter_condition_met = True
                                    logger.info(f"✓ Custom filter condition matches: {filter_column} = {filter_value}")
                    
                    # Also check if the column has hiddenButton or showButton set (indicates filter is active)
                    if flt_clm.hiddenButton or (hasattr(flt_clm, 'showButton') and not flt_clm.showButton):
                        logger.info(f"  Filter button state indicates filter is active on column {filter_column}")
                        # If we found the filter column but couldn't match the value, still consider it if button state indicates filter
                        if not filter_condition_met:
                            logger.warning(f"  Filter column found but condition value not matched. Button state suggests filter is active.")
                            # For LibreOffice Calc, sometimes the filter value might not be directly accessible
                            # We'll be more lenient if the filter column exists and is active
                            filter_condition_met = True
                            logger.info(f"  Accepting filter based on button state (LibreOffice Calc compatibility)")
                    
                    break
        else:
            logger.info("AutoFilter is not enabled, checking for Standard Filter (row hiding)")
        
        # Check 3: If AutoFilter not found or condition not met, check row hiding (Standard Filter)
        # Standard Filter hides rows that don't match the condition
        # For filter condition B = 1, rows with B != 1 should be hidden, rows with B = 1 should be visible
        if not filter_condition_met:
            logger.info(f"Checking row hiding state for Standard Filter on column {filter_column} = {filter_value}")
            
            # Load workbook again with data_only=True to get calculated values instead of formulas
            try:
                wb_values = openpyxl.load_workbook(result, data_only=True)
                ws_values = wb_values.active
            except Exception as e:
                logger.warning(f"Failed to load workbook with data_only=True: {e}, using original workbook")
                ws_values = ws
            
            # Check rows in the formula range to see if filtering is applied correctly
            # We need to check if rows with B != filter_value are hidden, and rows with B == filter_value are visible
            visible_count = 0
            hidden_count = 0
            matching_visible = 0
            matching_hidden = 0
            non_matching_visible = 0
            non_matching_hidden = 0
            
            for row_num in range(start_row, end_row + 1):
                # Get the cell VALUE (calculated result) in the filter column, not the formula
                filter_cell = ws_values[f"{filter_column}{row_num}"]
                cell_value = filter_cell.value
                
                # Check if row is hidden
                row_dimension = ws.row_dimensions.get(row_num)
                is_hidden = row_dimension is not None and row_dimension.hidden if row_dimension else False
                
                # Convert cell value to string for comparison (use calculated value, not formula)
                # Handle different value types (int, float, str, etc.)
                if cell_value is None:
                    cell_value_str = ""
                elif isinstance(cell_value, (int, float)):
                    cell_value_str = str(int(cell_value)) if isinstance(cell_value, float) and cell_value.is_integer() else str(cell_value)
                else:
                    cell_value_str = str(cell_value)
                
                if is_hidden:
                    hidden_count += 1
                    if cell_value_str == str(filter_value):
                        matching_hidden += 1
                        logger.warning(f"  Row {row_num}: B={cell_value_str} matches filter but is HIDDEN (unexpected)")
                    else:
                        non_matching_hidden += 1
                        logger.debug(f"  Row {row_num}: B={cell_value_str} doesn't match filter and is HIDDEN (expected)")
                else:
                    visible_count += 1
                    if cell_value_str == str(filter_value):
                        matching_visible += 1
                        logger.debug(f"  Row {row_num}: B={cell_value_str} matches filter and is VISIBLE (expected)")
                    else:
                        non_matching_visible += 1
                        logger.warning(f"  Row {row_num}: B={cell_value_str} doesn't match filter but is VISIBLE (unexpected)")
            
            logger.info(f"  Row visibility summary:")
            logger.info(f"    Total rows: {end_row - start_row + 1}")
            logger.info(f"    Visible: {visible_count}, Hidden: {hidden_count}")
            logger.info(f"    Matching filter ({filter_column}={filter_value}): {matching_visible} visible, {matching_hidden} hidden")
            logger.info(f"    Non-matching: {non_matching_visible} visible, {non_matching_hidden} hidden")
            
            # Standard Filter should hide rows that don't match the condition
            # So rows with B != filter_value should be hidden, rows with B == filter_value should be visible
            if matching_visible > 0 and non_matching_visible == 0:
                # All matching rows are visible, all non-matching rows are hidden - perfect!
                filter_condition_met = True
                filter_found = True
                logger.info(f"✓ Standard Filter correctly applied: {matching_visible} matching rows visible, {non_matching_hidden} non-matching rows hidden")
            elif matching_visible > 0:
                # Some matching rows are visible - accept if most are correct
                if non_matching_visible == 0 or (matching_visible > non_matching_visible):
                    filter_condition_met = True
                    filter_found = True
                    logger.info(f"✓ Standard Filter applied: {matching_visible} matching rows visible")
                else:
                    logger.warning(f"  Standard Filter may not be correctly applied: {non_matching_visible} non-matching rows are visible")
            else:
                logger.warning(f"  No matching rows are visible, filter may not be correctly applied")
        
        if not filter_found:
            logger.error(f"Filter not found on column {filter_column} (colId: {filter_col_id})")
            if ws.auto_filter is not None and ws.auto_filter.ref is not None:
                logger.error(f"Available filter columns: {[flt_clm.colId for flt_clm in ws.auto_filter.filterColumn]}")
            else:
                logger.error("No AutoFilter found, and Standard Filter (row hiding) not detected")
            return 0.0
        
        if not filter_condition_met:
            logger.error(f"Filter condition not met: {filter_column} = {filter_value}")
            logger.error("Please check if the filter is correctly applied in LibreOffice Calc")
            return 0.0
        
        logger.info("=" * 60)
        logger.info("✓ All verification checks passed")
        logger.info(f"  - All {checked_count} cells in {formula_range} contain correct formulas")
        if ws.auto_filter is not None and ws.auto_filter.ref is not None:
            logger.info(f"  - AutoFilter is enabled")
        else:
            logger.info(f"  - Standard Filter detected (via row hiding)")
        logger.info(f"  - Filter applied to column {filter_column} with condition = {filter_value}")
        logger.info("=" * 60)
        return 1.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0



def verify_column_format_match(result: str, expected: str = None, **options) -> float:
    """
    Verify if two column ranges have identical formatting, including merged cells, borders, fonts, fills, alignment, etc.
    
    This function checks:
    1. Whether merged cells in source range match merged cells in target range (same positions and sizes)
    2. Whether border styles match for all cells
    3. Whether font properties match (size, color, bold, italic, underline, name)
    4. Whether fill/background colors match
    5. Whether alignment matches (horizontal, vertical)
    6. Whether number formats match
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - source_range: Source range to compare (e.g., "E6:E35")
            - target_range: Target range to compare (e.g., "G6:G35")
    
    Returns:
        float: 1.0 if all formatting matches, 0.0 otherwise
    """
    try:
        from openpyxl.utils import get_column_letter, column_index_from_string
        from openpyxl.cell.cell import MergedCell
        from openpyxl.styles import Border, Side
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        source_range = options.get('source_range', 'E6:E35')
        target_range = options.get('target_range', 'G6:G35')
        
        logger.info(f"Verifying column format match in file: {result}")
        logger.info(f"Source range: {source_range}")
        logger.info(f"Target range: {target_range}")
        
        # Parse source range
        try:
            source_clean = source_range.replace('$', '')
            if ':' in source_clean:
                source_start, source_end = source_clean.split(':')
                source_start_col_letter = ''.join([c for c in source_start if c.isalpha()])
                source_start_row = int(''.join([c for c in source_start if c.isdigit()]))
                source_start_col = column_index_from_string(source_start_col_letter)
                source_end_col_letter = ''.join([c for c in source_end if c.isalpha()])
                source_end_row = int(''.join([c for c in source_end if c.isdigit()]))
                source_end_col = column_index_from_string(source_end_col_letter)
            else:
                logger.error(f"Invalid source range format: {source_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse source range {source_range}: {e}")
            return 0.0
        
        # Parse target range
        try:
            target_clean = target_range.replace('$', '')
            if ':' in target_clean:
                target_start, target_end = target_clean.split(':')
                target_start_col_letter = ''.join([c for c in target_start if c.isalpha()])
                target_start_row = int(''.join([c for c in target_start if c.isdigit()]))
                target_start_col = column_index_from_string(target_start_col_letter)
                target_end_col_letter = ''.join([c for c in target_end if c.isalpha()])
                target_end_row = int(''.join([c for c in target_end if c.isdigit()]))
                target_end_col = column_index_from_string(target_end_col_letter)
            else:
                logger.error(f"Invalid target range format: {target_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse target range {target_range}: {e}")
            return 0.0
        
        # Verify ranges have same number of rows
        if (source_end_row - source_start_row) != (target_end_row - target_start_row):
            logger.error(f"Source and target ranges have different row counts: {source_range} vs {target_range}")
            return 0.0
        
        # Verify ranges are single columns
        if source_start_col != source_end_col:
            logger.error(f"Source range must be a single column: {source_range}")
            return 0.0
        if target_start_col != target_end_col:
            logger.error(f"Target range must be a single column: {target_range}")
            return 0.0
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=False)
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Get all merged ranges
        merged_ranges = list(ws.merged_cells.ranges)
        
        # Build merged cell maps for both columns
        source_merged_map = {}  # row -> (start_row, end_row)
        target_merged_map = {}  # row -> (start_row, end_row)
        
        for merged_range in merged_ranges:
            merged_start_col = merged_range.min_col
            merged_start_row = merged_range.min_row
            merged_end_col = merged_range.max_col
            merged_end_row = merged_range.max_row
            
            # Check if merged range is in source column
            if merged_start_col == source_start_col and merged_end_col == source_start_col:
                if not (merged_end_row < source_start_row or merged_start_row > source_end_row):
                    for row in range(merged_start_row, merged_end_row + 1):
                        if source_start_row <= row <= source_end_row:
                            source_merged_map[row] = (merged_start_row, merged_end_row)
            
            # Check if merged range is in target column
            if merged_start_col == target_start_col and merged_end_col == target_start_col:
                if not (merged_end_row < target_start_row or merged_start_row > target_end_row):
                    for row in range(merged_start_row, merged_end_row + 1):
                        if target_start_row <= row <= target_end_row:
                            target_merged_map[row] = (merged_start_row, merged_end_row)
        
        # Check 1: Merged cells match
        logger.info("Checking merged cells...")
        source_merged_groups = {}
        target_merged_groups = {}
        
        for row in range(source_start_row, source_end_row + 1):
            if row in source_merged_map:
                merge_key = source_merged_map[row]
                if merge_key not in source_merged_groups:
                    source_merged_groups[merge_key] = []
                source_merged_groups[merge_key].append(row)
        
        for row in range(target_start_row, target_end_row + 1):
            if row in target_merged_map:
                merge_key = target_merged_map[row]
                if merge_key not in target_merged_groups:
                    target_merged_groups[merge_key] = []
                target_merged_groups[merge_key].append(row)
        
        # Convert to relative positions for comparison
        source_relative_merges = {}
        for (start_row, end_row), rows in source_merged_groups.items():
            rel_start = start_row - source_start_row
            rel_end = end_row - source_start_row
            source_relative_merges[(rel_start, rel_end)] = rows
        
        target_relative_merges = {}
        for (start_row, end_row), rows in target_merged_groups.items():
            rel_start = start_row - target_start_row
            rel_end = end_row - target_start_row
            target_relative_merges[(rel_start, rel_end)] = rows
        
        if source_relative_merges != target_relative_merges:
            logger.error(f"Merged cells do not match: source={source_relative_merges}, target={target_relative_merges}")
            return 0.0
        
        logger.info("✓ Merged cells match")
        
        # Check 2-6: Format properties for each row
        logger.info("Checking format properties for each row...")
        all_passed = True
        checked_count = 0
        passed_count = 0
        
        def get_cell_border_info(cell):
            """Get border information as a comparable format"""
            if cell.border is None:
                return None
            border = cell.border
            return {
                'left': str(border.left.style) if border.left else None,
                'right': str(border.right.style) if border.right else None,
                'top': str(border.top.style) if border.top else None,
                'bottom': str(border.bottom.style) if border.bottom else None,
            }
        
        def get_cell_font_info(cell):
            """Get font information as a comparable format"""
            if cell.font is None:
                return None
            font = cell.font
            return {
                'name': font.name,
                'size': font.size,
                'bold': font.bold,
                'italic': font.italic,
                'underline': str(font.underline) if font.underline else None,
                'color': font.color.rgb if font.color and font.color.rgb else None,
            }
        
        def get_cell_fill_info(cell):
            """Get fill information as a comparable format"""
            if cell.fill is None:
                return None
            fill = cell.fill
            try:
                fg_color = fill.fgColor.rgb if fill.fgColor and fill.fgColor.rgb else None
            except:
                fg_color = None
            try:
                bg_color = fill.bgColor.rgb if fill.bgColor and fill.bgColor.rgb else None
            except:
                bg_color = None
            return {
                'fgColor': fg_color,
                'bgColor': bg_color,
                'fill_type': fill.fill_type if hasattr(fill, 'fill_type') else None,
            }
        
        def get_cell_alignment_info(cell):
            """Get alignment information as a comparable format"""
            if cell.alignment is None:
                return None
            alignment = cell.alignment
            return {
                'horizontal': str(alignment.horizontal) if alignment.horizontal else None,
                'vertical': str(alignment.vertical) if alignment.vertical else None,
            }
        
        for row_offset in range(source_end_row - source_start_row + 1):
            source_row = source_start_row + row_offset
            target_row = target_start_row + row_offset
            
            source_cell_coord = f"{source_start_col_letter}{source_row}"
            target_cell_coord = f"{target_start_col_letter}{target_row}"
            
            # Skip if this row is part of a merged cell (only check top-left cell)
            if source_row in source_merged_map:
                merge_start, merge_end = source_merged_map[source_row]
                if source_row != merge_start:
                    continue  # Skip non-top-left cells in merged range
            
            try:
                source_cell = ws[source_cell_coord]
                target_cell = ws[target_cell_coord]
                checked_count += 1
                
                # Check borders
                source_border = get_cell_border_info(source_cell)
                target_border = get_cell_border_info(target_cell)
                if source_border != target_border:
                    logger.warning(f"Row {source_row}: Border mismatch - source={source_border}, target={target_border}")
                    all_passed = False
                    continue
                
                # Check font
                source_font = get_cell_font_info(source_cell)
                target_font = get_cell_font_info(target_cell)
                if source_font != target_font:
                    logger.warning(f"Row {source_row}: Font mismatch - source={source_font}, target={target_font}")
                    all_passed = False
                    continue
                
                # Check fill
                source_fill = get_cell_fill_info(source_cell)
                target_fill = get_cell_fill_info(target_cell)
                if source_fill != target_fill:
                    logger.warning(f"Row {source_row}: Fill mismatch - source={source_fill}, target={target_fill}")
                    all_passed = False
                    continue
                
                # Check alignment
                source_alignment = get_cell_alignment_info(source_cell)
                target_alignment = get_cell_alignment_info(target_cell)
                if source_alignment != target_alignment:
                    logger.warning(f"Row {source_row}: Alignment mismatch - source={source_alignment}, target={target_alignment}")
                    all_passed = False
                    continue
                
                # Check number format
                source_num_format = source_cell.number_format
                target_num_format = target_cell.number_format
                if source_num_format != target_num_format:
                    logger.warning(f"Row {source_row}: Number format mismatch - source={source_num_format}, target={target_num_format}")
                    all_passed = False
                    continue
                
                passed_count += 1
                
            except Exception as e:
                logger.error(f"Error checking row {source_row}: {e}")
                all_passed = False
                continue
        
        if not all_passed:
            logger.error(f"Format verification failed: {passed_count}/{checked_count} cells passed")
            return 0.0
        
        logger.info("=" * 60)
        logger.info("✓ All format verification checks passed")
        logger.info(f"  - Merged cells match between {source_range} and {target_range}")
        logger.info(f"  - All {checked_count} cells have matching format properties:")
        logger.info(f"    * Borders")
        logger.info(f"    * Fonts (size, color, style)")
        logger.info(f"    * Fills (background colors)")
        logger.info(f"    * Alignment")
        logger.info(f"    * Number formats")
        logger.info("=" * 60)
        return 1.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_clean_remove_newlines(result: str, expected: str = None, **options) -> float:
    """
    Verify if CLEAN formulas exist in specified range to remove newlines from source cells.
    
    This function STRICTLY checks ALL cells in the specified range - no tolerance, no auto-detection.
    Every single cell in the specified range must contain the correct CLEAN formula.
    
    This function checks:
    1. Whether ALL cells in the specified range (e.g., B2:B4) contain CLEAN formulas
    2. Whether formulas reference the corresponding source column cell (B2->A2, B3->A3, etc.)
    3. Whether formulas contain the correct CLEAN function
    4. Whether formulas have the correct structure: =CLEAN(source_cell)
    
    IMPORTANT: This function checks ALL cells in the specified range, regardless of whether they
    appear to be empty. If any cell in the specified range is missing a formula, verification fails.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_range: Range containing CLEAN formulas (e.g., "B2:B4") - ALL cells must have formulas
            - source_column: Source column letter (e.g., "A")
            - expected_function: Expected function name (default: "CLEAN")
    
    Returns:
        float: 1.0 if ALL cells in specified range contain correct CLEAN formulas, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_range = options.get('check_range', 'B2:B4')
        source_column = options.get('source_column', 'A')
        expected_function = options.get('expected_function', 'CLEAN')
        
        logger.info(f"Verifying CLEAN formulas in file: {result}")
        logger.info(f"Check range: {check_range}")
        logger.info(f"Source column: {source_column}")
        logger.info(f"Expected function: {expected_function}")
        
        # Parse check range - strictly use the specified range
        try:
            check_range_clean = check_range.replace('$', '')
            if ':' in check_range_clean:
                check_start_cell, check_end_cell = check_range_clean.split(':')
                check_start_col_letter = ''.join([c for c in check_start_cell if c.isalpha()])
                check_start_row = int(''.join([c for c in check_start_cell if c.isdigit()]))
                check_start_col = column_index_from_string(check_start_col_letter)
                check_end_col_letter = ''.join([c for c in check_end_cell if c.isalpha()])
                check_end_row = int(''.join([c for c in check_end_cell if c.isdigit()]))
                check_end_col = column_index_from_string(check_end_col_letter)
            else:
                logger.error(f"Invalid check range format: {check_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse check range {check_range}: {e}")
            return 0.0
        
        # Verify that range is a single column
        if check_start_col != check_end_col:
            logger.error(f"Check range must be a single column, got: {check_range}")
            return 0.0
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Strictly check ALL cells in the specified range - no auto-detection
        logger.info(f"Checking all cells in range {check_range} (rows {check_start_row} to {check_end_row})")
        
        # Check CLEAN formulas - check ALL rows in the specified range
        all_passed = True
        checked_count = 0
        passed_count = 0
        
        for row_num in range(check_start_row, check_end_row + 1):
            cell_coord = f"{check_start_col_letter}{row_num}"
            expected_source_cell = f"{source_column}{row_num}"
            
            try:
                cell = ws[cell_coord]
                checked_count += 1
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.warning(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                else:
                    if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains CLEAN function
                clean_pattern = rf'\b{re.escape(expected_function)}\s*\('
                if not re.search(clean_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not contain {expected_function} function")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 2: Formula references the corresponding source column cell (A2, A3, etc.)
                source_cell_pattern = rf'\b{re.escape(expected_source_cell)}\b'
                if not re.search(source_cell_pattern, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {cell_coord} formula does not reference {expected_source_cell}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: Formula structure is CLEAN(source_cell) - allow for optional spaces
                clean_structure_pattern = rf'{re.escape(expected_function)}\s*\(\s*{re.escape(expected_source_cell)}\s*\)'
                if not re.search(clean_structure_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not have correct {expected_function}({expected_source_cell}) structure")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: Formula closes parentheses correctly
                open_count = formula_text.count('(')
                close_count = formula_text.count(')')
                if open_count != close_count:
                    logger.warning(f"Cell {cell_coord} formula has mismatched parentheses")
                    all_passed = False
                    continue
                
                passed_count += 1
                logger.debug(f"✓ Cell {cell_coord} has valid CLEAN formula")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        # Require all specified cells to have correct formulas (no tolerance)
        if checked_count > 0:
            if all_passed and passed_count == checked_count:
                logger.info("=" * 60)
                logger.info(f"✓ All {checked_count} cells contain correct CLEAN formulas")
                logger.info("=" * 60)
                return 1.0
            else:
                logger.error("=" * 60)
                logger.error(f"✗ Verification failed: {passed_count}/{checked_count} cells passed")
                logger.error(f"  All specified cells must contain correct CLEAN formulas")
                logger.error("=" * 60)
                return 0.0
        else:
            logger.error("=" * 60)
            logger.error("✗ No cells were checked")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_sumif_category_sum(result: str, expected: str = None, **options) -> float:
    """
    Verify if SUMIF formulas exist in specified range for calculating sum by category.
    
    This function checks:
    1. Whether ALL cells in the specified range (e.g., E3:E6) contain formulas
    2. Whether formulas contain SUMIF function
    3. Whether SUMIF references the correct range (e.g., $A$2:$A$13)
    4. Whether SUMIF criteria references the correct column with relative row (e.g., D3, D4, D5, D6)
    5. Whether SUMIF sum_range references the correct range (e.g., $B$2:$B$13)
    6. Whether formula structure is correct: SUMIF(range, criteria, sum_range)
    
    IMPORTANT: This function checks ALL cells in the specified range. If any cell is missing a formula, verification fails.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_range: Range to check (e.g., "E3:E6") - ALL cells must have formulas
            - expected_functions: List of expected function names (default: ["SUMIF"])
            - sumif_range: SUMIF range reference (default: "$A$2:$A$13")
            - sumif_criteria_col: Column letter for SUMIF criteria (default: "D")
            - sumif_sum_range: SUMIF sum_range reference (default: "$B$2:$B$13")
    
    Returns:
        float: 1.0 if ALL cells in specified range contain correct formulas, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_range = options.get('check_range', 'E3:E6')
        expected_functions = options.get('expected_functions', ['SUMIF'])
        sumif_range = options.get('sumif_range', '$A$2:$A$13')
        sumif_criteria_col = options.get('sumif_criteria_col', 'D')
        sumif_sum_range = options.get('sumif_sum_range', '$B$2:$B$13')
        
        logger.info(f"Verifying SUMIF category sum formulas in file: {result}")
        logger.info(f"Range to check: {check_range}")
        logger.info(f"Expected functions: {expected_functions}")
        logger.info(f"SUMIF range: {sumif_range}")
        logger.info(f"SUMIF criteria column: {sumif_criteria_col}")
        logger.info(f"SUMIF sum_range: {sumif_sum_range}")
        
        # Parse the range - strictly use the specified range
        try:
            range_clean = check_range.replace('$', '')
            if ':' in range_clean:
                start_cell, end_cell = range_clean.split(':')
                start_col_letter = ''.join([c for c in start_cell if c.isalpha()])
                start_row = int(''.join([c for c in start_cell if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                end_col_letter = ''.join([c for c in end_cell if c.isalpha()])
                end_row = int(''.join([c for c in end_cell if c.isdigit()]))
                end_col = column_index_from_string(end_col_letter)
            else:
                logger.error(f"Invalid range format: {check_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse range {check_range}: {e}")
            return 0.0
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Strictly check ALL cells in the specified range - no auto-detection
        logger.info(f"Checking all cells in range {check_range} (rows {start_row} to {end_row})")
        
        all_passed = True
        checked_count = 0
        passed_count = 0
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{start_col_letter}{row_num}"
            expected_criteria_cell = f"{sumif_criteria_col}{row_num}"
            
            try:
                cell = ws[cell_coord]
                checked_count += 1
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.warning(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                else:
                    if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains SUMIF function
                sumif_pattern = r'\bSUMIF\s*\('
                if not re.search(sumif_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not contain SUMIF function")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 2: SUMIF references the correct range (e.g., $A$2:$A$13)
                # Allow variations: $A$2:$A$13, A$2:A$13, $A2:$A13, A2:A13
                sumif_range_clean = sumif_range.replace('$', '')
                # Direct match without word boundaries - range references are typically separated by commas or parentheses
                sumif_range_patterns = [
                    re.escape(sumif_range),  # $A$2:$A$13
                    re.escape(sumif_range_clean),  # A2:A13
                ]
                # Also check for variations with different $ placements
                sumif_range_parts = sumif_range_clean.split(':')
                if len(sumif_range_parts) == 2:
                    sumif_range_patterns.extend([
                        rf'\${re.escape(sumif_range_parts[0])}\s*:\s*\${re.escape(sumif_range_parts[1])}',  # $A2:$A13
                        rf'{re.escape(sumif_range_parts[0])}\s*:\s*\${re.escape(sumif_range_parts[1])}',  # A2:$A13
                        rf'\${re.escape(sumif_range_parts[0])}\s*:\s*{re.escape(sumif_range_parts[1])}',  # $A2:A13
                    ])
                
                sumif_range_found = False
                for pattern in sumif_range_patterns:
                    if re.search(pattern, formula_text, re.IGNORECASE):
                        sumif_range_found = True
                        break
                if not sumif_range_found:
                    logger.warning(f"Cell {cell_coord} formula does not reference SUMIF range {sumif_range}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: SUMIF criteria references the correct column with relative row (e.g., D3, D4, D5, D6)
                # Allow variations: D3, $D3, D$3, $D$3
                escaped_criteria_cell = re.escape(expected_criteria_cell)
                escaped_criteria_col = re.escape(sumif_criteria_col)
                criteria_cell_patterns = [
                    rf'\b{escaped_criteria_cell}\b',  # D3
                    rf'\${escaped_criteria_col}{row_num}\b',  # $D3
                    rf'\b{escaped_criteria_col}\${row_num}\b',  # D$3
                    rf'\${escaped_criteria_col}\${row_num}\b',  # $D$3
                ]
                
                criteria_cell_found = False
                for pattern in criteria_cell_patterns:
                    if re.search(pattern, formula_text, re.IGNORECASE):
                        criteria_cell_found = True
                        break
                
                if not criteria_cell_found:
                    logger.warning(f"Cell {cell_coord} formula does not reference criteria cell {expected_criteria_cell}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: SUMIF sum_range references the correct range (e.g., $B$2:$B$13)
                # Allow variations: $B$2:$B$13, B$2:B$13, $B2:$B13, B2:B13
                sumif_sum_range_clean = sumif_sum_range.replace('$', '')
                # Direct match without word boundaries - range references are typically separated by commas or parentheses
                sumif_sum_range_patterns = [
                    re.escape(sumif_sum_range),  # $B$2:$B$13
                    re.escape(sumif_sum_range_clean),  # B2:B13
                ]
                # Also check for variations with different $ placements
                sumif_sum_range_parts = sumif_sum_range_clean.split(':')
                if len(sumif_sum_range_parts) == 2:
                    sumif_sum_range_patterns.extend([
                        rf'\${re.escape(sumif_sum_range_parts[0])}\s*:\s*\${re.escape(sumif_sum_range_parts[1])}',  # $B2:$B13
                        rf'{re.escape(sumif_sum_range_parts[0])}\s*:\s*\${re.escape(sumif_sum_range_parts[1])}',  # B2:$B13
                        rf'\${re.escape(sumif_sum_range_parts[0])}\s*:\s*{re.escape(sumif_sum_range_parts[1])}',  # $B2:B13
                    ])
                
                sumif_sum_range_found = False
                for pattern in sumif_sum_range_patterns:
                    if re.search(pattern, formula_text, re.IGNORECASE):
                        sumif_sum_range_found = True
                        break
                if not sumif_sum_range_found:
                    logger.warning(f"Cell {cell_coord} formula does not reference SUMIF sum_range {sumif_sum_range}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 5: Formula closes parentheses correctly
                open_count = formula_text.count('(')
                close_count = formula_text.count(')')
                if open_count != close_count:
                    logger.warning(f"Cell {cell_coord} formula has mismatched parentheses")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                passed_count += 1
                logger.debug(f"✓ Cell {cell_coord} has valid SUMIF formula")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        # Require ALL cells to pass (strict check)
        if checked_count > 0:
            if all_passed and passed_count == checked_count:
                logger.info("=" * 60)
                logger.info(f"✓ All cells in range {check_range} contain correct SUMIF formulas")
                logger.info(f"Passed: {passed_count}/{checked_count}")
                logger.info("=" * 60)
                return 1.0
            else:
                logger.error("=" * 60)
                logger.error(f"✗ Not all cells in range {check_range} contain correct formulas")
                logger.error(f"Passed: {passed_count}/{checked_count}")
                logger.error("=" * 60)
                return 0.0
        else:
            logger.error("=" * 60)
            logger.error("✗ No cells were checked")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_multi_condition_filter(result: str, expected: str = None, **options) -> float:
    """
    Verify if multi-condition filter formulas exist using either method:
    Method 1: IFERROR(INDEX(SMALL(IF(...)))) in specified range
    Method 2: FILTER function in specified cell
    
    This function checks BOTH methods and returns 1.0 if EITHER method passes.
    
    Method 1 checks:
    1. Whether ALL cells in the specified range (e.g., G2:K3) contain formulas
    2. Whether formulas contain IFERROR, INDEX, SMALL, and IF functions
    3. Whether IF conditions check three criteria with AND logic (multiplication)
    4. Whether conditions reference correct ranges and values
    5. Whether INDEX references correct column (e.g., $A:$A)
    6. Whether ROWS function is used correctly for row counting
    
    Method 2 checks:
    1. Whether specified cell (e.g., G2) contains FILTER formula
    2. Whether FILTER references correct data range
    3. Whether FILTER conditions check three criteria with AND logic (multiplication)
    4. Whether conditions reference correct ranges and values
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - method1_range: Range to check for method 1 (e.g., "G2:K3")
            - method1_expected_functions: List of expected functions (default: ["IFERROR", "INDEX", "SMALL", "IF"])
            - method1_condition_ranges: Dict with condition ranges and values
            - method1_index_range: INDEX range reference (default: "$A:$A")
            - method1_row_range: ROW range reference (default: "$C$2:$C$7")
            - method2_cell: Cell to check for method 2 (e.g., "G2")
            - method2_expected_functions: List of expected functions (default: ["FILTER"])
            - method2_data_range: FILTER data range (default: "A1:E7")
            - method2_condition_ranges: Dict with condition ranges and values
    
    Returns:
        float: 1.0 if EITHER method passes, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        # Get options
        method1_range = options.get('method1_range', 'G2:K3')
        method1_expected_functions = options.get('method1_expected_functions', ['IFERROR', 'INDEX', 'SMALL', 'IF'])
        method1_condition_ranges = options.get('method1_condition_ranges', {})
        method1_index_range = options.get('method1_index_range', '$A:$A')
        method1_row_range = options.get('method1_row_range', '$C$2:$C$7')
        
        method2_cell = options.get('method2_cell', 'G2')
        method2_expected_functions = options.get('method2_expected_functions', ['FILTER'])
        method2_data_range = options.get('method2_data_range', 'A1:E7')
        method2_condition_ranges = options.get('method2_condition_ranges', {})
        
        logger.info(f"Verifying multi-condition filter formulas in file: {result}")
        logger.info(f"Method 1 range: {method1_range}")
        logger.info(f"Method 2 cell: {method2_cell}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        method1_passed = False
        method2_passed = False
        
        # Check Method 1: IFERROR(INDEX(SMALL(IF(...))))
        logger.info("=" * 60)
        logger.info("Checking Method 1: IFERROR(INDEX(SMALL(IF(...))))")
        logger.info("=" * 60)
        
        try:
            # Parse method1_range
            range_clean = method1_range.replace('$', '')
            if ':' not in range_clean:
                logger.error(f"Invalid method1_range format: {method1_range}")
                method1_passed = False
            else:
                start_cell, end_cell = range_clean.split(':')
                start_col_letter = ''.join([c for c in start_cell if c.isalpha()])
                start_row = int(''.join([c for c in start_cell if c.isdigit()]))
                end_col_letter = ''.join([c for c in end_cell if c.isalpha()])
                end_row = int(''.join([c for c in end_cell if c.isdigit()]))
                
                all_passed = True
                checked_count = 0
                passed_count = 0
                
                # For method 1, formula is filled across G2:K3
                # INDEX range changes with column: G2 uses A:A, H2 uses B:B, I2 uses C:C, J2 uses D:D, K2 uses E:E
                # So we check all cells in the range
                for row_num in range(start_row, end_row + 1):
                    for col_num in range(column_index_from_string(start_col_letter), column_index_from_string(end_col_letter) + 1):
                        cell_coord = f"{get_column_letter(col_num)}{row_num}"
                        
                        # Calculate expected INDEX column based on cell position
                        # G column (7) -> A column (1), H column (8) -> B column (2), etc.
                        start_col_index = column_index_from_string(start_col_letter)
                        cell_col_index = col_num
                        expected_index_col_index = cell_col_index - start_col_index + 1  # G=7 -> 1 (A), H=8 -> 2 (B)
                        expected_index_col_letter = get_column_letter(expected_index_col_index)
                        expected_index_range = f"{expected_index_col_letter}:{expected_index_col_letter}"  # A:A, B:B, C:C, etc.
                        
                        try:
                            cell = ws[cell_coord]
                            checked_count += 1
                            
                            # Check if cell contains a formula
                            if cell.data_type != "f":
                                logger.warning(f"Cell {cell_coord} does not contain a formula")
                                all_passed = False
                                continue
                            
                            # Get formula text
                            formula_text = None
                            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                                formula_text = cell._value
                            elif hasattr(cell, "formula"):
                                formula_text = cell.formula
                            else:
                                if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                                    formula_text = cell.value
                            
                            if formula_text is None:
                                logger.warning(f"Could not extract formula from cell {cell_coord}")
                                all_passed = False
                                continue
                            
                            formula_upper = formula_text.upper()
                            logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                            
                            # Check required functions
                            for func in method1_expected_functions:
                                func_pattern = rf'\b{func}\s*\('
                                if not re.search(func_pattern, formula_upper):
                                    logger.warning(f"Cell {cell_coord} formula does not contain {func} function")
                                    all_passed = False
                                    break
                            
                            if not all_passed:
                                continue
                            
                            # Check IFERROR structure
                            iferror_pattern = r'IFERROR\s*\('
                            if not re.search(iferror_pattern, formula_upper):
                                logger.warning(f"Cell {cell_coord} formula does not contain IFERROR function")
                                all_passed = False
                                continue
                            
                            # Check INDEX structure - column should match cell position
                            # G column -> A:A, H column -> B:B, I column -> C:C, J column -> D:D, K column -> E:E
                            index_pattern = rf'INDEX\s*\(\s*{re.escape(expected_index_range)}'
                            if not re.search(index_pattern, formula_upper):
                                logger.warning(f"Cell {cell_coord} formula does not reference INDEX range {expected_index_range} (expected for column {get_column_letter(col_num)})")
                                all_passed = False
                                continue
                            
                            # Check AGGREGATE function
                            aggregate_pattern = r'AGGREGATE\s*\('
                            if not re.search(aggregate_pattern, formula_upper):
                                logger.warning(f"Cell {cell_coord} formula does not contain AGGREGATE function")
                                all_passed = False
                                continue
                            
                            # Check AGGREGATE parameters: AGGREGATE(15, 6, ...)
                            # 15 = SMALL function, 6 = ignore errors
                            aggregate_params_pattern = r'AGGREGATE\s*\(\s*15\s*,\s*6\s*,'
                            if not re.search(aggregate_params_pattern, formula_upper):
                                logger.warning(f"Cell {cell_coord} formula does not have correct AGGREGATE parameters (15, 6)")
                                all_passed = False
                                continue
                            
                            # Check ROW function
                            row_pattern = r'ROW\s*\('
                            if not re.search(row_pattern, formula_upper):
                                logger.warning(f"Cell {cell_coord} formula does not contain ROW function")
                                all_passed = False
                                continue
                            
                            # Check ROW range reference
                            row_range_clean = method1_row_range.replace('$', '')
                            row_range_patterns = [
                                rf'ROW\s*\(\s*{re.escape(method1_row_range)}',  # ROW($C$2:$C$7)
                                rf'ROW\s*\(\s*{re.escape(row_range_clean)}',  # ROW(C2:C7)
                            ]
                            row_range_found = any(re.search(p, formula_text, re.IGNORECASE) for p in row_range_patterns)
                            if not row_range_found:
                                logger.warning(f"Cell {cell_coord} formula does not reference ROW range {method1_row_range}")
                                all_passed = False
                                continue
                            
                            # Check for division operator (/) after ROW - ROW(...)/
                            row_divide_pattern = r'ROW\s*\([^)]+\)\s*/'
                            if not re.search(row_divide_pattern, formula_text, re.IGNORECASE):
                                logger.warning(f"Cell {cell_coord} formula does not have ROW(...)/ pattern")
                                all_passed = False
                                continue
                            
                            # Check conditions (three conditions with multiplication)
                            gender_range_full = method1_condition_ranges.get('gender_range', '$C$2:$C$7')
                            gender_range_clean = gender_range_full.replace('$', '')
                            gender_value = method1_condition_ranges.get('gender_value', '女')
                            dept_range_full = method1_condition_ranges.get('dept_range', '$D$2:$D$7')
                            dept_range_clean = dept_range_full.replace('$', '')
                            dept_value = method1_condition_ranges.get('dept_value', '财务部')
                            edu_range_full = method1_condition_ranges.get('edu_range', '$E$2:$E$7')
                            edu_range_clean = edu_range_full.replace('$', '')
                            edu_value = method1_condition_ranges.get('edu_value', '本科')
                            
                            # Check for condition patterns (allow variations with/without $, different quote types)
                            # Pattern: range = "value" or range = 'value' or range = value
                            gender_patterns = [
                                rf'{re.escape(gender_range_full)}\s*=\s*["\']{re.escape(gender_value)}["\']',  # $C$2:$C$7="女"
                                rf'{re.escape(gender_range_clean)}\s*=\s*["\']{re.escape(gender_value)}["\']',  # C2:C7="女"
                                rf'{re.escape(gender_range_full)}\s*=\s*{re.escape(gender_value)}',  # $C$2:$C$7=女 (no quotes)
                                rf'{re.escape(gender_range_clean)}\s*=\s*{re.escape(gender_value)}',  # C2:C7=女 (no quotes)
                            ]
                            dept_patterns = [
                                rf'{re.escape(dept_range_full)}\s*=\s*["\']{re.escape(dept_value)}["\']',
                                rf'{re.escape(dept_range_clean)}\s*=\s*["\']{re.escape(dept_value)}["\']',
                                rf'{re.escape(dept_range_full)}\s*=\s*{re.escape(dept_value)}',
                                rf'{re.escape(dept_range_clean)}\s*=\s*{re.escape(dept_value)}',
                            ]
                            edu_patterns = [
                                rf'{re.escape(edu_range_full)}\s*=\s*["\']{re.escape(edu_value)}["\']',
                                rf'{re.escape(edu_range_clean)}\s*=\s*["\']{re.escape(edu_value)}["\']',
                                rf'{re.escape(edu_range_full)}\s*=\s*{re.escape(edu_value)}',
                                rf'{re.escape(edu_range_clean)}\s*=\s*{re.escape(edu_value)}',
                            ]
                            
                            gender_found = any(re.search(p, formula_text, re.IGNORECASE) for p in gender_patterns)
                            dept_found = any(re.search(p, formula_text, re.IGNORECASE) for p in dept_patterns)
                            edu_found = any(re.search(p, formula_text, re.IGNORECASE) for p in edu_patterns)
                            
                            if not (gender_found and dept_found and edu_found):
                                logger.warning(f"Cell {cell_coord} formula does not contain all three conditions")
                                logger.debug(f"  Gender found: {gender_found}, Dept found: {dept_found}, Edu found: {edu_found}")
                                logger.debug(f"  Formula: {formula_text}")
                                all_passed = False
                                continue
                            
                            # Check for multiplication operator (*) between conditions (AND logic)
                            if '*' not in formula_text:
                                logger.warning(f"Cell {cell_coord} formula does not use multiplication for AND logic")
                                all_passed = False
                                continue
                            
                            # Check ROWS function
                            rows_pattern = r'ROWS\s*\('
                            if not re.search(rows_pattern, formula_upper):
                                logger.warning(f"Cell {cell_coord} formula does not contain ROWS function")
                                all_passed = False
                                continue
                            
                            # Check parentheses balance
                            open_count = formula_text.count('(')
                            close_count = formula_text.count(')')
                            if open_count != close_count:
                                logger.warning(f"Cell {cell_coord} formula has mismatched parentheses")
                                all_passed = False
                                continue
                            
                            passed_count += 1
                            logger.debug(f"✓ Cell {cell_coord} has valid Method 1 formula")
                            
                        except Exception as e:
                            logger.error(f"Error checking cell {cell_coord}: {e}")
                            import traceback
                            logger.error(traceback.format_exc())
                            all_passed = False
                
                if checked_count > 0 and all_passed and passed_count == checked_count:
                    method1_passed = True
                    logger.info(f"✓ Method 1 passed: {passed_count}/{checked_count} cells")
                else:
                    logger.warning(f"✗ Method 1 failed: {passed_count}/{checked_count} cells passed")
                    
        except Exception as e:
            logger.warning(f"Method 1 check failed: {e}")
            import traceback
            logger.error(traceback.format_exc())
            method1_passed = False
        
        # Check Method 2: FILTER function
        logger.info("=" * 60)
        logger.info("Checking Method 2: FILTER function")
        logger.info("=" * 60)
        
        try:
            cell = ws[method2_cell]
            
            # Check if cell contains a formula
            if cell.data_type != "f":
                logger.warning(f"Cell {method2_cell} does not contain a formula")
                method2_passed = False
            else:
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                else:
                    if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {method2_cell}")
                    method2_passed = False
                else:
                    formula_upper = formula_text.upper()
                    logger.debug(f"Cell {method2_cell} formula: {formula_text}")
                    
                    # Check FILTER function
                    filter_pattern = r'\bFILTER\s*\('
                    if not re.search(filter_pattern, formula_upper):
                        logger.warning(f"Cell {method2_cell} formula does not contain FILTER function")
                        method2_passed = False
                    else:
                        # Check data range
                        data_range_clean = method2_data_range.replace('$', '')
                        data_range_pattern = re.escape(data_range_clean)
                        if not re.search(data_range_pattern, formula_text, re.IGNORECASE):
                            logger.warning(f"Cell {method2_cell} formula does not reference data range {method2_data_range}")
                            method2_passed = False
                        else:
                            # Check conditions
                            gender_range_full = method2_condition_ranges.get('gender_range', 'C1:C7')
                            gender_range_clean = gender_range_full.replace('$', '')
                            gender_value = method2_condition_ranges.get('gender_value', '女')
                            dept_range_full = method2_condition_ranges.get('dept_range', 'D1:D7')
                            dept_range_clean = dept_range_full.replace('$', '')
                            dept_value = method2_condition_ranges.get('dept_value', '财务部')
                            edu_range_full = method2_condition_ranges.get('edu_range', 'E1:E7')
                            edu_range_clean = edu_range_full.replace('$', '')
                            edu_value = method2_condition_ranges.get('edu_value', '本科')
                            
                            # Check for condition patterns (allow variations with/without $, different quote types)
                            gender_patterns = [
                                rf'{re.escape(gender_range_full)}\s*=\s*["\']{re.escape(gender_value)}["\']',
                                rf'{re.escape(gender_range_clean)}\s*=\s*["\']{re.escape(gender_value)}["\']',
                                rf'{re.escape(gender_range_full)}\s*=\s*{re.escape(gender_value)}',
                                rf'{re.escape(gender_range_clean)}\s*=\s*{re.escape(gender_value)}',
                            ]
                            dept_patterns = [
                                rf'{re.escape(dept_range_full)}\s*=\s*["\']{re.escape(dept_value)}["\']',
                                rf'{re.escape(dept_range_clean)}\s*=\s*["\']{re.escape(dept_value)}["\']',
                                rf'{re.escape(dept_range_full)}\s*=\s*{re.escape(dept_value)}',
                                rf'{re.escape(dept_range_clean)}\s*=\s*{re.escape(dept_value)}',
                            ]
                            edu_patterns = [
                                rf'{re.escape(edu_range_full)}\s*=\s*["\']{re.escape(edu_value)}["\']',
                                rf'{re.escape(edu_range_clean)}\s*=\s*["\']{re.escape(edu_value)}["\']',
                                rf'{re.escape(edu_range_full)}\s*=\s*{re.escape(edu_value)}',
                                rf'{re.escape(edu_range_clean)}\s*=\s*{re.escape(edu_value)}',
                            ]
                            
                            gender_found = any(re.search(p, formula_text, re.IGNORECASE) for p in gender_patterns)
                            dept_found = any(re.search(p, formula_text, re.IGNORECASE) for p in dept_patterns)
                            edu_found = any(re.search(p, formula_text, re.IGNORECASE) for p in edu_patterns)
                            
                            if not (gender_found and dept_found and edu_found):
                                logger.warning(f"Cell {method2_cell} formula does not contain all three conditions")
                                logger.debug(f"  Gender found: {gender_found}, Dept found: {dept_found}, Edu found: {edu_found}")
                                logger.debug(f"  Formula: {formula_text}")
                                method2_passed = False
                            else:
                                # Check for multiplication operator (*) between conditions
                                if '*' not in formula_text:
                                    logger.warning(f"Cell {method2_cell} formula does not use multiplication for AND logic")
                                    method2_passed = False
                                else:
                                    # Check parentheses balance
                                    open_count = formula_text.count('(')
                                    close_count = formula_text.count(')')
                                    if open_count != close_count:
                                        logger.warning(f"Cell {method2_cell} formula has mismatched parentheses")
                                        method2_passed = False
                                    else:
                                        method2_passed = True
                                        logger.info(f"✓ Method 2 passed: FILTER formula is correct")
                                        
        except Exception as e:
            logger.warning(f"Method 2 check failed: {e}")
            import traceback
            logger.error(traceback.format_exc())
            method2_passed = False
        
        # Return 1.0 if EITHER method passes
        logger.info("=" * 60)
        if method1_passed:
            logger.info("✓ Verification passed: Method 1 (IFERROR(INDEX(SMALL(IF(...))))) is correct")
            logger.info("=" * 60)
            return 1.0
        elif method2_passed:
            logger.info("✓ Verification passed: Method 2 (FILTER) is correct")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("✗ Verification failed: Neither method passed")
            logger.error(f"  Method 1 (IFERROR(INDEX(SMALL(IF(...))))): {'PASSED' if method1_passed else 'FAILED'}")
            logger.error(f"  Method 2 (FILTER): {'PASSED' if method2_passed else 'FAILED'}")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_vlookup_groupby_scan(result: str, expected: str = None, **options) -> float:
    """
    Verify if VLOOKUP with GROUPBY, SCAN, RIGHT, CONCAT formula exists in specified cell.
    
    This function checks:
    1. Whether the specified cell contains a VLOOKUP formula
    2. Whether the formula contains GROUPBY, SCAN, RIGHT, CONCAT, and SUM functions
    3. Whether VLOOKUP references the correct lookup value (e.g., A7)
    4. Whether SCAN function references the correct range (e.g., B2:B4)
    5. Whether RIGHT function extracts correct number of characters (e.g., 3)
    6. Whether GROUPBY references the correct sum range (e.g., D2:D4)
    7. Whether VLOOKUP col_index is correct (e.g., 2)
    8. Whether the formula structure is correct: VLOOKUP(lookup_value, GROUPBY(RIGHT(SCAN(...), n), sum_range, SUM), col_index,)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_cell: Cell to check (e.g., "B7")
            - expected_functions: List of expected function names (default: ["VLOOKUP", "GROUPBY", "SCAN", "RIGHT", "CONCAT", "SUM"])
            - vlookup_lookup_value: VLOOKUP lookup value cell (e.g., "A7")
            - scan_range: SCAN range reference (e.g., "B2:B4")
            - right_num_chars: Number of characters for RIGHT function (default: 3)
            - groupby_sum_range: GROUPBY sum range reference (e.g., "D2:D4")
            - vlookup_col_index: VLOOKUP column index (default: 2)
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_cell = options.get('check_cell', 'B7')
        expected_functions = options.get('expected_functions', ['VLOOKUP', 'GROUPBY', 'SCAN', 'RIGHT', 'CONCAT', 'SUM'])
        vlookup_lookup_value = options.get('vlookup_lookup_value', 'A7')
        scan_range = options.get('scan_range', 'B2:B4')
        right_num_chars = options.get('right_num_chars', 3)
        groupby_sum_range = options.get('groupby_sum_range', 'D2:D4')
        vlookup_col_index = options.get('vlookup_col_index', 2)
        
        logger.info(f"Verifying VLOOKUP(GROUPBY(SCAN)) formula in file: {result}")
        logger.info(f"Cell to check: {check_cell}")
        logger.info(f"Expected functions: {expected_functions}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Get the cell to check
        try:
            cell = ws[check_cell]
        except Exception as e:
            logger.error(f"Failed to access cell {check_cell}: {e}")
            return 0.0
        
        # Check if cell contains a formula
        if cell.data_type != "f":
            logger.error(f"Cell {check_cell} does not contain a formula")
            return 0.0
        
        # Get formula text
        formula_text = None
        if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
            formula_text = cell._value
        elif hasattr(cell, "formula"):
            formula_text = cell.formula
        elif cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
            formula_text = cell.value
        
        if formula_text is None:
            logger.error(f"Could not extract formula from cell {check_cell}")
            return 0.0
        
        formula_upper = formula_text.upper()
        logger.info(f"Cell {check_cell} formula: {formula_text}")
        
        # Check 1: Formula contains all expected functions
        for func in expected_functions:
            func_pattern = rf'\b{func}\s*\('
            if not re.search(func_pattern, formula_upper):
                logger.error(f"Cell {check_cell} formula does not contain {func} function")
                logger.error(f"Formula: {formula_text}")
                return 0.0
        
        # Check 2: VLOOKUP structure - VLOOKUP(lookup_value, table_array, col_index, [range_lookup])
        vlookup_pattern = r'\bVLOOKUP\s*\('
        if not re.search(vlookup_pattern, formula_upper):
            logger.error(f"Cell {check_cell} formula does not contain VLOOKUP function")
            return 0.0
        
        # Check 3: VLOOKUP references the correct lookup value
        vlookup_lookup_clean = vlookup_lookup_value.replace('$', '')
        vlookup_lookup_patterns = [
            re.escape(vlookup_lookup_value),  # A7
            re.escape(vlookup_lookup_clean),  # A7 (if no $)
            rf'\${re.escape(vlookup_lookup_clean)}',  # $A7
            rf'{re.escape(vlookup_lookup_clean)}\$',  # A$7
            rf'\${re.escape(vlookup_lookup_clean)}\$',  # $A$7
        ]
        vlookup_lookup_found = False
        # Find VLOOKUP opening parenthesis and check first parameter
        vlookup_match = re.search(r'VLOOKUP\s*\(', formula_text, re.IGNORECASE)
        if vlookup_match:
            # Extract the first parameter after VLOOKUP(
            start_pos = vlookup_match.end()
            # Find the first comma or closing parenthesis
            end_pos = start_pos
            paren_count = 0
            while end_pos < len(formula_text):
                if formula_text[end_pos] == '(':
                    paren_count += 1
                elif formula_text[end_pos] == ')':
                    if paren_count == 0:
                        break
                    paren_count -= 1
                elif formula_text[end_pos] == ',' and paren_count == 0:
                    break
                end_pos += 1
            
            first_param = formula_text[start_pos:end_pos].strip()
            for pattern in vlookup_lookup_patterns:
                if re.search(pattern, first_param, re.IGNORECASE):
                    vlookup_lookup_found = True
                    break
        
        if not vlookup_lookup_found:
            logger.warning(f"Cell {check_cell} formula may not reference VLOOKUP lookup value {vlookup_lookup_value}")
            logger.warning(f"Formula: {formula_text}")
            # Don't fail here, as the lookup value might be in a different format
        
        # Check 4: SCAN function structure - SCAN(initial_value, array, function)
        scan_pattern = r'\bSCAN\s*\('
        if not re.search(scan_pattern, formula_upper):
            logger.error(f"Cell {check_cell} formula does not contain SCAN function")
            return 0.0
        
        # Check 5: SCAN references the correct range
        scan_range_clean = scan_range.replace('$', '')
        scan_range_patterns = [
            re.escape(scan_range),  # B2:B4
            re.escape(scan_range_clean),  # B2:B4 (if no $)
        ]
        # Also check for variations with different $ placements
        scan_range_parts = scan_range_clean.split(':')
        if len(scan_range_parts) == 2:
            scan_range_patterns.extend([
                rf'\${re.escape(scan_range_parts[0])}\s*:\s*\${re.escape(scan_range_parts[1])}',  # $B2:$B4
                rf'{re.escape(scan_range_parts[0])}\s*:\s*\${re.escape(scan_range_parts[1])}',  # B2:$B4
                rf'\${re.escape(scan_range_parts[0])}\s*:\s*{re.escape(scan_range_parts[1])}',  # $B2:B4
            ])
        
        scan_range_found = False
        for pattern in scan_range_patterns:
            if re.search(pattern, formula_text, re.IGNORECASE):
                scan_range_found = True
                break
        
        if not scan_range_found:
            logger.warning(f"Cell {check_cell} formula may not reference SCAN range {scan_range}")
            logger.warning(f"Formula: {formula_text}")
            # Don't fail here, as the range might be in a different format
        
        # Check 6: RIGHT function structure - RIGHT(text, num_chars)
        right_pattern = r'\bRIGHT\s*\('
        if not re.search(right_pattern, formula_upper):
            logger.error(f"Cell {check_cell} formula does not contain RIGHT function")
            return 0.0
        
        # Check 7: RIGHT extracts correct number of characters
        # Look for RIGHT(..., 3) or RIGHT(...,3) pattern
        right_num_patterns = [
            rf'RIGHT\s*\([^,)]+,\s*{right_num_chars}\s*\)',  # RIGHT(..., 3)
            rf'RIGHT\s*\([^,)]+,{right_num_chars}\s*\)',  # RIGHT(...,3)
        ]
        right_num_found = False
        for pattern in right_num_patterns:
            if re.search(pattern, formula_upper):
                right_num_found = True
                break
        
        if not right_num_found:
            logger.warning(f"Cell {check_cell} formula may not use RIGHT with {right_num_chars} characters")
            logger.warning(f"Formula: {formula_text}")
            # Don't fail here, as the number might be in a different format
        
        # Check 8: CONCAT function in SCAN
        concat_pattern = r'\bCONCAT\s*\('
        if not re.search(concat_pattern, formula_upper):
            logger.error(f"Cell {check_cell} formula does not contain CONCAT function")
            return 0.0
        
        # Check 9: GROUPBY function structure - GROUPBY(rows, values, function)
        groupby_pattern = r'\bGROUPBY\s*\('
        if not re.search(groupby_pattern, formula_upper):
            logger.error(f"Cell {check_cell} formula does not contain GROUPBY function")
            return 0.0
        
        # Check 10: GROUPBY references the correct sum range
        groupby_sum_range_clean = groupby_sum_range.replace('$', '')
        groupby_sum_range_patterns = [
            re.escape(groupby_sum_range),  # D2:D4
            re.escape(groupby_sum_range_clean),  # D2:D4 (if no $)
        ]
        # Also check for variations with different $ placements
        groupby_sum_range_parts = groupby_sum_range_clean.split(':')
        if len(groupby_sum_range_parts) == 2:
            groupby_sum_range_patterns.extend([
                rf'\${re.escape(groupby_sum_range_parts[0])}\s*:\s*\${re.escape(groupby_sum_range_parts[1])}',  # $D2:$D4
                rf'{re.escape(groupby_sum_range_parts[0])}\s*:\s*\${re.escape(groupby_sum_range_parts[1])}',  # D2:$D4
                rf'\${re.escape(groupby_sum_range_parts[0])}\s*:\s*{re.escape(groupby_sum_range_parts[1])}',  # $D2:D4
            ])
        
        groupby_sum_range_found = False
        for pattern in groupby_sum_range_patterns:
            if re.search(pattern, formula_text, re.IGNORECASE):
                groupby_sum_range_found = True
                break
        
        if not groupby_sum_range_found:
            logger.warning(f"Cell {check_cell} formula may not reference GROUPBY sum range {groupby_sum_range}")
            logger.warning(f"Formula: {formula_text}")
            # Don't fail here, as the range might be in a different format
        
        # Check 11: SUM function in GROUPBY
        sum_pattern = r'\bSUM\s*\('
        if not re.search(sum_pattern, formula_upper):
            logger.error(f"Cell {check_cell} formula does not contain SUM function")
            return 0.0
        
        # Check 12: VLOOKUP col_index is correct
        # Look for VLOOKUP(..., ..., 2, ...) pattern
        # This is tricky because GROUPBY is the second parameter, so we need to find the col_index after GROUPBY closes
        # For simplicity, we'll check if the number 2 appears in the context of VLOOKUP
        vlookup_col_index_patterns = [
            rf'VLOOKUP\s*\([^,)]+,\s*[^,)]+,\s*{vlookup_col_index}\s*,',  # VLOOKUP(..., ..., 2,)
            rf'VLOOKUP\s*\([^,)]+,\s*[^,)]+,\s*{vlookup_col_index}\s*\)',  # VLOOKUP(..., ..., 2)
        ]
        vlookup_col_index_found = False
        for pattern in vlookup_col_index_patterns:
            if re.search(pattern, formula_upper):
                vlookup_col_index_found = True
                break
        
        if not vlookup_col_index_found:
            logger.warning(f"Cell {check_cell} formula may not use VLOOKUP col_index {vlookup_col_index}")
            logger.warning(f"Formula: {formula_text}")
            # Don't fail here, as the col_index might be in a different format
        
        # Check 13: Formula structure - VLOOKUP should contain GROUPBY which contains RIGHT(SCAN(...))
        # Check that GROUPBY is inside VLOOKUP
        vlookup_groupby_pattern = r'VLOOKUP\s*\([^,)]+,\s*GROUPBY\s*\('
        if not re.search(vlookup_groupby_pattern, formula_upper):
            logger.warning(f"Cell {check_cell} formula may not have correct VLOOKUP(GROUPBY(...)) structure")
            logger.warning(f"Formula: {formula_text}")
            # Don't fail here, as the structure might be correct but formatted differently
        
        # Check 14: RIGHT should contain SCAN
        right_scan_pattern = r'RIGHT\s*\(\s*SCAN\s*\('
        if not re.search(right_scan_pattern, formula_upper):
            logger.warning(f"Cell {check_cell} formula may not have correct RIGHT(SCAN(...)) structure")
            logger.warning(f"Formula: {formula_text}")
            # Don't fail here, as the structure might be correct but formatted differently
        
        # Check 15: Formula closes parentheses correctly
        open_count = formula_text.count('(')
        close_count = formula_text.count(')')
        if open_count != close_count:
            logger.error(f"Cell {check_cell} formula has mismatched parentheses")
            logger.error(f"Formula: {formula_text}")
            return 0.0
        
        logger.info("=" * 60)
        logger.info(f"✓ VLOOKUP(GROUPBY(SCAN)) formula verification passed")
        logger.info(f"Cell {check_cell} contains correct formula structure")
        logger.info("=" * 60)
        return 1.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_sum_vlookup_index(result: str, expected: str = None, **options) -> float:
    """
    Verify if SUM with VLOOKUP and INDEX formula exists in specified cell.
    
    This function checks:
    1. Whether the specified cell contains a SUM formula
    2. Whether the formula contains VLOOKUP and INDEX functions
    3. Whether VLOOKUP references the correct lookup value (e.g., "客户1")
    4. Whether VLOOKUP references the correct table array (e.g., B2:D3)
    5. Whether VLOOKUP col_index is correct (e.g., 3)
    6. Whether VLOOKUP range_lookup is correct (e.g., 0 for exact match)
    7. Whether INDEX references the correct array (e.g., D2:D3)
    8. Whether INDEX row_num is correct (e.g., 2)
    9. Whether the formula structure is correct: SUM(VLOOKUP(...), INDEX(...))
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_cell: Cell to check (e.g., "B7")
            - expected_functions: List of expected function names (default: ["SUM", "VLOOKUP", "INDEX"])
            - vlookup_lookup_value: VLOOKUP lookup value (e.g., "\"客户1\"")
            - vlookup_table_array: VLOOKUP table array (e.g., "B2:D3")
            - vlookup_col_index: VLOOKUP column index (default: 3)
            - vlookup_range_lookup: VLOOKUP range lookup (default: 0 for exact match)
            - index_array: INDEX array reference (e.g., "D2:D3")
            - index_row_num: INDEX row number (default: 2)
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_cell = options.get('check_cell', 'B7')
        expected_functions = options.get('expected_functions', ['SUM', 'VLOOKUP', 'INDEX'])
        vlookup_lookup_value = options.get('vlookup_lookup_value', '"客户1"')
        vlookup_table_array = options.get('vlookup_table_array', 'B2:D3')
        vlookup_col_index = options.get('vlookup_col_index', 3)
        vlookup_range_lookup = options.get('vlookup_range_lookup', 0)
        index_array = options.get('index_array', 'D2:D3')
        index_row_num = options.get('index_row_num', 2)
        
        logger.info(f"Verifying SUM(VLOOKUP, INDEX) formula in file: {result}")
        logger.info(f"Cell to check: {check_cell}")
        logger.info(f"Expected functions: {expected_functions}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Get the cell to check
        try:
            cell = ws[check_cell]
        except Exception as e:
            logger.error(f"Failed to access cell {check_cell}: {e}")
            return 0.0
        
        # Check if cell contains a formula
        if cell.data_type != "f":
            logger.error(f"Cell {check_cell} does not contain a formula")
            return 0.0
        
        # Get formula text
        formula_text = None
        if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
            formula_text = cell._value
        elif hasattr(cell, "formula"):
            formula_text = cell.formula
        elif cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
            formula_text = cell.value
        
        if formula_text is None:
            logger.error(f"Could not extract formula from cell {check_cell}")
            return 0.0
        
        formula_upper = formula_text.upper()
        logger.info(f"Cell {check_cell} formula: {formula_text}")
        
        # Check 1: Formula contains all expected functions
        for func in expected_functions:
            func_pattern = rf'\b{func}\s*\('
            if not re.search(func_pattern, formula_upper):
                logger.error(f"Cell {check_cell} formula does not contain {func} function")
                logger.error(f"Formula: {formula_text}")
                return 0.0
        
        # Check 2: SUM structure - SUM(value1, value2)
        sum_pattern = r'\bSUM\s*\('
        if not re.search(sum_pattern, formula_upper):
            logger.error(f"Cell {check_cell} formula does not contain SUM function")
            return 0.0
        
        # Check 3: VLOOKUP structure - VLOOKUP(lookup_value, table_array, col_index, range_lookup)
        vlookup_pattern = r'\bVLOOKUP\s*\('
        if not re.search(vlookup_pattern, formula_upper):
            logger.error(f"Cell {check_cell} formula does not contain VLOOKUP function")
            return 0.0
        
        # Check 4: VLOOKUP references the correct lookup value
        # Remove quotes from lookup value for pattern matching
        vlookup_lookup_clean = vlookup_lookup_value.strip('"').strip("'")
        vlookup_lookup_patterns = [
            re.escape(vlookup_lookup_value),  # "客户1"
            rf'["\']{re.escape(vlookup_lookup_clean)}["\']',  # "客户1" or '客户1'
            re.escape(vlookup_lookup_clean),  # 客户1 (without quotes)
        ]
        vlookup_lookup_found = False
        for pattern in vlookup_lookup_patterns:
            if re.search(pattern, formula_text, re.IGNORECASE):
                vlookup_lookup_found = True
                break
        
        if not vlookup_lookup_found:
            logger.warning(f"Cell {check_cell} formula may not reference VLOOKUP lookup value {vlookup_lookup_value}")
            logger.warning(f"Formula: {formula_text}")
            # Don't fail here, as the lookup value might be in a different format
        
        # Check 5: VLOOKUP references the correct table array
        vlookup_table_array_clean = vlookup_table_array.replace('$', '')
        vlookup_table_array_patterns = [
            re.escape(vlookup_table_array),  # B2:D3
            re.escape(vlookup_table_array_clean),  # B2:D3 (if no $)
        ]
        # Also check for variations with different $ placements
        vlookup_table_array_parts = vlookup_table_array_clean.split(':')
        if len(vlookup_table_array_parts) == 2:
            vlookup_table_array_patterns.extend([
                rf'\${re.escape(vlookup_table_array_parts[0])}\s*:\s*\${re.escape(vlookup_table_array_parts[1])}',  # $B2:$D3
                rf'{re.escape(vlookup_table_array_parts[0])}\s*:\s*\${re.escape(vlookup_table_array_parts[1])}',  # B2:$D3
                rf'\${re.escape(vlookup_table_array_parts[0])}\s*:\s*{re.escape(vlookup_table_array_parts[1])}',  # $B2:D3
            ])
        
        vlookup_table_array_found = False
        for pattern in vlookup_table_array_patterns:
            if re.search(pattern, formula_text, re.IGNORECASE):
                vlookup_table_array_found = True
                break
        
        if not vlookup_table_array_found:
            logger.warning(f"Cell {check_cell} formula may not reference VLOOKUP table array {vlookup_table_array}")
            logger.warning(f"Formula: {formula_text}")
            # Don't fail here, as the range might be in a different format
        
        # Check 6: VLOOKUP col_index is correct
        # Look for VLOOKUP(..., ..., 3, ...) pattern
        vlookup_col_index_patterns = [
            rf'VLOOKUP\s*\([^,)]+,\s*[^,)]+,\s*{vlookup_col_index}\s*,',  # VLOOKUP(..., ..., 3,)
            rf'VLOOKUP\s*\([^,)]+,\s*[^,)]+,\s*{vlookup_col_index}\s*\)',  # VLOOKUP(..., ..., 3)
        ]
        vlookup_col_index_found = False
        for pattern in vlookup_col_index_patterns:
            if re.search(pattern, formula_upper):
                vlookup_col_index_found = True
                break
        
        if not vlookup_col_index_found:
            logger.warning(f"Cell {check_cell} formula may not use VLOOKUP col_index {vlookup_col_index}")
            logger.warning(f"Formula: {formula_text}")
            # Don't fail here, as the col_index might be in a different format
        
        # Check 7: VLOOKUP range_lookup is correct (0 for exact match)
        vlookup_range_lookup_patterns = [
            rf'VLOOKUP\s*\([^,)]+,\s*[^,)]+,\s*[^,)]+,\s*{vlookup_range_lookup}\s*\)',  # VLOOKUP(..., ..., ..., 0)
            rf'VLOOKUP\s*\([^,)]+,\s*[^,)]+,\s*[^,)]+,\s*{vlookup_range_lookup}\s*,',  # VLOOKUP(..., ..., ..., 0,)
            rf'VLOOKUP\s*\([^,)]+,\s*[^,)]+,\s*[^,)]+,\s*FALSE\s*\)',  # VLOOKUP(..., ..., ..., FALSE)
        ]
        vlookup_range_lookup_found = False
        for pattern in vlookup_range_lookup_patterns:
            if re.search(pattern, formula_upper):
                vlookup_range_lookup_found = True
                break
        
        if not vlookup_range_lookup_found:
            logger.warning(f"Cell {check_cell} formula may not use VLOOKUP range_lookup {vlookup_range_lookup}")
            logger.warning(f"Formula: {formula_text}")
            # Don't fail here, as the range_lookup might be in a different format
        
        # Check 8: INDEX structure - INDEX(array, row_num, [column_num])
        index_pattern = r'\bINDEX\s*\('
        if not re.search(index_pattern, formula_upper):
            logger.error(f"Cell {check_cell} formula does not contain INDEX function")
            return 0.0
        
        # Check 9: INDEX references the correct array
        index_array_clean = index_array.replace('$', '')
        index_array_patterns = [
            re.escape(index_array),  # D2:D3
            re.escape(index_array_clean),  # D2:D3 (if no $)
        ]
        # Also check for variations with different $ placements
        index_array_parts = index_array_clean.split(':')
        if len(index_array_parts) == 2:
            index_array_patterns.extend([
                rf'\${re.escape(index_array_parts[0])}\s*:\s*\${re.escape(index_array_parts[1])}',  # $D2:$D3
                rf'{re.escape(index_array_parts[0])}\s*:\s*\${re.escape(index_array_parts[1])}',  # D2:$D3
                rf'\${re.escape(index_array_parts[0])}\s*:\s*{re.escape(index_array_parts[1])}',  # $D2:D3
            ])
        
        index_array_found = False
        for pattern in index_array_patterns:
            if re.search(pattern, formula_text, re.IGNORECASE):
                index_array_found = True
                break
        
        if not index_array_found:
            logger.warning(f"Cell {check_cell} formula may not reference INDEX array {index_array}")
            logger.warning(f"Formula: {formula_text}")
            # Don't fail here, as the range might be in a different format
        
        # Check 10: INDEX row_num is correct
        # Look for INDEX(..., 2) or INDEX(..., 2, ...) pattern
        index_row_num_patterns = [
            rf'INDEX\s*\([^,)]+,\s*{index_row_num}\s*\)',  # INDEX(..., 2)
            rf'INDEX\s*\([^,)]+,\s*{index_row_num}\s*,',  # INDEX(..., 2,)
        ]
        index_row_num_found = False
        for pattern in index_row_num_patterns:
            if re.search(pattern, formula_upper):
                index_row_num_found = True
                break
        
        if not index_row_num_found:
            logger.warning(f"Cell {check_cell} formula may not use INDEX row_num {index_row_num}")
            logger.warning(f"Formula: {formula_text}")
            # Don't fail here, as the row_num might be in a different format
        
        # Check 11: Formula structure - SUM should contain VLOOKUP and INDEX
        # Check that VLOOKUP is inside SUM
        sum_vlookup_pattern = r'SUM\s*\(\s*VLOOKUP\s*\('
        if not re.search(sum_vlookup_pattern, formula_upper):
            logger.warning(f"Cell {check_cell} formula may not have correct SUM(VLOOKUP(...)) structure")
            logger.warning(f"Formula: {formula_text}")
            # Don't fail here, as the structure might be correct but formatted differently
        
        # Check 12: INDEX should be inside SUM
        sum_index_pattern = r'SUM\s*\([^,)]+,\s*INDEX\s*\('
        if not re.search(sum_index_pattern, formula_upper):
            logger.warning(f"Cell {check_cell} formula may not have correct SUM(..., INDEX(...)) structure")
            logger.warning(f"Formula: {formula_text}")
            # Don't fail here, as the structure might be correct but formatted differently
        
        # Check 13: Formula closes parentheses correctly
        open_count = formula_text.count('(')
        close_count = formula_text.count(')')
        if open_count != close_count:
            logger.error(f"Cell {check_cell} formula has mismatched parentheses")
            logger.error(f"Formula: {formula_text}")
            return 0.0
        
        logger.info("=" * 60)
        logger.info(f"✓ SUM(VLOOKUP, INDEX) formula verification passed")
        logger.info(f"Cell {check_cell} contains correct formula structure")
        logger.info("=" * 60)
        return 1.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_concatenate_cells(result: str, expected: str = None, **options) -> float:
    """
    Verify if at least one cell in the worksheet contains a formula that concatenates A1 and B1.
    
    This function checks:
    1. Whether at least one cell in the worksheet contains a formula
    2. Whether the formula uses & operator to concatenate A1 and B1 (e.g., =A1&B1)
    3. OR whether the formula uses CONCATENATE function to merge A1 and B1 (e.g., =CONCATENATE(A1,B1))
    4. Whether the formula references the correct source cells (A1 and B1)
    
    The function searches through all cells in the worksheet to find at least one matching formula.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - source_cell1: First source cell to concatenate (default: "A1")
            - source_cell2: Second source cell to concatenate (default: "B1")
    
    Returns:
        float: 1.0 if at least one cell contains correct concatenation formula, 0.0 otherwise
    """
    try:
        import re
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        source_cell1 = options.get('source_cell1', 'A1')
        source_cell2 = options.get('source_cell2', 'B1')
        
        logger.info(f"Verifying concatenate formulas in file: {result}")
        logger.info(f"Looking for formulas that concatenate {source_cell1} and {source_cell2}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Search through all cells in the worksheet
        found_formula = False
        found_cell = None
        found_formula_text = None
        
        # Get the maximum row and column with data
        max_row = ws.max_row
        max_col = ws.max_column
        
        logger.info(f"Searching through worksheet (max_row={max_row}, max_col={max_col})")
        
        # Search all cells
        for row in range(1, max_row + 1):
            for col in range(1, max_col + 1):
                cell = ws.cell(row=row, column=col)
                cell_coord = f"{get_column_letter(col)}{row}"
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                else:
                    if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                
                if formula_text is None:
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Checking cell {cell_coord} formula: {formula_text}")
                
                # Check for two patterns:
                # Pattern 1: =A1&B1 (using & operator)
                # Pattern 2: =CONCATENATE(A1,B1) (using CONCATENATE function)
                
                # Pattern 1: Check for & operator concatenation
                # Match patterns like: =A1&B1, =$A$1&$B$1, =A1 & B1, etc.
                # Remove $ signs for matching
                source_cell1_clean = source_cell1.replace('$', '')
                source_cell2_clean = source_cell2.replace('$', '')
                formula_clean = formula_text.replace('$', '')
                
                # Pattern 1: & operator
                # Match: A1&B1 or A1 & B1 (with optional spaces)
                ampersand_pattern = rf'\b{re.escape(source_cell1_clean)}\s*&\s*{re.escape(source_cell2_clean)}\b'
                if re.search(ampersand_pattern, formula_clean, re.IGNORECASE):
                    found_formula = True
                    found_cell = cell_coord
                    found_formula_text = formula_text
                    logger.info(f"Found & operator concatenation in cell {cell_coord}: {formula_text}")
                    break
                
                # Pattern 2: CONCATENATE function
                # Match: =CONCATENATE(A1,B1) or =CONCATENATE(A1, B1) (with optional spaces)
                concatenate_pattern = rf'\bCONCATENATE\s*\(\s*{re.escape(source_cell1_clean)}\s*,\s*{re.escape(source_cell2_clean)}\s*\)'
                if re.search(concatenate_pattern, formula_clean, re.IGNORECASE):
                    found_formula = True
                    found_cell = cell_coord
                    found_formula_text = formula_text
                    logger.info(f"Found CONCATENATE function in cell {cell_coord}: {formula_text}")
                    break
            
            if found_formula:
                break
        
        if found_formula:
            logger.info("=" * 60)
            logger.info(f"✓ Concatenate formula verification passed")
            logger.info(f"Found formula in cell {found_cell}: {found_formula_text}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error("✗ Verification failed: No cell found with concatenation formula")
            logger.error(f"Expected formula: ={source_cell1}&{source_cell2} or =CONCATENATE({source_cell1},{source_cell2})")
            logger.error("=" * 60)
            return 0.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_lookup_date_match(result: str, expected: str = None, **options) -> float:
    """
    Verify if LOOKUP formulas exist in specified range with correct structure.
    
    This function checks:
    1. Whether cells in specified range contain formulas
    2. Whether formulas contain LOOKUP function
    3. Whether LOOKUP lookup_value references the correct column and row (e.g., $I3, $I4)
    4. Whether LOOKUP lookup_array is correct (e.g., $A:$A)
    5. Whether LOOKUP result_vector references the correct column based on mapping (K->C, L->D, M->E, N->F, O->G)
    6. Whether formula structure is correct: LOOKUP(lookup_value, lookup_array, result_vector)
    
    The function automatically detects the number of data rows by checking for non-empty cells
    in the specified range. It stops checking after finding 3 consecutive empty rows.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_range: Range to check (e.g., "K3:O217")
            - lookup_value_col: Column letter for LOOKUP lookup value (default: "I")
            - lookup_array: LOOKUP lookup array range (default: "$A:$A")
            - result_col_mapping: Dictionary mapping result columns to source columns (e.g., {"K": "C", "L": "D"})
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_range = options.get('check_range', 'K3:O217')
        lookup_value_col = options.get('lookup_value_col', 'I')
        lookup_array = options.get('lookup_array', '$A:$A')
        result_col_mapping = options.get('result_col_mapping', {
            'K': 'C',
            'L': 'D',
            'M': 'E',
            'N': 'F',
            'O': 'G'
        })
        
        logger.info(f"Verifying LOOKUP formulas in file: {result}")
        logger.info(f"Range to check: {check_range}")
        logger.info(f"Lookup value column: {lookup_value_col}")
        logger.info(f"Lookup array: {lookup_array}")
        logger.info(f"Result column mapping: {result_col_mapping}")
        
        # Parse the range manually
        try:
            # Remove $ signs and split by :
            range_clean = check_range.replace('$', '')
            if ':' in range_clean:
                start_cell, end_cell = range_clean.split(':')
                # Parse start cell
                start_col_letter = ''.join([c for c in start_cell if c.isalpha()])
                start_row = int(''.join([c for c in start_cell if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                # Parse end cell
                end_col_letter = ''.join([c for c in end_cell if c.isalpha()])
                end_row = int(''.join([c for c in end_cell if c.isdigit()]))
                end_col = column_index_from_string(end_col_letter)
            else:
                # Single cell
                start_col_letter = ''.join([c for c in range_clean if c.isalpha()])
                start_row = int(''.join([c for c in range_clean if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                end_col_letter = start_col_letter
                end_row = start_row
                end_col = start_col
        except Exception as e:
            logger.error(f"Failed to parse range {check_range}: {e}")
            return 0.0
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Auto-detect end row by checking for consecutive empty rows
        logger.info(f"Auto-detecting end row in range {check_range}...")
        detected_end_row = start_row
        empty_count = 0
        
        for row_num in range(start_row, end_row + 1):
            has_data = False
            for col_num in range(start_col, end_col + 1):
                col_letter = get_column_letter(col_num)
                cell = ws[f"{col_letter}{row_num}"]
                if cell.value is not None or (cell.data_type == "f"):
                    has_data = True
                    break
            
            if has_data:
                empty_count = 0
                detected_end_row = row_num
            else:
                empty_count += 1
                if empty_count >= 3:
                    break
        
        logger.info(f"Auto-detected end row: {detected_end_row}")
        actual_end_row = min(detected_end_row, end_row)
        
        # Check each cell in the range
        all_passed = True
        checked_count = 0
        passed_count = 0
        
        for row_num in range(start_row, actual_end_row + 1):
            for col_num in range(start_col, end_col + 1):
                col_letter = get_column_letter(col_num)
                cell_coord = f"{col_letter}{row_num}"
                
                try:
                    cell = ws[cell_coord]
                    checked_count += 1
                    
                    # Check if cell contains a formula
                    if cell.data_type != "f":
                        logger.warning(f"Cell {cell_coord} does not contain a formula")
                        all_passed = False
                        continue
                    
                    # Get formula text
                    formula_text = None
                    if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                        formula_text = cell._value
                    elif hasattr(cell, "formula"):
                        formula_text = cell.formula
                    else:
                        if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                            formula_text = cell.value
                    
                    if formula_text is None:
                        logger.warning(f"Could not extract formula from cell {cell_coord}")
                        all_passed = False
                        continue
                    
                    formula_upper = formula_text.upper()
                    logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                    
                    # Check 1: Formula contains LOOKUP function
                    lookup_pattern = r'\bLOOKUP\s*\('
                    if not re.search(lookup_pattern, formula_upper):
                        logger.warning(f"Cell {cell_coord} formula does not contain LOOKUP function")
                        logger.warning(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 2: LOOKUP lookup_value references the correct column and row
                    # Should be $I{row_num} or I{row_num} (with optional $)
                    lookup_value_patterns = [
                        rf'\${re.escape(lookup_value_col)}{row_num}\b',  # $I3
                        rf'{re.escape(lookup_value_col)}{row_num}\b',   # I3
                        rf'\${re.escape(lookup_value_col)}\${row_num}\b',  # $I$3
                    ]
                    lookup_value_found = False
                    for pattern in lookup_value_patterns:
                        if re.search(pattern, formula_text, re.IGNORECASE):
                            lookup_value_found = True
                            break
                    
                    if not lookup_value_found:
                        logger.warning(f"Cell {cell_coord} formula LOOKUP lookup_value does not reference {lookup_value_col}{row_num}")
                        logger.warning(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 3: LOOKUP lookup_array is correct (e.g., $A:$A)
                    lookup_array_pattern = re.escape(lookup_array).replace('\\$', '\\$?')
                    if not re.search(lookup_array_pattern, formula_text, re.IGNORECASE):
                        logger.warning(f"Cell {cell_coord} formula LOOKUP lookup_array does not reference {lookup_array}")
                        logger.warning(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 4: LOOKUP result_vector references the correct column based on mapping
                    # Get expected result column from mapping
                    if col_letter.upper() not in result_col_mapping:
                        logger.warning(f"Cell {cell_coord} column {col_letter} not in result_col_mapping")
                        all_passed = False
                        continue
                    
                    expected_result_col = result_col_mapping[col_letter.upper()]
                    # Should be {expected_result_col}:{expected_result_col} (e.g., C:C, D:D)
                    result_vector_patterns = [
                        rf'\b{re.escape(expected_result_col)}:{re.escape(expected_result_col)}\b',  # C:C
                        rf'\${re.escape(expected_result_col)}:\${re.escape(expected_result_col)}\b',  # $C:$C
                    ]
                    result_vector_found = False
                    for pattern in result_vector_patterns:
                        if re.search(pattern, formula_text, re.IGNORECASE):
                            result_vector_found = True
                            break
                    
                    if not result_vector_found:
                        logger.warning(f"Cell {cell_coord} formula LOOKUP result_vector does not reference {expected_result_col}:{expected_result_col}")
                        logger.warning(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 5: Formula structure is LOOKUP(lookup_value, lookup_array, result_vector)
                    # Extract LOOKUP parameters
                    lookup_match = re.search(r'LOOKUP\s*\(', formula_text, re.IGNORECASE)
                    if lookup_match:
                        # Find the parameters
                        start_pos = lookup_match.end()
                        # Count parentheses to find the end of LOOKUP function
                        paren_count = 1
                        pos = start_pos
                        while pos < len(formula_text) and paren_count > 0:
                            if formula_text[pos] == '(':
                                paren_count += 1
                            elif formula_text[pos] == ')':
                                paren_count -= 1
                            pos += 1
                        
                        if paren_count != 0:
                            logger.warning(f"Cell {cell_coord} formula LOOKUP has mismatched parentheses")
                            all_passed = False
                            continue
                    
                    # All checks passed for this cell
                    passed_count += 1
                    logger.debug(f"✓ Cell {cell_coord} passed verification")
                    
                except Exception as e:
                    logger.warning(f"Error checking cell {cell_coord}: {e}")
                    all_passed = False
                    continue
        
        # Calculate pass rate
        if checked_count == 0:
            logger.error("No cells were checked")
            return 0.0
        
        pass_rate = passed_count / checked_count
        logger.info(f"Checked {checked_count} cells, {passed_count} passed (pass rate: {pass_rate:.2%})")
        
        # Require at least 90% pass rate
        if pass_rate >= 0.9:
            logger.info("=" * 60)
            logger.info(f"✓ LOOKUP formula verification passed")
            logger.info(f"Pass rate: {pass_rate:.2%}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ LOOKUP formula verification failed")
            logger.error(f"Pass rate: {pass_rate:.2%} (required: >= 90%)")
            logger.error("=" * 60)
            return 0.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_index_column_row_transform(result: str, expected: str = None, **options) -> float:
    """
    Verify if INDEX formula with COLUMN and ROW functions exists in specified range to transform single column data into two columns.
    
    This function STRICTLY checks ALL cells in the specified range - no tolerance, no auto-detection.
    Every single cell in the specified range must contain the correct formula.
    
    This function checks:
    1. Whether ALL cells in the specified formula range (e.g., F2:G25) contain formulas
    2. Whether formulas contain INDEX, COLUMN, and ROW functions
    3. Whether INDEX references the correct source column (e.g., $A:$A)
    4. Whether formulas have the correct structure: =INDEX($A:$A,COLUMN(A1)+ROW(A1)*2-1)&""
    5. Whether COLUMN and ROW functions use relative references (A1 pattern)
    6. Whether formula includes &"" concatenation
    
    The formula =INDEX($A:$A,COLUMN(A1)+ROW(A1)*2-1)&"" works as follows:
    - INDEX($A:$A, ...) extracts data from column A
    - COLUMN(A1) returns 1 (column A is column 1), but when copied to G column, it becomes COLUMN(B1)=2
    - ROW(A1) returns the row number of the current cell (F2: ROW(A1)=1, F3: ROW(A2)=2)
    - COLUMN(A1)+ROW(A1)*2-1 calculates the index: F2=1+1*2-1=2 (A2), G2=2+1*2-1=3 (A3), F3=1+2*2-1=4 (A4)
    - &"" ensures the result is text format
    - This transforms A column data into F and G columns, with every two A rows corresponding to one F-G row
    
    IMPORTANT: This function checks ALL cells in the specified formula range. If any cell is missing a formula, verification fails.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formula_range: Range containing formulas (e.g., "F2:G25") - ALL cells must have formulas
            - source_column: Source column for INDEX function (default: "A")
            - expected_formula_pattern: Expected formula pattern (default: "=INDEX($A:$A,COLUMN(A1)+ROW(A1)*2-1)&\"\"")
            - expected_functions: List of expected function names (default: ["INDEX", "COLUMN", "ROW"])
    
    Returns:
        float: 1.0 if ALL cells in specified range contain correct formulas, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formula_range = options.get('formula_range', 'F2:G25')
        source_column = options.get('source_column', 'A')
        expected_functions = options.get('expected_functions', ['INDEX', 'COLUMN', 'ROW'])
        
        logger.info(f"Verifying INDEX(COLUMN+ROW) transform formula in file: {result}")
        logger.info(f"Formula range: {formula_range}")
        logger.info(f"Source column: {source_column}")
        
        # Parse the formula range
        try:
            range_clean = formula_range.replace("$", "")
            if ":" in range_clean:
                start_cell, end_cell = range_clean.split(":")
                start_col_letter = "".join([c for c in start_cell if c.isalpha()])
                start_row = int("".join([c for c in start_cell if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                end_col_letter = "".join([c for c in end_cell if c.isalpha()])
                end_row = int("".join([c for c in end_cell if c.isdigit()]))
                end_col = column_index_from_string(end_col_letter)
            else:
                logger.error(f"Invalid range format: {formula_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse range {formula_range}: {e}")
            return 0.0
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=False)
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check 1: Verify ALL cells in formula range contain formulas
        logger.info(f"Checking all cells in range {formula_range} (rows {start_row} to {end_row}, columns {start_col} to {end_col})")
        
        all_passed = True
        checked_count = 0
        passed_count = 0
        
        for row_num in range(start_row, end_row + 1):
            for col_num in range(start_col, end_col + 1):
                col_letter = get_column_letter(col_num)
                cell_coord = f"{col_letter}{row_num}"
                
                try:
                    cell = ws[cell_coord]
                    checked_count += 1
                    
                    # Check if cell contains a formula
                    if cell.data_type != "f":
                        logger.error(f"Cell {cell_coord} does not contain a formula")
                        all_passed = False
                        continue
                    
                    # Get formula text
                    formula_text = None
                    if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                        formula_text = cell._value
                    elif hasattr(cell, "formula"):
                        formula_text = cell.formula
                    elif cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                    
                    if formula_text is None:
                        logger.error(f"Could not extract formula from cell {cell_coord}")
                        all_passed = False
                        continue
                    
                    formula_upper = formula_text.upper()
                    logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                    
                    # Check 1: Formula contains all expected functions
                    for func_name in expected_functions:
                        func_pattern = rf'\b{re.escape(func_name.upper())}\s*\('
                        if not re.search(func_pattern, formula_upper):
                            logger.error(f"Cell {cell_coord} formula does not contain {func_name} function")
                            logger.error(f"Formula: {formula_text}")
                            all_passed = False
                            break
                    
                    if not all_passed:
                        continue
                    
                    # Check 2: Formula contains INDEX function
                    index_pattern = r'\bINDEX\s*\('
                    if not re.search(index_pattern, formula_upper):
                        logger.error(f"Cell {cell_coord} formula does not contain INDEX function")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 3: INDEX references the correct source column (e.g., $A:$A)
                    source_col_patterns = [
                        rf'\$\s*{re.escape(source_column.upper())}\s*:\s*\$\s*{re.escape(source_column.upper())}',
                        rf'\$\s*{re.escape(source_column.upper())}\s*:\s*{re.escape(source_column.upper())}',
                        rf'{re.escape(source_column.upper())}\s*:\s*\$\s*{re.escape(source_column.upper())}',
                        rf'{re.escape(source_column.upper())}\s*:\s*{re.escape(source_column.upper())}',
                    ]
                    source_col_found = False
                    for pattern in source_col_patterns:
                        if re.search(pattern, formula_upper):
                            source_col_found = True
                            break
                    
                    if not source_col_found:
                        logger.error(f"Cell {cell_coord} formula INDEX does not reference ${source_column}:${source_column}")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 4: Formula contains COLUMN function
                    column_pattern = r'\bCOLUMN\s*\('
                    if not re.search(column_pattern, formula_upper):
                        logger.error(f"Cell {cell_coord} formula does not contain COLUMN function")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 5: COLUMN function uses relative reference (A1 pattern, not $A$1)
                    # Look for COLUMN(A1), COLUMN(B1), etc. (relative reference)
                    column_ref_pattern = r'COLUMN\s*\(\s*[A-Z]+\d+\s*\)'
                    if not re.search(column_ref_pattern, formula_upper):
                        logger.error(f"Cell {cell_coord} formula COLUMN does not use relative reference (A1 pattern)")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 6: Formula contains ROW function
                    row_pattern = r'\bROW\s*\('
                    if not re.search(row_pattern, formula_upper):
                        logger.error(f"Cell {cell_coord} formula does not contain ROW function")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 7: ROW function uses relative reference (A1 pattern, not $A$1)
                    row_ref_pattern = r'ROW\s*\(\s*[A-Z]+\d+\s*\)'
                    if not re.search(row_ref_pattern, formula_upper):
                        logger.error(f"Cell {cell_coord} formula ROW does not use relative reference (A1 pattern)")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 8: Formula contains the pattern COLUMN(...)+ROW(...)*2-1
                    # This pattern calculates the index: COLUMN(A1)+ROW(A1)*2-1
                    index_calc_pattern = r'COLUMN\s*\([^)]+\)\s*\+\s*ROW\s*\([^)]+\)\s*\*\s*2\s*-\s*1'
                    if not re.search(index_calc_pattern, formula_upper):
                        logger.error(f"Cell {cell_coord} formula does not contain COLUMN(...)+ROW(...)*2-1 pattern")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    # Check 9: Formula contains &"" concatenation (optional but common)
                    # This is flexible - some formulas might not have it
                    concat_pattern = r'&\s*""'
                    has_concat = re.search(concat_pattern, formula_upper)
                    if not has_concat:
                        logger.debug(f"Cell {cell_coord} formula does not contain &\"\" concatenation (optional)")
                    
                    # Check 10: Formula structure is INDEX($A:$A,COLUMN(A1)+ROW(A1)*2-1)&""
                    # Verify the overall structure
                    # INDEX should be followed by source column, then the calculation
                    index_structure_pattern = r'INDEX\s*\(\s*\$\s*[A-Z]+\s*:\s*\$\s*[A-Z]+\s*,\s*COLUMN\s*\([^)]+\)\s*\+\s*ROW\s*\([^)]+\)\s*\*\s*2\s*-\s*1'
                    if not re.search(index_structure_pattern, formula_upper):
                        logger.error(f"Cell {cell_coord} formula does not have correct INDEX structure")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        continue
                    
                    passed_count += 1
                    logger.debug(f"✓ Cell {cell_coord} has valid formula: {formula_text}")
                    
                except Exception as e:
                    logger.error(f"Error checking cell {cell_coord}: {e}")
                    all_passed = False
        
        if not all_passed:
            logger.error("=" * 60)
            logger.error(f"✗ INDEX(COLUMN+ROW) transform formula verification failed")
            logger.error(f"Some cells in range {formula_range} are missing formulas or have incorrect formulas")
            logger.error("=" * 60)
            return 0.0
        
        # Calculate pass rate
        if checked_count == 0:
            logger.error("No cells were checked")
            return 0.0
        
        pass_rate = passed_count / checked_count
        logger.info(f"Checked {checked_count} cells, {passed_count} passed (pass rate: {pass_rate:.2%})")
        
        # Require 100% pass rate (all cells must have correct formulas)
        if pass_rate == 1.0:
            logger.info("=" * 60)
            logger.info(f"✓ INDEX(COLUMN+ROW) transform formula verification passed")
            logger.info(f"All {checked_count} cells in range {formula_range} contain correct formulas")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ INDEX(COLUMN+ROW) transform formula verification failed")
            logger.error(f"Pass rate: {pass_rate:.2%} (required: 100%)")
            logger.error("=" * 60)
            return 0.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_count_find_conditional_formatting(result: str, expected: str = None, **options) -> float:
    """
    Verify if conditional formatting with COUNT(FIND(...)) formulas exists in specified range with font colors.
    
    This function checks:
    1. Whether the specified range (e.g., D1:D44) has conditional formatting
    2. Whether there are two conditional formatting rules:
       - Condition 1: COUNT(FIND("罗江",D1)) with red font color
       - Condition 2: COUNT(FIND("中江",D1)) with blue font color
    3. Whether both conditions apply to the specified range
    4. Whether the font colors match the expected colors (red and blue)
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_range: Range to check (e.g., "D1:D44")
            - condition1_formula_pattern: Expected formula pattern for condition 1 (default: 'COUNT(FIND("罗江",D1))')
            - condition1_font_color: Expected font color for condition 1 (default: "red")
            - condition2_formula_pattern: Expected formula pattern for condition 2 (default: 'COUNT(FIND("中江",D1))')
            - condition2_font_color: Expected font color for condition 2 (default: "blue")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        from openpyxl.worksheet.cell_range import CellRange
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_range = options.get('check_range', 'D1:D44')
        condition1_formula_pattern = options.get('condition1_formula_pattern', 'COUNT(FIND("罗江",D1))')
        condition1_font_color = options.get('condition1_font_color', 'red')
        condition2_formula_pattern = options.get('condition2_formula_pattern', 'COUNT(FIND("中江",D1))')
        condition2_font_color = options.get('condition2_font_color', 'blue')
        
        logger.info(f"Verifying conditional formatting in file: {result}")
        logger.info(f"Range to check: {check_range}")
        logger.info(f"Condition 1: {condition1_formula_pattern} -> {condition1_font_color}")
        logger.info(f"Condition 2: {condition2_formula_pattern} -> {condition2_font_color}")
        
        # Parse the range
        try:
            range_clean = check_range.replace('$', '')
            if ':' in range_clean:
                start_cell, end_cell = range_clean.split(':')
                # Parse start cell
                start_col_letter = ''.join([c for c in start_cell if c.isalpha()])
                start_row = int(''.join([c for c in start_cell if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                # Parse end cell
                end_col_letter = ''.join([c for c in end_cell if c.isalpha()])
                end_row = int(''.join([c for c in end_cell if c.isdigit()]))
                end_col = column_index_from_string(end_col_letter)
            else:
                logger.error(f"Invalid range format: {check_range}. Expected format like 'D1:D44'")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse range {check_range}: {e}")
            return 0.0
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=False)
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check conditional formatting
        conditional_formattings = ws.conditional_formatting
        
        if not conditional_formattings:
            logger.error("No conditional formatting found in worksheet")
            return 0.0
        
        found_condition1 = False
        found_condition2 = False
        condition1_range_cells = None
        condition2_range_cells = None
        
        # Helper function to check if color matches
        def check_font_color(font_color_obj, expected_color_name):
            """Check if font color matches expected color name"""
            if font_color_obj is None or not hasattr(font_color_obj, 'rgb'):
                logger.debug(f"Font color object is None or has no rgb attribute")
                return False
            
            color_rgb = font_color_obj.rgb
            if color_rgb is None:
                logger.debug(f"Font color RGB is None")
                return False
            
            color_str = str(color_rgb).upper()
            logger.debug(f"Checking color: {color_str} against {expected_color_name}")
            
            # Convert color name to RGB values
            if expected_color_name.lower() == 'red':
                # Red: high red, low green, low blue
                if len(color_str) >= 6:
                    if len(color_str) == 8:
                        r_val = int(color_str[2:4], 16)
                        g_val = int(color_str[4:6], 16)
                        b_val = int(color_str[6:8], 16)
                    elif len(color_str) == 6:
                        r_val = int(color_str[0:2], 16)
                        g_val = int(color_str[2:4], 16)
                        b_val = int(color_str[4:6], 16)
                    else:
                        logger.debug(f"Unexpected color string length: {len(color_str)}")
                        return False
                    # Red: R > 200, G < 100, B < 100
                    is_red = r_val > 200 and g_val < 100 and b_val < 100
                    logger.debug(f"Red check: RGB({r_val}, {g_val}, {b_val}) -> {is_red}")
                    return is_red
            elif expected_color_name.lower() == 'blue':
                # Blue: low red, low green, high blue
                if len(color_str) >= 6:
                    if len(color_str) == 8:
                        r_val = int(color_str[2:4], 16)
                        g_val = int(color_str[4:6], 16)
                        b_val = int(color_str[6:8], 16)
                    elif len(color_str) == 6:
                        r_val = int(color_str[0:2], 16)
                        g_val = int(color_str[2:4], 16)
                        b_val = int(color_str[4:6], 16)
                    else:
                        logger.debug(f"Unexpected color string length: {len(color_str)}")
                        return False
                    # Blue: R < 100, G < 100, B > 200 (relaxed: allow some tolerance)
                    is_blue = r_val < 150 and g_val < 150 and b_val > 150
                    logger.debug(f"Blue check: RGB({r_val}, {g_val}, {b_val}) -> {is_blue}")
                    return is_blue
            
            logger.debug(f"Color name {expected_color_name} not recognized")
            return False
        
        # Check each conditional formatting rule
        for fmt in conditional_formattings:
            # Check if this formatting applies to any cell in our target range
            fmt_applies_to_range = False
            for rge in fmt.cells:
                # Check if this range overlaps with our target range
                cf_start_col = rge.min_col
                cf_start_row = rge.min_row
                cf_end_col = rge.max_col
                cf_end_row = rge.max_row
                
                # Check if ranges overlap
                if not (cf_end_col < start_col or cf_start_col > end_col or 
                        cf_end_row < start_row or cf_start_row > end_row):
                    fmt_applies_to_range = True
                    break
            
            if not fmt_applies_to_range:
                continue
            
            # Check each rule in this formatting
            for r in fmt.rules:
                # Check formula
                if not r.formula:
                    continue
                
                formula_text = r.formula[0] if isinstance(r.formula, list) else str(r.formula)
                formula_upper = formula_text.upper()
                
                logger.debug(f"Found conditional formatting formula: {formula_text}")
                
                # Check if formula contains COUNT and FIND
                count_pattern = r'\bCOUNT\s*\('
                find_pattern = r'\bFIND\s*\('
                
                if not re.search(count_pattern, formula_upper) or not re.search(find_pattern, formula_upper):
                    logger.debug(f"Formula does not contain COUNT(FIND(...)): {formula_text}")
                    continue
                
                # Check font color
                font_color = None
                if r.dxf and r.dxf.font:
                    try:
                        if r.dxf.font.color:
                            font_color = r.dxf.font.color
                    except:
                        pass
                
                if font_color is None:
                    logger.debug(f"Conditional formatting rule has no font color")
                    continue
                
                # Get font color RGB for debugging
                font_color_rgb = None
                if font_color and hasattr(font_color, 'rgb'):
                    font_color_rgb = font_color.rgb
                logger.debug(f"Font color RGB: {font_color_rgb}")
                
                # Check condition 1: COUNT(FIND("罗江",D1))
                # Pattern: COUNT(FIND("罗江",D1)) or COUNT(FIND("罗江",D$1)) etc.
                # Use original formula_text (not uppercase) for Chinese character matching
                condition1_match = re.search(r'COUNT\s*\(\s*FIND\s*\(\s*["\'""]罗江["\'""]\s*,\s*D\$?\d+\s*\)\s*\)', formula_text, re.IGNORECASE)
                
                if condition1_match:
                    color_match = check_font_color(font_color, condition1_font_color)
                    logger.debug(f"Condition 1 match: formula={condition1_match is not None}, color={color_match}")
                    if color_match:
                        found_condition1 = True
                        condition1_range_cells = rge
                        logger.info(f"✓ Found condition 1: {formula_text} -> {condition1_font_color}")
                        # Don't continue here, check condition 2 as well
                
                # Check condition 2: COUNT(FIND("中江",D1))
                # Use original formula_text (not uppercase) for Chinese character matching
                condition2_match = re.search(r'COUNT\s*\(\s*FIND\s*\(\s*["\'""]中江["\'""]\s*,\s*D\$?\d+\s*\)\s*\)', formula_text, re.IGNORECASE)
                
                if condition2_match:
                    color_match = check_font_color(font_color, condition2_font_color)
                    logger.debug(f"Condition 2 match: formula={condition2_match is not None}, color={color_match}")
                    if color_match:
                        found_condition2 = True
                        condition2_range_cells = rge
                        logger.info(f"✓ Found condition 2: {formula_text} -> {condition2_font_color}")
                        # Don't continue here, both conditions might be in separate rules
        
        # Verify both conditions are found
        if not found_condition1:
            logger.error("=" * 60)
            logger.error("✗ Condition 1 not found")
            logger.error(f"  Expected: {condition1_formula_pattern} -> {condition1_font_color}")
            logger.error("=" * 60)
            return 0.0
        
        if not found_condition2:
            logger.error("=" * 60)
            logger.error("✗ Condition 2 not found")
            logger.error(f"  Expected: {condition2_formula_pattern} -> {condition2_font_color}")
            logger.error("=" * 60)
            return 0.0
        
        # Verify that both conditions apply to the target range
        if condition1_range_cells:
            cf_start_col = condition1_range_cells.min_col
            cf_start_row = condition1_range_cells.min_row
            cf_end_col = condition1_range_cells.max_col
            cf_end_row = condition1_range_cells.max_row
            
            if cf_start_col > start_col or cf_end_col < end_col or \
               cf_start_row > start_row or cf_end_row < end_row:
                logger.error("=" * 60)
                logger.error("✗ Condition 1 range does not fully cover target range")
                logger.error(f"  Target range: {check_range} (cols {start_col}-{end_col}, rows {start_row}-{end_row})")
                logger.error(f"  CF range: cols {cf_start_col}-{cf_end_col}, rows {cf_start_row}-{cf_end_row}")
                logger.error("=" * 60)
                return 0.0
        
        if condition2_range_cells:
            cf_start_col = condition2_range_cells.min_col
            cf_start_row = condition2_range_cells.min_row
            cf_end_col = condition2_range_cells.max_col
            cf_end_row = condition2_range_cells.max_row
            
            if cf_start_col > start_col or cf_end_col < end_col or \
               cf_start_row > start_row or cf_end_row < end_row:
                logger.error("=" * 60)
                logger.error("✗ Condition 2 range does not fully cover target range")
                logger.error(f"  Target range: {check_range} (cols {start_col}-{end_col}, rows {start_row}-{end_row})")
                logger.error(f"  CF range: cols {cf_start_col}-{cf_end_col}, rows {cf_start_row}-{cf_end_row}")
                logger.error("=" * 60)
                return 0.0
        
        logger.info("=" * 60)
        logger.info(f"✓ Conditional formatting verification passed")
        logger.info(f"  - Condition 1: {condition1_formula_pattern} -> {condition1_font_color} ✓")
        logger.info(f"  - Condition 2: {condition2_formula_pattern} -> {condition2_font_color} ✓")
        logger.info(f"  - Range: {check_range}")
        logger.info("=" * 60)
        return 1.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_sumpRODUCT_multi_condition_sum(result: str, expected: str = None, **options) -> float:
    """
    Verify if SUMPRODUCT formulas with multiple conditions exist in specified range for multi-condition summing.
    
    This function STRICTLY checks ALL cells in the specified range - no tolerance, no auto-detection.
    Every single cell in the specified range must contain the correct formula.
    
    This function checks:
    1. Whether ALL cells in the specified range (e.g., H3:H4) contain formulas
    2. Whether formulas contain SUMPRODUCT, ISNUMBER, SEARCH, TRIM, LOOKUP, and ROW functions
    3. Whether SEARCH function references the correct column with relative row (e.g., F3, F4)
    4. Whether LOOKUP function references the correct range (e.g., A$2:A$9)
    5. Whether TRIM function is used for both search and match conditions
    6. Whether match condition references the correct columns (B$2:B$9 and G3, G4)
    7. Whether sum range references the correct range (e.g., C$2:C$9)
    8. Whether formula structure is correct: SUMPRODUCT(ISNUMBER(SEARCH(...))*(TRIM(...)=TRIM(...))*...)
    
    IMPORTANT: This function checks ALL cells in the specified ranges, regardless of whether they
    appear to be empty. If any cell in the specified range is missing a formula, verification fails.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_range: Range to check (e.g., "H3:H4") - ALL cells must have formulas
            - expected_functions: List of expected function names (default: ["SUMPRODUCT", "ISNUMBER", "SEARCH", "TRIM", "LOOKUP", "ROW"])
            - lookup_range: LOOKUP range reference (default: "A$2:A$9")
            - search_col: Column letter for SEARCH criteria (default: "F")
            - match_col: Column letter for match condition (default: "B")
            - match_col_ref: Column letter for match reference (default: "G")
            - sum_range: Sum range reference (default: "C$2:C$9")
    
    Returns:
        float: 1.0 if ALL cells in specified range contain correct formulas, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_range = options.get('check_range', 'H3:H4')
        expected_functions = options.get('expected_functions', ['SUMPRODUCT', 'ISNUMBER', 'SEARCH', 'TRIM', 'LOOKUP', 'ROW'])
        lookup_range = options.get('lookup_range', 'A$2:A$9')
        search_col = options.get('search_col', 'F')
        match_col = options.get('match_col', 'B')
        match_col_ref = options.get('match_col_ref', 'G')
        sum_range = options.get('sum_range', 'C$2:C$9')
        
        logger.info(f"Verifying SUMPRODUCT multi-condition sum formulas in file: {result}")
        logger.info(f"Range to check: {check_range}")
        logger.info(f"Expected functions: {expected_functions}")
        
        # Parse the range - strictly use the specified range
        try:
            range_clean = check_range.replace('$', '')
            if ':' in range_clean:
                start_cell, end_cell = range_clean.split(':')
                start_col_letter = ''.join([c for c in start_cell if c.isalpha()])
                start_row = int(''.join([c for c in start_cell if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                end_col_letter = ''.join([c for c in end_cell if c.isalpha()])
                end_row = int(''.join([c for c in end_cell if c.isdigit()]))
                end_col = column_index_from_string(end_col_letter)
            else:
                logger.error(f"Invalid range format: {check_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse range {check_range}: {e}")
            return 0.0
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Strictly check ALL cells in the specified range - no auto-detection
        logger.info(f"Checking all cells in range {check_range} (rows {start_row} to {end_row})")
        
        all_passed = True
        checked_count = 0
        passed_count = 0
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{start_col_letter}{row_num}"
            expected_search_cell = f"{search_col}{row_num}"
            expected_match_cell = f"{match_col_ref}{row_num}"
            
            try:
                cell = ws[cell_coord]
                checked_count += 1
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.warning(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                else:
                    if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains all expected functions
                for func in expected_functions:
                    func_pattern = rf'\b{func}\s*\('
                    if not re.search(func_pattern, formula_upper):
                        logger.warning(f"Cell {cell_coord} formula does not contain {func} function")
                        logger.warning(f"Formula: {formula_text}")
                        all_passed = False
                        break
                
                if not all_passed:
                    continue
                
                # Check 2: Formula contains SUMPRODUCT function
                sumproduct_pattern = r'\bSUMPRODUCT\s*\('
                if not re.search(sumproduct_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not contain SUMPRODUCT function")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: Formula contains ISNUMBER(SEARCH(...)) structure
                isnumber_search_pattern = r'\bISNUMBER\s*\(\s*SEARCH\s*\('
                if not re.search(isnumber_search_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not contain ISNUMBER(SEARCH(...)) structure")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: SEARCH function references the correct column with relative row (F3, F4, etc.)
                # Allow variations: F3, $F3, F$3, $F$3
                escaped_search_cell = re.escape(expected_search_cell)
                escaped_search_col = re.escape(search_col)
                search_cell_patterns = [
                    rf'\b{escaped_search_cell}\b',  # F3
                    rf'\${escaped_search_col}{row_num}\b',  # $F3
                    rf'\b{escaped_search_col}\${row_num}\b',  # F$3
                    rf'\${escaped_search_col}\${row_num}\b',  # $F$3
                ]
                
                search_cell_found = False
                for pattern in search_cell_patterns:
                    if re.search(pattern, formula_text, re.IGNORECASE):
                        search_cell_found = True
                        break
                
                if not search_cell_found:
                    logger.warning(f"Cell {cell_coord} formula does not reference search cell {expected_search_cell}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 5: LOOKUP function references the correct range (A$2:A$9)
                # Allow variations: A$2:A$9, $A$2:$A$9, A2:A9, $A2:$A9, A$2:$A$9, $A$2:A$9
                # Extract column and row info from lookup_range (e.g., "A$2:A$9" -> "A", "2", "9")
                lookup_parts = re.match(r'([A-Z]+)\$?(\d+):([A-Z]+)\$?(\d+)', lookup_range, re.IGNORECASE)
                if lookup_parts:
                    lookup_col = lookup_parts.group(1)
                    lookup_start_row = lookup_parts.group(2)
                    lookup_end_row = lookup_parts.group(4)
                    # Match any combination of $ placement
                    lookup_range_patterns = [
                        rf'\$?{re.escape(lookup_col)}\$?{lookup_start_row}\s*:\s*\$?{re.escape(lookup_col)}\$?{lookup_end_row}',
                    ]
                else:
                    # Fallback to exact match
                    lookup_range_patterns = [
                        rf'\b{re.escape(lookup_range)}\b',
                    ]
                
                lookup_range_found = False
                for pattern in lookup_range_patterns:
                    if re.search(pattern, formula_text, re.IGNORECASE):
                        lookup_range_found = True
                        break
                
                if not lookup_range_found:
                    logger.warning(f"Cell {cell_coord} formula does not reference LOOKUP range {lookup_range}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 6: Formula contains TRIM function for both search and match
                trim_pattern = r'\bTRIM\s*\('
                trim_matches = len(re.findall(trim_pattern, formula_upper))
                if trim_matches < 2:
                    logger.warning(f"Cell {cell_coord} formula should contain at least 2 TRIM functions")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 7: Match condition references the correct columns (B$2:B$9 and G3, G4, etc.)
                # Check for B$2:B$9 or similar patterns
                # Allow various combinations: B$2:B$9, $B$2:$B$9, B2:B9, $B2:$B9, B$2:$B$9, $B$2:B$9
                match_range_patterns = [
                    rf'\$?{re.escape(match_col)}\$?\d+\s*:\s*\$?{re.escape(match_col)}\$?\d+',
                ]
                
                match_range_found = False
                for pattern in match_range_patterns:
                    if re.search(pattern, formula_text, re.IGNORECASE):
                        match_range_found = True
                        break
                
                if not match_range_found:
                    logger.warning(f"Cell {cell_coord} formula does not reference match range with column {match_col}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check for G3, G4, etc. in match condition
                escaped_match_cell = re.escape(expected_match_cell)
                escaped_match_col_ref = re.escape(match_col_ref)
                match_cell_patterns = [
                    rf'\b{escaped_match_cell}\b',  # G3
                    rf'\${escaped_match_col_ref}{row_num}\b',  # $G3
                    rf'\b{escaped_match_col_ref}\${row_num}\b',  # G$3
                    rf'\${escaped_match_col_ref}\${row_num}\b',  # $G$3
                ]
                
                match_cell_found = False
                for pattern in match_cell_patterns:
                    if re.search(pattern, formula_text, re.IGNORECASE):
                        match_cell_found = True
                        break
                
                if not match_cell_found:
                    logger.warning(f"Cell {cell_coord} formula does not reference match cell {expected_match_cell}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 8: Sum range references the correct range (C$2:C$9)
                # Allow variations: C$2:C$9, $C$2:$C$9, C2:C9, $C2:$C9, C$2:$C$9, $C$2:C$9
                # Extract column and row info from sum_range (e.g., "C$2:C$9" -> "C", "2", "9")
                sum_parts = re.match(r'([A-Z]+)\$?(\d+):([A-Z]+)\$?(\d+)', sum_range, re.IGNORECASE)
                if sum_parts:
                    sum_col = sum_parts.group(1)
                    sum_start_row = sum_parts.group(2)
                    sum_end_row = sum_parts.group(4)
                    # Match any combination of $ placement
                    sum_range_patterns = [
                        rf'\$?{re.escape(sum_col)}\$?{sum_start_row}\s*:\s*\$?{re.escape(sum_col)}\$?{sum_end_row}',
                    ]
                else:
                    # Fallback to exact match
                    sum_range_patterns = [
                        rf'\b{re.escape(sum_range)}\b',
                    ]
                
                sum_range_found = False
                for pattern in sum_range_patterns:
                    if re.search(pattern, formula_text, re.IGNORECASE):
                        sum_range_found = True
                        break
                
                if not sum_range_found:
                    logger.warning(f"Cell {cell_coord} formula does not reference sum range {sum_range}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 9: Formula structure contains multiplication operators (*) for conditions
                # Should have at least 2 multiplication operators for the conditions
                mult_count = formula_text.count('*')
                if mult_count < 2:
                    logger.warning(f"Cell {cell_coord} formula should contain multiplication operators for conditions")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 10: Formula closes parentheses correctly
                open_count = formula_text.count('(')
                close_count = formula_text.count(')')
                if open_count != close_count:
                    logger.warning(f"Cell {cell_coord} formula has mismatched parentheses")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                passed_count += 1
                logger.info(f"✓ Cell {cell_coord} formula verification passed")
                
            except Exception as e:
                logger.warning(f"Error checking cell {cell_coord}: {e}")
                all_passed = False
                continue
        
        if not all_passed or checked_count == 0:
            logger.error("=" * 60)
            logger.error(f"✗ SUMPRODUCT multi-condition sum verification failed")
            logger.error(f"  Checked: {checked_count} cells")
            logger.error(f"  Passed: {passed_count} cells")
            logger.error(f"  Range: {check_range}")
            logger.error("=" * 60)
            return 0.0
        
        if passed_count != checked_count:
            logger.error("=" * 60)
            logger.error(f"✗ Not all cells passed verification")
            logger.error(f"  Checked: {checked_count} cells")
            logger.error(f"  Passed: {passed_count} cells")
            logger.error(f"  Range: {check_range}")
            logger.error("=" * 60)
            return 0.0
        
        logger.info("=" * 60)
        logger.info(f"✓ SUMPRODUCT multi-condition sum verification passed")
        logger.info(f"  - Checked: {checked_count} cells")
        logger.info(f"  - Passed: {passed_count} cells")
        logger.info(f"  - Range: {check_range}")
        logger.info("=" * 60)
        return 1.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_sumpRODUCT_mmult_find_hours_sum(result: str, expected: str = None, **options) -> float:
    """
    Verify if SUMPRODUCT(MMULT(1-ISERR(FIND(...)))) formulas exist in specified range for summing hours when multiple names exist in cells.
    
    This function STRICTLY checks ALL cells in the specified range - no tolerance, no auto-detection.
    Every single cell in the specified range must contain the correct formula.
    
    This function checks:
    1. Whether ALL cells in the specified range (e.g., C18:C22) contain formulas
    2. Whether formulas contain SUMPRODUCT, MMULT, ISERR, FIND, and ROW functions
    3. Whether FIND function references the correct column with relative row (e.g., B18, B19, B20, etc.)
    4. Whether FIND function references the correct search range (e.g., B$2:J$11)
    5. Whether MMULT function contains 1-ISERR(FIND(...)) structure
    6. Whether MMULT function contains ROW($1:$9)^0 structure
    7. Whether SUMPRODUCT function references the correct sum range (e.g., M$1:M$10)
    8. Whether formula structure is correct: SUMPRODUCT(MMULT(1-ISERR(FIND(B18,B$2:J$11)),ROW($1:$9)^0),M$1:M$10)
    
    IMPORTANT: This function checks ALL cells in the specified ranges, regardless of whether they
    appear to be empty. If any cell in the specified range is missing a formula, verification fails.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_range: Range to check (e.g., "C18:C22") - ALL cells must have formulas
            - expected_functions: List of expected function names (default: ["SUMPRODUCT", "MMULT", "ISERR", "FIND", "ROW"])
            - find_criteria_col: Column letter for FIND criteria (default: "B")
            - find_search_range: FIND search range reference (default: "B$2:J$11")
            - row_range: ROW range reference (default: "$1:$9")
            - sum_range: Sum range reference (default: "M$1:M$10")
    
    Returns:
        float: 1.0 if ALL cells in specified range contain correct formulas, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_range = options.get('check_range', 'C18:C22')
        expected_functions = options.get('expected_functions', ['SUMPRODUCT', 'MMULT', 'ISERR', 'FIND', 'ROW'])
        find_criteria_col = options.get('find_criteria_col', 'B')
        find_search_range = options.get('find_search_range', 'B$2:J$11')
        row_range = options.get('row_range', '$1:$9')
        sum_range = options.get('sum_range', 'M$1:M$10')
        
        logger.info(f"Verifying SUMPRODUCT(MMULT(FIND)) hours sum formulas in file: {result}")
        logger.info(f"Range to check: {check_range}")
        logger.info(f"Expected functions: {expected_functions}")
        
        # Parse the range - strictly use the specified range
        try:
            range_clean = check_range.replace('$', '')
            if ':' in range_clean:
                start_cell, end_cell = range_clean.split(':')
                start_col_letter = ''.join([c for c in start_cell if c.isalpha()])
                start_row = int(''.join([c for c in start_cell if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                end_col_letter = ''.join([c for c in end_cell if c.isalpha()])
                end_row = int(''.join([c for c in end_cell if c.isdigit()]))
                end_col = column_index_from_string(end_col_letter)
            else:
                logger.error(f"Invalid range format: {check_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse range {check_range}: {e}")
            return 0.0
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Strictly check ALL cells in the specified range - no auto-detection
        logger.info(f"Checking all cells in range {check_range} (rows {start_row} to {end_row})")
        
        all_passed = True
        checked_count = 0
        passed_count = 0
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{start_col_letter}{row_num}"
            expected_find_cell = f"{find_criteria_col}{row_num}"
            
            try:
                cell = ws[cell_coord]
                checked_count += 1
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.warning(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                else:
                    if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains all expected functions
                for func in expected_functions:
                    func_pattern = rf'\b{func}\s*\('
                    if not re.search(func_pattern, formula_upper):
                        logger.warning(f"Cell {cell_coord} formula does not contain {func} function")
                        logger.warning(f"Formula: {formula_text}")
                        all_passed = False
                        break
                
                if not all_passed:
                    continue
                
                # Check 2: Formula contains SUMPRODUCT function
                sumproduct_pattern = r'\bSUMPRODUCT\s*\('
                if not re.search(sumproduct_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not contain SUMPRODUCT function")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: Formula contains MMULT function
                mmult_pattern = r'\bMMULT\s*\('
                if not re.search(mmult_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not contain MMULT function")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: Formula contains 1-ISERR(FIND(...)) structure
                iserr_find_pattern = r'1\s*-\s*ISERR\s*\(\s*FIND\s*\('
                if not re.search(iserr_find_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not contain 1-ISERR(FIND(...)) structure")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 5: FIND function references the correct cell with relative row (B18, B19, B20, etc.)
                # Allow variations: B18, $B18, B$18, $B$18
                escaped_find_cell = re.escape(expected_find_cell)
                escaped_find_col = re.escape(find_criteria_col)
                find_cell_patterns = [
                    rf'\b{escaped_find_cell}\b',  # B18
                    rf'\${escaped_find_col}{row_num}\b',  # $B18
                    rf'\b{escaped_find_col}\${row_num}\b',  # B$18
                    rf'\${escaped_find_col}\${row_num}\b',  # $B$18
                ]
                
                find_cell_found = False
                for pattern in find_cell_patterns:
                    if re.search(pattern, formula_text, re.IGNORECASE):
                        find_cell_found = True
                        break
                
                if not find_cell_found:
                    logger.warning(f"Cell {cell_coord} formula does not reference FIND criteria cell {expected_find_cell}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 6: FIND function references the correct search range (B$2:J$11)
                # Allow variations: B$2:J$11, $B$2:$J$11, B2:J11, $B2:$J11, etc.
                find_parts = re.match(r'([A-Z]+)\$?(\d+):([A-Z]+)\$?(\d+)', find_search_range, re.IGNORECASE)
                if find_parts:
                    find_start_col = find_parts.group(1)
                    find_start_row = find_parts.group(2)
                    find_end_col = find_parts.group(3)
                    find_end_row = find_parts.group(4)
                    # Match any combination of $ placement
                    find_range_patterns = [
                        rf'\$?{re.escape(find_start_col)}\$?{find_start_row}\s*:\s*\$?{re.escape(find_end_col)}\$?{find_end_row}',
                    ]
                else:
                    # Fallback to exact match
                    find_range_patterns = [
                        rf'\b{re.escape(find_search_range)}\b',
                    ]
                
                find_range_found = False
                for pattern in find_range_patterns:
                    if re.search(pattern, formula_text, re.IGNORECASE):
                        find_range_found = True
                        break
                
                if not find_range_found:
                    logger.warning(f"Cell {cell_coord} formula does not reference FIND search range {find_search_range}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 7: Formula contains ROW($1:$9)^0 structure
                # Allow variations: ROW($1:$9)^0, ROW($1:$9)^ 0, ROW($1:$9) ^0, etc.
                row_parts = re.match(r'\$?(\d+):\$?(\d+)', row_range, re.IGNORECASE)
                if row_parts:
                    row_start = row_parts.group(1)
                    row_end = row_parts.group(2)
                    row_patterns = [
                        rf'ROW\s*\(\s*\$?{row_start}\s*:\s*\$?{row_end}\s*\)\s*\^\s*0',
                    ]
                else:
                    row_patterns = [
                        rf'ROW\s*\(\s*{re.escape(row_range)}\s*\)\s*\^\s*0',
                    ]
                
                row_pattern_found = False
                for pattern in row_patterns:
                    if re.search(pattern, formula_text, re.IGNORECASE):
                        row_pattern_found = True
                        break
                
                if not row_pattern_found:
                    logger.warning(f"Cell {cell_coord} formula does not contain ROW({row_range})^0 structure")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 8: SUMPRODUCT function references the correct sum range (M$1:M$10)
                # Allow variations: M$1:M$10, $M$1:$M$10, M1:M10, $M1:$M10, etc.
                sum_parts = re.match(r'([A-Z]+)\$?(\d+):([A-Z]+)\$?(\d+)', sum_range, re.IGNORECASE)
                if sum_parts:
                    sum_start_col = sum_parts.group(1)
                    sum_start_row = sum_parts.group(2)
                    sum_end_col = sum_parts.group(3)
                    sum_end_row = sum_parts.group(4)
                    # Match any combination of $ placement
                    sum_range_patterns = [
                        rf'\$?{re.escape(sum_start_col)}\$?{sum_start_row}\s*:\s*\$?{re.escape(sum_end_col)}\$?{sum_end_row}',
                    ]
                else:
                    # Fallback to exact match
                    sum_range_patterns = [
                        rf'\b{re.escape(sum_range)}\b',
                    ]
                
                sum_range_found = False
                for pattern in sum_range_patterns:
                    if re.search(pattern, formula_text, re.IGNORECASE):
                        sum_range_found = True
                        break
                
                if not sum_range_found:
                    logger.warning(f"Cell {cell_coord} formula does not reference sum range {sum_range}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 9: Formula structure is SUMPRODUCT(MMULT(...), ...)
                sumproduct_mmult_pattern = r'SUMPRODUCT\s*\(\s*MMULT\s*\('
                if not re.search(sumproduct_mmult_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not have correct SUMPRODUCT(MMULT(...)) structure")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 10: Formula closes parentheses correctly
                open_count = formula_text.count('(')
                close_count = formula_text.count(')')
                if open_count != close_count:
                    logger.warning(f"Cell {cell_coord} formula has mismatched parentheses")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                passed_count += 1
                logger.info(f"✓ Cell {cell_coord} formula verification passed")
                
            except Exception as e:
                logger.warning(f"Error checking cell {cell_coord}: {e}")
                all_passed = False
                continue
        
        if not all_passed or checked_count == 0:
            logger.error("=" * 60)
            logger.error(f"✗ SUMPRODUCT(MMULT(FIND)) hours sum verification failed")
            logger.error(f"  Checked: {checked_count} cells")
            logger.error(f"  Passed: {passed_count} cells")
            logger.error(f"  Range: {check_range}")
            logger.error("=" * 60)
            return 0.0
        
        if passed_count != checked_count:
            logger.error("=" * 60)
            logger.error(f"✗ Not all cells passed verification")
            logger.error(f"  Checked: {checked_count} cells")
            logger.error(f"  Passed: {passed_count} cells")
            logger.error(f"  Range: {check_range}")
            logger.error("=" * 60)
            return 0.0
        
        logger.info("=" * 60)
        logger.info(f"✓ SUMPRODUCT(MMULT(FIND)) hours sum verification passed")
        logger.info(f"  - Checked: {checked_count} cells")
        logger.info(f"  - Passed: {passed_count} cells")
        logger.info(f"  - Range: {check_range}")
        logger.info("=" * 60)
        return 1.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0

def verify_sumpRODUCT_price_extract(result: str, expected: str = None, **options) -> float:
    """
    Verify if SUMPRODUCT formulas exist in specified range for extracting prices by level from price table.
    
    This function STRICTLY checks ALL cells in the specified range - no tolerance, no auto-detection.
    Every single cell in the specified range must contain the correct formula.
    
    This function checks:
    1. Whether ALL cells in the specified range (e.g., C2:C10) contain formulas
    2. Whether formulas contain SUMPRODUCT function
    3. Whether formulas contain first condition: ($F$2:$F$7=$A{row}) with absolute reference F$2:$F$7 and relative reference A column
    4. Whether formulas contain second condition: ($G$1:$J$1=$B{row}) with absolute reference G$1:$J$1 and relative reference B column
    5. Whether formulas contain sum range: $G$2:$J$7 with absolute reference
    6. Whether formula structure is correct: SUMPRODUCT(($F$2:$F$7=$A2)*($G$1:$J$1=$B2)*$G$2:$J$7)
    
    IMPORTANT: This function checks ALL cells in the specified ranges, regardless of whether they
    appear to be empty. If any cell in the specified range is missing a formula, verification fails.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_range: Range to check (e.g., "C2:C10") - ALL cells must have formulas
            - expected_functions: List of expected function names (default: ["SUMPRODUCT"])
            - condition1_range: First condition range (default: "$F$2:$F$7")
            - condition1_col: First condition column reference (default: "A")
            - condition2_range: Second condition range (default: "$G$1:$J$1")
            - condition2_col: Second condition column reference (default: "B")
            - sum_range: Sum range reference (default: "$G$2:$J$7")
    
    Returns:
        float: 1.0 if ALL cells in specified range contain correct formulas, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_range = options.get('check_range', 'C2:C10')
        expected_functions = options.get('expected_functions', ['SUMPRODUCT'])
        condition1_range = options.get('condition1_range', '$F$2:$F$7')
        condition1_col = options.get('condition1_col', 'A')
        condition2_range = options.get('condition2_range', '$G$1:$J$1')
        condition2_col = options.get('condition2_col', 'B')
        sum_range = options.get('sum_range', '$G$2:$J$7')
        
        logger.info(f"Verifying SUMPRODUCT price extract formulas in file: {result}")
        logger.info(f"Range to check: {check_range}")
        logger.info(f"Expected functions: {expected_functions}")
        
        # Parse the range - strictly use the specified range
        try:
            range_clean = check_range.replace('$', '')
            if ':' in range_clean:
                start_cell, end_cell = range_clean.split(':')
                start_col_letter = ''.join([c for c in start_cell if c.isalpha()])
                start_row = int(''.join([c for c in start_cell if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                end_col_letter = ''.join([c for c in end_cell if c.isalpha()])
                end_row = int(''.join([c for c in end_cell if c.isdigit()]))
                end_col = column_index_from_string(end_col_letter)
            else:
                logger.error(f"Invalid range format: {check_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse range {check_range}: {e}")
            return 0.0
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Strictly check ALL cells in the specified range - no auto-detection
        logger.info(f"Checking all cells in range {check_range} (rows {start_row} to {end_row})")
        
        all_passed = True
        checked_count = 0
        passed_count = 0
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{start_col_letter}{row_num}"
            expected_condition1_cell = f"{condition1_col}{row_num}"
            expected_condition2_cell = f"{condition2_col}{row_num}"
            
            try:
                cell = ws[cell_coord]
                checked_count += 1
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.warning(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                else:
                    if cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                        formula_text = cell.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains all expected functions
                for func in expected_functions:
                    func_pattern = rf'\b{func}\s*\('
                    if not re.search(func_pattern, formula_upper):
                        logger.warning(f"Cell {cell_coord} formula does not contain {func} function")
                        logger.warning(f"Formula: {formula_text}")
                        all_passed = False
                        break
                
                if not all_passed:
                    continue
                
                # Check 2: Formula contains SUMPRODUCT function
                sumproduct_pattern = r'\bSUMPRODUCT\s*\('
                if not re.search(sumproduct_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not contain SUMPRODUCT function")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: Formula contains first condition: ($F$2:$F$7=$A{row})
                # Allow flexible spacing, case, and optional $ signs
                # Pattern: ($F$2:$F$7=$A2) or (F$2:F$7=$A2) or ($F2:$F7=$A2) etc.
                condition1_range_clean = condition1_range.replace("$", "")
                condition1_patterns = [
                    rf'\(\s*\$?F\$?2\s*:\s*\$?F\$?7\s*=\s*\$?{condition1_col}{row_num}\s*\)',  # Flexible $ placement
                    rf'\(\s*{re.escape(condition1_range)}\s*=\s*\$?{condition1_col}{row_num}\s*\)',  # Exact match with $
                    rf'\(\s*{re.escape(condition1_range_clean)}\s*=\s*\$?{condition1_col}{row_num}\s*\)',  # Without $
                ]
                condition1_matched = any(re.search(pattern, formula_text, re.IGNORECASE) for pattern in condition1_patterns)
                if not condition1_matched:
                    logger.warning(f"Cell {cell_coord} formula does not contain first condition ({condition1_range}={expected_condition1_cell})")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: Formula contains second condition: ($G$1:$J$1=$B{row})
                condition2_range_clean = condition2_range.replace("$", "")
                condition2_patterns = [
                    rf'\(\s*\$?G\$?1\s*:\s*\$?J\$?1\s*=\s*\$?{condition2_col}{row_num}\s*\)',  # Flexible $ placement
                    rf'\(\s*{re.escape(condition2_range)}\s*=\s*\$?{condition2_col}{row_num}\s*\)',  # Exact match with $
                    rf'\(\s*{re.escape(condition2_range_clean)}\s*=\s*\$?{condition2_col}{row_num}\s*\)',  # Without $
                ]
                condition2_matched = any(re.search(pattern, formula_text, re.IGNORECASE) for pattern in condition2_patterns)
                if not condition2_matched:
                    logger.warning(f"Cell {cell_coord} formula does not contain second condition ({condition2_range}={expected_condition2_cell})")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 5: Formula contains sum range: $G$2:$J$7
                sum_range_clean = sum_range.replace("$", "")
                sum_range_patterns = [
                    rf'\b\$?G\$?2\s*:\s*\$?J\$?7\b',  # Flexible $ placement
                    rf'\b{re.escape(sum_range)}\b',  # Exact match with $
                    rf'\b{re.escape(sum_range_clean)}\b',  # Without $
                ]
                sum_range_matched = any(re.search(pattern, formula_text, re.IGNORECASE) for pattern in sum_range_patterns)
                if not sum_range_matched:
                    logger.warning(f"Cell {cell_coord} formula does not contain sum range {sum_range}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 6: Formula structure contains multiplication operators (*) between conditions
                # Look for pattern: condition1*condition2*sum_range
                if '*' not in formula_text:
                    logger.warning(f"Cell {cell_coord} formula does not contain multiplication operators (*)")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 7: Formula closes parentheses correctly
                open_count = formula_text.count('(')
                close_count = formula_text.count(')')
                if open_count != close_count:
                    logger.warning(f"Cell {cell_coord} formula has mismatched parentheses")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                passed_count += 1
                logger.debug(f"✓ Cell {cell_coord} has valid SUMPRODUCT price extract formula")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        # Require all specified cells to have correct formulas (no tolerance)
        if checked_count > 0:
            if all_passed and passed_count == checked_count:
                logger.info("=" * 60)
                logger.info(f"✓ SUMPRODUCT price extract verification passed")
                logger.info(f"  - Checked: {checked_count} cells")
                logger.info(f"  - Passed: {passed_count} cells")
                logger.info(f"  - Range: {check_range}")
                logger.info("=" * 60)
                return 1.0
            else:
                logger.error("=" * 60)
                logger.error(f"✗ SUMPRODUCT price extract verification failed")
                logger.error(f"  - Checked: {checked_count} cells")
                logger.error(f"  - Passed: {passed_count} cells")
                logger.error(f"  - Range: {check_range}")
                logger.error(f"  All specified cells must contain correct formulas")
                logger.error("=" * 60)
                return 0.0
        else:
            logger.error("=" * 60)
            logger.error("✗ No cells were checked")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0
    """
    Verify if store and staff pivot formulas are correctly applied to display multiple staff members per store in one row.
    
    This function checks:
    1. Whether ALL cells in C2:C34 contain COUNTIF formulas: =COUNTIF($A$2:A2,A2)
    2. Whether G2 contains UNIQUE formula: =UNIQUE(A2:A34)
    3. Whether ALL cells in H2:H31 contain INDEX+MATCH+IFERROR formulas: =IFERROR(INDEX($B$2:$B$34,MATCH($G2&1,$A$2:$A$34&$C$2:$C$34,0)),"")
    4. Whether ALL cells in I2:I31 contain INDEX+MATCH+IFERROR formulas: =IFERROR(INDEX($B$2:$B$34,MATCH($G2&2,$A$2:$A$34&$C$2:$C$34,0)),"")
    5. Whether ALL cells in J2:J31 contain INDEX+MATCH+IFERROR formulas: =IFERROR(INDEX($B$2:$B$34,MATCH($G2&3,$A$2:$A$34&$C$2:$C$34,0)),"")
    6. Whether headers in G1, H1, I1, J1 are: 门店, 店员1, 店员2, 店员3
    
    IMPORTANT: This function checks ALL cells in the specified ranges. If any cell is missing a formula, verification fails.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - countif_range: Range for COUNTIF formulas (default: "C2:C34")
            - unique_cell: Cell for UNIQUE formula (default: "G2")
            - unique_range: Range for UNIQUE function (default: "A2:A34")
            - staff_range_h: Range for first staff column (default: "H2:H31")
            - staff_range_i: Range for second staff column (default: "I2:I31")
            - staff_range_j: Range for third staff column (default: "J2:J31")
            - headers: Dict mapping column letters to expected header text (default: {"G": "门店", "H": "店员1", "I": "店员2", "J": "店员3"})
            - source_data_range: Source data range for INDEX (default: "$B$2:$B$34")
            - match_range_a: First part of MATCH range (default: "$A$2:$A$34")
            - match_range_c: Second part of MATCH range (default: "$C$2:$C$34")
    
    Returns:
        float: 1.0 if ALL cells in specified ranges contain correct formulas and headers are correct, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import column_index_from_string, get_column_letter
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        countif_range = options.get("countif_range", "C2:C34")
        unique_cell = options.get("unique_cell", "G2")
        unique_range = options.get("unique_range", "A2:A34")
        staff_range_h = options.get("staff_range_h", "H2:H31")
        staff_range_i = options.get("staff_range_i", "I2:I31")
        staff_range_j = options.get("staff_range_j", "J2:J31")
        headers = options.get("headers", {"G": "门店", "H": "店员1", "I": "店员2", "J": "店员3"})
        source_data_range = options.get("source_data_range", "$B$2:$B$34")
        match_range_a = options.get("match_range_a", "$A$2:$A$34")
        match_range_c = options.get("match_range_c", "$C$2:$C$34")
        
        logger.info(f"Verifying store and staff pivot formulas in file: {result}")
        logger.info(f"COUNTIF range: {countif_range}")
        logger.info(f"UNIQUE cell: {unique_cell}")
        logger.info(f"Staff ranges: {staff_range_h}, {staff_range_i}, {staff_range_j}")
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        all_passed = True
        
        # Helper function to parse range
        def parse_range(range_str):
            range_clean = range_str.replace("$", "")
            if ":" in range_clean:
                start_cell, end_cell = range_clean.split(":")
                start_col_letter = "".join([c for c in start_cell if c.isalpha()])
                start_row = int("".join([c for c in start_cell if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                end_col_letter = "".join([c for c in end_cell if c.isalpha()])
                end_row = int("".join([c for c in end_cell if c.isdigit()]))
                end_col = column_index_from_string(end_col_letter)
                return start_col, start_row, end_col, end_row
            else:
                # Single cell
                col_letter = "".join([c for c in range_clean if c.isalpha()])
                row = int("".join([c for c in range_clean if c.isdigit()]))
                col = column_index_from_string(col_letter)
                return col, row, col, row
        
        # Helper function to get formula from cell
        def get_formula(cell):
            if cell.data_type != "f":
                return None
            formula_text = None
            if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                formula_text = cell._value
            elif hasattr(cell, "formula"):
                formula_text = cell.formula
            elif cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                formula_text = cell.value
            return formula_text
        
        # Check 1: COUNTIF formulas in C2:C34
        logger.info("Checking COUNTIF formulas...")
        start_col, start_row, end_col, end_row = parse_range(countif_range)
        for row in range(start_row, end_row + 1):
            cell_coord = f"{get_column_letter(start_col)}{row}"
            cell = ws[cell_coord]
            formula_text = get_formula(cell)
            
            if formula_text is None:
                logger.warning(f"Cell {cell_coord} does not contain a formula")
                all_passed = False
                continue
            
            formula_upper = formula_text.upper()
            
            # Check for COUNTIF function
            if not re.search(r'\bCOUNTIF\s*\(', formula_upper):
                logger.warning(f"Cell {cell_coord} formula does not contain COUNTIF function")
                logger.warning(f"Formula: {formula_text}")
                all_passed = False
                continue
            
            # Check for pattern: COUNTIF($A$2:A2, A2)
            # Allow variations in spacing and $ placement
            countif_pattern = r'COUNTIF\s*\(\s*\$?A\$?2\s*:\s*\$?A\d+\s*,\s*\$?A\d+\s*\)'
            if not re.search(countif_pattern, formula_upper):
                logger.warning(f"Cell {cell_coord} formula does not match COUNTIF pattern")
                logger.warning(f"Formula: {formula_text}")
                all_passed = False
                continue
            
            logger.debug(f"✓ Cell {cell_coord} has valid COUNTIF formula")
        
        # Check 2: UNIQUE formula in G2
        logger.info("Checking UNIQUE formula...")
        unique_col, unique_row, _, _ = parse_range(unique_cell)
        unique_cell_coord = f"{get_column_letter(unique_col)}{unique_row}"
        unique_cell_obj = ws[unique_cell_coord]
        unique_formula = get_formula(unique_cell_obj)
        
        if unique_formula is None:
            logger.warning(f"Cell {unique_cell_coord} does not contain a formula")
            all_passed = False
        else:
            unique_formula_upper = unique_formula.upper()
            
            # Check for UNIQUE function
            if not re.search(r'\bUNIQUE\s*\(', unique_formula_upper):
                logger.warning(f"Cell {unique_cell_coord} formula does not contain UNIQUE function")
                logger.warning(f"Formula: {unique_formula}")
                all_passed = False
            else:
                # Check for pattern: UNIQUE(A2:A34)
                unique_range_clean = unique_range.replace("$", "")
                unique_pattern = rf'UNIQUE\s*\(\s*\$?A\$?2\s*:\s*\$?A\$?34\s*\)'
                if not re.search(unique_pattern, unique_formula_upper):
                    logger.warning(f"Cell {unique_cell_coord} formula does not match UNIQUE pattern")
                    logger.warning(f"Formula: {unique_formula}")
                    all_passed = False
                else:
                    logger.debug(f"✓ Cell {unique_cell_coord} has valid UNIQUE formula")
        
        # Check 3-5: INDEX+MATCH+IFERROR formulas in H, I, J columns
        staff_ranges = [
            (staff_range_h, 1, "H"),
            (staff_range_i, 2, "I"),
            (staff_range_j, 3, "J")
        ]
        
        for staff_range, staff_num, col_letter in staff_ranges:
            logger.info(f"Checking INDEX+MATCH+IFERROR formulas in {staff_range} (staff {staff_num})...")
            start_col, start_row, end_col, end_row = parse_range(staff_range)
            
            for row in range(start_row, end_row + 1):
                cell_coord = f"{get_column_letter(start_col)}{row}"
                cell = ws[cell_coord]
                formula_text = get_formula(cell)
                
                if formula_text is None:
                    logger.warning(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                
                # Check for IFERROR function
                if not re.search(r'\bIFERROR\s*\(', formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not contain IFERROR function")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check for INDEX function
                if not re.search(r'\bINDEX\s*\(', formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not contain INDEX function")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check for MATCH function
                if not re.search(r'\bMATCH\s*\(', formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not contain MATCH function")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check for pattern: INDEX($B$2:$B$34, MATCH($G{row}&{staff_num}, $A$2:$A$34&$C$2:$C$34, 0))
                # Check INDEX range
                source_data_range_clean = source_data_range.replace("$", "")
                index_pattern = rf'INDEX\s*\(\s*\$?B\$?2\s*:\s*\$?B\$?34\s*,'
                if not re.search(index_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not contain correct INDEX range")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check MATCH pattern: MATCH($G{row}&{staff_num}, $A$2:$A$34&$C$2:$C$34, 0)
                # Allow variations in spacing
                g_cell_pattern = rf'\$?G{row}'
                match_pattern = rf'MATCH\s*\(\s*{re.escape(g_cell_pattern)}\s*&\s*{staff_num}\s*,'
                if not re.search(match_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not contain correct MATCH lookup value pattern (G{row}&{staff_num})")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check MATCH range: $A$2:$A$34&$C$2:$C$34
                match_range_a_clean = match_range_a.replace("$", "")
                match_range_c_clean = match_range_c.replace("$", "")
                match_range_pattern = rf'{re.escape(match_range_a_clean)}\s*&\s*{re.escape(match_range_c_clean)}'
                if not re.search(match_range_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula does not contain correct MATCH range pattern")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check MATCH third parameter is 0
                match_third_param_pattern = r'MATCH\s*\([^,]+,\s*[^,]+,\s*0\s*\)'
                if not re.search(match_third_param_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula MATCH function does not have 0 as third parameter")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check IFERROR error value is ""
                iferror_error_pattern = r'IFERROR\s*\([^,]+,\s*""\s*\)'
                if not re.search(iferror_error_pattern, formula_upper):
                    logger.warning(f"Cell {cell_coord} formula IFERROR function does not have \"\" as error value")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                logger.debug(f"✓ Cell {cell_coord} has valid INDEX+MATCH+IFERROR formula")
        
        # Check 6: Headers
        logger.info("Checking headers...")
        for col_letter, expected_header in headers.items():
            header_cell_coord = f"{col_letter}1"
            header_cell = ws[header_cell_coord]
            header_value = str(header_cell.value).strip() if header_cell.value else ""
            
            if header_value != expected_header:
                logger.warning(f"Cell {header_cell_coord} header is '{header_value}', expected '{expected_header}'")
                all_passed = False
            else:
                logger.debug(f"✓ Cell {header_cell_coord} has correct header: {expected_header}")
        
        if all_passed:
            logger.info("=" * 60)
            logger.info("✓ Store and staff pivot verification passed")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error("✗ Store and staff pivot verification failed")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0




def verify_name_count_summary(result: str, expected: str = None, **options) -> float:
    """
    Verify if name count summary is correctly displayed with names and their occurrence counts.
    
    This function checks:
    1. Whether there exists a range (excluding columns A, C, B, D) with 5 consecutive cells containing the 5 names: 冯文荣、王伟荣、单瓞绵、董水军、张无忌
    2. Whether each name's right adjacent cell contains the correct count: 52, 77, 51, 51, 25 respectively
    
    IMPORTANT: This function searches for the names in any columns except A, C, B, D, and verifies the counts.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - expected_names: List of expected names (default: ["冯文荣", "王伟荣", "单瓞绵", "董水军", "张无忌"])
            - expected_counts: List of expected counts corresponding to names (default: [52, 77, 51, 51, 25])
            - exclude_columns: List of column letters to exclude from search (default: ["A", "C", "B", "D"])
            - search_start_row: Starting row for search (default: 1)
            - search_end_row: Ending row for search (default: 1000)
    
    Returns:
        float: 1.0 if names and counts are found correctly, 0.0 otherwise
    """
    try:
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        expected_names = options.get("expected_names", ["冯文荣", "王伟荣", "单瓞绵", "董水军", "张无忌"])
        expected_counts = options.get("expected_counts", [52, 77, 51, 51, 25])
        exclude_columns = options.get("exclude_columns", ["A", "C", "B", "D"])
        search_start_row = options.get("search_start_row", 1)
        search_end_row = options.get("search_end_row", 1000)
        
        logger.info(f"Verifying name count summary in file: {result}")
        logger.info(f"Expected names: {expected_names}")
        logger.info(f"Expected counts: {expected_counts}")
        logger.info(f"Exclude columns: {exclude_columns}")
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=True)  # data_only=True to get values
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Convert exclude columns to column indices
        exclude_col_indices = set()
        for col_letter in exclude_columns:
            exclude_col_indices.add(column_index_from_string(col_letter))
        
        # Search for the 5 consecutive cells containing the names
        found = False
        found_location = None
        
        # Search through all columns except excluded ones
        for col_idx in range(1, ws.max_column + 1):
            if col_idx in exclude_col_indices:
                continue
            
            col_letter = get_column_letter(col_idx)
            
            # Search through rows
            for row in range(search_start_row, min(search_end_row + 1, ws.max_row + 1)):
                # Check if we can find 5 consecutive cells starting from this row
                if row + 4 > ws.max_row:
                    continue
                
                # Check if these 5 cells contain all expected names
                found_names = []
                found_counts = []
                all_match = True
                
                for i in range(5):
                    name_cell = ws[f"{col_letter}{row + i}"]
                    count_cell = ws[f"{get_column_letter(col_idx + 1)}{row + i}"]
                    
                    name_value = str(name_cell.value).strip() if name_cell.value else ""
                    count_value = count_cell.value
                    
                    # Check if this name is in expected names
                    if name_value in expected_names:
                        found_names.append(name_value)
                        # Try to convert count to int
                        try:
                            count_int = int(float(count_value)) if count_value is not None else None
                            found_counts.append(count_int)
                        except (ValueError, TypeError):
                            found_counts.append(None)
                    else:
                        all_match = False
                        break
                
                # Check if we found all 5 names
                if all_match and len(found_names) == 5:
                    # Check if all expected names are present
                    if set(found_names) == set(expected_names):
                        # Verify counts match
                        name_count_map = dict(zip(expected_names, expected_counts))
                        counts_match = True
                        for name, count in zip(found_names, found_counts):
                            if count != name_count_map.get(name):
                                counts_match = False
                                break
                        
                        if counts_match:
                            found = True
                            found_location = (col_letter, row)
                            logger.info(f"Found names and counts at {col_letter}{row}:{get_column_letter(col_idx + 1)}{row + 4}")
                            break
                
                if found:
                    break
            
            if found:
                break
        
        if found:
            logger.info("=" * 60)
            logger.info("✓ Name count summary verification passed")
            logger.info(f"  - Location: {found_location[0]}{found_location[1]}")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error("✗ Name count summary verification failed")
            logger.error("  - Could not find 5 consecutive cells with expected names and counts")
            logger.error("=" * 60)
            return 0.0
            
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_sort_choose_person_contract(result: str, expected: str = None, **options) -> float:
    """
    Verify if M10:O25 range contains correctly sorted data matching the source data after sorting.
    
    This function checks:
    1. Reads source data from F11:F25 (names), G11:G25 (contract amounts), I11:I25 (contract locations)
    2. Sorts the data: first by name (descending), then by contract amount (descending) within same name
    3. Compares M10:O25 range cell by cell with the sorted data
    4. Ensures every cell matches exactly, no deviation allowed
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - result_range: Result range to check (default: "M10:O25")
            - source_name_range: Source name range (default: "F11:F25")
            - source_amount_range: Source amount range (default: "G11:G25")
            - source_location_range: Source location range (default: "I11:I25")
    
    Returns:
        float: 1.0 if all cells match exactly, 0.0 otherwise
    """
    try:
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        result_range = options.get('result_range', 'M10:O25')
        source_name_range = options.get('source_name_range', 'F11:F25')
        source_amount_range = options.get('source_amount_range', 'G11:G25')
        source_location_range = options.get('source_location_range', 'I11:I25')
        
        logger.info(f"Verifying sorted data in file: {result}")
        logger.info(f"Result range: {result_range}")
        logger.info(f"Source ranges: {source_name_range}, {source_amount_range}, {source_location_range}")
        
        # Load workbook to get values
        try:
            wb = openpyxl.load_workbook(result, data_only=True)  # data_only=True to get values
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Helper function to parse range and get cell values
        def parse_range_get_values(range_str):
            range_clean = range_str.replace("$", "")
            if ":" in range_clean:
                start_cell, end_cell = range_clean.split(":")
                start_col_letter = "".join([c for c in start_cell if c.isalpha()])
                start_row = int("".join([c for c in start_cell if c.isdigit()]))
                end_col_letter = "".join([c for c in end_cell if c.isalpha()])
                end_row = int("".join([c for c in end_cell if c.isdigit()]))
                
                values = []
                for row in range(start_row, end_row + 1):
                    row_values = []
                    start_col_idx = column_index_from_string(start_col_letter)
                    end_col_idx = column_index_from_string(end_col_letter)
                    for col_idx in range(start_col_idx, end_col_idx + 1):
                        col_letter = get_column_letter(col_idx)
                        cell = ws[f"{col_letter}{row}"]
                        # Get cell value, convert None to empty string, numbers to float for comparison
                        cell_value = cell.value
                        if cell_value is None:
                            cell_value = ""
                        elif isinstance(cell_value, (int, float)):
                            # Keep as number for comparison
                            cell_value = float(cell_value) if isinstance(cell_value, float) else int(cell_value)
                        else:
                            cell_value = str(cell_value).strip()
                        row_values.append(cell_value)
                    values.append(row_values)
                return values
            else:
                logger.error(f"Invalid range format: {range_str}")
                return None
        
        # Read source data
        source_names = parse_range_get_values(source_name_range)
        source_amounts = parse_range_get_values(source_amount_range)
        source_locations = parse_range_get_values(source_location_range)
        
        if source_names is None or source_amounts is None or source_locations is None:
            logger.error("Failed to read source data")
            return 0.0
        
        # Combine source data into list of tuples (name, amount, location)
        source_data = []
        for i in range(len(source_names)):
            name = source_names[i][0] if source_names[i] else ""
            amount = source_amounts[i][0] if source_amounts[i] else ""
            location = source_locations[i][0] if source_locations[i] else ""
            source_data.append((name, amount, location))
        
        logger.info(f"Source data rows: {len(source_data)}")
        
        # Sort source data: first by name (descending), then by amount (descending)
        # For descending sort, we use reverse=True
        # For name comparison, handle empty strings and None
        def sort_key(item):
            name, amount, location = item
            # Convert name to string for comparison, empty string sorts last in descending
            name_str = str(name) if name is not None and name != "" else ""
            # Convert amount to float for comparison, None/empty sorts last in descending
            try:
                amount_num = float(amount) if amount is not None and amount != "" else float('-inf')
            except (ValueError, TypeError):
                amount_num = float('-inf')
            # Return tuple for multi-level sort: (name, amount)
            # For descending: we'll use reverse=True, so we want higher values first
            # In descending order, we want names in reverse alphabetical order
            return (name_str, amount_num)
        
        sorted_source_data = sorted(source_data, key=sort_key, reverse=True)
        
        logger.info(f"Sorted source data rows: {len(sorted_source_data)}")
        
        # Read result data
        result_data = parse_range_get_values(result_range)
        if result_data is None:
            logger.error("Failed to read result data")
            return 0.0
        
        logger.info(f"Result data rows: {len(result_data)}, cols: {len(result_data[0]) if result_data else 0}")
        
        # Check if dimensions match
        # Result range M10:O25 is 16 rows x 3 columns
        # Source data is 15 rows, but result includes header row (M10)
        # So we need to check: result_data[1:] (skip header) should match sorted_source_data
        
        if len(result_data) < len(sorted_source_data):
            logger.error(f"Result data has fewer rows ({len(result_data)}) than sorted source data ({len(sorted_source_data)})")
            return 0.0
        
        # Compare data cell by cell
        # If M10 is header, compare from M11:O25 (result_data[1:]) with sorted_source_data
        # If M10 is data, compare from M10:O25 (result_data) with sorted_source_data
        # We'll try both approaches, but typically M10 might be header
        
        # Try comparing from row 1 (assuming M10 is header)
        start_row_idx = 1
        if len(result_data) - start_row_idx == len(sorted_source_data):
            # M10 is likely header, compare from M11
            comparison_data = result_data[start_row_idx:]
        elif len(result_data) == len(sorted_source_data):
            # M10 is data, compare from M10
            start_row_idx = 0
            comparison_data = result_data
        else:
            logger.error(f"Row count mismatch: result has {len(result_data)} rows, sorted source has {len(sorted_source_data)} rows")
            return 0.0
        
        # Check column count
        if len(comparison_data[0]) != 3:
            logger.error(f"Result data should have 3 columns, but has {len(comparison_data[0])}")
            return 0.0
        
        # Compare cell by cell
        all_match = True
        mismatch_count = 0
        
        for i in range(len(sorted_source_data)):
            expected_name, expected_amount, expected_location = sorted_source_data[i]
            actual_row = comparison_data[i]
            actual_name = actual_row[0] if len(actual_row) > 0 else None
            actual_amount = actual_row[1] if len(actual_row) > 1 else None
            actual_location = actual_row[2] if len(actual_row) > 2 else None
            
            # Normalize values for comparison
            def normalize_value(val):
                if val is None:
                    return ""
                if isinstance(val, (int, float)):
                    return float(val)
                return str(val).strip()
            
            expected_name_norm = normalize_value(expected_name)
            expected_amount_norm = normalize_value(expected_amount)
            expected_location_norm = normalize_value(expected_location)
            
            actual_name_norm = normalize_value(actual_name)
            actual_amount_norm = normalize_value(actual_amount)
            actual_location_norm = normalize_value(actual_location)
            
            # Compare name
            if expected_name_norm != actual_name_norm:
                logger.error(f"Row {i+start_row_idx+10} (M{10+i+start_row_idx}): Name mismatch - Expected: '{expected_name_norm}', Actual: '{actual_name_norm}'")
                all_match = False
                mismatch_count += 1
                continue
            
            # Compare amount (handle numeric comparison)
            if isinstance(expected_amount_norm, (int, float)) and isinstance(actual_amount_norm, (int, float)):
                if abs(expected_amount_norm - actual_amount_norm) > 0.001:  # Allow small floating point differences
                    logger.error(f"Row {i+start_row_idx+10} (N{10+i+start_row_idx}): Amount mismatch - Expected: {expected_amount_norm}, Actual: {actual_amount_norm}")
                    all_match = False
                    mismatch_count += 1
                    continue
            elif expected_amount_norm != actual_amount_norm:
                logger.error(f"Row {i+start_row_idx+10} (N{10+i+start_row_idx}): Amount mismatch - Expected: '{expected_amount_norm}', Actual: '{actual_amount_norm}'")
                all_match = False
                mismatch_count += 1
                continue
            
            # Compare location
            if expected_location_norm != actual_location_norm:
                logger.error(f"Row {i+start_row_idx+10} (O{10+i+start_row_idx}): Location mismatch - Expected: '{expected_location_norm}', Actual: '{actual_location_norm}'")
                all_match = False
                mismatch_count += 1
                continue
        
        if all_match:
            logger.info("=" * 60)
            logger.info(f"✓ Sorted data verification passed")
            logger.info(f"  - Result range: {result_range}")
            logger.info(f"  - Compared {len(sorted_source_data)} rows")
            logger.info(f"  - All cells match exactly")
            logger.info("=" * 60)
            return 1.0
        else:
            logger.error("=" * 60)
            logger.error(f"✗ Sorted data verification failed")
            logger.error(f"  - Result range: {result_range}")
            logger.error(f"  - Mismatches: {mismatch_count} out of {len(sorted_source_data)} rows")
            logger.error(f"  - All cells must match exactly, no deviation allowed")
            logger.error("=" * 60)
            return 0.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_right_match_left_extract(result: str, expected: str = None, **options) -> float:
    """
    Verify if RIGHT(MATCH(LEFT(...))) formulas exist in ALL cells of specified range to extract text after last asterisk.
    
    This function STRICTLY checks ALL cells in the specified range - no tolerance, no auto-detection.
    Every single cell in the specified range must contain the correct formula.
    
    This function checks:
    1. Whether ALL cells in the specified formula range (e.g., B2:B33) contain formulas
    2. Whether formulas contain RIGHT, MATCH, and LEFT functions
    3. Whether formulas reference the correct source column cell with relative row (e.g., A2, A3, etc.)
    4. Whether formulas contain ROW($1:$99) or similar array reference
    5. Whether formulas contain the pattern matching logic for asterisk "*"
    6. Whether formulas have the correct structure: =RIGHT(A2,MATCH(,0/(LEFT(RIGHT(A2,ROW($1:$99)))="*"),)-1)
    
    The formula =RIGHT(A2,MATCH(,0/(LEFT(RIGHT(A2,ROW($1:$99)))="*"),)-1) works as follows:
    - RIGHT(A2, ...) extracts characters from the right side of A2
    - MATCH(,0/(LEFT(RIGHT(A2,ROW($1:$99)))="*"),) finds the position of the last "*"
      * LEFT(RIGHT(A2,ROW($1:$99))) checks characters from right to left (ROW($1:$99) generates array 1 to 99)
      * 0/(LEFT(RIGHT(A2,ROW($1:$99)))="*") converts matching "*" to 0, non-matching to error
      * MATCH finds the first 0 position, which is the last "*" position
    - -1 adjusts the position to get the number of characters after "*"
    
    IMPORTANT: This function checks ALL cells in the specified formula range. If any cell is missing a formula, verification fails.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formula_range: Range containing formulas (e.g., "B2:B33") - ALL cells must have formulas
            - source_column: Source column for formula (default: "A")
            - expected_functions: List of expected function names (default: ["RIGHT", "MATCH", "LEFT"])
            - expected_pattern: Expected pattern character (default: "*")
            - row_array_pattern: Expected ROW array pattern (default: "ROW($1:$99)")
    
    Returns:
        float: 1.0 if ALL cells in specified range contain correct formulas, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formula_range = options.get('formula_range', 'B2:B33')
        source_column = options.get('source_column', 'A')
        expected_functions = options.get('expected_functions', ['RIGHT', 'MATCH', 'LEFT'])
        expected_pattern = options.get('expected_pattern', '*')
        row_array_pattern = options.get('row_array_pattern', 'ROW($1:$99)')
        
        logger.info(f"Verifying RIGHT(MATCH(LEFT)) extract formulas in file: {result}")
        logger.info(f"Formula range: {formula_range}")
        logger.info(f"Source column: {source_column}")
        logger.info(f"Expected functions: {expected_functions}")
        logger.info(f"Expected pattern: {expected_pattern}")
        
        # Parse the formula range
        try:
            range_clean = formula_range.replace("$", "")
            if ":" in range_clean:
                start_cell, end_cell = range_clean.split(":")
                start_col_letter = "".join([c for c in start_cell if c.isalpha()])
                start_row = int("".join([c for c in start_cell if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                end_col_letter = "".join([c for c in end_cell if c.isalpha()])
                end_row = int("".join([c for c in end_cell if c.isdigit()]))
                end_col = column_index_from_string(end_col_letter)
            else:
                logger.error(f"Invalid range format: {formula_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse range {formula_range}: {e}")
            return 0.0
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check ALL cells in formula range
        logger.info(f"Checking all cells in range {formula_range} (rows {start_row} to {end_row})")
        
        all_passed = True
        checked_count = 0
        passed_count = 0
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{start_col_letter}{row_num}"
            expected_source_cell = f"{source_column}{row_num}"
            
            try:
                cell = ws[cell_coord]
                checked_count += 1
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.error(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                elif cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula_text = cell.value
                
                if formula_text is None:
                    logger.error(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains all expected functions
                for func_name in expected_functions:
                    func_pattern = rf'\b{re.escape(func_name.upper())}\s*\('
                    if not re.search(func_pattern, formula_upper):
                        logger.error(f"Cell {cell_coord} formula does not contain {func_name} function")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        break
                
                if not all_passed:
                    continue
                
                # Check 2: Formula contains RIGHT function
                right_pattern = r'\bRIGHT\s*\('
                if not re.search(right_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain RIGHT function")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: Formula contains MATCH function
                match_pattern = r'\bMATCH\s*\('
                if not re.search(match_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain MATCH function")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: Formula contains LEFT function
                left_pattern = r'\bLEFT\s*\('
                if not re.search(left_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain LEFT function")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 5: Formula references the correct source column with correct row
                # Allow both relative (A2) and absolute ($A2) references, but prefer relative
                source_cell_patterns = [
                    rf'\b{re.escape(source_column.upper())}\s*{row_num}\b',  # A2 (relative)
                    rf'\$\s*{re.escape(source_column.upper())}\s*{row_num}\b',  # $A2 (mixed)
                ]
                source_cell_found = False
                for pattern in source_cell_patterns:
                    if re.search(pattern, formula_upper):
                        source_cell_found = True
                        break
                
                if not source_cell_found:
                    logger.error(f"Cell {cell_coord} formula does not reference {expected_source_cell}")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 6: Formula contains ROW array pattern (e.g., ROW($1:$99))
                row_array_pattern_upper = row_array_pattern.upper()
                # Escape special characters but allow flexibility in spacing
                row_array_escaped = re.escape(row_array_pattern_upper).replace(r'\$', r'\$?').replace(r'\ ', r'\s*')
                if not re.search(row_array_escaped, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain ROW array pattern {row_array_pattern}")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 7: Formula contains pattern matching logic (0/(...)=...)
                # This checks for the structure: 0/(LEFT(RIGHT(...))="*")
                pattern_match_logic = r'0\s*/\s*\(\s*LEFT\s*\('
                if not re.search(pattern_match_logic, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain pattern matching logic (0/(LEFT(...)))")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 8: Formula contains the expected pattern character (e.g., "*")
                # Escape the pattern character for regex
                pattern_escaped = re.escape(expected_pattern)
                pattern_check = rf'=\s*["\']?\s*{pattern_escaped}\s*["\']?'
                if not re.search(pattern_check, formula_text):
                    logger.error(f"Cell {cell_coord} formula does not contain pattern matching for '{expected_pattern}'")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 9: Formula structure should be RIGHT(source, MATCH(,0/(LEFT(RIGHT(...))="*"),)-1)
                # Check that MATCH is inside RIGHT
                right_match_pattern = r'RIGHT\s*\([^,)]+,\s*MATCH\s*\('
                if not re.search(right_match_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not have correct RIGHT(MATCH(...)) structure")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 10: Formula should contain -1 at the end (adjustment for position)
                minus_one_pattern = r'-\s*1\s*\)'
                if not re.search(minus_one_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain -1 adjustment")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 11: Formula closes parentheses correctly
                open_count = formula_text.count('(')
                close_count = formula_text.count(')')
                if open_count != close_count:
                    logger.error(f"Cell {cell_coord} formula has mismatched parentheses")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                passed_count += 1
                logger.info(f"✓ Cell {cell_coord} has valid formula: {formula_text}")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                all_passed = False
        
        if not all_passed:
            logger.error(f"✗ Formula verification failed: {passed_count}/{checked_count} cells passed")
            return 0.0
        
        if checked_count == 0:
            logger.error(f"No cells found in range {formula_range}")
            return 0.0
        
        logger.info("=" * 60)
        logger.info(f"✓ All {checked_count} cells in range {formula_range} contain correct RIGHT(MATCH(LEFT)) formulas")
        logger.info(f"  - All cells passed verification")
        logger.info(f"  - Formula structure: RIGHT(source, MATCH(,0/(LEFT(RIGHT(...))=\"*\"),)-1)")
        logger.info("=" * 60)
        return 1.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_if_mod_date_calculate(result: str, expected: str = None, **options) -> float:
    """
    Verify if IF(MOD(...), DATE(...), DATE(...)) formulas exist in ALL cells of specified range to calculate dates.
    
    This function STRICTLY checks ALL cells in the specified range - no tolerance, no auto-detection.
    Every single cell in the specified range must contain the correct formula.
    
    This function checks:
    1. Whether ALL cells in the specified formula range (e.g., D2:D43) contain formulas
    2. Whether formulas contain IF, MOD, DATE, YEAR, INT, RIGHT, LEN, FIND, and MONTH functions
    3. Whether formulas reference the correct source column cells with relative row (e.g., A2, B2, etc.)
    4. Whether formulas have the correct structure: IF(MOD(B2,1), DATE(YEAR(A2),INT(B2),RIGHT(B2,LEN(B2)-FIND(".",B2))), DATE(YEAR(A2),MONTH(A2),B2))
    
    The formula =IF(MOD(B2,1),DATE(YEAR(A2),INT(B2),RIGHT(B2,LEN(B2)-FIND(".",B2))),DATE(YEAR(A2),MONTH(A2),B2)) works as follows:
    - IF(MOD(B2,1), ...) checks if B2 has a decimal part
      * MOD(B2,1) returns the remainder of B2 divided by 1, non-zero if decimal exists (truthy), 0 if integer (falsy)
    - If B2 has decimal part (MOD(B2,1) is truthy):
      * DATE(YEAR(A2),INT(B2),RIGHT(B2,LEN(B2)-FIND(".",B2)))
      * YEAR(A2) gets the year from A2
      * INT(B2) gets the integer part of B2 as month
      * RIGHT(B2,LEN(B2)-FIND(".",B2)) extracts the decimal part as day
    - If B2 is integer (MOD(B2,1) is falsy):
      * DATE(YEAR(A2),MONTH(A2),B2)
      * YEAR(A2) gets the year from A2
      * MONTH(A2) gets the month from A2
      * B2 is used as day
    
    IMPORTANT: This function checks ALL cells in the specified formula range. If any cell is missing a formula, verification fails.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formula_range: Range containing formulas (e.g., "D2:D43") - ALL cells must have formulas
            - source_column_a: Source column A for formula (default: "A")
            - source_column_b: Source column B for formula (default: "B")
            - expected_functions: List of expected function names (default: ["IF", "MOD", "DATE", "YEAR", "INT", "RIGHT", "LEN", "FIND", "MONTH"])
    
    Returns:
        float: 1.0 if ALL cells in specified range contain correct formulas, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formula_range = options.get('formula_range', 'D2:D43')
        source_column_a = options.get('source_column_a', 'A')
        source_column_b = options.get('source_column_b', 'B')
        expected_functions = options.get('expected_functions', ['IF', 'MOD', 'DATE', 'YEAR', 'INT', 'RIGHT', 'LEN', 'FIND', 'MONTH'])
        
        logger.info(f"Verifying IF(MOD(DATE)) calculation formulas in file: {result}")
        logger.info(f"Formula range: {formula_range}")
        logger.info(f"Source column A: {source_column_a}")
        logger.info(f"Source column B: {source_column_b}")
        logger.info(f"Expected functions: {expected_functions}")
        
        # Parse the formula range
        try:
            range_clean = formula_range.replace("$", "")
            if ":" in range_clean:
                start_cell, end_cell = range_clean.split(":")
                start_col_letter = "".join([c for c in start_cell if c.isalpha()])
                start_row = int("".join([c for c in start_cell if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                end_col_letter = "".join([c for c in end_cell if c.isalpha()])
                end_row = int("".join([c for c in end_cell if c.isdigit()]))
                end_col = column_index_from_string(end_col_letter)
            else:
                logger.error(f"Invalid range format: {formula_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse range {formula_range}: {e}")
            return 0.0
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check ALL cells in formula range
        logger.info(f"Checking all cells in range {formula_range} (rows {start_row} to {end_row})")
        
        all_passed = True
        checked_count = 0
        passed_count = 0
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{start_col_letter}{row_num}"
            expected_source_cell_a = f"{source_column_a}{row_num}"
            expected_source_cell_b = f"{source_column_b}{row_num}"
            
            try:
                cell = ws[cell_coord]
                checked_count += 1
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.error(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                elif cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula_text = cell.value
                
                if formula_text is None:
                    logger.error(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains all expected functions
                for func_name in expected_functions:
                    func_pattern = rf'\b{re.escape(func_name.upper())}\s*\('
                    if not re.search(func_pattern, formula_upper):
                        logger.error(f"Cell {cell_coord} formula does not contain {func_name} function")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        break
                
                if not all_passed:
                    continue
                
                # Check 2: Formula contains IF function
                if_pattern = r'\bIF\s*\('
                if not re.search(if_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain IF function")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: Formula contains MOD function
                mod_pattern = r'\bMOD\s*\('
                if not re.search(mod_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain MOD function")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: Formula contains DATE function (should appear twice)
                date_pattern = r'\bDATE\s*\('
                date_matches = re.findall(date_pattern, formula_upper)
                if len(date_matches) < 2:
                    logger.error(f"Cell {cell_coord} formula does not contain two DATE functions (found {len(date_matches)})")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 5: Formula contains YEAR function (should appear twice)
                year_pattern = r'\bYEAR\s*\('
                year_matches = re.findall(year_pattern, formula_upper)
                if len(year_matches) < 2:
                    logger.error(f"Cell {cell_coord} formula does not contain two YEAR functions (found {len(year_matches)})")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 6: Formula contains INT function
                int_pattern = r'\bINT\s*\('
                if not re.search(int_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain INT function")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 7: Formula contains RIGHT function
                right_pattern = r'\bRIGHT\s*\('
                if not re.search(right_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain RIGHT function")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 8: Formula contains LEN function
                len_pattern = r'\bLEN\s*\('
                if not re.search(len_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain LEN function")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 9: Formula contains FIND function
                find_pattern = r'\bFIND\s*\('
                if not re.search(find_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain FIND function")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 10: Formula contains MONTH function
                month_pattern = r'\bMONTH\s*\('
                if not re.search(month_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain MONTH function")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 11: Formula references the correct source column A with correct row
                source_cell_a_patterns = [
                    rf'\b{re.escape(source_column_a.upper())}\s*{row_num}\b',  # A2 (relative)
                    rf'\$\s*{re.escape(source_column_a.upper())}\s*{row_num}\b',  # $A2 (mixed)
                ]
                source_cell_a_found = False
                for pattern in source_cell_a_patterns:
                    if re.search(pattern, formula_upper):
                        source_cell_a_found = True
                        break
                
                if not source_cell_a_found:
                    logger.error(f"Cell {cell_coord} formula does not reference {expected_source_cell_a}")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 12: Formula references the correct source column B with correct row
                source_cell_b_patterns = [
                    rf'\b{re.escape(source_column_b.upper())}\s*{row_num}\b',  # B2 (relative)
                    rf'\$\s*{re.escape(source_column_b.upper())}\s*{row_num}\b',  # $B2 (mixed)
                ]
                source_cell_b_found = False
                for pattern in source_cell_b_patterns:
                    if re.search(pattern, formula_upper):
                        source_cell_b_found = True
                        break
                
                if not source_cell_b_found:
                    logger.error(f"Cell {cell_coord} formula does not reference {expected_source_cell_b}")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 13: Formula structure should be IF(MOD(B2,1), DATE(...), DATE(...))
                # Check that MOD is inside IF
                if_mod_pattern = r'IF\s*\(\s*MOD\s*\('
                if not re.search(if_mod_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not have correct IF(MOD(...)) structure")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 14: Formula contains RIGHT(LEN(FIND pattern for decimal extraction
                right_len_find_pattern = r'RIGHT\s*\([^,)]+,\s*LEN\s*\([^,)]+\)\s*-\s*FIND\s*\('
                if not re.search(right_len_find_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not have correct RIGHT(LEN(...)-FIND(...)) structure")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 15: Formula contains FIND with dot pattern (for decimal point)
                find_dot_pattern = r'FIND\s*\(\s*["\']?\s*\.\s*["\']?\s*,'
                if not re.search(find_dot_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain FIND with dot pattern for decimal point")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 16: Formula closes parentheses correctly
                open_count = formula_text.count('(')
                close_count = formula_text.count(')')
                if open_count != close_count:
                    logger.error(f"Cell {cell_coord} formula has mismatched parentheses")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                passed_count += 1
                logger.info(f"✓ Cell {cell_coord} has valid formula: {formula_text}")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                all_passed = False
        
        if not all_passed:
            logger.error(f"✗ Formula verification failed: {passed_count}/{checked_count} cells passed")
            return 0.0
        
        if checked_count == 0:
            logger.error(f"No cells found in range {formula_range}")
            return 0.0
        
        logger.info("=" * 60)
        logger.info(f"✓ All {checked_count} cells in range {formula_range} contain correct IF(MOD(DATE)) formulas")
        logger.info(f"  - All cells passed verification")
        logger.info(f"  - Formula structure: IF(MOD(B2,1), DATE(YEAR(A2),INT(B2),RIGHT(B2,LEN(B2)-FIND(\".\",B2))), DATE(YEAR(A2),MONTH(A2),B2))")
        logger.info("=" * 60)
        return 1.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_financial_month_convert(result: str, expected: str = None, **options) -> float:
    """
    Verify if financial month conversion formulas exist in ALL cells of specified range.
    
    This function STRICTLY checks ALL cells in the specified range - no tolerance, no auto-detection.
    Every single cell in the specified range must contain the correct formula.
    
    This function checks:
    1. Whether ALL cells in the specified formula range (e.g., B1:B58) contain formulas
    2. Whether formulas contain YEAR, DAY, MONTH, and IF functions
    3. Whether formulas reference the correct source column cells with relative row (e.g., A1, A2, etc.)
    4. Whether formulas have the correct structure: (YEAR(A1)+(DAY(A1)>25))&"/"&IF(((DAY(A1)>25)+MONTH(A1))>12,--(DAY(A1)>25),((DAY(A1)>25)+MONTH(A1)))
    5. Whether formulas contain string concatenation operator &
    6. Whether formulas contain logical expression (DAY(...)>25)
    
    The formula =(YEAR(A1)+(DAY(A1)>25))&"/"&IF(((DAY(A1)>25)+MONTH(A1))>12,--(DAY(A1)>25),((DAY(A1)>25)+MONTH(A1))) works as follows:
    - YEAR(A1)+(DAY(A1)>25) calculates the financial year
      * YEAR(A1) gets the year from A1
      * DAY(A1)>25 returns TRUE(1) if day > 25, FALSE(0) otherwise
      * If day > 25, year is incremented by 1 (cross-year case)
    - (DAY(A1)>25)+MONTH(A1) calculates the financial month
      * DAY(A1)>25 returns 1 if day > 25, 0 otherwise
      * MONTH(A1) gets the month from A1
      * If day > 25, month is incremented by 1
    - IF(((DAY(A1)>25)+MONTH(A1))>12,--(DAY(A1)>25),((DAY(A1)>25)+MONTH(A1))) handles cross-year case
      * If month > 12, returns 1 (January)
      * --(DAY(A1)>25) converts logical value to numeric (1 if day > 25, 0 otherwise)
      * Otherwise returns the calculated month
    - &"/"& concatenates year and month into "year/month" format
    
    IMPORTANT: This function checks ALL cells in the specified formula range. If any cell is missing a formula, verification fails.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formula_range: Range containing formulas (e.g., "B1:B58") - ALL cells must have formulas
            - source_column: Source column for formula (default: "A")
            - expected_functions: List of expected function names (default: ["YEAR", "DAY", "MONTH", "IF"])
    
    Returns:
        float: 1.0 if ALL cells in specified range contain correct formulas, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formula_range = options.get('formula_range', 'B1:B58')
        source_column = options.get('source_column', 'A')
        expected_functions = options.get('expected_functions', ['YEAR', 'DAY', 'MONTH', 'IF'])
        
        logger.info(f"Verifying financial month conversion formulas in file: {result}")
        logger.info(f"Formula range: {formula_range}")
        logger.info(f"Source column: {source_column}")
        logger.info(f"Expected functions: {expected_functions}")
        
        # Parse the formula range
        try:
            range_clean = formula_range.replace("$", "")
            if ":" in range_clean:
                start_cell, end_cell = range_clean.split(":")
                start_col_letter = "".join([c for c in start_cell if c.isalpha()])
                start_row = int("".join([c for c in start_cell if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                end_col_letter = "".join([c for c in end_cell if c.isalpha()])
                end_row = int("".join([c for c in end_cell if c.isdigit()]))
                end_col = column_index_from_string(end_col_letter)
            else:
                logger.error(f"Invalid range format: {formula_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse range {formula_range}: {e}")
            return 0.0
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check ALL cells in formula range
        logger.info(f"Checking all cells in range {formula_range} (rows {start_row} to {end_row})")
        
        all_passed = True
        checked_count = 0
        passed_count = 0
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{start_col_letter}{row_num}"
            expected_source_cell = f"{source_column}{row_num}"
            
            try:
                cell = ws[cell_coord]
                checked_count += 1
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.error(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                elif cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula_text = cell.value
                
                if formula_text is None:
                    logger.error(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains all expected functions
                for func_name in expected_functions:
                    func_pattern = rf'\b{re.escape(func_name.upper())}\s*\('
                    if not re.search(func_pattern, formula_upper):
                        logger.error(f"Cell {cell_coord} formula does not contain {func_name} function")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        break
                
                if not all_passed:
                    continue
                
                # Check 2: Formula contains YEAR function
                year_pattern = r'\bYEAR\s*\('
                if not re.search(year_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain YEAR function")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: Formula contains DAY function
                day_pattern = r'\bDAY\s*\('
                if not re.search(day_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain DAY function")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: Formula contains MONTH function
                month_pattern = r'\bMONTH\s*\('
                if not re.search(month_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain MONTH function")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 5: Formula contains IF function
                if_pattern = r'\bIF\s*\('
                if not re.search(if_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain IF function")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 6: Formula contains string concatenation operator &
                if '&' not in formula_text:
                    logger.error(f"Cell {cell_coord} formula does not contain string concatenation operator &")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 7: Formula contains logical expression DAY(...)>25
                day_gt_25_pattern = r'DAY\s*\([^)]+\)\s*>\s*25'
                if not re.search(day_gt_25_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain logical expression DAY(...)>25")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 8: Formula references the correct source column cell with relative row
                # Allow for variations: A1, $A1, A$1, $A$1
                escaped_source_cell = re.escape(expected_source_cell)
                escaped_source_col = re.escape(source_column)
                source_cell_patterns = [
                    rf'\b{escaped_source_cell}\b',  # A1
                    rf'\${escaped_source_col}{row_num}\b',  # $A1
                    rf'\b{escaped_source_col}\${row_num}\b',  # A$1
                    rf'\${escaped_source_col}\${row_num}\b',  # $A$1
                ]
                
                source_cell_found = False
                for pattern in source_cell_patterns:
                    if re.search(pattern, formula_text, re.IGNORECASE):
                        source_cell_found = True
                        break
                
                if not source_cell_found:
                    logger.error(f"Cell {cell_coord} formula does not reference source cell {expected_source_cell}")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 9: Formula contains YEAR(...)+(DAY(...)>25) pattern
                year_plus_day_pattern = r'YEAR\s*\([^)]+\)\s*\+\s*\(\s*DAY\s*\([^)]+\)\s*>\s*25\s*\)'
                if not re.search(year_plus_day_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not have correct YEAR(...)+(DAY(...)>25) structure")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 10: Formula contains (DAY(...)>25)+MONTH(...) pattern
                day_plus_month_pattern = r'\(\s*DAY\s*\([^)]+\)\s*>\s*25\s*\)\s*\+\s*MONTH\s*\('
                if not re.search(day_plus_month_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not have correct (DAY(...)>25)+MONTH(...) structure")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 11: Formula contains IF with month > 12 condition
                if_month_gt_12_pattern = r'IF\s*\(\s*\(\s*\(\s*DAY\s*\([^)]+\)\s*>\s*25\s*\)\s*\+\s*MONTH\s*\([^)]+\)\s*\)\s*>\s*12'
                if not re.search(if_month_gt_12_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not have correct IF(((DAY(...)>25)+MONTH(...))>12,...) structure")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 12: Formula contains string "/" for concatenation
                if '"/"' not in formula_text and "'/" not in formula_text and '"/' not in formula_text:
                    logger.error(f"Cell {cell_coord} formula does not contain string \"/\" for concatenation")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 13: Formula closes parentheses correctly
                open_count = formula_text.count('(')
                close_count = formula_text.count(')')
                if open_count != close_count:
                    logger.error(f"Cell {cell_coord} formula has mismatched parentheses")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                passed_count += 1
                logger.info(f"✓ Cell {cell_coord} has valid formula: {formula_text}")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                all_passed = False
        
        if not all_passed:
            logger.error(f"✗ Formula verification failed: {passed_count}/{checked_count} cells passed")
            return 0.0
        
        if checked_count == 0:
            logger.error(f"No cells found in range {formula_range}")
            return 0.0
        
        logger.info("=" * 60)
        logger.info(f"✓ All {checked_count} cells in range {formula_range} contain correct financial month conversion formulas")
        logger.info(f"  - All cells passed verification")
        logger.info(f"  - Formula structure: (YEAR(A1)+(DAY(A1)>25))&\"/\"&IF(((DAY(A1)>25)+MONTH(A1))>12,--(DAY(A1)>25),((DAY(A1)>25)+MONTH(A1)))")
        logger.info("=" * 60)
        return 1.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_sortby_letter_number_sort(result: str, expected: str = None, **options) -> float:
    """
    Verify if SORTBY formula exists in specified cell to sort data by letter first, then by number.
    
    This function STRICTLY checks ALL cells in the specified range - no tolerance, no auto-detection.
    Every single cell in the specified range must contain the correct formula or correct result.
    
    This function checks:
    1. Whether the formula cell (e.g., B2) contains a SORTBY formula
    2. Whether the formula contains SORTBY, RIGHT, LEFT, and LEN functions
    3. Whether the formula references the correct source range (e.g., A2:A78)
    4. Whether the formula has the correct structure: =SORTBY(A2:A78,RIGHT(A2:A78),,--LEFT(A2:A78,LEN(A2:A78)-1),)
    5. Whether all cells in the result range (B2:B78) contain formulas or correct sorted results
    
    The formula =SORTBY(A2:A78,RIGHT(A2:A78),,--LEFT(A2:A78,LEN(A2:A78)-1),) works as follows:
    - SORTBY sorts the array A2:A78 based on sort keys
    - First sort key: RIGHT(A2:A78) extracts the last character (letter) from each cell
    - Second sort key: --LEFT(A2:A78,LEN(A2:A78)-1) extracts all characters except the last (number part)
      * LEN(A2:A78)-1 calculates the number of characters to extract (total length minus 1)
      * LEFT extracts the number part
      * -- (double negative) converts text to number for proper numeric sorting
    - Sorting order: first by letter (abcd...), then by number (ascending) within same letter
    
    IMPORTANT: This function checks ALL cells in the specified formula range. If any cell is missing a formula or has incorrect result, verification fails.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - formula_cell: Cell containing the formula (e.g., "B2")
            - formula_range: Range containing formulas/results (e.g., "B2:B78") - ALL cells must have formulas or correct results
            - source_range: Source range for SORTBY function (e.g., "A2:A78")
            - expected_functions: List of expected function names (default: ["SORTBY", "RIGHT", "LEFT", "LEN"])
    
    Returns:
        float: 1.0 if ALL cells in specified range contain correct formulas or results, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        formula_cell = options.get('formula_cell', 'B2')
        formula_range = options.get('formula_range', 'B2:B78')
        source_range = options.get('source_range', 'A2:A78')
        expected_functions = options.get('expected_functions', ['SORTBY', 'RIGHT', 'LEFT', 'LEN'])
        
        logger.info(f"Verifying SORTBY letter-number sort in file: {result}")
        logger.info(f"Formula cell: {formula_cell}")
        logger.info(f"Formula range: {formula_range}")
        logger.info(f"Source range: {source_range}")
        
        # Parse the formula range
        try:
            range_clean = formula_range.replace("$", "")
            if ":" in range_clean:
                start_cell, end_cell = range_clean.split(":")
                start_col_letter = "".join([c for c in start_cell if c.isalpha()])
                start_row = int("".join([c for c in start_cell if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                end_col_letter = "".join([c for c in end_cell if c.isalpha()])
                end_row = int("".join([c for c in end_cell if c.isdigit()]))
                end_col = column_index_from_string(end_col_letter)
            else:
                logger.error(f"Invalid range format: {formula_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse range {formula_range}: {e}")
            return 0.0
        
        # Parse source range
        try:
            source_range_clean = source_range.replace("$", "")
            if ":" in source_range_clean:
                source_start, source_end = source_range_clean.split(":")
                source_start_col = "".join([c for c in source_start if c.isalpha()])
                source_start_row = int("".join([c for c in source_start if c.isdigit()]))
                source_end_col = "".join([c for c in source_end if c.isalpha()])
                source_end_row = int("".join([c for c in source_end if c.isdigit()]))
            else:
                logger.error(f"Invalid source range format: {source_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse source range {source_range}: {e}")
            return 0.0
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=False)
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check 1: Verify the formula cell contains SORTBY formula
        logger.info(f"Checking formula cell {formula_cell}")
        
        try:
            formula_cell_obj = ws[formula_cell]
            
            # Check if cell contains a formula (including array formulas)
            # Array formulas may have data_type "f" or may be stored differently
            is_formula = False
            if formula_cell_obj.data_type == "f":
                is_formula = True
            # Also check if it's an array formula by checking array_formulas attribute
            elif hasattr(ws, "array_formulas"):
                for array_range, array_formula in ws.array_formulas.items():
                    if formula_cell in array_range:
                        is_formula = True
                        break
            
            if not is_formula:
                logger.error(f"Cell {formula_cell} does not contain a formula")
                return 0.0
            
            # Get formula text - try multiple methods for array formulas
            formula_text = None
            
            # Method 1: Check if value is ArrayFormula object (most direct for array formulas)
            if formula_cell_obj.value is not None:
                # Check if it's an ArrayFormula object
                from openpyxl.worksheet.formula import ArrayFormula
                if isinstance(formula_cell_obj.value, ArrayFormula):
                    # ArrayFormula object has a 'text' attribute that contains the formula
                    if hasattr(formula_cell_obj.value, "text"):
                        formula_text = formula_cell_obj.value.text
                    elif hasattr(formula_cell_obj.value, "formula"):
                        formula_text = formula_cell_obj.value.formula
                    elif hasattr(formula_cell_obj.value, "__str__"):
                        # Try string representation
                        formula_str = str(formula_cell_obj.value)
                        if "SORTBY" in formula_str.upper() or formula_str.startswith("="):
                            formula_text = formula_str
            
            # Method 2: Check _value attribute (might also be ArrayFormula)
            if formula_text is None and hasattr(formula_cell_obj, "_value"):
                from openpyxl.worksheet.formula import ArrayFormula
                if isinstance(formula_cell_obj._value, ArrayFormula):
                    if hasattr(formula_cell_obj._value, "text"):
                        formula_text = formula_cell_obj._value.text
                    elif hasattr(formula_cell_obj._value, "formula"):
                        formula_text = formula_cell_obj._value.formula
                    elif hasattr(formula_cell_obj._value, "__str__"):
                        formula_str = str(formula_cell_obj._value)
                        if "SORTBY" in formula_str.upper() or formula_str.startswith("="):
                            formula_text = formula_str
                elif isinstance(formula_cell_obj._value, str):
                    if formula_cell_obj._value.startswith("="):
                        formula_text = formula_cell_obj._value
                    elif "SORTBY" in formula_cell_obj._value.upper():
                        formula_text = "=" + formula_cell_obj._value if not formula_cell_obj._value.startswith("=") else formula_cell_obj._value
            
            # Method 3: Check array_formulas attribute (for array formulas)
            if formula_text is None and hasattr(ws, "array_formulas"):
                try:
                    # array_formulas is a dict where keys are ranges and values are formula strings
                    for array_range_str, array_formula in ws.array_formulas.items():
                        # Check if formula_cell is within the array range
                        cell_in_range = False
                        if ":" in array_range_str:
                            start_cell_str, end_cell_str = array_range_str.split(":")
                            # Parse range to check if formula_cell is in it
                            try:
                                # Get column and row from formula_cell
                                cell_col_letter = "".join([c for c in formula_cell if c.isalpha()])
                                cell_row = int("".join([c for c in formula_cell if c.isdigit()]))
                                cell_col = column_index_from_string(cell_col_letter)
                                
                                # Get column and row from start and end cells
                                start_col_letter = "".join([c for c in start_cell_str if c.isalpha()])
                                start_row = int("".join([c for c in start_cell_str if c.isdigit()]))
                                start_col = column_index_from_string(start_col_letter)
                                
                                end_col_letter = "".join([c for c in end_cell_str if c.isalpha()])
                                end_row = int("".join([c for c in end_cell_str if c.isdigit()]))
                                end_col = column_index_from_string(end_col_letter)
                                
                                # Check if cell is within range
                                if start_col <= cell_col <= end_col and start_row <= cell_row <= end_row:
                                    cell_in_range = True
                            except Exception as e:
                                # Fallback: simple string check
                                if formula_cell in array_range_str or array_range_str.startswith(formula_cell):
                                    cell_in_range = True
                        elif formula_cell == array_range_str:
                            # Exact match
                            cell_in_range = True
                        
                        if cell_in_range:
                            # Extract formula text
                            if isinstance(array_formula, str):
                                formula_text = array_formula
                            elif isinstance(array_formula, tuple) and len(array_formula) > 0:
                                formula_text = array_formula[0]
                            elif hasattr(array_formula, "text"):
                                formula_text = array_formula.text
                            break
                except Exception as e:
                    logger.debug(f"Error checking array_formulas: {e}")
            
            # Method 4: Check formula attribute
            if formula_text is None and hasattr(formula_cell_obj, "formula"):
                formula_text = formula_cell_obj.formula
            
            # Method 5: Check value attribute (for regular formulas)
            if formula_text is None and formula_cell_obj.value is not None:
                if isinstance(formula_cell_obj.value, str):
                    if formula_cell_obj.value.startswith("="):
                        formula_text = formula_cell_obj.value
                    elif "SORTBY" in formula_cell_obj.value.upper():
                        formula_text = "=" + formula_cell_obj.value if not formula_cell_obj.value.startswith("=") else formula_cell_obj.value
            
            # Method 5: Check array_value attribute (if exists)
            if formula_text is None and hasattr(formula_cell_obj, "array_value"):
                if isinstance(formula_cell_obj.array_value, str):
                    if formula_cell_obj.array_value.startswith("="):
                        formula_text = formula_cell_obj.array_value
                    elif "SORTBY" in formula_cell_obj.array_value.upper():
                        formula_text = "=" + formula_cell_obj.array_value if not formula_cell_obj.array_value.startswith("=") else formula_cell_obj.array_value
            
            # Method 6: Try to get from internal formula representation
            if formula_text is None:
                # Try accessing internal attributes
                if hasattr(formula_cell_obj, "formula") and formula_cell_obj.formula:
                    formula_text = formula_cell_obj.formula
                elif hasattr(formula_cell_obj, "_value") and isinstance(formula_cell_obj._value, str):
                    # Even if it doesn't start with "=", it might be a formula
                    if "SORTBY" in formula_cell_obj._value.upper() or "RIGHT" in formula_cell_obj._value.upper():
                        formula_text = "=" + formula_cell_obj._value if not formula_cell_obj._value.startswith("=") else formula_cell_obj._value
            
            if formula_text is None:
                logger.error(f"Could not extract formula from cell {formula_cell}")
                logger.error(f"Cell data_type: {formula_cell_obj.data_type}")
                logger.error(f"Cell value: {formula_cell_obj.value}")
                logger.error(f"Cell value type: {type(formula_cell_obj.value)}")
                if hasattr(formula_cell_obj.value, "__dict__"):
                    logger.error(f"Cell value attributes: {dir(formula_cell_obj.value)}")
                logger.error(f"Cell has _value: {hasattr(formula_cell_obj, '_value')}")
                if hasattr(formula_cell_obj, "_value"):
                    logger.error(f"Cell _value: {formula_cell_obj._value}")
                    logger.error(f"Cell _value type: {type(formula_cell_obj._value)}")
                    if hasattr(formula_cell_obj._value, "__dict__"):
                        logger.error(f"Cell _value attributes: {dir(formula_cell_obj._value)}")
                if hasattr(ws, "array_formulas"):
                    logger.error(f"Array formulas in sheet: {list(ws.array_formulas.keys())}")
                return 0.0
            
            # Ensure formula starts with "="
            if not formula_text.startswith("="):
                formula_text = "=" + formula_text
            
            formula_upper = formula_text.upper()
            logger.debug(f"Cell {formula_cell} formula: {formula_text}")
            
            # Check 1: Formula contains SORTBY function
            sortby_pattern = r'\bSORTBY\s*\('
            if not re.search(sortby_pattern, formula_upper):
                logger.error(f"Cell {formula_cell} formula does not contain SORTBY function")
                logger.error(f"Formula: {formula_text}")
                return 0.0
            
            # Check 2: Formula contains all expected functions
            for func_name in expected_functions:
                func_pattern = rf'\b{re.escape(func_name.upper())}\s*\('
                if not re.search(func_pattern, formula_upper):
                    logger.error(f"Cell {formula_cell} formula does not contain {func_name} function")
                    logger.error(f"Formula: {formula_text}")
                    return 0.0
            
            # Check 3: Formula contains RIGHT function
            right_pattern = r'\bRIGHT\s*\('
            if not re.search(right_pattern, formula_upper):
                logger.error(f"Cell {formula_cell} formula does not contain RIGHT function")
                logger.error(f"Formula: {formula_text}")
                return 0.0
            
            # Check 4: Formula contains LEFT function
            left_pattern = r'\bLEFT\s*\('
            if not re.search(left_pattern, formula_upper):
                logger.error(f"Cell {formula_cell} formula does not contain LEFT function")
                logger.error(f"Formula: {formula_text}")
                return 0.0
            
            # Check 5: Formula contains LEN function
            len_pattern = r'\bLEN\s*\('
            if not re.search(len_pattern, formula_upper):
                logger.error(f"Cell {formula_cell} formula does not contain LEN function")
                logger.error(f"Formula: {formula_text}")
                return 0.0
            
            # Check 6: Formula references the correct source range
            # Allow flexible matching for range references (with or without $)
            source_range_patterns = [
                re.escape(source_range),
                re.escape(source_range.replace("$", "")),
                re.escape(source_range.replace("A", "A").replace("$", "")),
            ]
            source_range_found = False
            for pattern in source_range_patterns:
                if re.search(pattern, formula_text, re.IGNORECASE):
                    source_range_found = True
                    break
            
            # Also check for partial match (e.g., A2:A78 without $)
            source_partial_pattern = rf'{re.escape(source_start_col)}\s*\d+\s*:\s*{re.escape(source_end_col)}\s*\d+'
            if not source_range_found and not re.search(source_partial_pattern, formula_text, re.IGNORECASE):
                logger.error(f"Cell {formula_cell} formula does not reference source range {source_range}")
                logger.error(f"Formula: {formula_text}")
                return 0.0
            
            # Check 7: Formula structure contains RIGHT and LEFT with LEN
            # Check for RIGHT(...) pattern
            right_match = re.search(r'RIGHT\s*\([^)]+\)', formula_upper)
            if not right_match:
                logger.error(f"Cell {formula_cell} formula does not have valid RIGHT function call")
                logger.error(f"Formula: {formula_text}")
                return 0.0
            
            # Check for LEFT(...LEN(...)-1) pattern
            left_len_pattern = r'LEFT\s*\([^,]+,\s*LEN\s*\([^)]+\)\s*-\s*1\s*\)'
            if not re.search(left_len_pattern, formula_upper):
                logger.error(f"Cell {formula_cell} formula does not have correct LEFT(LEN(...)-1) structure")
                logger.error(f"Formula: {formula_text}")
                return 0.0
            
            # Check 8: Formula contains double negative (--) for number conversion
            double_negative_pattern = r'--\s*LEFT'
            if not re.search(double_negative_pattern, formula_upper):
                logger.error(f"Cell {formula_cell} formula does not contain -- (double negative) for number conversion")
                logger.error(f"Formula: {formula_text}")
                return 0.0
            
            logger.info(f"✓ Cell {formula_cell} has valid SORTBY formula: {formula_text}")
            
        except Exception as e:
            logger.error(f"Error checking formula cell {formula_cell}: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return 0.0
        
        # Check 2: Verify ALL cells in formula range contain formulas or correct results
        logger.info(f"Checking all cells in range {formula_range} (rows {start_row} to {end_row})")
        
        all_passed = True
        checked_count = 0
        passed_count = 0
        
        # For SORTBY array formula, we need to check if all cells have formulas or if they have correct sorted results
        # Since SORTBY is an array formula, it might be entered only in B2, but results should appear in all cells
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{start_col_letter}{row_num}"
            
            try:
                cell = ws[cell_coord]
                checked_count += 1
                
                # For SORTBY array formulas, cells might contain:
                # 1. The formula itself (in B2)
                # 2. Array formula results (in other cells)
                # 3. Or the formula might be copied to all cells
                
                # Check if cell contains a formula
                if cell.data_type == "f":
                    # Cell has a formula - verify it's correct
                    cell_formula = None
                    
                    # Method 1: Check if value is ArrayFormula object (for array formulas)
                    if cell.value is not None:
                        from openpyxl.worksheet.formula import ArrayFormula
                        if isinstance(cell.value, ArrayFormula):
                            if hasattr(cell.value, "text"):
                                cell_formula = cell.value.text
                            elif hasattr(cell.value, "formula"):
                                cell_formula = cell.value.formula
                            elif hasattr(cell.value, "__str__"):
                                formula_str = str(cell.value)
                                if "SORTBY" in formula_str.upper() or formula_str.startswith("="):
                                    cell_formula = formula_str
                    
                    # Method 2: Check _value attribute (might also be ArrayFormula)
                    if cell_formula is None and hasattr(cell, "_value"):
                        from openpyxl.worksheet.formula import ArrayFormula
                        if isinstance(cell._value, ArrayFormula):
                            if hasattr(cell._value, "text"):
                                cell_formula = cell._value.text
                            elif hasattr(cell._value, "formula"):
                                cell_formula = cell._value.formula
                            elif hasattr(cell._value, "__str__"):
                                formula_str = str(cell._value)
                                if "SORTBY" in formula_str.upper() or formula_str.startswith("="):
                                    cell_formula = formula_str
                        elif isinstance(cell._value, str) and cell._value.startswith("="):
                            cell_formula = cell._value
                    
                    # Method 3: Check formula attribute
                    if cell_formula is None and hasattr(cell, "formula"):
                        cell_formula = cell.formula
                    
                    # Method 4: Check value attribute (for regular formulas)
                    if cell_formula is None and cell.value is not None:
                        if isinstance(cell.value, str) and cell.value.startswith("="):
                            cell_formula = cell.value
                    
                    # Ensure formula starts with "="
                    if cell_formula and not cell_formula.startswith("="):
                        cell_formula = "=" + cell_formula
                    
                    if cell_formula:
                        cell_formula_upper = cell_formula.upper()
                        # Check if it contains SORTBY (might be the same formula or array formula result)
                        if not re.search(r'\bSORTBY\s*\(', cell_formula_upper):
                            # If it's not the main formula cell and doesn't have SORTBY, it might be an array formula result
                            # In LibreOffice, array formulas might show as individual formulas in each cell
                            # We'll accept this as long as the main formula cell is correct
                            if cell_coord == formula_cell:
                                logger.error(f"Cell {cell_coord} should contain SORTBY formula but doesn't")
                                logger.error(f"Extracted formula: {cell_formula}")
                                all_passed = False
                                continue
                        passed_count += 1
                        logger.debug(f"✓ Cell {cell_coord} has formula: {cell_formula[:50]}...")
                    else:
                        # Cell marked as formula but we can't extract it
                        if cell_coord == formula_cell:
                            logger.error(f"Could not extract formula from cell {cell_coord}")
                            logger.error(f"Cell data_type: {cell.data_type}")
                            logger.error(f"Cell value type: {type(cell.value)}")
                            all_passed = False
                            continue
                        # For other cells, might be array formula results
                        passed_count += 1
                else:
                    # Cell doesn't have a formula - might be array formula result
                    # For SORTBY array formulas, results are calculated values
                    # We'll accept non-formula cells as long as they have values (array formula results)
                    if cell.value is not None:
                        passed_count += 1
                        logger.debug(f"✓ Cell {cell_coord} has value (array formula result): {cell.value}")
                    else:
                        logger.error(f"Cell {cell_coord} has no formula and no value")
                        all_passed = False
                        continue
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                all_passed = False
        
        if not all_passed:
            logger.error(f"✗ Formula verification failed: {passed_count}/{checked_count} cells passed")
            return 0.0
        
        if checked_count == 0:
            logger.error(f"No cells found in range {formula_range}")
            return 0.0
        
        logger.info("=" * 60)
        logger.info(f"✓ All {checked_count} cells in range {formula_range} contain correct SORTBY formulas or results")
        logger.info(f"  - Formula cell {formula_cell} contains correct SORTBY formula")
        logger.info(f"  - Formula structure: SORTBY(A2:A78,RIGHT(A2:A78),,--LEFT(A2:A78,LEN(A2:A78)-1),)")
        logger.info(f"  - All cells passed verification")
        logger.info("=" * 60)
        return 1.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_irr_profit_calculation(result: str, expected: str = None, **options) -> float:
    """
    Verify if IRR and profit calculation formulas exist in specified ranges for calculating financial product IRR.
    
    This function STRICTLY checks ALL cells in the specified ranges - no tolerance, no auto-detection.
    Every single cell in the specified ranges must contain the correct formula.
    
    This function checks:
    1. Whether ALL cells in the profit range (e.g., G2:G20) contain formulas =E2-D2, =E3-D3, etc.
    2. Whether the IRR cell (e.g., F2) contains formula =IRR(G2:G20)
    3. Whether profit formulas reference the correct E and D column cells with relative row
    4. Whether IRR formula references the correct profit range (G2:G20)
    5. Whether formulas use relative references correctly (each row references its own data)
    
    IMPORTANT: This function checks ALL cells in the specified ranges, regardless of whether they
    appear to be empty. If any cell in the specified range is missing a formula, verification fails.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - profit_range: Range containing profit formulas (e.g., "G2:G20") - ALL cells must have formulas
            - irr_cell: Cell containing IRR formula (e.g., "F2") - must have formula
            - source_col_e: Source column E for profit calculation (default: "E")
            - source_col_d: Source column D for profit calculation (default: "D")
    
    Returns:
        float: 1.0 if ALL cells in specified ranges contain correct formulas, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        profit_range = options.get('profit_range', 'G2:G20')
        irr_cell = options.get('irr_cell', 'F2')
        source_col_e = options.get('source_col_e', 'E')
        source_col_d = options.get('source_col_d', 'D')
        
        logger.info(f"Verifying IRR and profit calculation formulas in file: {result}")
        logger.info(f"Profit range: {profit_range}, IRR cell: {irr_cell}")
        
        # Parse profit range - strictly use the specified range
        try:
            profit_range_clean = profit_range.replace('$', '')
            if ':' in profit_range_clean:
                profit_start_cell, profit_end_cell = profit_range_clean.split(':')
                profit_start_col_letter = ''.join([c for c in profit_start_cell if c.isalpha()])
                profit_start_row = int(''.join([c for c in profit_start_cell if c.isdigit()]))
                profit_start_col = column_index_from_string(profit_start_col_letter)
                profit_end_col_letter = ''.join([c for c in profit_end_cell if c.isalpha()])
                profit_end_row = int(''.join([c for c in profit_end_cell if c.isdigit()]))
                profit_end_col = column_index_from_string(profit_end_col_letter)
            else:
                logger.error(f"Invalid profit range format: {profit_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse profit range {profit_range}: {e}")
            return 0.0
        
        # Verify that profit range is a single column
        if profit_start_col != profit_end_col:
            logger.error(f"Profit range must be a single column, got: {profit_range}")
            return 0.0
        
        # Parse IRR cell
        try:
            irr_cell_clean = irr_cell.replace('$', '')
            irr_col_letter = ''.join([c for c in irr_cell_clean if c.isalpha()])
            irr_row = int(''.join([c for c in irr_cell_clean if c.isdigit()]))
            irr_col = column_index_from_string(irr_col_letter)
        except Exception as e:
            logger.error(f"Failed to parse IRR cell {irr_cell}: {e}")
            return 0.0
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Strictly check ALL cells in the specified ranges - no auto-detection
        logger.info(f"Checking all cells in profit range {profit_range} (rows {profit_start_row} to {profit_end_row})")
        logger.info(f"Checking IRR cell {irr_cell}")
        
        # Check profit formulas - check ALL rows in the specified range
        all_passed = True
        checked_count = 0
        passed_count = 0
        
        for row_num in range(profit_start_row, profit_end_row + 1):
            profit_cell_coord = f"{profit_start_col_letter}{row_num}"
            
            try:
                profit_cell = ws[profit_cell_coord]
                checked_count += 1
                
                # Check if cell contains a formula
                if profit_cell.data_type != "f":
                    logger.warning(f"Cell {profit_cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(profit_cell, "_value") and isinstance(profit_cell._value, str) and profit_cell._value.startswith("="):
                    formula_text = profit_cell._value
                elif hasattr(profit_cell, "formula"):
                    formula_text = profit_cell.formula
                else:
                    if profit_cell.value is not None and isinstance(profit_cell.value, str) and profit_cell.value.startswith("="):
                        formula_text = profit_cell.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {profit_cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {profit_cell_coord} formula: {formula_text}")
                
                # Check 1: Formula structure should be =E{row_num}-D{row_num} or similar
                # Expected pattern: =E{row_num}-D{row_num} (with possible $ for absolute references)
                expected_e_cell = f"{source_col_e}{row_num}"
                expected_d_cell = f"{source_col_d}{row_num}"
                
                # Pattern to match E{row}-D{row} (allowing for $ absolute references)
                e_pattern = rf'{re.escape(source_col_e)}\$?{row_num}'
                d_pattern = rf'{re.escape(source_col_d)}\$?{row_num}'
                
                # Check if formula contains both E and D column references for this row
                e_match = re.search(e_pattern, formula_text, re.IGNORECASE)
                d_match = re.search(d_pattern, formula_text, re.IGNORECASE)
                
                if not e_match or not d_match:
                    logger.warning(f"Cell {profit_cell_coord} formula does not reference correct cells {expected_e_cell} and {expected_d_cell}")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 2: Formula should be subtraction (E - D)
                # Pattern: =E{row}-D{row} or =E{row} - D{row} (with spaces)
                subtraction_pattern = rf'{re.escape(source_col_e)}\$?{row_num}\s*-\s*{re.escape(source_col_d)}\$?{row_num}'
                if not re.search(subtraction_pattern, formula_text, re.IGNORECASE):
                    logger.warning(f"Cell {profit_cell_coord} formula does not have correct subtraction structure (E-D)")
                    logger.warning(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: Formula should start with =
                if not formula_text.strip().startswith('='):
                    logger.warning(f"Cell {profit_cell_coord} formula does not start with =")
                    all_passed = False
                    continue
                
                # Check 4: Formula closes parentheses correctly (if any)
                open_count = formula_text.count('(')
                close_count = formula_text.count(')')
                if open_count != close_count:
                    logger.warning(f"Cell {profit_cell_coord} formula has mismatched parentheses")
                    all_passed = False
                    continue
                
                passed_count += 1
                logger.debug(f"✓ Cell {profit_cell_coord} has valid profit formula")
                
            except Exception as e:
                logger.error(f"Error checking profit cell {profit_cell_coord}: {e}")
                import traceback
                logger.error(traceback.format_exc())
                all_passed = False
        
        # Check IRR formula in F2
        try:
            irr_cell_obj = ws[irr_cell]
            checked_count += 1
            
            # Check if cell contains a formula
            if irr_cell_obj.data_type != "f":
                logger.warning(f"Cell {irr_cell} does not contain a formula")
                all_passed = False
            else:
                # Get formula text
                formula_text = None
                if hasattr(irr_cell_obj, "_value") and isinstance(irr_cell_obj._value, str) and irr_cell_obj._value.startswith("="):
                    formula_text = irr_cell_obj._value
                elif hasattr(irr_cell_obj, "formula"):
                    formula_text = irr_cell_obj.formula
                else:
                    if irr_cell_obj.value is not None and isinstance(irr_cell_obj.value, str) and irr_cell_obj.value.startswith("="):
                        formula_text = irr_cell_obj.value
                
                if formula_text is None:
                    logger.warning(f"Could not extract formula from cell {irr_cell}")
                    all_passed = False
                else:
                    formula_upper = formula_text.upper()
                    logger.debug(f"Cell {irr_cell} formula: {formula_text}")
                    
                    # Check 1: Formula contains IRR function
                    irr_pattern = r'\bIRR\s*\('
                    if not re.search(irr_pattern, formula_upper):
                        logger.warning(f"Cell {irr_cell} formula does not contain IRR function")
                        logger.warning(f"Formula: {formula_text}")
                        all_passed = False
                    else:
                        # Check 2: Formula references the correct profit range (G2:G20)
                        expected_range = f"{profit_start_col_letter}{profit_start_row}:{profit_end_col_letter}{profit_end_row}"
                        # Pattern to match G2:G20 (allowing for $ absolute references)
                        range_pattern = rf'{re.escape(profit_start_col_letter)}\$?{profit_start_row}\s*:\s*{re.escape(profit_end_col_letter)}\$?{profit_end_row}'
                        
                        if not re.search(range_pattern, formula_text, re.IGNORECASE):
                            logger.warning(f"Cell {irr_cell} formula does not reference correct range {expected_range}")
                            logger.warning(f"Formula: {formula_text}")
                            all_passed = False
                        else:
                            # Check 3: Formula structure is =IRR(G2:G20)
                            irr_range_pattern = rf'IRR\s*\(\s*{re.escape(profit_start_col_letter)}\$?{profit_start_row}\s*:\s*{re.escape(profit_end_col_letter)}\$?{profit_end_row}\s*\)'
                            if not re.search(irr_range_pattern, formula_upper):
                                logger.warning(f"Cell {irr_cell} formula does not have correct IRR(range) structure")
                                logger.warning(f"Formula: {formula_text}")
                                all_passed = False
                            else:
                                # Check 4: Formula closes parentheses correctly
                                open_count = formula_text.count('(')
                                close_count = formula_text.count(')')
                                if open_count != close_count:
                                    logger.warning(f"Cell {irr_cell} formula has mismatched parentheses")
                                    all_passed = False
                                else:
                                    passed_count += 1
                                    logger.debug(f"✓ Cell {irr_cell} has valid IRR formula")
        except Exception as e:
            logger.error(f"Error checking IRR cell {irr_cell}: {e}")
            import traceback
            logger.error(traceback.format_exc())
            all_passed = False
        
        if not all_passed:
            logger.error(f"✗ Formula verification failed: {passed_count}/{checked_count} cells passed")
            return 0.0
        
        if checked_count == 0:
            logger.error(f"No cells found in specified ranges")
            return 0.0
        
        logger.info("=" * 60)
        logger.info(f"✓ All {checked_count} cells contain correct formulas")
        logger.info(f"  - Profit range {profit_range}: {profit_end_row - profit_start_row + 1} cells with =E-D formulas")
        logger.info(f"  - IRR cell {irr_cell}: =IRR({profit_range}) formula")
        logger.info(f"  - All cells passed verification")
        logger.info("=" * 60)
        return 1.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_remove_empty_rows(result: str, expected: str = None, **options) -> float:
    """
    Verify if all empty rows have been removed from the Excel file.
    
    This function checks:
    1. Whether every row in the worksheet contains at least one non-empty cell
    2. A row is considered empty if all cells in that row are None, empty strings, or only whitespace
    3. The verification scans all rows from row 1 to max_row
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - start_row: Starting row to check (default: 1)
            - end_row: Ending row to check (default: None, checks all rows)
            - ignore_header: Whether to ignore the first row (default: False)
    
    Returns:
        float: 1.0 if all rows contain content (no empty rows), 0.0 otherwise
    """
    try:
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        start_row = options.get('start_row', 1)
        end_row = options.get('end_row', None)
        ignore_header = options.get('ignore_header', False)
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=False)
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Determine the range to check
        max_row = ws.max_row
        if end_row is None:
            end_row = max_row
        
        logger.info(f"Checking rows {start_row} to {end_row} for empty rows...")
        logger.info(f"Total rows in worksheet: {max_row}")
        
        # Adjust start_row if ignoring header
        check_start_row = start_row + 1 if ignore_header else start_row
        
        # Check each row
        empty_rows_found = []
        for row_num in range(check_start_row, end_row + 1):
            row = ws[row_num]
            
            # Check if row is empty
            is_empty = True
            for cell in row:
                cell_value = cell.value
                # Check if cell has content
                if cell_value is not None:
                    # Check if it's not an empty string or only whitespace
                    if isinstance(cell_value, str):
                        if cell_value.strip() != "":
                            is_empty = False
                            break
                    else:
                        # Non-string value (number, date, etc.) is considered content
                        is_empty = False
                        break
            
            if is_empty:
                empty_rows_found.append(row_num)
                logger.warning(f"Empty row found at row {row_num}")
        
        # Verification result
        if len(empty_rows_found) > 0:
            logger.error(f"Found {len(empty_rows_found)} empty row(s): {empty_rows_found}")
            logger.error("Verification failed: Empty rows still exist in the worksheet")
            return 0.0
        
        logger.info("=" * 60)
        logger.info(f"✓ All rows contain content (checked rows {check_start_row} to {end_row})")
        logger.info(f"✓ No empty rows found")
        logger.info("=" * 60)
        return 1.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_and_not_conditional_formatting(result: str, expected: str = None, **options) -> float:
    """
    Verify if conditional formatting with AND and NOT formulas exists in specified range with fill colors.
    
    This function checks:
    1. Whether the specified range (e.g., E13:J47) has conditional formatting
    2. Whether there are two conditional formatting rules:
       - Condition 1: AND($B13 + $D13 <= E13, E13 <= $B13 + $C13) with green fill color
       - Condition 2: NOT(AND($B13 + $D13 <= E13, E13 <= $B13 + $C13)) with red fill color
    3. Whether both conditions apply to the specified range
    4. Whether the fill colors match the expected colors (green and red)
    5. Whether each cell in the range has the correct conditional formatting
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_range: Range to check (e.g., "E13:J47")
            - condition1_formula_pattern: Expected formula pattern for condition 1 (default: 'AND($B13 + $D13 <= E13, E13 <= $B13 + $C13)')
            - condition1_fill_color: Expected fill color for condition 1 (default: "green")
            - condition2_formula_pattern: Expected formula pattern for condition 2 (default: 'NOT(AND($B13 + $D13 <= E13, E13 <= $B13 + $C13))')
            - condition2_fill_color: Expected fill color for condition 2 (default: "red")
    
    Returns:
        float: 1.0 if verification passes, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        from openpyxl.worksheet.cell_range import CellRange
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_range = options.get('check_range', 'E13:J47')
        condition1_formula_pattern = options.get('condition1_formula_pattern', 'AND($B13 + $D13 <= E13, E13 <= $B13 + $C13)')
        condition1_fill_color = options.get('condition1_fill_color', 'green')
        condition2_formula_pattern = options.get('condition2_formula_pattern', 'NOT(AND($B13 + $D13 <= E13, E13 <= $B13 + $C13))')
        condition2_fill_color = options.get('condition2_fill_color', 'red')
        
        logger.info(f"Verifying conditional formatting in file: {result}")
        logger.info(f"Range to check: {check_range}")
        logger.info(f"Condition 1: {condition1_formula_pattern} -> {condition1_fill_color}")
        logger.info(f"Condition 2: {condition2_formula_pattern} -> {condition2_fill_color}")
        
        # Parse the range
        try:
            range_clean = check_range.replace('$', '')
            if ':' in range_clean:
                start_cell, end_cell = range_clean.split(':')
                # Parse start cell
                start_col_letter = ''.join([c for c in start_cell if c.isalpha()])
                start_row = int(''.join([c for c in start_cell if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                # Parse end cell
                end_col_letter = ''.join([c for c in end_cell if c.isalpha()])
                end_row = int(''.join([c for c in end_cell if c.isdigit()]))
                end_col = column_index_from_string(end_col_letter)
            else:
                logger.error(f"Invalid range format: {check_range}. Expected format like 'E13:J47'")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse range {check_range}: {e}")
            return 0.0
        
        # Load workbook
        try:
            wb = openpyxl.load_workbook(result, data_only=False)
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Check conditional formatting
        conditional_formattings = ws.conditional_formatting
        
        if not conditional_formattings:
            logger.error("No conditional formatting found in worksheet")
            return 0.0
        
        # Debug: Print all conditional formatting rules
        logger.info("=" * 60)
        logger.info("DEBUG: All conditional formatting rules found:")
        for idx, fmt in enumerate(conditional_formattings):
            logger.info(f"  CF Rule {idx + 1}:")
            for rge in fmt.cells:
                logger.info(f"    Range: {rge}")
            for rule_idx, r in enumerate(fmt.rules):
                logger.info(f"    Rule {rule_idx + 1}:")
                if r.formula:
                    formula_text = r.formula[0] if isinstance(r.formula, list) else str(r.formula)
                    logger.info(f"      Formula: {formula_text}")
                else:
                    logger.info(f"      Formula: None")
                if r.dxf:
                    if r.dxf.fill:
                        try:
                            if r.dxf.fill.bgColor:
                                logger.info(f"      Fill bgColor: {r.dxf.fill.bgColor.rgb}")
                            if r.dxf.fill.fgColor:
                                logger.info(f"      Fill fgColor: {r.dxf.fill.fgColor.rgb}")
                        except Exception as e:
                            logger.info(f"      Fill color error: {e}")
                    if r.dxf.font:
                        try:
                            if r.dxf.font.color:
                                logger.info(f"      Font color: {r.dxf.font.color.rgb}")
                        except Exception as e:
                            logger.info(f"      Font color error: {e}")
        logger.info("=" * 60)
        
        found_condition1 = False
        found_condition2 = False
        condition1_range_cells = None
        condition2_range_cells = None
        
        # Helper function to check if fill color matches
        def check_fill_color(fill_color_obj, expected_color_name):
            """Check if fill color matches expected color name"""
            if fill_color_obj is None:
                logger.debug(f"Fill color object is None")
                return False
            
            color_rgb = None
            if hasattr(fill_color_obj, 'rgb'):
                color_rgb = fill_color_obj.rgb
            elif hasattr(fill_color_obj, 'bgColor') and fill_color_obj.bgColor:
                color_rgb = fill_color_obj.bgColor.rgb
            elif hasattr(fill_color_obj, 'fgColor') and fill_color_obj.fgColor:
                color_rgb = fill_color_obj.fgColor.rgb
            
            if color_rgb is None:
                logger.debug(f"Fill color RGB is None")
                return False
            
            color_str = str(color_rgb).upper()
            logger.debug(f"Checking color: {color_str} against {expected_color_name}")
            
            # Convert color name to RGB values
            if expected_color_name.lower() == 'green':
                # Check for known green color values (LibreOffice may use different shades)
                known_greens = ['FF00A933', '00A933', '00FF00', 'FF00FF00', '008000', 'FF008000', '90EE90', 'FF90EE90']
                if color_str in known_greens or color_str.endswith('00A933') or color_str.endswith('00FF00') or color_str.endswith('008000'):
                    logger.debug(f"Green check: Known green color value {color_str}")
                    return True
                
                # Green: low red, high green, low blue (relaxed criteria for LibreOffice)
                if len(color_str) >= 6:
                    if len(color_str) == 8:
                        r_val = int(color_str[2:4], 16)
                        g_val = int(color_str[4:6], 16)
                        b_val = int(color_str[6:8], 16)
                    elif len(color_str) == 6:
                        r_val = int(color_str[0:2], 16)
                        g_val = int(color_str[2:4], 16)
                        b_val = int(color_str[4:6], 16)
                    else:
                        logger.debug(f"Unexpected color string length: {len(color_str)}")
                        return False
                    # Green: R < 150, G > 100, B < 150 (relaxed for LibreOffice)
                    is_green = r_val < 150 and g_val > 100 and b_val < 150 and g_val > r_val and g_val > b_val
                    logger.debug(f"Green check: RGB({r_val}, {g_val}, {b_val}) -> {is_green}")
                    return is_green
            elif expected_color_name.lower() == 'red':
                # Check for known red color values (LibreOffice may use different shades)
                known_reds = ['FFFF0000', 'FF0000', 'FF00', 'FFFF00', 'DC143C', 'FFDC143C', 'CD5C5C', 'FFCD5C5C']
                if color_str in known_reds or color_str.endswith('FF0000') or color_str.endswith('FF00'):
                    logger.debug(f"Red check: Known red color value {color_str}")
                    return True
                
                # Red: high red, low green, low blue (relaxed criteria for LibreOffice)
                if len(color_str) >= 6:
                    if len(color_str) == 8:
                        r_val = int(color_str[2:4], 16)
                        g_val = int(color_str[4:6], 16)
                        b_val = int(color_str[6:8], 16)
                    elif len(color_str) == 6:
                        r_val = int(color_str[0:2], 16)
                        g_val = int(color_str[2:4], 16)
                        b_val = int(color_str[4:6], 16)
                    else:
                        logger.debug(f"Unexpected color string length: {len(color_str)}")
                        return False
                    # Red: R > 150, G < 150, B < 150, R > G, R > B (relaxed for LibreOffice)
                    is_red = r_val > 150 and g_val < 150 and b_val < 150 and r_val > g_val and r_val > b_val
                    logger.debug(f"Red check: RGB({r_val}, {g_val}, {b_val}) -> {is_red}")
                    return is_red
            
            logger.debug(f"Color name {expected_color_name} not recognized")
            return False
        
        # Check each conditional formatting rule
        for fmt in conditional_formattings:
            # Check if this formatting applies to any cell in our target range
            fmt_applies_to_range = False
            for rge in fmt.cells:
                # Check if this range overlaps with our target range
                cf_start_col = rge.min_col
                cf_start_row = rge.min_row
                cf_end_col = rge.max_col
                cf_end_row = rge.max_row
                
                # Check if ranges overlap
                if not (cf_end_col < start_col or cf_start_col > end_col or 
                        cf_end_row < start_row or cf_start_row > end_row):
                    fmt_applies_to_range = True
                    break
            
            if not fmt_applies_to_range:
                continue
            
            # Check each rule in this formatting
            for r in fmt.rules:
                # Check formula
                if not r.formula:
                    continue
                
                formula_text = r.formula[0] if isinstance(r.formula, list) else str(r.formula)
                formula_upper = formula_text.upper()
                
                logger.info(f"Checking conditional formatting formula: {formula_text}")
                
                # Check if formula contains AND
                and_pattern = r'\bAND\s*\('
                if not re.search(and_pattern, formula_upper):
                    logger.debug(f"Formula does not contain AND: {formula_text}")
                    continue
                
                logger.info(f"  Formula contains AND, checking pattern...")
                
                # Check fill color and font color (LibreOffice may use font color instead of fill color)
                fill_color = None
                font_color = None
                if r.dxf:
                    if r.dxf.fill:
                        try:
                            if r.dxf.fill.bgColor:
                                fill_color = r.dxf.fill.bgColor
                            elif r.dxf.fill.fgColor:
                                fill_color = r.dxf.fill.fgColor
                        except:
                            pass
                    if r.dxf.font:
                        try:
                            if r.dxf.font.color:
                                font_color = r.dxf.font.color
                        except:
                            pass
                
                # Use font color if fill color is not available (LibreOffice Calc behavior)
                color_to_check = fill_color if fill_color is not None else font_color
                
                if color_to_check is None:
                    logger.debug(f"Conditional formatting rule has no fill or font color")
                    continue
                
                # Check condition 1: AND($B13 + $D13 <= E13, E13 <= $B13 + $C13)
                # Pattern: AND($B$?13 + $D$?13 <= E$?13, E$?13 <= $B$?13 + $C$?13)
                # Allow variations in absolute/relative references
                # Also try to match with different row references (E13, E$13, $E13, $E$13)
                condition1_patterns = [
                    r'AND\s*\(\s*\$?B\$?\d+\s*\+\s*\$?D\$?\d+\s*<=\s*E\$?\d+\s*,\s*E\$?\d+\s*<=\s*\$?B\$?\d+\s*\+\s*\$?C\$?\d+\s*\)',
                    r'AND\s*\(\s*\$B\$?\d+\s*\+\s*\$D\$?\d+\s*<=\s*\$?E\$?\d+\s*,\s*\$?E\$?\d+\s*<=\s*\$B\$?\d+\s*\+\s*\$C\$?\d+\s*\)',
                ]
                condition1_match = None
                for pattern in condition1_patterns:
                    condition1_match = re.search(pattern, formula_upper)
                    if condition1_match:
                        logger.info(f"  Condition 1 pattern matched: {pattern}")
                        break
                
                if condition1_match:
                    color_match = check_fill_color(color_to_check, condition1_fill_color)
                    color_type = "fill" if fill_color is not None else "font"
                    logger.info(f"  Condition 1: formula match={condition1_match is not None}, {color_type} color match={color_match}")
                    if color_match:
                        found_condition1 = True
                        if condition1_range_cells is None:
                            condition1_range_cells = rge
                        else:
                            # Merge ranges if multiple ranges found
                            from openpyxl.worksheet.cell_range import CellRange
                            try:
                                combined = CellRange(condition1_range_cells.coord + ":" + rge.coord)
                                condition1_range_cells = combined
                            except:
                                condition1_range_cells = rge
                        logger.info(f"✓ Found condition 1: {formula_text} -> {condition1_fill_color} ({color_type} color)")
                    else:
                        logger.warning(f"  Condition 1 formula matched but color did not match (color: {color_to_check.rgb if hasattr(color_to_check, 'rgb') else 'unknown'})")
                else:
                    logger.debug(f"  Condition 1 pattern did not match: {formula_text}")
                
                # Check condition 2: NOT(AND($B13 + $D13 <= E13, E13 <= $B13 + $C13))
                # Pattern: NOT(AND($B$?13 + $D$?13 <= E$?13, E$?13 <= $B$?13 + $C$?13))
                condition2_patterns = [
                    r'NOT\s*\(\s*AND\s*\(\s*\$?B\$?\d+\s*\+\s*\$?D\$?\d+\s*<=\s*E\$?\d+\s*,\s*E\$?\d+\s*<=\s*\$?B\$?\d+\s*\+\s*\$?C\$?\d+\s*\)\s*\)',
                    r'NOT\s*\(\s*AND\s*\(\s*\$B\$?\d+\s*\+\s*\$D\$?\d+\s*<=\s*\$?E\$?\d+\s*,\s*\$?E\$?\d+\s*<=\s*\$B\$?\d+\s*\+\s*\$C\$?\d+\s*\)\s*\)',
                ]
                condition2_match = None
                for pattern in condition2_patterns:
                    condition2_match = re.search(pattern, formula_upper)
                    if condition2_match:
                        logger.info(f"  Condition 2 pattern matched: {pattern}")
                        break
                
                if condition2_match:
                    color_match = check_fill_color(color_to_check, condition2_fill_color)
                    color_type = "fill" if fill_color is not None else "font"
                    logger.info(f"  Condition 2: formula match={condition2_match is not None}, {color_type} color match={color_match}")
                    if color_match:
                        found_condition2 = True
                        if condition2_range_cells is None:
                            condition2_range_cells = rge
                        else:
                            # Merge ranges if multiple ranges found
                            from openpyxl.worksheet.cell_range import CellRange
                            try:
                                combined = CellRange(condition2_range_cells.coord + ":" + rge.coord)
                                condition2_range_cells = combined
                            except:
                                condition2_range_cells = rge
                        logger.info(f"✓ Found condition 2: {formula_text} -> {condition2_fill_color} ({color_type} color)")
                    else:
                        logger.warning(f"  Condition 2 formula matched but color did not match (color: {color_to_check.rgb if hasattr(color_to_check, 'rgb') else 'unknown'})")
                else:
                    logger.debug(f"  Condition 2 pattern did not match: {formula_text}")
        
        # Verify both conditions are found
        if not found_condition1:
            logger.error("=" * 60)
            logger.error("✗ Condition 1 not found")
            logger.error(f"  Expected: {condition1_formula_pattern} -> {condition1_fill_color}")
            logger.error("=" * 60)
            return 0.0
        
        if not found_condition2:
            logger.error("=" * 60)
            logger.error("✗ Condition 2 not found")
            logger.error(f"  Expected: {condition2_formula_pattern} -> {condition2_fill_color}")
            logger.error("=" * 60)
            return 0.0
        
        # Verify that both conditions apply to the target range
        # Note: If CF is applied to first row only (e.g., E13:J13) with relative references,
        # LibreOffice will automatically apply it to all rows, so we check if:
        # 1. CF range covers the first row of target range, OR
        # 2. CF range fully covers the target range
        
        # Check if formulas use relative references (will auto-apply to other rows)
        uses_relative_refs = False
        for fmt in conditional_formattings:
            for r in fmt.rules:
                if r.formula:
                    formula_text = r.formula[0] if isinstance(r.formula, list) else str(r.formula)
                    # Check if formula uses relative references (E13 instead of $E$13)
                    # Pattern: E13, E$13, $E13 (but not $E$13)
                    if re.search(r'[^$]E\$?\d+', formula_text, re.IGNORECASE):
                        uses_relative_refs = True
                        break
            if uses_relative_refs:
                break
        
        if condition1_range_cells:
            cf_start_col = condition1_range_cells.min_col
            cf_start_row = condition1_range_cells.min_row
            cf_end_col = condition1_range_cells.max_col
            cf_end_row = condition1_range_cells.max_row
            
            # Check column coverage
            col_ok = cf_start_col <= start_col and cf_end_col >= end_col
            # Check row coverage: either fully covers OR covers first row with relative refs
            row_ok = (cf_start_row <= start_row and cf_end_row >= end_row) or \
                     (uses_relative_refs and cf_start_row == start_row and cf_end_row >= start_row and cf_start_col <= start_col and cf_end_col >= end_col)
            
            if not (col_ok and row_ok):
                logger.error("=" * 60)
                logger.error("✗ Condition 1 range does not cover target range")
                logger.error(f"  Target range: {check_range} (cols {start_col}-{end_col}, rows {start_row}-{end_row})")
                logger.error(f"  CF range: cols {cf_start_col}-{cf_end_col}, rows {cf_start_row}-{cf_end_row}")
                logger.error(f"  Uses relative refs: {uses_relative_refs}")
                logger.error("=" * 60)
                return 0.0
            else:
                logger.info(f"✓ Condition 1 range covers target range (CF: {cf_start_col}-{cf_end_col}, {cf_start_row}-{cf_end_row})")
        
        if condition2_range_cells:
            cf_start_col = condition2_range_cells.min_col
            cf_start_row = condition2_range_cells.min_row
            cf_end_col = condition2_range_cells.max_col
            cf_end_row = condition2_range_cells.max_row
            
            # Check column coverage
            col_ok = cf_start_col <= start_col and cf_end_col >= end_col
            # Check row coverage: either fully covers OR covers first row with relative refs
            row_ok = (cf_start_row <= start_row and cf_end_row >= end_row) or \
                     (uses_relative_refs and cf_start_row == start_row and cf_end_row >= start_row and cf_start_col <= start_col and cf_end_col >= end_col)
            
            if not (col_ok and row_ok):
                logger.error("=" * 60)
                logger.error("✗ Condition 2 range does not cover target range")
                logger.error(f"  Target range: {check_range} (cols {start_col}-{end_col}, rows {start_row}-{end_row})")
                logger.error(f"  CF range: cols {cf_start_col}-{cf_end_col}, rows {cf_start_row}-{cf_end_row}")
                logger.error(f"  Uses relative refs: {uses_relative_refs}")
                logger.error("=" * 60)
                return 0.0
            else:
                logger.info(f"✓ Condition 2 range covers target range (CF: {cf_start_col}-{cf_end_col}, {cf_start_row}-{cf_end_row})")
        
        # Verify that ALL cells in the target range have conditional formatting
        # We need to check each cell individually to ensure it's covered
        total_target_cells = (end_row - start_row + 1) * (end_col - start_col + 1)
        cells_with_cf = set()
        
        # Collect all cells covered by the matching conditional formatting
        for fmt in conditional_formattings:
            for rge in fmt.cells:
                # Check if this range overlaps with our target range
                if not (rge.max_col < start_col or rge.min_col > end_col or 
                        rge.max_row < start_row or rge.min_row > end_row):
                    # This range overlaps, check if it has the matching rules
                    for r in fmt.rules:
                        if not r.formula:
                            continue
                        formula_text = r.formula[0] if isinstance(r.formula, list) else str(r.formula)
                        formula_upper = formula_text.upper()
                        
                        # Check if this is a matching rule
                        and_pattern = r'\bAND\s*\('
                        if not re.search(and_pattern, formula_upper):
                            continue
                        
                        # Check fill color and font color
                        fill_color = None
                        font_color = None
                        if r.dxf:
                            if r.dxf.fill:
                                try:
                                    if r.dxf.fill.bgColor:
                                        fill_color = r.dxf.fill.bgColor
                                    elif r.dxf.fill.fgColor:
                                        fill_color = r.dxf.fill.fgColor
                                except:
                                    pass
                            if r.dxf.font:
                                try:
                                    if r.dxf.font.color:
                                        font_color = r.dxf.font.color
                                except:
                                    pass
                        
                        color_to_check = fill_color if fill_color is not None else font_color
                        if color_to_check is None:
                            continue
                        
                        # Check if this is condition 1 or condition 2
                        condition1_match = re.search(
                            r'AND\s*\(\s*\$?B\$?\d+\s*\+\s*\$?D\$?\d+\s*<=\s*E\$?\d+\s*,\s*E\$?\d+\s*<=\s*\$?B\$?\d+\s*\+\s*\$?C\$?\d+\s*\)',
                            formula_upper
                        )
                        condition2_match = re.search(
                            r'NOT\s*\(\s*AND\s*\(\s*\$?B\$?\d+\s*\+\s*\$?D\$?\d+\s*<=\s*E\$?\d+\s*,\s*E\$?\d+\s*<=\s*\$?B\$?\d+\s*\+\s*\$?C\$?\d+\s*\)\s*\)',
                            formula_upper
                        )
                        
                        is_condition1 = condition1_match and check_fill_color(color_to_check, condition1_fill_color)
                        is_condition2 = condition2_match and check_fill_color(color_to_check, condition2_fill_color)
                        
                        if not (is_condition1 or is_condition2):
                            continue
                        
                        # This is a matching rule, add all cells in the range to the set
                        # If using relative refs and CF is only on first row, assume it applies to all rows
                        if uses_relative_refs and rge.min_row == start_row and rge.max_row == start_row:
                            # CF applied to first row only, but with relative refs, it applies to all rows
                            for row in range(start_row, end_row + 1):
                                for col in range(max(start_col, rge.min_col), min(end_col, rge.max_col) + 1):
                                    cells_with_cf.add((row, col))
                        else:
                            # CF applied to specific range
                            for row in range(max(start_row, rge.min_row), min(end_row, rge.max_row) + 1):
                                for col in range(max(start_col, rge.min_col), min(end_col, rge.max_col) + 1):
                                    cells_with_cf.add((row, col))
        
        # Check if all target cells are covered
        missing_cells = []
        for row in range(start_row, end_row + 1):
            for col in range(start_col, end_col + 1):
                if (row, col) not in cells_with_cf:
                    col_letter = get_column_letter(col)
                    missing_cells.append(f"{col_letter}{row}")
        
        if missing_cells:
            logger.error("=" * 60)
            logger.error(f"✗ {len(missing_cells)} cells in target range do not have conditional formatting")
            logger.error(f"  Missing cells (first 20): {', '.join(missing_cells[:20])}")
            if len(missing_cells) > 20:
                logger.error(f"  ... and {len(missing_cells) - 20} more cells")
            logger.error(f"  Total target cells: {total_target_cells}")
            logger.error(f"  Cells with CF: {len(cells_with_cf)}")
            logger.error("=" * 60)
            return 0.0
        
        if len(cells_with_cf) < total_target_cells:
            logger.error("=" * 60)
            logger.error(f"✗ Not all target cells have conditional formatting")
            logger.error(f"  Expected: {total_target_cells} cells")
            logger.error(f"  Found: {len(cells_with_cf)} cells")
            logger.error("=" * 60)
            return 0.0
        
        logger.info("=" * 60)
        logger.info(f"✓ Conditional formatting verification passed")
        logger.info(f"  - Condition 1: {condition1_formula_pattern} -> {condition1_fill_color} ✓")
        logger.info(f"  - Condition 2: {condition2_formula_pattern} -> {condition2_fill_color} ✓")
        logger.info(f"  - Range: {check_range} (all {total_target_cells} cells verified)")
        logger.info("=" * 60)
        return 1.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0


def verify_text_sumpRODUCT_mmult_match_win_lose(result: str, expected: str = None, **options) -> float:
    """
    Verify if TEXT(SUMPRODUCT(MMULT(MATCH(...)))) formulas exist in ALL cells of specified range to calculate win/lose/draw results.
    
    This function STRICTLY checks ALL cells in the specified range - no tolerance, no auto-detection.
    Every single cell in the specified range must contain the correct formula.
    
    The formula =TEXT(SUMPRODUCT(MMULT(N(MOD(MATCH(OFFSET(A$2,,MATCH(H11,B$1:E$1,),20),H$2:L$2,),5)+1=MATCH(B$2:E$21,H$2:L$2,)),{1;1;1;1})-MMULT(N(MOD(MATCH(OFFSET(A$2,,MATCH(H11,B$1:E$1,),20),H$2:L$2,)+4,5)=MOD(MATCH(B$2:E$21,H$2:L$2,),5)),{1;1;1;1})),"贏0;輸0;平") 
    calculates win/lose/draw results based on five-element cycle (金木水火土) game logic.
    
    This function checks:
    1. Whether ALL cells in the specified range (e.g., I12:I15) contain formulas
    2. Whether formulas contain TEXT, SUMPRODUCT, MMULT, MATCH, OFFSET, MOD, and N functions
    3. Whether formulas contain the correct structure with two MMULT operations
    4. Whether formulas contain OFFSET with MATCH(H11,B$1:E$1,) reference
    5. Whether formulas contain MATCH(B$2:E$21,H$2:L$2,) reference
    6. Whether formulas contain MOD operations with 5 (for five-element cycle)
    7. Whether formulas contain TEXT format string "贏0;輸0;平" or similar
    8. Whether formulas contain array constant {1;1;1;1}
    
    IMPORTANT: This function checks ALL cells in the specified range. If any cell is missing a formula, verification fails.
    
    Args:
        result (str): Path to result Excel file
        expected (str): Not used (for compatibility with framework interface)
        options (dict): Configuration options, should contain:
            - check_range: Range to check (e.g., "I12:I15") - ALL cells must have formulas
            - expected_functions: List of expected function names (default: ["TEXT", "SUMPRODUCT", "MMULT", "MATCH", "OFFSET", "MOD", "N"])
            - offset_match_ref: OFFSET MATCH reference (default: "MATCH(H11,B$1:E$1,)")
            - match_range: MATCH range reference (default: "B$2:E$21")
            - match_lookup: MATCH lookup array (default: "H$2:L$2")
            - text_format: TEXT format string (default: "贏0;輸0;平")
            - array_constant: Array constant pattern (default: "{1;1;1;1}")
    
    Returns:
        float: 1.0 if ALL cells in specified range contain correct formulas, 0.0 otherwise
    """
    try:
        import re
        from openpyxl.utils import get_column_letter, column_index_from_string
        
        if result is None or not os.path.exists(result):
            logger.error(f"Result file not found: {result}")
            return 0.0
        
        check_range = options.get('check_range', 'I12:I15')
        expected_functions = options.get('expected_functions', ['TEXT', 'SUMPRODUCT', 'MMULT', 'MATCH', 'OFFSET', 'MOD', 'N'])
        offset_match_ref = options.get('offset_match_ref', 'MATCH(H11,B$1:E$1,)')
        match_range = options.get('match_range', 'B$2:E$21')
        match_lookup = options.get('match_lookup', 'H$2:L$2')
        text_format = options.get('text_format', '贏0;輸0;平')
        array_constant = options.get('array_constant', '{1;1;1;1}')
        
        logger.info(f"Verifying TEXT(SUMPRODUCT(MMULT(MATCH))) win/lose formulas in file: {result}")
        logger.info(f"Range to check: {check_range}")
        logger.info(f"Expected functions: {expected_functions}")
        
        # Parse the range
        try:
            range_clean = check_range.replace('$', '')
            if ':' in range_clean:
                start_cell, end_cell = range_clean.split(':')
                start_col_letter = ''.join([c for c in start_cell if c.isalpha()])
                start_row = int(''.join([c for c in start_cell if c.isdigit()]))
                start_col = column_index_from_string(start_col_letter)
                end_col_letter = ''.join([c for c in end_cell if c.isalpha()])
                end_row = int(''.join([c for c in end_cell if c.isdigit()]))
                end_col = column_index_from_string(end_col_letter)
            else:
                logger.error(f"Invalid range format: {check_range}")
                return 0.0
        except Exception as e:
            logger.error(f"Failed to parse range {check_range}: {e}")
            return 0.0
        
        # Load workbook to get formulas
        try:
            wb = openpyxl.load_workbook(result, data_only=False)  # data_only=False to get formulas
            ws = wb.active
        except Exception as e:
            logger.error(f"Failed to load workbook: {e}")
            return 0.0
        
        # Strictly check ALL cells in the specified range
        logger.info(f"Checking all cells in range {check_range} (rows {start_row} to {end_row})")
        
        all_passed = True
        checked_count = 0
        passed_count = 0
        
        for row_num in range(start_row, end_row + 1):
            cell_coord = f"{start_col_letter}{row_num}"
            
            try:
                cell = ws[cell_coord]
                checked_count += 1
                
                # Check if cell contains a formula
                if cell.data_type != "f":
                    logger.error(f"Cell {cell_coord} does not contain a formula")
                    all_passed = False
                    continue
                
                # Get formula text
                formula_text = None
                if hasattr(cell, "_value") and isinstance(cell._value, str) and cell._value.startswith("="):
                    formula_text = cell._value
                elif hasattr(cell, "formula"):
                    formula_text = cell.formula
                elif cell.value is not None and isinstance(cell.value, str) and cell.value.startswith("="):
                    formula_text = cell.value
                
                if formula_text is None:
                    logger.error(f"Could not extract formula from cell {cell_coord}")
                    all_passed = False
                    continue
                
                formula_upper = formula_text.upper()
                logger.debug(f"Cell {cell_coord} formula: {formula_text}")
                
                # Check 1: Formula contains all expected functions
                for func in expected_functions:
                    func_pattern = rf'\b{re.escape(func.upper())}\s*\('
                    if not re.search(func_pattern, formula_upper):
                        logger.error(f"Cell {cell_coord} formula does not contain {func} function")
                        logger.error(f"Formula: {formula_text}")
                        all_passed = False
                        break
                
                if not all_passed:
                    continue
                
                # Check 2: Formula contains TEXT function
                text_pattern = r'\bTEXT\s*\('
                if not re.search(text_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain TEXT function")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 3: Formula contains SUMPRODUCT function
                sumproduct_pattern = r'\bSUMPRODUCT\s*\('
                if not re.search(sumproduct_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain SUMPRODUCT function")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 4: Formula contains MMULT function (should appear twice)
                mmult_pattern = r'\bMMULT\s*\('
                mmult_matches = len(re.findall(mmult_pattern, formula_upper))
                if mmult_matches < 2:
                    logger.error(f"Cell {cell_coord} formula does not contain at least 2 MMULT functions (found {mmult_matches})")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 5: Formula contains OFFSET function
                offset_pattern = r'\bOFFSET\s*\('
                if not re.search(offset_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain OFFSET function")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 6: Formula contains MATCH function (should appear multiple times)
                match_pattern = r'\bMATCH\s*\('
                match_matches = len(re.findall(match_pattern, formula_upper))
                if match_matches < 3:
                    logger.error(f"Cell {cell_coord} formula does not contain at least 3 MATCH functions (found {match_matches})")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 7: Formula contains MOD function with 5 (for five-element cycle)
                mod_pattern = r'\bMOD\s*\([^,]+,\s*5\s*\)'
                if not re.search(mod_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain MOD(...,5) pattern")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 8: Formula contains N function
                n_pattern = r'\bN\s*\('
                if not re.search(n_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain N function")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 9: Formula contains OFFSET with MATCH reference pattern
                # Allow flexibility in spacing and reference format
                offset_match_pattern = r'OFFSET\s*\([^,]+,\s*,\s*MATCH\s*\(\s*H\d+\s*,\s*B\$?\d+\s*:\s*E\$?\d+\s*,\s*\)'
                if not re.search(offset_match_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain OFFSET(...,MATCH(H...,B$1:E$1,)) pattern")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 10: Formula contains MATCH(B$2:E$21,H$2:L$2,) pattern
                match_range_pattern = r'MATCH\s*\(\s*B\$?\d+\s*:\s*E\$?\d+\s*,\s*H\$?\d+\s*:\s*L\$?\d+\s*,\s*\)'
                if not re.search(match_range_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain MATCH(B$2:E$21,H$2:L$2,) pattern")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 11: Formula contains array constant {1;1;1;1} or similar
                array_pattern = r'\{[^}]*1[^}]*;[^}]*1[^}]*;[^}]*1[^}]*;[^}]*1[^}]*\}'
                if not re.search(array_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain array constant pattern like {{1;1;1;1}}")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 12: Formula contains TEXT format string (allow variations)
                # Escape special characters in text_format
                text_format_escaped = re.escape(text_format)
                # Allow flexibility in quotes and spacing
                text_format_pattern = rf'["\']?\s*{text_format_escaped}\s*["\']?'
                if not re.search(text_format_pattern, formula_text):
                    logger.error(f"Cell {cell_coord} formula does not contain TEXT format string '{text_format}'")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 13: Formula structure - TEXT(SUMPRODUCT(...))
                text_sumpRODUCT_pattern = r'TEXT\s*\(\s*SUMPRODUCT\s*\('
                if not re.search(text_sumpRODUCT_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not have correct TEXT(SUMPRODUCT(...)) structure")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 14: Formula contains subtraction between two MMULT operations
                # Look for pattern: MMULT(...) - MMULT(...)
                mmult_subtract_pattern = r'MMULT\s*\([^)]+\)\s*-\s*MMULT\s*\('
                if not re.search(mmult_subtract_pattern, formula_upper):
                    logger.error(f"Cell {cell_coord} formula does not contain MMULT(...) - MMULT(...) subtraction pattern")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                # Check 15: Formula closes parentheses correctly
                open_count = formula_text.count('(')
                close_count = formula_text.count(')')
                if open_count != close_count:
                    logger.error(f"Cell {cell_coord} formula has mismatched parentheses (open: {open_count}, close: {close_count})")
                    logger.error(f"Formula: {formula_text}")
                    all_passed = False
                    continue
                
                passed_count += 1
                logger.debug(f"✓ Cell {cell_coord} passed all checks")
                
            except Exception as e:
                logger.error(f"Error checking cell {cell_coord}: {e}")
                all_passed = False
                continue
        
        if not all_passed:
            logger.error("=" * 60)
            logger.error(f"✗ Formula verification failed")
            logger.error(f"  Checked: {checked_count} cells")
            logger.error(f"  Passed: {passed_count} cells")
            logger.error(f"  Range: {check_range}")
            logger.error("=" * 60)
            return 0.0
        
        if checked_count == 0:
            logger.error("=" * 60)
            logger.error(f"✗ No cells were checked in range {check_range}")
            logger.error("=" * 60)
            return 0.0
        
        logger.info("=" * 60)
        logger.info(f"✓ TEXT(SUMPRODUCT(MMULT(MATCH))) formula verification passed")
        logger.info(f"  - Checked: {checked_count} cells")
        logger.info(f"  - Passed: {passed_count} cells")
        logger.info(f"  - Range: {check_range}")
        logger.info("=" * 60)
        return 1.0
        
    except Exception as e:
        import traceback
        logger.error(f"Verification failed: {e}")
        logger.error(traceback.format_exc())
        return 0.0